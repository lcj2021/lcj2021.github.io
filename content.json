{"meta":{"title":"Liucj's Harbour","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2022-10-31T16:28:05.000Z","updated":"2022-10-31T16:40:47.327Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"刘城君，男，汉族，2001年5月出生，共青团员，湖南大学计算机科学与技术专业2019级学生。研究兴趣为图计算、图挖掘、图嵌入学习。国内首例rCPD治愈患者 [^1]。 R-CPD 逆行性环咽肌功能障碍[^2]这是一种由于环咽肌功能失调，不能自下而上的通过食管入口把气体排出来的罕见疾病，主要临床表现为不能打嗝。 本人为国内首例rCPD治愈患者，希望能帮助到rCPD病友，可以查看本人求医治愈经历，联系本人微信13352891273 Awards Entry Time Organizer Silver Award(Rank 12) CCSP[^3] Central China Oct,2021 China Computer Federation Third Prize of 湖南省大学生数学竞赛 Oct,2021 Third Prize of 全国大学生数学建模大赛湖南赛区 Sep,2021 University Merit Student of HNU December,2020 Hunan University Second Prize(Rank 44) of HNU Mathematic Competition May,2020 Hunan University First &amp; Second Prize Scholarships Hunan University For more infoMore info about me can be found in CV and CV-zh [^1]: 2021年4月30日中午1时，中山大学附属第三医院窦祖林教授 主刀[^2]: 首次被Robert Bastian定义于Inability to Belch and Associated Symptoms Due to Retrograde Cricopharyngeus Dysfunction: Diagnosis and Treatment[^3]: The CCF College Computer Systems &amp; Programming Contest"}],"posts":[{"title":"周记 - 2022 10.31-11.6","slug":"周记 - 2022 10.31-11.6","date":"2022-11-03T16:00:00.000Z","updated":"2022-11-07T08:24:35.618Z","comments":true,"path":"2022/11/04/周记 - 2022 10.31-11.6/","link":"","permalink":"http://example.com/2022/11/04/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/","excerpt":"","text":"11.3 周四 晴今天一早起来就看到知乎推送《多地核酸开始自费》，又了解到大舅那边前几天已经开始自费了，收费是4元/次。不禁联想到昨天还吐槽核酸检测人员的高收入。 早十有《高性能计算》，依旧是平平无奇地上半节课签到，课间从复邻舍401后门溜回宿舍。不过今天罗HZ老师提到了签到的问题，在课上指出了缺课达3次需要补卡。我想起上上周自己因为没看课表，直接漏掉了一次签到。不料午饭后，有同学在课程群里问有没有爬山组队。这才知道所谓的补卡其实是跟LHZ爬岳麓山，好感度++。自己也得找个机会把缺的这次签到补回来。 下午依旧是赛前的日常刷题。看到了百度上关于 晚饭步步高挑香小面。晚九点打算继续昨晚的师大天马宿舍之行。虽然没有大门大开，但是也只是扫个码就放行了。漫步在师大宿舍园区，我和ZZM都明显感觉到和湖大天马宿舍不同的地方。简单来说就是中南南校区和这里都更加具有校园的氛围，体现在绿化，路旁的人行道，路旁的宣传栏，也体现在这里建筑的杂乱。 11.4 周五 晴8点30分第一个下床。刷题。干午饭。学委此时也发了关于毕设导师的通知了，毕设郑老师之前提过，但是目前又没了消息。我最担心的是找不到愿意挂名的导师。 下午第三节有《软件工程》，课上做了些2022辽宁省赛的题目，发现题目难度不大。做了可莉的五子棋和画画。图的分割和栈与公约数暂时没想到做法。 晚上有例行的每周大组会，我问了WSH，发现大家都找了毕设的导师，所以我也打算把当前进度汇报一下，顺便问问毕设的事情。于是跟老师和彭Z约了明天晚上讨论进度。 11.5 周六 晴今天14:00-16:00是ICPC沈阳站的热身赛。所以10点半不到就吃了午餐，休息小睡了20分钟后。便在阜埠河公交站和zwl骑车去院楼105准备上机环境。 在比赛开始时，zwl的后置录像手机夹住了关机键，手机直接关机了，所以我们整场比赛都没法正常交题。不过还是能看题面，A题签到，B题是输出 (随机生成)满足条件的a序列的期望。公式是$\\frac{(n!)^2}{n^n}$。就是不知道double的精度能否满足要求。C题是类似石子合并的DP题。但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$，所以最后只能写一个假算法。赛后问了SJ，得知是四边形不等式决策单调性相关，打扰了。 晚上的Atcoder只打了半小时。 11.6 周日 晴总结: 遗憾打铁仍是凌晨1点睡，8:30起床，10:30前进餐完毕，睡了10来分钟。11:30到院楼参加沈阳正是赛。 开题签到题，统计字符串中T和D的个数，WA了一发。第二题找规律题，姜哥首先发现r取越大越好，但是只考虑a[i]作为左端点，没加上右端点的情况，WA了一发 第三题构造题，我首先用子矩阵数量公式判断出了无解情况。ZWL打表，发现了长相特殊的合法情况，所以尝试将二维压缩为一维。问题转换成把一个数分解成若干个$\\frac{i \\times (i+1)}{2}$表示。我提出从i王高到低贪心，二分i的位置，上机同时姜哥找反例。姜哥发现没有反例并且提出可以线性，但是我写到后面犯傻，直接神志不清，并不清楚线性的意思。于是姜哥接过来完成算法。第一发TLE，endl原因。第二发WA，爆long long。最后过了 第四题大模拟暴搜，题意没读懂，其实就是炉石随从攻击的逻辑，奈何没玩过。调试1个半小时，没能调对第二个样例。以为是精度问题。最后Rank290+无奈打铁。","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 275 A-F","slug":"题解 - AtCoder Beginner Contest 275 A-F","date":"2022-11-03T16:00:00.000Z","updated":"2022-11-04T05:26:55.507Z","comments":true,"path":"2022/11/04/题解 - AtCoder Beginner Contest 275 A-F/","link":"","permalink":"http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/","excerpt":"","text":"C题意一个$r \\times c (r, c\\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数. 如 123456789##.......##.......................#......#...........#......#.................... 具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子. 具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子. 因此，答案是 2. 思路枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标. 向量[x, y]顺时针旋转90°: [y, -x] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rot(array&lt;int, 2&gt; &amp; v) &#123; auto [x, y] = v; v = &#123;y, -x&#125;;&#125;bool check(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= 9 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 9;&#125;void solve()&#123; for (int i = 1; i &lt;= 9; ++ i) for (int j = 1; j &lt;= 9; ++ j) cin &gt;&gt; g[i][j]; cerr &lt;&lt; g[5][5] &lt;&lt; endl; cerr &lt;&lt; g[5][7] &lt;&lt; endl; set&lt;set&lt;array&lt;int, 2&gt;&gt;&gt; S; for (int ci = 1; ci &lt;= 9; ++ ci) for (int cj = 1; cj &lt;= 9; ++ cj) &#123; for (int ni = 1; ni &lt;= 9; ++ ni) &#123; for (int nj = 1; nj &lt;= 9; ++ nj) if (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == &#x27;#&#x27; &amp;&amp; g[ni][nj] == &#x27;#&#x27;) &#123; array&lt;int, 2&gt; v = &#123;ni - ci, nj - cj&#125;; rot(v); int i3 = ni + v[0], j3 = nj + v[1]; rot(v); int i4 = i3 + v[0], j4 = j3 + v[1]; // if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7) cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl; if (check(i3, j3) &amp;&amp; check(i4, j4) &amp;&amp; g[i3][j3] == &#x27;#&#x27; &amp;&amp; g[i4][j4] == &#x27;#&#x27;) &#123; // cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl; set&lt;array&lt;int, 2&gt;&gt; s; s.insert(&#123;ci, cj&#125;); s.insert(&#123;ni, nj&#125;); s.insert(&#123;i3, j3&#125;); s.insert(&#123;i4, j4&#125;); S.insert(s); &#125; &#125; &#125; &#125; cerr &lt;&lt; S.size() &lt;&lt; endl; cout &lt;&lt; S.size() &lt;&lt; endl;&#125; D题意为非负整数 x 定义的函数 f(x) 满足以下条件： $f(0) = 1$ $f(k) = f(\\lfloor \\frac{k}{2}\\rfloor) + f(\\lfloor \\frac{k}{3}\\rfloor)$ 对于任何正整数 k 然后找到 $f(N), N\\in[0, 1^{18}]$. 分析最多需要$log_2n \\times log_3n$这么多个数的f值. 标准记搜 代码123456789101112131415int n;unordered_map&lt;int, int&gt; dp;int dfs(int u) &#123; if (dp.count(u)) return dp[u]; return dp[u] = dfs(u / 2) + dfs(u / 3);&#125;void solve()&#123; cin &gt;&gt; n; dp[0] = 1; cout &lt;&lt; dfs(n) &lt;&lt; endl; cerr &lt;&lt; dp.size() &lt;&lt; endl;&#125; E题意一个一维的棋盘上有 N + 1 个格子，下标从 0 到 N ，玩家要从 0 这个点出发，前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子，每个骰面上都有不同的数字，值域是 $[1, M]$ ，扔出每个面的概率都是 $\\frac{1}{M}$ . 玩家需要根据要出来的骰面前进，如果预计前进之后走出了棋盘，就需要退回多走出的步数，如果在终点停了下来，游戏就胜利了，不能再扔骰子. 问 K 回合后，玩家胜利的概率. 将结果对 998244353 取模. $0 \\le M \\le N \\le 1000, M \\in [1, 10], K \\in [1, 1000]$ . 分析令 dp[i][j] 为扔第 j 次骰子后，玩家到达下标为 i 的格子的概率. 对于每一个 dp[i][j] $dp[next_i][j + 1] = dp[i][j] \\times \\frac{1}{M}$. 注意如果走出了棋盘，要特殊讨论停下来的下标. 已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了 代码1234567891011121314151617181920212223242526272829303132333435363738394041const int N = 1000 + 10, mod = 998244353;int n, m, k;int dp[N][N]; // 到达第i格, 共走了j步的所有情况之和// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]int qmi(int a, int k)&#123; int res = 1 % mod; while (k) &#123; if (k &amp; 1) res = res * a % mod; a = a * a % mod; k &gt;&gt;= 1; &#125; return res;&#125;void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; dp[0][0] = 1; int m_1 = qmi(m , mod - 2); for (int j = 0; j &lt; k; ++ j) &#123; for (int i = 0; i &lt; n; ++ i) &#123; for (int len = 1; len &lt;= m; ++ len) &#123; int ni = i + len; if (ni &gt; n) &#123; ni = n - (ni - n); &#125; // if (next_i &lt;= i) &#123; // cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl; // &#125; dp[ni][j + 1] += (dp[i][j] * m_1) % mod; dp[ni][j + 1] %= mod; &#125; &#125; dp[n][j + 1] += dp[n][j]; dp[n][j + 1] %= mod; &#125; cerr &lt;&lt; dp[n][k] &lt;&lt; endl; cout &lt;&lt; dp[n][k] &lt;&lt; endl;&#125; F题意给定一个数组 A ，定义一次操作的内容是，删除 A 中一段连续的序列. 问对于 1, 2, …, M 中的每个数 s ，分别至少要操作多少次， 才能使得 A 中剩下的数和为 s ，如果不可能就输出 -1 . $0 \\le N \\le M \\le 3000， 1 \\le a_i \\le 3000$ 思路数组分段式的DP, 用一个维度表示当前元素是否在分段中 dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中 如果a[i]不计入总和: dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); 如果a[i]计入总和: dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); 代码123456789101112131415161718192021222324252627282930const int N = 3e3 + 10;int n, m;int a[N];int dp[N][N][2]; // 前i个数, 构成总和为j, 且第i个数是否在总和中void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++ i) dp[i][0][0] = 1; dp[0][0][1] = 0; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= m; ++ j) &#123; dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); if (j - a[i] &gt;= 0) &#123; dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); &#125; &#125; &#125; // cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl; for (int j = 1; j &lt;= m; ++ j) &#123; int ans = min(&#123;dp[n][j][0], dp[n][j][1]&#125;); if (ans &gt; 0x3f3f3f3f3f3f3f3f / 2) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 评价这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的 C 模拟 + 向量旋转 D 记忆化搜索 E 概率DP F DP + 数组划分 / 选取子段","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_模拟","slug":"算法-模拟","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%8B%9F/"},{"name":"算法_记忆化搜索","slug":"算法-记忆化搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"算法_DP_概率","slug":"算法-DP-概率","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%A6%82%E7%8E%87/"},{"name":"算法_DP_数组划分","slug":"算法-DP-数组划分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86/"}]},{"title":"题解 - AtCoder Beginner Contest 192 D-F","slug":"题解 - AtCoder Beginner Contest 192 D-F","date":"2022-11-02T16:00:00.000Z","updated":"2022-11-04T15:49:37.028Z","comments":true,"path":"2022/11/03/题解 - AtCoder Beginner Contest 192 D-F/","link":"","permalink":"http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/","excerpt":"","text":"D题意给定整数 $X, X \\in [1, 10^{60}]$和 $M, M \\in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. 求对于所有的 $a&gt;d,a \\in \\mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\\le M$. 分析首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. 注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. 同时, long long 相乘可能会爆, 必须乘乘数base之前判断当前val &gt; target / base . 或者用 __int128AtCoder 支持 或龟速乘. 代码123456789101112131415161718192021222324252627282930313233343536string x;int m;void solve()&#123; cin &gt;&gt; x &gt;&gt; m; signed mx = 0; for (auto &amp;ch : x) mx = max(mx, ch - &#x27;0&#x27;); if (x.size() == 1) &#123; // 特判: 因为题目要求不同的数 if (mx &lt;= m) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; auto check = [&amp;](int base) -&gt; bool &#123; int val = 0; for (int i = 0; i &lt; x.size(); ++ i) &#123; if (val &gt; m / base) &#123; // 每次 + *base 之前 跟目标 /base 作比较 防止溢出 return false; &#125; int b = x[i] - &#x27;0&#x27;; val *= base; val += b; &#125; return (val &lt;= m); &#125;; int l = mx, r = 1e18 + 10; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; cerr &lt;&lt; l &lt;&lt; endl; cout &lt;&lt; l - mx &lt;&lt; endl;&#125; E题意$G(N, M), N, M \\leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\\in\\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \\in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 -1. 分析注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. 代码12345678910111213141516171819202122232425262728293031323334const int N = 1e5 + 10;int n, m, x, y;vector&lt;array&lt;int, 3&gt;&gt; G[N];int dist[N];void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= m; ++ i) &#123; int a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k; G[a].pb(&#123;b, t, k&#125;); G[b].pb(&#123;a, t, k&#125;); &#125; priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, greater&lt;array&lt;int, 2&gt;&gt;&gt; pq; memset(dist, 0x3f, sizeof dist); dist[x] = 0; pq.push(&#123;0, x&#125;); while (pq.size()) &#123; auto [cd, cv] = pq.top(); pq.pop(); if (cd &gt; dist[cv]) continue; // cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl; for (auto [nv, t, k] : G[cv]) &#123; int nd = (cd + k - 1) / k * k; nd = nd + t; // cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl; if (nd &lt; dist[nv]) &#123; dist[nv] = nd; pq.push(&#123;nd, nv&#125;); &#125; &#125; &#125; cerr &lt;&lt; dist[y] &lt;&lt; endl; if (dist[y] &gt;= 0x3f3f3f3f3f3f3f3f / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dist[y] &lt;&lt; endl;&#125; F题意给定数组a[N], $a[i] \\leq 1e7$和$X \\in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. 思路100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数 枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. dp[k][i][j] = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值 不拿第k个物品: dp[k][i][j] = dp[k - 1][i][j]; 拿第k个物品: dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); 总复杂度 $\\mathcal{O}(n^4)$. 代码12345678910111213141516171819202122232425262728293031323334353637383940const int N = 100 + 10;int n, x;int a[N], w[N];int dp[N][N][N]; void solve()&#123; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; int ans = 1e18; for (int choose = 1; choose &lt;= n; ++ choose) &#123; int m = x % choose; for (int i = 1; i &lt;= n; ++ i) w[i] = a[i] % choose; memset(dp, -1, sizeof dp); // dp[k][i][j] = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值 dp[0][0][0] = 0; for (int k = 1; k &lt;= n; ++ k) &#123; for (int i = 1; i &lt;= min(k, choose); ++ i) &#123; for (int j = 0; j &lt; choose; ++ j) &#123; if (~dp[k - 1][i][j]) &#123; dp[k][i][j] = dp[k - 1][i][j]; &#125; if (~dp[k - 1][i - 1][(j - w[k] + choose) % choose]) &#123; dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); &#125; &#125; &#125; &#125; // 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose if (~dp[n][choose][m]) &#123; ans = min(ans, (x - dp[n][choose][m]) / choose); &#125; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; 评价D 考察乘法溢出, 各种边界讨论比较繁琐 E 最短路变形, 松弛边权做一下变化即可 F 背包+模数, 在外层套一层for模数choose, 状态表示加一个维度表示当前总和mod choose的值","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_DP_背包","slug":"算法-DP-背包","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E8%83%8C%E5%8C%85/"}]},{"title":"题解 - 牛客小白月赛59 D-F","slug":"题解 - 牛客小白月赛59 D-F","date":"2022-10-31T16:00:00.000Z","updated":"2022-11-03T10:56:26.285Z","comments":true,"path":"2022/11/01/题解 - 牛客小白月赛59 D-F/","link":"","permalink":"http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/","excerpt":"","text":"D - 国际象棋题意n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋) 分析每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\\“四个方向上已经连了几个了. 注意不能分8个方向 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 1e3 + 10;int n, m, k, t;int h[N], g[N][N];int dx[] = &#123;1, -1, 1, -1, 0, 0, -1, 1&#125;, dy[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;;int solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t; memset(g, -1, sizeof g); for (int tt = 1; tt &lt;= t; ++ tt) &#123; int col, x = tt % 2; cin &gt;&gt; col; g[++ h[col]][col] = x; int cx = h[col], cy = col;// cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;// for (int i = n; i &gt;= 1; -- i) for (int j = 1; j &lt;= m; ++ j) cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \\n&quot;[j == m]; int cnt = 1; while (cx + 1 &lt;= n &amp;&amp; g[cx + 1][cy] == x) ++ cx, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy] == x) -- cx, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cy + 1 &lt;= m &amp;&amp; g[cx][cy + 1] == x) ++ cy, ++ cnt; cx = h[col], cy = col; while (cy - 1 &gt;= 1 &amp;&amp; g[cx][cy - 1] == x) -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy + 1 &lt;= m &amp;&amp; g[cx + 1][cy + 1] == x) ++ cx, ++ cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy - 1] == x) -- cx, -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx + 1][cy - 1] == x) ++ cx, -- cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy + 1 &gt;= 1 &amp;&amp; g[cx - 1][cy + 1] == x) -- cx, ++ cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; \\\\ &quot; &lt;&lt; cnt &lt;&lt; endl; &#125; return t;&#125; E - 弹珠碰撞题意长度为 n 的线段上，有 m 颗弹珠在匀速以1单位/s 左右滚动。弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. 两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动，并交换两颗弹珠滚动的方向。一颗弹珠可以反复发生碰撞，如果在停滞中受到碰撞，则停滞时间会累加。 如果一颗弹珠滚到了位置 0 或位置 n+1，那么这颗弹珠就滚出了线段。问最后一颗弹珠在什么时候滚出线段？ 分析a -&gt; &lt;- b 左右两个弹珠相撞后 &lt;-a b -&gt; &lt;-b a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的 算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行. ​ 代码123456789101112131415161718192021222324252627const int N = 1e6 + 10;int n, m;struct &#123; int d, p;&#125; ball[N];int pre1[N]; // -&gt;int suf0[N]; // &lt;-void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].d; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].p; sort(ball + 1, ball + 1 + m, [&amp;](auto &amp;a, auto &amp;b) &#123; return a.p &lt; b.p; &#125;); for (int i = 1; i &lt;= m; ++ i) pre1[i] = pre1[i - 1] + (ball[i].d == 1); for (int i = m; i &gt;= 1; -- i) suf0[i] = suf0[i + 1] + (ball[i].d == 0); int ans = 0; for (int i = 1; i &lt;= m; ++ i) &#123; auto [d, p] = ball[i]; int t = (d ? (n + 1 - p) + suf0[i] : p + pre1[i]); // cerr &lt;&lt; t &lt;&lt; endl; ans = max(t, ans); &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; F - 困难卷积题意给定整数序列 a[n], b[n]，求：$$\\sum_{i=1}^n\\sum_{j=1}^n\\Big\\lfloor\\sqrt{|a_i-b_j|}\\Big\\rfloor$$ 其中 $\\lfloor x\\rfloor$表示不超过 x 的最大整数，例如 $\\lfloor 3.5\\rfloor=3,\\lfloor\\sqrt 2\\rfloor =1$。 $1≤n≤10^6，0\\leq a_i,b_i\\leq 3\\times 10^6，\\sum a_i,\\sum b_i\\leq 10^7$。 分析3e6 排除暴力. 注意到$\\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行 代码1234567891011121314151617const int N = 1e6 + 10;int a[N], b[N];int n;void solve()&#123; cin &gt;&gt; n; map&lt;int, int&gt; cnta, cntb; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i], cnta[a[i]] ++; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; b[i], cntb[b[i]] ++; int ans = 0; for (auto [va, ca] : cnta) for (auto [vb, cb] : cntb) &#123; ans += floor(sqrt(abs(va - vb))) * ca * cb; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_思维","slug":"算法-思维","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%80%9D%E7%BB%B4/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-31T11:31:34.473Z","updated":"2022-10-31T11:29:53.845Z","comments":true,"path":"2022/10/31/hello-world/","link":"","permalink":"http://example.com/2022/10/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Ubuntu 下使用 Clash 代理","slug":"Ubuntu 下使用 Clash 代理","date":"2022-02-01T16:00:00.000Z","updated":"2022-10-31T16:21:23.581Z","comments":true,"path":"2022/02/02/Ubuntu 下使用 Clash 代理/","link":"","permalink":"http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/","excerpt":"","text":"Ubuntu科学上网 在 https://github.com/Dreamacro/clash/releases 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash。 添加执行权限（sudo chmod + x clash），将 clash 放到 /usr/bin/ 目录下（sudo cp clash /usr/bin/）。 在终端中运行 clash，会在 ~/.config/clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件。用商家提供的替换这两个文件，重新运行 clash。 设置系统代理： 用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响。 将clash进程加入开机自启动","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]}],"categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"},{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"算法_模拟","slug":"算法-模拟","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%8B%9F/"},{"name":"算法_记忆化搜索","slug":"算法-记忆化搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"算法_DP_概率","slug":"算法-DP-概率","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%A6%82%E7%8E%87/"},{"name":"算法_DP_数组划分","slug":"算法-DP-数组划分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86/"},{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_DP_背包","slug":"算法-DP-背包","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E8%83%8C%E5%8C%85/"},{"name":"算法_思维","slug":"算法-思维","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%80%9D%E7%BB%B4/"},{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]}