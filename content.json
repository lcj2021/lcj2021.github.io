{"meta":{"title":"Liucj's Harbour","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2023-03-03T11:35:05.000Z","updated":"2023-03-03T11:40:31.144Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"刘城君，男，汉族，2001年5月出生，共青团员，湖南大学计算机科学与技术专业2019级学生。研究兴趣为图计算，图挖掘，图数据库优化。CP(Competitive Programming)爱好者，钢琴爱好者（自学ing）。国内首例rCPD治愈患者 [^1]。 R-CPD 逆行性环咽肌功能障碍[^2]这是一种由于环咽肌功能失调，不能自下而上的通过食管入口把气体排出来的罕见疾病，主要临床表现为不能打嗝。 本人为国内首例rCPD治愈患者，希望能帮助到rCPD病友，可以查看本人求医治愈经历，联系本人微信13352891273 Awards Entry Time Organizer Outstanding Graduate of HNU Mar,2023 HNU Bronze Award 47th ACM-ICPC Nanjing Dec,2022 ICPC Foundation Silver Award(Rank 12) CCSP[^3] Central China Oct,2021 China Computer Federation Third Prize of 湖南省大学生数学竞赛 Oct,2021 Third Prize of 全国大学生数学建模大赛湖南赛区 Sep,2021 Merit Student of HNU December,2020 Hunan University Second Prize(Rank 44) of HNU Mathematic Competition May,2020 Hunan University First &amp; Second Prize Scholarships Hunan University For more infoMore info about me can be found in CV and CV-zh [^1]: 2021年4月30日中午1时，中山大学附属第三医院窦祖林教授 主刀[^2]: 首次被Robert Bastian定义于Inability to Belch and Associated Symptoms Due to Retrograde Cricopharyngeus Dysfunction: Diagnosis and Treatment[^3]: The CCF College Computer Systems &amp; Programming Contest"}],"posts":[{"title":"记录 - 看番记录","slug":"记录 - 看番记录","date":"2023-07-21T16:00:00.000Z","updated":"2023-07-23T15:57:30.793Z","comments":true,"path":"2023/07/22/记录 - 看番记录/","link":"","permalink":"http://example.com/2023/07/22/%E8%AE%B0%E5%BD%95%20-%20%E7%9C%8B%E7%95%AA%E8%AE%B0%E5%BD%95/","excerpt":"","text":"备注 A叔: Animenzzz 猪仔: 和音社-猪仔很忙 P大: Phyxinon T叔: Theishter 已看你的名字 OP &amp; ED: 梦灯笼 (黄昏之时) OST: sparkle火花 (A叔), 前前前世 (A叔), 三叶的主题曲 火影忍者 (TV 1-720集) OP: Sign, silhouette剪影 (A叔) 继母的拖油瓶是我的前女友 剃须，然后捡到女高中生 青春猪头少年不会梦到兔女郎学姐 ED: 不可思議のカルテ 尸体派对 青春猪头少年不会梦到怀梦美少女 辉夜大小姐想让我告白 (天才们的恋爱头脑战) S1 Charlotte 四月是你的谎言 OP: 若能绽放光芒 (A叔), 七色交响曲 ED: オレンジ Orange (猪仔, T叔) OST: 私の嘘, Again, 弟弟一般的存在 古典: 爱的忧伤, 冬风, 肖邦第一叙事曲, 圣桑:引子与回旋 天气之子 OST: Grand Escape (A叔, P大) 通往夏天的隧道（难懂） 辉夜大小姐想让我告白 S2 鬼灭之刃 立志篇 OP: 红莲华 OST: 灶门炭治郎之歌 鬼灭之刃 无限列车篇 鬼灭之刃 游郭篇 看得见的女孩 鬼灭之刃 锻刀村篇 紫罗兰永恒花园 (1-3集 + OVA + 4-6集 + 外传) OP: Sincerely (A叔, 猪仔) ED: みちしるべ路标 (A叔) 比宇宙还远的地方 (1-8集) 未看 辉夜大小姐想让我告白 S3 辉夜大小姐想让我告白 剧场版 初吻不会结束 我的青春恋爱物语果然有问题 轻音少女 路人女主的养成方法 冰菓 中二病也要谈恋爱 工作细胞 堀与宫村 干物妹小埋 钢之炼金术师 月色真美 天使降临到我身边 吹响! 上低音号 小林家的龙女仆 12季 逆转裁判 12季 Jose与虎与鱼 天降之物 甲铁城的卡巴内利 从零开始的异世界生活 关於我转生变成史莱姆这档事 blood c 灵能百分百 刀剑神域 fate 一拳超人 one punch man 咒术回战 夏日重现 一人之下 罪恶王冠 EVA 我推的孩子","categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"事记 - 在湖大的最后3天 (2023 06.14-06.16)","slug":"事记 - 在湖大的最后3天 (2023 06.14-06.16)","date":"2023-06-15T16:00:00.000Z","updated":"2023-07-22T11:09:46.379Z","comments":true,"path":"2023/06/16/事记 - 在湖大的最后3天 (2023 06.14-06.16)/","link":"","permalink":"http://example.com/2023/06/16/%E4%BA%8B%E8%AE%B0%20-%20%E5%9C%A8%E6%B9%96%E5%A4%A7%E7%9A%84%E6%9C%80%E5%90%8E3%E5%A4%A9%20(2023%2006.14-06.16)/","excerpt":"","text":"06.14 周三今天主要是早上八点左右到院楼门口拍年级集体毕业照. 06.15 周四 小雨晚上跟jimmy去五一那边吃”在湖大最后的晚餐”, 事实上明晚还有一餐hhh. 可惜zzm得跟他家人一起聚餐, 不能一起来. zzm送我俩走到后湖阜埠河地铁站, 他就去跟他家人聚餐了. 我和jmy选了亚马逊, 其实也就是&lt;云计算技术&gt;这门课最后果哥请我, wf, 林st和武xy聚餐的地方. 在地铁出站时遇到了雷yl和陈sy, 刚想说巧, 谁知在亚马逊又遇到了. 这次来主要就吃了4-5杯冰淇淋, 巧克力, 荔枝, 芒果味. 人均150左右, 吃的很饱. 饭后我和jimmy在五一广场兜了个圈, 开始想去地下商城, 谁知几个入口都被堵死了, 只好作罢. 随后我提出走到湘江边上, 沿着大方向一直走, 路过了太平街. 这我才想起在开学第一天晚上我和老爸就来过, 行程与4年前形成了”首尾呼应”. 走到江边发现找不到地下隧道之类的到江岸, 又只好作罢. 最后我们走到万达广场, 从就近的地铁站回了宿舍. 06.16 周五 (毕业典礼 &amp; 学位授予) 小雨今天就是毕业典礼了, 也是在HNU的最后一天了. 早上六点多就起了床, 跟jmy和zzm俩一起坐地铁去, 咱穿的文化衫都是蓝色, 不过信息院的文化衫似乎质感有些差, 电气院的是棉的hhh. 毕业典礼上我和刘hp坐在一块, 才知道电气院已经有大佬发了CVPR, 是真的猛. 听毕业典礼的时候下了小雨, 不过座位上有雨衣所以问题不大. 典礼结束之后去大礼堂参加学位授予仪式, 路上遇到了zwling, 以后的stronghold in Beijing, hhh. 寒暄了几句便开始排队了. 授予仪式的时候我忘记向老师鞠躬了, 难顶. 学院的毕业礼物是一个学院形状的的箔片和一块鼠标垫. emmm… 学位授予弄完之后我就和8班一起拍了集体毕业照, 就在岳麓书院门口和大礼堂门口拍了几张. zzm和jmy等着我和他们一起拍毕业照, 可是这边的学位授予搞了太久, 还是没能一起拍成. 之后就和wf, 吴老师和夏老师4个一起在红楼门口, 信息院门口拍了几张. 中午回到宿舍睡了一下, 一睡就睡了好久, 以至于我赶过去院楼领双证的时候, wdy都已经快回到宿舍了. 这也是我最后一次来院楼了, 当我在院楼门口的升学去向和优秀毕设展板上看到自己的名字的时候, 一种自豪感油然而生, 这4年的光阴也算是没有虚度啊. 领完双证, 我就在彭老师开组会的教室门口等了大概40分钟. 跟彭老师和同门们一起在院楼2楼和院楼门口拍了毕业照. 一想到将来可能就基本没有机会见面了, 自然是难受. 彭老师说以后肯定会去上海, 我这才好受些. 在湖大吃的最后一餐, 我选择了师生缘二楼大碗饭的土豆牛肉, 并且没有打包带回宿舍. 四年前的情景仍历历在目: 到湖大的第一餐, 就是这个位置, 这道土豆牛肉. 这四年时间里, 食堂窗口换了又换, 幸运的是这家大碗饭还在. 真的很喜欢这种回到原点的感觉. 回到宿舍, 收拾剩下的床单被褥, 才发现根本无法随身带, 这时下棋了小雨. 我冒着雨狂奔着把东西抗下楼, 赶着最后一批顺丰寄回家. 临近出发, 我和舍友穿着学士服在我床前拍了几张照片. 临走前 此去经年, 顶峰相见! 后记TO HNU 虽然你和我想象中有些不同，更加喧嚣，浮躁，甚至治安差，成天在施工。似乎是欲扬先抑的标准开头，但确实是这样呢。故事的开始，我由于疾病不顾考核翘晚自习，报复式地在疫情期间玩了数千小时的游戏。直到转专业通知下发，那时我便知道，我…得开始奔跑起来了。为了不将遗憾带随我毕业，我不顾他人眼光，做了很多事情。拿着刚及格的高数成绩去转专业，经常地翘课去各大医院求医做检查，从弹力带到负重的引体向上；重新捡起大一时敬畏的算法竞赛，忍受着寂寞在暑假留校训练，无头苍蝇一般尝试着各种疯狂idea并测试效果…将要跑到终点时，这些场景真的像走马灯一样：期末周和同学在研讨空间的争分夺秒，申请加入课题组时的紧张和期待，“高数一百”成立那晚的树下会议，跟舍友赶早八的3人电瓶车，一个也没能完成的“510大四计划”，看鬼灭之刃时在舍友面前中二地重复各种呼吸的名字，总是停留在理论却从未实践的发型与穿搭；和发小在后湖夜谈喝下了第一口酒……好生气，没能找回研楼弄丢的耳机和综楼被偷的自行车；好满足，你的每个角落我大概都逛了个遍了吧；好遗憾，四年里没能欣赏到湘江的烟花，也没能遇到她；好惭愧，起初我总是抱怨着你的种种不好；好开心，我遇到了510的三位兄弟，好幸运，能加入到心仪的课题组和优秀的老师同学们讨论，好给力，我结识了两位实力强劲的队友；好荣幸，能和大佬们一起在考前突击…..果然，是你真的太好了。我相信几十年后的我重温这段时光，他会自豪地说:跟你度过的这4年没有遗憾。 2023.06.16 长沙-&gt;广州 回忆于：07.22日15点30分BGM: &lt;みちしるべ-路标&gt; 紫罗兰永恒花园TV ED","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"Linux - Linux Cheatsheet","slug":"Linux - Linux cheatsheet","date":"2023-04-09T16:00:00.000Z","updated":"2023-04-17T08:10:56.584Z","comments":true,"path":"2023/04/10/Linux - Linux cheatsheet/","link":"","permalink":"http://example.com/2023/04/10/Linux%20-%20Linux%20cheatsheet/","excerpt":"","text":"查看内存情况用top指令能看到kb形式的内存情况; 用free -m可以看到mb形式, free -g是gb形式 查看CPU信息cat /proc/cpuinfo 查看端口情况netstat -anp | grep -w 10208: 查看port=10208的端口 1234tcp 0 0 0.0.0.0:10208 0.0.0.0:* LISTEN 6602/docker-proxy tcp 0 0 10.28.5.208:34098 10.28.5.208:10208 ESTABLISHED 6874/ssh tcp 0 0 10.28.5.208:46100 10.28.5.208:10208 TIME_WAIT - tcp6 0 0 :::10208 :::* LISTEN 6609/docker-proxy 可以发现pid=6602, 6609等进程和port=10208有关 根据pid查看对应进程ps -aux | grep 6602: 查看pid=6602对应具体的进程 1234root 6602 0.0 0.0 1160936 3888 ? Sl 10:46 0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 10208 -container-ip 172.17.0.3 -container-port 22root 7252 0.0 0.0 13140 1120 pts/286 S+ 10:49 0:00 grep --color=auto 6602 可以发现就是自己执行的docker指令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Cheatsheet","slug":"Cheatsheet","permalink":"http://example.com/tags/Cheatsheet/"}]},{"title":"Spark & Hadoop","slug":"笔记 - Spark & Hadoop","date":"2023-04-08T16:00:00.000Z","updated":"2023-04-09T15:03:45.276Z","comments":true,"path":"2023/04/09/笔记 - Spark & Hadoop/","link":"","permalink":"http://example.com/2023/04/09/%E7%AC%94%E8%AE%B0%20-%20Spark%20&%20Hadoop/","excerpt":"","text":"spark3和hadoop3是啥关系,没有hadoop3能跑spark3吗?chatGPT: Spark3和Hadoop3都是大数据领域的重要开源软件，但它们并不是互相依赖的。Spark是一个独立的计算框架，它可以在不同的分布式存储系统上运行，包括Hadoop分布式文件系统（HDFS）。因此，在没有Hadoop3的情况下，Spark3仍然可以在其他分布式存储系统上运行，如Amazon S3、Azure Blob Storage等。不过，如果要在HDFS上运行Spark3，需要使用Hadoop2.7或更高版本。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"}]},{"title":"Docker","slug":"笔记 - Docker","date":"2023-04-05T16:00:00.000Z","updated":"2023-04-09T04:27:27.037Z","comments":true,"path":"2023/04/06/笔记 - Docker/","link":"","permalink":"http://example.com/2023/04/06/%E7%AC%94%E8%AE%B0%20-%20Docker/","excerpt":"","text":"报错: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?(1) 关闭docker(2) 启动docker daemon(3) 验证docker是否激活 123service docker stopsystemctl start dockersystemctl status docker 坑点: Docker 执行entrypoint.sh后自行exitDocker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 systemd 去启动后台服务, 容器内没有后台服务的概念. 我在dockerfile里 123COPY entrypoint.sh /sbinRUN chmod 777 /sbin/entrypoint.shENTRYPOINT [&quot;/sbin/entrypoint.sh&quot;] 其中entrypoint.sh 12#!/bin/bashservice ssh start 然后发现容器执行后就立即退出了. 这就是因为没有搞明白前台, 后台的概念, 没有区分容器和虚拟机的差异, 依旧在以传统虚拟机的角度去理解容器. 对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的, 主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西. 通过上面的介绍, 我们应该知道上面那个问题的原因了, 一句话：在Docker daemon模式下, 无论是使用ENTRYPOINT, 还是CMD, 最后的命令, 一定要使当前进程也就是容器的主进程一直运行下去, 这样才能够防容器退出, 否则主进程退出了, 容器就没有意义了, 就会跟着退出. 下面一些也是无效的启动方式 123CMD [&quot;/usr/local/tomcat.sh&quot;,&quot;start&quot;] ENTRYPOINT [&quot;/usr/local/tomcat.sh&quot;] CMD [&quot;start&quot;] 下面这样写才有效, 但是前提是容器的环境中要有sshd这个终端服务器命令. 12##SSH终端服务器作为后台运行 ENTRYPOINT /usr/local/tomcat.sh start &amp;&amp; /usr/sbin/sshd -D 笔记将当前用户添加到docker用户组为了避免每次使用docker命令都需要加上sudo权限, 可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)： sudo usermod -aG docker $USER执行完此操作后, 需要退出服务器, 再重新登录回来, 才可以省去sudo权限. 镜像（images） docker pull ubuntu:20.04: 拉取一个镜像 docker images: 列出本地所有镜像 docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04: 删除镜像ubuntu:20.04 docker [container] commit CONTAINER IMAGE_NAME:TAG: 创建某个container的镜像 docker save -o ubuntu_20_04.tar ubuntu:20.04: 将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中 docker load -i ubuntu_20_04.tar: 将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来容器(container) docker [container] create -it ubuntu:20.04: 利用镜像ubuntu:20.04创建一个容器. docker ps -a: 查看本地的所有容器 docker [container] start CONTAINER: 启动容器 docker [container] stop CONTAINER: 停止容器 docker [container] restart CONTAINER: 重启容器 docker [contaienr] run -itd ubuntu:20.04: 创建并启动一个容器 docker [container] attach CONTAINER: 进入容器先按Ctrl-p, 再按Ctrl-q可以挂起容器 docker [container] exec CONTAINER COMMAND: 在容器中执行命令 docker [container] rm CONTAINER: 删除容器 docker container prune: 删除所有已停止的容器 docker export -o xxx.tar CONTAINER: 将容器CONTAINER导出到本地文件xxx.tar中 docker import xxx.tar image_name:tag: 将本地文件xxx.tar导入成镜像, 并将镜像命名为image_name:tag docker export/import与docker save/load的区别: export/import会丢弃历史记录和元数据信息, 仅保存容器当时的快照状态save/load会保存完整记录, 体积更大 docker top CONTAINER: 查看某个容器内的所有进程 docker stats: 查看所有容器的统计信息, 包括CPU、内存、存储、网络等信息 docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx: 在本地和容器间复制文件 docker rename CONTAINER1 CONTAINER2: 重命名容器 docker update CONTAINER --memory 500MB: 修改容器限制 实战 进入AC Terminal, 然后： scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name: # 将镜像上传到自己租的云端服务器ssh server_name # 登录自己的云端服务器 docker load -i docker_lesson_1_0.tar # 将镜像加载到本地docker run -p 20000:22 –name my_docker_server -itd docker_lesson:1.0 # 创建并运行docker_lesson:1.0镜像 docker attach my_docker_server # 进入创建的docker容器passwd # 设置root密码 去云平台控制台中修改安全组配置, 放行端口20000. 返回AC Terminal, 即可通过ssh登录自己的docker容器： ssh &#114;&#x6f;&#111;&#116;&#64;&#x78;&#120;&#x78;&#46;&#120;&#x78;&#x78;&#x2e;&#x78;&#120;&#x78;&#46;&#x78;&#x78;&#x78; -p 20000 # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址然后, 可以仿照上节课内容, 创建工作账户acs. 最后, 可以参考4. ssh——ssh登录配置docker容器的别名和免密登录. 小Tips 如果apt-get下载软件速度较慢, 可以参考清华大学开源软件镜像站中的内容, 修改软件源.","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"周记 - 2023 04.03-04.09","slug":"周记 - 2023 04.03-04.09","date":"2023-04-02T16:00:00.000Z","updated":"2023-04-08T15:20:57.963Z","comments":true,"path":"2023/04/03/周记 - 2023 04.03-04.09/","link":"","permalink":"http://example.com/2023/04/03/%E5%91%A8%E8%AE%B0%20-%202023%2004.03-04.09/","excerpt":"","text":"04.03 周一 阴-&gt;暴雨下午心血来潮, 又打开了cf, 随便找了道R1300的题做. 想了挺久, 可能写完加起来得有1h了. 然后又找了道R1500的构造题, 没想到直接红温了hhh, 干到下午5点多要吃饭了还是WA2, 直接拍屁股走人了. 晚上想试下用python的库来画出webgraph官网上的那种degree-frequency图(xy轴分别都取了log10对数). 然后就想起了数模摸鱼期间用的jupyter ipynotebook, 于是就在郑老师的服务器上创了个.ipynb文件, 发现连接不上内核… 寄! 明天再说8. 04.04 周二 雨早上8点半不到就起床了, 因为跟老师约好了讨论. 下午睡醒就着手于寻找最相关的因素, 首先先排除了”高度数点平均度数 与 平均度数之间的倍数”. 04.05 周三 雨04.06 周四 雨04.07 周五 晴难得出太阳, 宿舍连廊也有挺多人开始晒被子了. 气温也挺合适, 感觉今天很适合出行呢. 上午 下午睡醒, 就和Jimmy一起去橘子洲on foot. 仍记得上学期期末那会, 我和zzm直接从五一广场步行回来, 沿途欣赏了湘江的夜景, 走过了1000多米的橘子洲大桥, 再一路走回天马. 所以这次也想着步行, 可是走到橘子洲, 才发现已经没啥力气再走到主席像那了. 04.08 周六 晴后记回忆于：03.29日22点30分 &amp;&amp; 03.30日晚22点30分BGM: &lt;四月是你的谎言&gt; OP &amp;&amp; ED &amp;&amp; OST","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2023 03.27-04.02","slug":"周记 - 2023 03.27-04.02","date":"2023-03-28T16:00:00.000Z","updated":"2023-04-05T02:16:00.774Z","comments":true,"path":"2023/03/29/周记 - 2023 03.27-04.02/","link":"","permalink":"http://example.com/2023/03/29/%E5%91%A8%E8%AE%B0%20-%202023%2003.27-04.02/","excerpt":"","text":"03.27 周一 小雨早上10点和郑老师讨论了下进度, 主要就是我目前的实验都是在爪机的WSL2上跑的小数据集, 最大也只能到orkut这种; 另外就是我简要汇报了下上周调研的路径规划的俩算法CCH和CRP, 然后4.9之前要写完个计划书之类的. 开完会我在昨天向蔡YZ学长要的服务器上, 装了boost, gflags和glog. 然后下午我又开摆了, 下午搜了下研究性实习的相关岗位. 晚上也摆, 看OIerDB看得津津有味. 睡前又稍稍看了看近期的CP比赛, 但是又不想思考, 做不动题, 颓废的一… 03.28 周二 小雨主要任务还是毕设, 其实就是把之前写挫了的算法改改. 把选块顺序从p-1, p-2…0, 改成了0, 1, 2…p-1. 这样有个好处就是最后double_expand的时候可以直接从FLAGS_p往后添加块了. 然后写着写着突然想看看学学Effective C++和Effective STL了. 于是去网上瞎逛, 又浪费了一个上午… 03.29 周三 阴今天一整天基本都在搞毕设. 忙活一整天下来, 总结一下就是搞了以下几个东西: 追踪了每条边的分配, one of 正确性验证 加入了边平衡性的检查, one of 正确性验证 加入了合并时分区间是否有交集的检查, one of 正确性验证 然而等全部写完, 并且收集完实验数据之后, 才发现边平衡性原来出了问题… 想了想, 哦, 原来合并的时候只能俩俩合并, 不能说有些桶里只有一个块, 有些桶三个块, 感觉上是真的寄了啊. 于是赶紧把代码注释掉一行, 重新跑了全部实验. 好在效果差的不太多, 该差的还是很差hhh. 今天吃饭的时候都看了, 看到有宇的妹妹因为被小混混威胁 + 自身崩坏的能力挂了, 有宇就直接黑化一蹶不振. 最后被奈绪救回来. 奈绪带男主去听演唱会, 男主突然找到缺失的一部分记忆. 从此决定去找找哥哥隼 晚上实在是想摆了, 但是啥都不想看, 啥都不想玩. 只能打开来刷刷全成就, 对着B站的攻略刷了半个小时, 刷完隐藏关卡之后才发现成就进度11/13. 点进去未完成成就, 竟然有个成就是5条命内通关全部, 完成的人只有0.1%. 果断把游戏给卸了hh. 到10点多, 我又开始对着实验结果发愁, 光按照这个指标来说, 我感觉在实际任务上超过NE和HEP的几率不是很大… 仔细想了想我又觉得点平衡性参数里更加重要的是max / avg, 毕竟每一个iteration的时长应该都取决最慢的那个分区. 所以变异系数感觉对于任务效果的表现力应该不如max / avg那么大. 好烦好烦啊啊啊. 于是向郑老师求助了一波, 老师也答应明早10点讨论下. 03.30 周四 晴早上九点下床, 十点开始跟老师讨论实验进度和接下来的对策. 目前主要遇到的问题就是: 点平衡性的max / avg下不来… 对策的话总结下来就是以下几点: 尝试把一些点在分区之间转移. 即把点数大的块分一些点到小的块上. 但是会损失边平衡性 把k调大, 因为目前最后split阶段, k默认=2. 我的直觉告诉我这会造成复制因子的暴增 大体框架沿(chao)用(xi)HEP. 即对高度数点和低度数点用HDRF和NE进行划分. NE部分换成现在的尝试5 中午吃饭看了第10话, 男主找到了他拥有穿越时空能力的哥哥隼, 然后有宇掠夺了隼的能力, 穿越回妹妹步未回学校前一天, 把妹妹的崩坏能力掠夺了, 然后又在小混混手下救下了妹妹. 中午睡醒起来又得去院楼毕设打卡, 不过还好天气还不错, 下午走在路上也感觉没那么冷了. 回来的时候去荫马塘做了10*双杠臂屈伸 + 10个引体向上. 想再来做第二组, 发现已经没剩下啥力气了… 第二组只能做4个双杠臂屈伸, 是真的难顶hh. 回来看了看空空如也的邮箱, 心里是真的难受, 我就想去实习下, 都是申请的那种研究岗位, 可是没有一封回复信hhh. 发呆了一会就干饭了. 晚饭直接把第11~13话都看完了. 主要就是说隼翼组织的司机受到反派威胁, 把友利和熊耳(就那个浑身湿透能追踪能力者的人)抓起来了, 然后有宇只身前往, 结果熊耳寄了. 有宇在友利的建议下选择跑遍全世界, 把所有能力者的能力都吸收掉, 以此来保护他们. 到后面周游世界, 吸收了一堆能力之后是真的挺尬的hhh, 就挺像火影疾风传第二次忍界大战那会一样, 有一种战力崩坏的美. 总的来说还算是Good Ending 8. 评分的话我给9.7. 打算明天再把的SP看完, 后天就到4月了, 可以看&lt;四谎&gt;了 晚上我照着对策2改了改代码, 其实挺容易改. 跑了下结果. 芜湖! 感觉还行诶. 大概就是以下这样: 点平衡 / 复制因子 尝试5 -k 2 尝试5 -k 3 尝试5 -k 4 HEP-1 HEP-10 HEP-100 NE Flickr(-round 0, 1.25) 2.9481 / 0.502106 / 1.67129 2.01713 / 0.310466 / 1.75087 1.64356 / 0.238927 / 1.78978 1.34667 / 0.18103 / 1.99497 2.84698 / 0.58959 / 1.86156 4.36106 / 0.78329 / 1.71191 5.75499 / 0.983405 / 1.58445 pokec 1.19651 / 0.107321 / 2.5574 1.18711 / 0.104949 / 4.09252 1.45267 / 0.193644 / 2.37787 1.44878 / 0.200215 / 2.32288 1.51142 / 0.204164 / 2.32316 friendster_mini 2.10636 / 0.404421 / 1.38031 1.51315 / 0.215674 / 1.42383 1.29898 / 0.127499 / 1.46265 1.48519 / 0.153918 / 1.88687 2.37839 / 0.391628 / 1.50684 3.99433 / 0.786431 / 1.30828 4.00521 / 0.786431 / 1.30592 LiveJournal 1.1505 / 0.0730565 / 1.66522 1.28244 / 0.28525 / 1.72622 1.31918 / 0.29089 / 1.56135 1.32731 / 0.299748 / 1.57191 orkut(-round 3, 1.25) 1.15136 / 0.07300 / 2.68283 1.22523 / 0.16664 / 2.87311 1.31264 / 0.1844 / 2.50675 1.30823 / 0.17113 / 2.51108 orkut big(跟HEP论文不是同一个数据集) 2.44573 / 0.328861 / 2.87441 1.37673 / 0.128226 / 3.49912 2.30367 / 0.411939 / 2.93919 5.44129 / 0.955494 / 2.22548 5.41935 / 0.948575 / 2.23474 Wikipedia 1.14254 / 0.082909 / 1.61386 1.16362 / 0.145142 / 2.20316 1.48398 / 0.29177 / 1.58819 1.43262 / 0.26002 / 1.5015 1.39854 / 0.254808 / 1.4999 twitter 3.08953 / 0.415019 / 1.61932 2.41878 / 0.288194 / 1.64963 1.98601 / 0.220865 / 1.68786 1.27907 / 0.162753 / 1.95498 2.6003 / 0.374952 / 1.68446 2.24783 / 0.361768 / 1.53564 5.37025 / 0.826788 / 1.48832 it-2004(-round 5, 1.25) 1.85107 / 0.22373 / 1.0787 1.33886 / 0.136391 / 1.06624 1.17596 / 0.0752637 / 1.11086 (edge balance: 1.02442) 1.27731 / 0.19878 / 1.2172 1.71589 / 0.38784 / 1.09575 2.37903 / 0.428073 / 1.06285 3.245 / 0.568176 / 1.04482 sinaweibo(-round 5, 1.25) 1.59702 / 0.3188 / 1.06843 1.17168 / 0.101349 / 1.07115 1.71819 / 0.263641 / 1.14221 2.8689 / 0.651315 / 1.10154 3.06843 / 0.699459 / 1.0565 2.96213 / 0.721086 / 1.04583 向郑老师汇报了之后, 我明确表达了自己对于正确性的怀疑, 打算明天搞个大检查看看hh. 03.31 周五 晴中午吃饭看 SP的P14. 下午在研究到底选哪个图计算框架来跑任务, 我看到的有好多的说: giraph(不知道是不是这么拼的), Gemini(thu大佬写的), powergraph(MPI), graphx(spark). 4篇论文里两篇是powergraph, 两篇是graphx. yysy我挺反感spark, hadoop生态的, 其实是因为我之前学过没学懂, 而且他们都是Java写的, 我对Java实在是没啥好感hhh. 说到Java, 我就想起&lt;编程新技术实务&gt;这门课, 我基本全称都是copy的github上的项目, Java可以说是只会一个”sout”. 先是想试试graphx, 然后spark不会, start-all启动失败, 寄. 然后晚上我查了查powergraph, 用mpi的可能好弄些. 但是hostname 好像一样是要多个ip, 寄 好像可以用docker来实现类似伪分布式之类的, 但是不会, 寄. 04.01 周六 晴四月终于来了, 今天气温感觉又回升了些了. 早上还是在查能不能用一台机器, 用docker来搞类似伪分布式的环境. 但是我docker完全不会. 哎, 这些基本功都没咋学过, 感觉是时候集中精力冲一波大电了. 早上想去搞一个真正的twitter-2010数据集, 之前下载的貌似不是完整版. 然后我去webgraph他们网站, 发现得安装他们的webgraph包. 无语了, java的东西, 整个上午都在搞这个包. 下午睡醒, 下床对着电脑网页发呆, 突然又想找找IT2004”偏斜度”的指标, 或者说目前算法能优化点平衡性的前提. 想起来webgraph网站上对于数据集有一些图表描述, 于是就打开了IT-2004和livejournal的对比了下. 发现 04.02 周日 晴早上一起来, 就发现昨晚睡前跑的uk-2007-05崩溃了… 重新跑了下, 发现光是载入全图, 内存就用了80+G. 好像得优化下算法了, 由于目前NE会对原edges进行修改, 所以我目前多加了个edges_backup, 导致内存占用差不多翻了一倍. 验证了下(vector) a = b 会不会把b.capacity也赋给a, 还是说只会把b.size给a, 验证代码如下: 1234567891011121314151617void solve() &#123; vector&lt;int&gt; a(10000), b(10000); cerr &lt;&lt; a.size() &lt;&lt; &#x27; &#x27; &lt;&lt; a.capacity() &lt;&lt; &#x27;\\n&#x27;; cerr &lt;&lt; b.size() &lt;&lt; &#x27; &#x27; &lt;&lt; b.capacity() &lt;&lt; &#x27;\\n&#x27;; while (a.size() &gt; 1000) a.pop_back(); a.shrink_to_fit(); cerr &lt;&lt; a.size() &lt;&lt; &#x27; &#x27; &lt;&lt; a.capacity() &lt;&lt; &#x27;\\n&#x27;; b = a; cerr &lt;&lt; b.size() &lt;&lt; &#x27; &#x27; &lt;&lt; b.capacity() &lt;&lt; &#x27;\\n&#x27;; b.shrink_to_fit(); cerr &lt;&lt; b.size() &lt;&lt; &#x27; &#x27; &lt;&lt; b.capacity() &lt;&lt; &#x27;\\n&#x27;;&#125;// 10000 10000// 10000 10000// 1000 1000// 1000 10000// 1000 1000 结果还真是只把size给了a, 看来还得加上个shrink_to_fit()才行啊hh. 下午晚上都在思考如何才能减少内存使用量. 下午想到的首先是把edges和edges_backup两个占内存大头的vector删掉其中一个, 然后再通过在struct edge_t里补充一个bool来做边的标记, 这样就可以通过一个struct来完成任务. 123456struct edge_t &#123; bool valid; uint32_t first, second;&#125; __attributed__((pakced)) ; 考虑到内存对齐的reserved bit会导致内存占用变大, 所以加上了__attributed__((pakced)), 然而这样可能又会对性能有很大影响… 再三思考下, 决定舍弃原本(1 &lt;&lt; 32) - 1的数据范围, 留出1 &lt;&lt; 31的数据范围用作valid标识. 效果如下: Memory Overhead(it-2004)| | 原版本 | 4.2优化 || ——- | ——- | ——- || it-2004 | 43.982g | 23.713g | 终于可以愉快地跑uk-2007-05了, 毕竟webgraph上的统计特征显示这张图也是有大批度数相近的高度数节点的, 挺期待效果的hhh. 晚上和rcpd病友王xh打了电话, 我从电话中得知她之前打过一针, 并且似乎没打准, 打到声带了. 上个月她又去了次, 打完后起初有效, 可是前几天又不会打了. 我们讨论到了窦教授和Bastian打针手段的不同点, 由于窦教授是通过超声定位, 从脖子注射的; 而Bastian是直接通过喉镜注射, 确实从精度上来看可能会没那么好. 她跟我谈到了去米国找Bastian打针, 我表示我将来的最终治疗是将环咽肌切开. 她似乎也正在经历我中学到大二那8年的痛苦, 于是我说至少现在已经清楚了病因和治疗方案, rcpd也会逐渐被普及, 接下来交给时间就好了. 令我倍感欣慰的是, 我得知我的经历和帖子给她和其他十几位病友带来了福音. 我也再次为自己的这段经历感到自豪, 毕竟此生最大的成就, 或者说给世界最大的贡献就是作为国内第一人接收了治疗, 并且传播了这个治疗方法. 后记回忆于：03.29日22点30分 &amp;&amp; 03.30日晚22点30分BGM: &lt;四月是你的谎言&gt; OP &amp;&amp; ED &amp;&amp; OST","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2023 03.20-03.26","slug":"周记 - 2023 03.20-03.26","date":"2023-03-21T16:00:00.000Z","updated":"2023-04-03T02:33:42.414Z","comments":true,"path":"2023/03/22/周记 - 2023 03.20-03.26/","link":"","permalink":"http://example.com/2023/03/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.20-03.26/","excerpt":"","text":"03.20 周一 小雨早上八点左右起床, 先是去校医院做个体检. 首先做内科, 测的心率92, 刚开始以为爬楼梯爬累了, 所以没当回事. 没想到测的舒张压也快到正常范围的上限了, 心肺功能变差了好多, 可能宅家宅久了8. 测身高体重依旧是常规操作, 穿羽绒大袍, 然后往口袋里塞点东西, 这次没带哑铃所以塞了个个水壶. 结果一看身高181.5cm, 体重58.5. BMI 17.+ 还是要完蛋. 回宿舍的路上自习想了想应该是头发长度的问题8, 毕竟他的机器是激光测的. 不过准确身高应该也有180了, 大四体测测的是179.6, 有点难顶, 真的好想报身高直接报180hhh. 下午晚上都在准备明天的毕设中期答辩, 中午午睡的时候手机忘记调勿扰了, 结果微信哐哐的震, 午睡就这么没了… 原来是毕设群的那些卷王在问参考文献翻译相关的要求, 我甚至还没开始准备, 只能被迫下床. 其实直到下午之前我都还没想好最终应该用怎么样的方案去应付明天的答辩. 因为目前的尝试效果都不咋地. 冥思苦想之后突然想到把BPart和NE瞎搞缝合. 然后写了个最简陋的试了下, 发现单从点平衡度量来看好像还行, 虽然我知道这种缝合怪肯定发不了文章的, 但是应付下毕设应该还是没啥问题的. 于是晚上我就疯狂搞PPT, 到12点zwling要我帮他去掉译文的水印. 看到他的文章翻译的好得一, 于是我试了下他用的arxiv翻译, 发现几篇文章都没法翻译, 寄. 03.21 周二 小雨P.S. 今天穿上了ICPC南京站的黑色棒球服, 简直不要太好看, 感觉在路上走自信力直接+50%. 早上8点半左右出门去院楼签到, 回来想去综合楼找个啥地方蹭下网, 下一些番, 主要想下&lt;追逐繁星的孩子&gt;, 因为据说好像跟&lt;玲芽之旅&gt;有点关系. 我找了间智慧教室, 看刚好生一个坑位有电源, 没想到是没电的, 电脑开机不到一分钟就自动关机了. 只能回宿舍继续肝下午答辩的PPT. 中午小睡了下, 但又没睡着. 下午1点半出门, 中楼121. 答辩可以说是水的一了, 就跟平时的实验验收一样, 只不过助教换成了老师而已, 老师看来也是接触过图划分的, NE的强悍她都猛地点头. 我说我想搞个双平衡的试试, 最后放了昨晚临时写的代码的结果, 老师说还不错, 问我是自己搞的吗. 我说老师指导的. 感觉还挺好应付过去的hhh. “答辩”完之后我就去帮zzm盖章. 首先是跑到红楼教务处, 老师让我去找二办的信息化部. 然后我就被当成球一样踢到了信息化部, 谁知那个老师态度那么差, 又把我踢回红楼. 我只能跑去复临舍试试打印机行不行. 试了下发现还真可以, 于是就帮zm盖好章了. 03.22 周三 小雨晚上老师来问我最新的实验效果, 我刚好可以把昨天下午新想出来算法的实验结果拿出来show off一下. 实验结果大概长这样: 边平衡性全为1 点平衡 / 复制因子 尝试5 HEP-1 HEP-10 HEP-100 NE Flickr 2.14585 / 2.92259 1.19371 / 3.64274 2.72022 / 2.68514 3.90338 / 2.09799 4.22383 / 1.98494 LiveJournal 1.07545 / 1.88658 1.55617 / 2.47976 1.28244 / 1.72622 1.31918 / 1.56135 1.36161 / 1.56927 pokec 1.1298 / 3.10058 1.18711 / 4.09252 1.45267 / 2.37787 1.44878 / 2.32288 1.49803 / 2.32138 orkut 1.06922 / 2.97 1.19931 / 5.40549 1.22523 / 2.87311 1.31264 / 2.50675 1.28039 / 2.52495 我还想在更大一点的数据集上试试效果, 于是相中了web-it-2004这个数据集. 主要是因为在HEP这篇文章里, IT-2004的偏斜度是最大的, 感觉上也是最有可能发挥效果的数据集. 结果捣鼓半天发现还得下载配置另外的java包才能获得完整数据集, 实在打扰. 晚上我还趁着春促买了些游戏, 这次学聪明了, 直接上steampy. 整了个&lt;千恋 * 万花&gt; 42.97R, &lt;高考恋爱一百天&gt; 20R. 又在Jimmy推荐下买了&lt;饥荒联机版&gt; 12R. 03.23 周四 大雨-&gt;小雨今天下午睡醒去帮zzm盖章, 软件所在保研手续这方面确实是有些bureaucratic. Jimmy刚好要去复临舍打印复试的成绩单, 所以顺路就一起坐车去了. 为了信息院毕设的坑比签到打卡, 只得在荫马塘下车, 看到教室只有不到10人, 是真的难蚌. 打卡完就是到复临舍打印成绩单, 没想到打印机刚好没墨了, Jimmy也治好作罢. 最后是我俩一起去电气院院楼找辅导员签字. 一开始我找错了人, 那位老师似乎也觉得实在没必要搞这种bureaucratic的东西, 态度也不是很好. 上到3楼又跑回2楼, 才找到19级新辅导员的办公室. 电气院又换辅导员了, 现在的辅导员是小热, 似乎她对这种表并不是很愿意签字, 只得叫zzm自己打电话给她, 甚至还让zzm授权我替他签名. 几番折腾下, 终于把表签完字盖完章了, 这时外面突然就开始下暴雨了… 和Jimmy在一楼门口等了几分钟, 还是决定趟着雨去下坡路的公交站坐车回天马. 没想到下车的时候雨就小了很多, 运气属实不太好呢hhh. 后记回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"Linux - Boost & glog & gflags的安装","slug":"Linux - Boost & glog & gflags的安装","date":"2023-03-05T16:00:00.000Z","updated":"2023-04-10T10:27:23.948Z","comments":true,"path":"2023/03/06/Linux - Boost & glog & gflags的安装/","link":"","permalink":"http://example.com/2023/03/06/Linux%20-%20Boost%20&%20glog%20&%20gflags%E7%9A%84%E5%AE%89%E8%A3%85/","excerpt":"","text":"已经不知道是第多少次装Boost了, 这次就记录下相关的步骤吧. 下载到boostwget boost的安装包, 以boost_1_81_0.tar.gz为例下载完成后进行解压缩. 编译器设置进入解压后产生的文件夹, 运行bootstrap.sh脚本 ./bootstrap.sh --with-libraries=all --with-toolset=gcc 编译./b2 toolset=gcc 出现: 12345678910The Boost C++ Libraries were successfully built!The following directory should be added to compiler include paths: /home/C_library/boost/boost_1_81_0The following directory should be added to linker library paths: /home/C_library/boost/boost_1_81_0/stage/lib 安装查看gcc版本, 发现: 1Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 11.3.0-1ubuntu1~22.04&#x27; --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr 所以boost也使用相同的prefix, 直接安装到gcc头文件目录和库文件目录下, 可以省略配置环境变量 ./b2 install --prefix=/usr cmake -DCMAKE_INSTALL_PREFIX=/thirdparty/gflags -DBUILD_SHARED_LIBS=ON -DGFLAGS_NAMESPACE=google -G”Unix Makefiles”","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"周记 - 2023 02.20-02.26","slug":"周记 - 2023 02.20-02.26","date":"2023-02-21T16:00:00.000Z","updated":"2023-03-01T15:26:32.645Z","comments":true,"path":"2023/02/22/周记 - 2023 02.20-02.26/","link":"","permalink":"http://example.com/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2002.20-02.26/","excerpt":"","text":"02.20 周一 晴随便做了些codeforces SWERC ICPC的签到题(&lt;=R1500). R1300的题, 能直接双指针, 我还套了个二分上去. 是真的喜欢二分哈… 晚上跟一道R1800的交互题对线, 想了快1小时, 怼出来了, 猜数题, 归根结底又是逐位确定一个数. 不过要不是能看到错误样例, 估计要多花很多时间. 02.21 周二 晴今天上午无意间想起了12.18(南京站那天)的CSP认证. 想去看看难度如何, 于是就去CSP官网看了看, 刚好题目也放上去了. 首先当然是看看咱们的答辩T3大模拟难度如何, 没想到鼠标滚轮一下就滚到底了. 题面出人意料的短, 定睛一看题意也很简单, 大概意思就是对一个矩形进行花式遍历 + 套用公式. 可以说是有史以来最简单的T3了. T2看了一眼, 感觉比T3难. 至少他涉及到了算法. 大概就是toposort + 自下向上的树形dp. 不得不说CSP的数据是真的弱, 代码有个逆天的BUG, 都能拿90分. T5 看了看, “区间连边”, 不是虚拟点就是线段树优化建图. 但是后者我掌握甚少, 打算明天系统学习一下, 顺便复习下线段树(我的数据结构水平连洛谷的线段树模板题2都敲不出来). 下午在yxc那学了会平衡树, 久光看了看视频, 就直接打扰了. yxc写的是旋转式的treap. 还没开始敲就知道自己搞不来. 所以我转而去学更加好写的split + merge的fhq 非旋式treap. 也算是对平衡树有了个初步认识. 不过以后就算遇到需要平衡树的题, 难题肯定是需要用到类似区间翻转之类的技术的, 我肯定也写不出来. 简单题我选择用pbds. 02.22 周三 晴今天一早在acwing上恰巧发现了昨天CSP T3”花式遍历”的简洁写法, 于是学习了下. 接下来便是痛苦的线段树优化建图的学习. 中午下午复习了线段树, 重温了懒标记. 补了一些线段树的基础题. 晚上对着maspy sensei的库学习具体RangeToRangeGraph的模板, 虽然maspy的模板也是基于zkw线段树的, 但是他并没有将线段树设成完全二叉树, 所以叶子节点不好区分. 学完之后拿来在codeforces 406D的模板题Legacy上试了试, 能过. 不过2022.12的CSP T5却样例都过不了. 纳闷了好久才发现样例的边权是带2的次幂的… 改过来之后, 再加上一个单汇多源最短路, 建个返图就行了. 最后骗了52分, 感觉还行. 02.24 周四 多云今晚打了小白月赛67, 体验是依托答辩. C题三角形切分那题题目也没说面积是否能为小数, 搞了一个多小时. D题是我自己sb了, 复制先前代码的时候忘记改符号了, 又得搞对拍. 然后用multiset又TLE. E题题意也是答辩. 看了半天样例才看懂, 最后5min才有思路, 其实就是倒着DP. 但是不完全对. 赛后5min才过. 不想鉴定hh. 02.26 周日 晴今天算是个值得纪念的日子, 因为就在今天, 我宣布LCJ正式进军钢琴界(虽然现在还莫得钱买真钢, 还是先拿家里的雅马哈小电子琴练着先). 下午花了一个下午, 尝试弹了弹拜厄的第11条: &lt;布谷鸟&gt;. 只能勉强把12小节谈下来, 不得不说是真的难. 首先难的便是识谱, 作为完全0基础选手, 只能一条线一条线地去数. 其次协调性也是大问题, 左右手经常打架, 是真的绝望… 不过听了下录音, 觉得还是有模有样的hhh. 晚上了解到妹妹之前玩的 这款APP, 手玩了下发现居然可以根据音频来评判弹奏是否正确. 可是会员贼贵, 一年得400了. 先试用一星期再说, 到时候再求助下万能的淘宝. 另外提一下今晚的ATC ABC 291. 发挥还行, 前期D题稍微卡了卡. 主要是看到”求方案数”, 我第一反应往组合计数上想了. 想了10min发现莫得思路. 于是看E, 发现E就是个类似差分约束的板子题. 直接toposort求最长路 + 判断是否为排列. 赛时30min的时候过掉了. 再反过来看D, 看到数据范围1e5, 这次很快转变思路, 想到了DP, 于是在第36min拿下. 本来没想着做出F的, 但是看了看好像又是那种比较能做的图论题. 类似删点最短路, 但又不完全像. 想着用线段树维护拓扑序区间内节点连边的最短路. 要维护区间最小值, 就要涉及到lazy_tag, 一涉及到lazy_tag, 我就寄. 毕竟总共就没做过几道线段树的题, 更别说lazy_tag了, 早知道之前下点功夫把maspy sensei的板子偷师下来, 放到自己的cp_library里面了. 怼了半天都没把样例怼出来. 最后zwl也觉得这种程度的图论题是应该做出来的, 哎真的难顶. 事后看了jiangly 发在B站的录像, 虽然也是起点终点求最短路, 但是他是枚举每一条边(u, v), 然后枚举(u, v)之间的点, 挨个去更新最小值. 我果然是思维僵尸hhh. 知足常乐咯, 表现分1300+, +30, 重新回到1100分. 后记回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2023 02.20-02.26","slug":"周记 - 2023 03.13-03.19","date":"2023-02-21T16:00:00.000Z","updated":"2023-03-21T12:19:46.814Z","comments":true,"path":"2023/02/22/周记 - 2023 03.13-03.19/","link":"","permalink":"http://example.com/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.13-03.19/","excerpt":"","text":"03.13 周一 晴今天7点就起床了, 依旧是老爸送我去大德路的广东省中医院去做针灸治疗, 顺便去开中药. 这次是第三次做针灸治疗, 感觉每次扎针的穴位都不太一样. 由于周日就要回长沙了, 所以我只开了5天的药. 03.14 周二 晴考虑到我中期答辩必须得线下进行, 所以我还得在中期答辩(3月21号, 下周二)之前回学校. 所以我挂了窦教授早上的号, 希望他能给我做麻醉的肉毒素注射. 从窦教授那里得知现在已经改进了技术, 已经不再需要用球囊扩张了. 03.15 周三 晴03.16 周四 晴又是得早起, 老爸送我去省中医院做针灸. 本来想的是今天先去做针灸, 然后坐地铁到岗顶找窦教授打针的, 然而窦教授今天没出诊, 于是打针作罢, 只能下周. 后记回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2023 02.13-02.19","slug":"周记 - 2023 02.13-02.19","date":"2023-02-18T16:00:00.000Z","updated":"2023-03-01T15:12:27.078Z","comments":true,"path":"2023/02/19/周记 - 2023 02.13-02.19/","link":"","permalink":"http://example.com/2023/02/19/%E5%91%A8%E8%AE%B0%20-%202023%2002.13-02.19/","excerpt":"","text":"02.15 周三 阴~大风今天早上得早起, 去中三三院对面那家 明兴康复中心 做食道测压检查. 早上早饭也没吃, 就出发了. 大概9点左右, 在岗顶路口遇到了JJJ同学, 我靠是真的巧了, 这波只能说直接”逮到”(Doge). 通过VX得知他大概也是45月份左右回学校. 这次食道测压麻醉方式跟之前不太一样, 护士是先拿普鲁卡因滴进去我的鼻子, 再插管的. 但是难受还是会有点难受的, 主要是吞咽的时候会有些许恶心感. 由于这次检查还是给窦教授测数据, 所以也没收费, 只是收了普鲁卡因的钱. 我从三院拿了药还回中心之后, 就直接回家了. 02.16 周四 多云~大风今天来看窦教授的专家门诊, 主要是希望窦教授能帮我补1针or2针. 结果遇到了另一位不会打嗝的病友, 她是来自Melbourne University的, 她在reddit上有rcpd病友群, 据说有几万人. 她这次来也是参考下国内这边的打针情况. 窦教授说会安排专门的麻醉室来打针, 不过比较难约上. 希望早点约上吧qwq 02.19 周日 阴今天晚上的ATC ABC是真的悲催. 表现分直接干到了400+, 灰名水平… 哎主要卡了C, 当时我就知道这盘大势已去. 没想到D题没有仔细思考就上来写, 到最后才发现做法是假的. 感觉其实就是一道codeforces div2 B题难度的gcd规律题. 是真的难受啊. 直接-52. 掉下1100了. 离青名1200再一次远去. 后记回忆于：02.15日晚19点30分 &amp;&amp; 02.19","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"事记 - 2022计算机保研回忆录","slug":"事记 - 2022计算机保研回忆录","date":"2023-02-15T16:00:00.000Z","updated":"2023-07-22T07:35:06.042Z","comments":true,"path":"2023/02/16/事记 - 2022计算机保研回忆录/","link":"","permalink":"http://example.com/2023/02/16/%E4%BA%8B%E8%AE%B0%20-%202022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/","excerpt":"","text":"术语:CS: 计算机科学SE: 软件工程 个人情况 本科院校: 湖南大学 专业: 计算机科学与技术 排名情况: 14/225(夏令营), 13/221(预推免). (这俩都是挑的最好的排名) 外语水平: 四级629, 六级598. 自认为口语能过关. 获奖及竞赛: 详见 &lt;关于博主&gt; 页面 科研项目: 本校实验室实习一年半(产出CCF A类会议挂名一篇), 复旦大学大数据学院一学期的实习(无产出)经历 最终去向: 复旦大学大数据学院 院校选择 学校：北上广的高校(中山, 北航, 同济, 华东师, 华工 etc.) + 华五人(理想: 交&gt;复&gt;南&gt;浙&gt;科&gt;人) 个人不太倾向研究所, 考虑到将来的选择, 可能更加注重title &amp;&amp; 身为广州人, 也更倾向于回家读书. 硕/博：硕士博士都行, 但是优先硕士. 如果科研顺利可以转博. 导师：人品 &gt; push程度 &gt; 学术能力 人品rk first 夏令营 学院 入营 优营 人大信院 ❌ - 复旦大数据 ✔️ 候补 南大CS 候补 放弃 南大SE 候补 放弃 科大大数据 候补 放弃 上交电院 ❌ - 同济SE ❌ - 计算所 ✔️ 放弃 天大智算 ✔️ 放弃 自动化所 ❌ - 北航CS ✔️ ✔️ 华东师SE ✔️ ✔️ 中山CS ❌ - 华工CS ❌ - 哈深CS ❌ - 武大CS ❌ - 华科CS ❌ - P.S. 中山大学: 由于个人操作疏忽, 在报名时, 忘记将最重要的盖了校章的资料上传了. 导致尽管有一群海王放弃, 开放第二波入营, 我也没能入营. 可以说是彻底无缘了. 南京大学CS &amp;&amp; SE: 并不是一批次入营, 而是在第二批入营的. 可是和华东师大的最终面试汇报冲突了, 权衡风险利弊(南大408大概率成为炮灰, 华东师范当时已经通过了笔试和导师面试)后还是选择了放弃. 科大大数据: 大概率是由于rk过低, 只能候补入营. 最后也没后补上. 清北的一些研究院也都投了, 显然白给hhh 华东师范大学 SEECNU的系统可以填报2个志愿, 所以我CS和SE都填了. 可是令我意外的是居然入了SE的夏令营, 听说ECNU有oq机制, 没想到居然放我入了SE. 具体考核的话, 分为机试 + 导师面试(包括看论文) + 个人汇报, 过程还是十分繁琐的, 这也算是筛除海王的一种方式吧. Stage1: 机试ECNU的机试是出了名的难. 这次我算是亲身体会到了. 总共3题. T1就按照题意模拟, 但我找不出BUG. T2感觉像是树形dp, 不过保守估计难度对应于codeforces 2000+分. T3是感觉像是删边最短路, 直接打扰, 不配看题. 还好是IOI赛制, 最后T1 WA了一个点85pt, T2瞎搞DP, 骗了30pt. T3爆零. 85+30+0=115pt. 有一说一T3直接暴力二进制枚举所有边, 可能还是可以骗些分的. 总体来说感觉还行. Stage2: 导师单面ECNU要求联系学院的一位老师, 联系好之后加了老师的QQ. 之后老师安排我阅读他的一篇长文. 我当时没注意到长文这一条件, 再加上当时在上苦逼的编译器小学期课, 天天在院楼苦逼地罚坐, 所以我临面试前一天赶忙看了看一篇短文, 大致是时空数据挖掘, 众包方向的A刊文章. P.S. 我还了解到我联系的这位老师和他所在的实验室都是热门, 他还跟我说学硕名额十分有限. 意思懂的都懂qwq 面试首先要求我汇报文章的主要内容, 然后老师提问了我对于实时性要求更高的场景, 能不能提出在线的算法, 我想了想瞎扯了下, 老师似乎不是很满意. 其次便是算法考核. T1是问给定一个数组a, 要求把这个数组分成2组, 使得两组的总和尽可能接近. 这题还算比较简单, 就是一个简单的背包dp, 目标物品价值便是1/2的数组总和. 老师听了似乎不是很满意, 要求我给出证明, 我只得面试结束后给他发过去. T2看似是最小生成树的问题, 但是没想到怎么建图, 所以我就说二分答案. 老师似乎不太理解我的意思. 到这里面试便草草结束. 无论是机试的考核内容和难度, 还是单独面试的算法考核, 都不难看出ECNU SE 对于编程和算法的要求都是蛮高的. Stage3: 最终汇报ECNU要求我们准备一个自我介绍的PPT, 然后在PPT内要放上Stage2所汇报的论文的内容. 汇报当天我在等候面试排队的时候, NJU CS的机试恰好开始了, NJU的小姐姐打电话来说要提前进场准备验证身份, 还说不参加要提前说. 没得办法, 只好先拖住了. 然鹅到NJU机试开始, 我都没能排队进入最终汇报, 只能打电话到NJU说放弃机试. 最终面试可以选择中英文汇报, 我由于时间仓促, 选择了中文. 到最后有个导师群面, 导师们用英文提问, 我只记得一个问题是介绍我在本校实验室所做的工作, 勉强支支吾吾答上来了. 最后夏令营闭幕式上会宣布优营成员, 还通过邮件发了优营证书, 属于是十分有心了. 我看优营还有SJTU的大佬, 属实打扰了. 北京航空航天大学 CS北航没有因为我过低的rank就把我筛掉, 估计是看在我那一丢丢算法竞赛经历的面子上才放我入营的. 知遇之恩, 由是感激. 北航考核方式是机试+面试. Stage1: 机试北航的机试一直都是以码农题著称, 我看了下往年的机试题, 感觉是难度还能接受的两道大模拟(低于CSP T3), 没想到今年的模拟这么逆天… 赛制是恶心的OI赛制. 可以用CSP的成绩来抵, 并且语言限定C++. 不过我CSP分数实在过低过于感人, 所以我还是来考机试了. T1是字符串处理 + 结构体排序. 由于是线上机试, 所以拥有东道主优势(doge). 其实是自己的键盘快捷键ide自己比较熟悉啦. T1应该拿满60了, 因为我T2实在是没办法, 所以自己造了几组数据梭哈T1. T2是关于编译原理的应用的巨大模拟之依托答辩, 实在难以模拟, 写不出来就输出样例想骗一下分. 不过这次机试好像并没有筛人, 但是机试很明显是算在了面试总评里面的. 赛后在腾讯会议看到了自己的高中同学, 西电acm知名选手et3_tsy. 我俩刚好在同一个房间, 祝福他能取得优异的成绩. 赛后我俩交流才发现T2连他这种巨佬都没干过, 区分度属实有点过于低了. Stage2: 导师群面面试是压力面, 内容包括政治+408+数学+英语, 面试问题汇总如下： 如今正处百年未有之大变局, 我们身为青年应该作为 函数极限的定义, 用\\epsilon-N语言来描述 同时抛两个硬币, 其中一个是正面, 问另一个是正面的概率 一个随机生成的01串, 口述一个算法能够统计其中的最长连续1的子串长度. 续上述问题, 长度为10000, 最长的连续1的子串长度期望大概是多少. 为什么要创建网络层 电话号码 IP相关? (记不清了) 之前在知乎经验贴上看到北航的面试很硬核. やはりや, 北航的夏令营确实是一种压力面, 就是那种几个老师会一起怼你的那种, 丝毫不会放松进攻节奏. 问到T4时我直接脱口而出dp, dp[i]表示以第i个字符作为结尾的1子串最大长度, 从dp[i-1]到dp[i]分为00, 01, 10, 11四种转移. 复杂度O(n). しかし, 接下来的T5我直接就傻了. 概率期望类的题我一向不擅长, 我仔细想了想状态设计. 可能是我误解了老师的问题, 老师打断我说大概给出一个数字. 我就瞎蒙了个10+给他们. 到此为止, 可以看得出老师们对于我以上的回答都是挺满意的. 然鹅接下来的问题直接就拉低了我的分数. 一位老师直接开始问计网相关的问题… “哦豁~完蛋!” 要知道咱的计网可是hsr教的呀(保研成绩单上扫一眼, 计网分数显著低的同学肯定是咱78班的. doge). 最终在我等复旦候补的时候, 打电话问我确认意向, 得知录到了计算机学院的0835 软件工程, 感觉已经很不错了. 北航最终认可了我, 再加上我的队友zwling也最终去北航了, 因此北航在我心目中第好感度和地位直接排进前3. 天大智算天大属于海王营. 首先参加机试, 机试难度 &lt; codeforces div4, 感觉很多人都能AK. 但是是OI赛制, 就很烦. 我提前大约20分钟完成. 但是没注意到最后一题的公式弄错了个地方, 估计那题爆零了qwq. 最后居然在Q群上说机试仅作为参考? 迷惑行为了属于是. 后续我也没参加了. 计算所计算所我报名的是”网络数据科学与技术重点实验室”, 其实是实在很难找到方向匹配的导师, 这个已经是找的相对匹配些的了. 入营邮件是群发的, 一看其他邮件的二级域名, pku, tongji, 实在是打扰了. 虽然最后也没想着参加机试, 但还是先回复了:”lcj+确认参加”. 结果最后还是没去参加机试. 预推免夏令营拿到了北航CS和华师SE的offer可以作为保底, 同时争取下复旦的候补, 此时我已经身心俱疲, 于是开摆. 只报了南大的CS, 估计是被拉黑了, 没能入营(虽然我知道就算入营了也不可能卷过408大关, 拿到0812学硕). 后记回忆于: 02.15日晚19点30分","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"Linux - WSL2 下使用宿主机代理","slug":"Linux - WSL2 下使用宿主机代理","date":"2023-02-13T16:00:00.000Z","updated":"2023-02-15T13:26:37.634Z","comments":true,"path":"2023/02/14/Linux - WSL2 下使用宿主机代理/","link":"","permalink":"http://example.com/2023/02/14/Linux%20-%20WSL2%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/","excerpt":"","text":"WSL2科学上网 前言: 情人节当天搞了一晚上… 最后参考的这篇才成功 https://www.cnblogs.com/tuilk/p/16287472.html, 1. Windows下打开代理1.1 允许局域网以Clash为例, 购买相关配置, 选择主页选项卡, 开启允许局域网: 1.2 开启防火墙打开Windows Defender 防火墙, 选择允许应用或功能通过 Windows Defender 防火墙: 点击更改设置, 找到Clash for Windows, 然后勾选专用和公用: 如果找不到Clash for Windows, 点击下方的允许其他应用, 然后找到安装路径, 将Clash for Windows.exe文件加入进来. 2. 配置WSL2(.bashrc 长期配置)写脚本, 放到脚本文件夹. 通过在.bashrc里配置alias调用脚本, 实现proxy的快速set和unset. 新建proxy.sh脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/shhostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)port=7890PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;set_proxy()&#123; export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot; export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot; export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot; export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot; export ALL_PROXY=&quot;$&#123;PROXY_SOCKS5&#125;&quot; export all_proxy=$&#123;PROXY_SOCKS5&#125; git config --global http.https://github.com.proxy $&#123;PROXY_HTTP&#125; git config --global https.https://github.com.proxy $&#123;PROXY_HTTP&#125; echo &quot;Proxy has been opened.&quot;&#125;unset_proxy()&#123; unset http_proxy unset HTTP_PROXY unset https_proxy unset HTTPS_PROXY unset ALL_PROXY unset all_proxy git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy echo &quot;Proxy has been closed.&quot;&#125;test_setting()&#123; echo &quot;Host IP:&quot; $&#123;hostip&#125; echo &quot;WSL IP:&quot; $&#123;wslip&#125; echo &quot;Try to connect to Google...&quot; resp=$(curl -I -s --connect-timeout 5 -m 5 -w &quot;%&#123;http_code&#125;&quot; -o /dev/null www.google.com) if [ $&#123;resp&#125; = 200 ]; then echo &quot;Proxy setup succeeded!&quot; else echo &quot;Proxy setup failed!&quot; fi&#125;if [ &quot;$1&quot; = &quot;set&quot; ]then set_proxyelif [ &quot;$1&quot; = &quot;unset&quot; ]then unset_proxyelif [ &quot;$1&quot; = &quot;test&quot; ]then test_settingelse echo &quot;Unsupported arguments.&quot;fi 注意: 其中第4行的&lt;PORT&gt;更换为自己的代理端口号. source ./proxy.sh set: 开启代理 source ./proxy.sh unset: 关闭代理 source ./proxy.sh test: 查看代理状态 2.1 任意路径下开启代理可以在~/.bashrc中添加如下内容, 并将其中的路径修改为上述脚本的路径: 1alias proxy=&quot;source /path/to/proxy.sh&quot; 然后输入如下命令: 1source ~/.bashrc 那么可以直接在任何路径下使用如下命令: proxy set: 开启代理 proxy unset: 关闭代理 proxy test: 查看代理状态 2.2 验证使用curl即可验证代理是否成功, 如果有返回值则说明代理成功. 1curl www.google.com","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"周记 - 2023 02.06-02.12","slug":"周记 - 2023 02.06-02.12","date":"2023-02-13T16:00:00.000Z","updated":"2023-02-15T12:12:25.636Z","comments":true,"path":"2023/02/14/周记 - 2023 02.06-02.12/","link":"","permalink":"http://example.com/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/","excerpt":"","text":"02.10 周五 多云~阴今天晚上参加了晚上7点的小白月赛66. 开局上来就被A搞了快10分钟. B更是因为没讨论 A &lt;= B的情况调到40分钟. D题一开始也是不会做, 不过好在发现了平方式的用意. 最后还剩半个多小时做E, 想了会发现是道完全图的构造题. 想着用set insert + erase + lower_bound 3e5次(2s时限)硬怼构造边权, 不过没写完. 赛后写完交了, TLE. やはり(yahari 果然)还是找出边权递增的顺序去赋值边权才行. 后话: 其实set硬怼也行, 不过得用到 霓虹大神maspy的 fastset 最后四题, 感觉我做E的时候还是太呆了. WF说要暂不返校要填表, 而且明天之前就要截止了. 我想着没啥理由, 然后就打了个嗝, 不过不是很畅通, 是那种嘶哑的, 心想之前考虑打 “加强针” (中间右边再补针). 不如趁这个机会打了得了, 所以就这么填了. 02.11 周六 多云~阴早上补昨晚小白月赛66的F题, 发现好像是个挺简单的一眼二分 + 尝试性贪心(只用从后往前合并和从前往后合并两种, 枚举下就知道哪个更优了). 晚上打ABC 289. 前四题依然慢速, 做了20+分钟… 尤其是B题别人用题目性质 + 双指针很快写完, 我还用并查集硬怼模拟. C题二进制枚举看半天题. D题因为转为index 0 based党, 所以dp方式也改成了刷表法. しかし(shi ka shi 可是) vector开小了, RE了一发. E题想了一个小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. 以为是O(n^2)的, 其实是O(m^2)的, 都没看到边数m &lt;= 2000. 属于是瞎猫撞上死耗子了. 表现分1364, +29来到1138. 离青名只差62分了, がんばって (顽张って ga n ba te加油)! 02.12 周日 多云~小雨中午起床收到微信下午开组会. やはり还是得继续科研进度. 开会讨论后, 认为应该从下游任务的实际实验效果看看. 所以得用到分布式图计算的环境. 但是我之前除了gstore外就没用过其他框架了. 问了蔡学长, 得知服务器集群得校园网访问. 实在难顶. 下午4点 场的codeforces 852 div2. 难得不是阴间时间. 直接炸穿. A40+分钟才过. 哎情况没讨论好, 多写了if, 其实都要考虑的. B一开始看到了条件”数组元素绝对值之差为1”, 后面又忘了这个条件了. C吃完饭后回来才写完. 表现分只有不到1000分呢. 我直接好家伙, 上个青名都费劲, 我好像只配打div3和div4. 哎谁让我上次div4没把握好机会呢? 要是上次写慢些, 老老实实把树状数组写了, 再检查好二分边界, 也没那么多烦事了. 不过呢, 这点掉分只能说是小问题, 打还是会继续打的. 只是cf这种rated波动那么大的比赛, 不如直接彻底开摆得了. 这样得失心放轻些, 说不定还能表现得正常些. 下次div2我想直接从C或D开始干了, 效仿rainboy大神. 后记回忆于：02.15日晚19点30分","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 289 A-E","slug":"题解 - AtCoder Beginner Contest 289 A-E","date":"2023-02-10T16:00:00.000Z","updated":"2023-02-15T13:25:48.137Z","comments":true,"path":"2023/02/11/题解 - AtCoder Beginner Contest 289 A-E/","link":"","permalink":"http://example.com/2023/02/11/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20289%20A-E/","excerpt":"","text":"+29! 表现分1364, 历史第二高, 感觉不错. E题冥思苦想想了1个多小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. A. flip题意将给定的01串s, 进行01翻转后输出 思路代码1234567void solve() &#123; string s; cin &gt;&gt; s; for (auto c : s) &#123; if (c == &#x27;0&#x27;) cout &lt;&lt; &#x27;1&#x27;; else cout &lt;&lt; &#x27;0&#x27;; &#125;&#125; B. V题意思路我是直接按照题意用并查集模拟了整个过程. 对于 代码12345678910111213141516171819202122232425262728293031323334353637383940const int N = 1000 + 10;int p[N];int find(int x) &#123; return x == p[x] ? p[x] : p[x] = find(p[x]);&#125;void merge(int u, int v) &#123; u = find(u), v = find(v); if (u == v) return; p[u] = v;&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(m); for (auto &amp;x : a) cin &gt;&gt; x, x --; vector&lt;vector&lt;int&gt;&gt; wcc(n); iota(p, p + n, 0); for (auto x : a) &#123; merge(x, x + 1); &#125; for (int i = 0; i &lt; n; ++ i) &#123; wcc[find(i)].pb(i); &#125; for (int i = 0; i &lt; n; ++ i) &#123; sort(all(wcc[i])); reverse(all(wcc[i])); &#125; set&lt;int&gt; S; for (int i = 0; i &lt; n; ++ i) S.insert(i); while (S.size()) &#123; int now = *S.begin(); for (auto x : wcc[find(now)]) &#123; cout &lt;&lt; x + 1 &lt;&lt; &#x27; &#x27;; S.erase(x); &#125; &#125;&#125; C. Coverage题意思路二进制枚举 代码12345678910111213141516171819202122232425262728void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector S(m, vector&lt;int&gt;(n)); for (int i = 0; i &lt; m; ++ i) &#123; int c; cin &gt;&gt; c; for (int j = 0; j &lt; c; ++ j) &#123; int x; cin &gt;&gt; x; x --; S[i][x] = 1; &#125; &#125; int ans = 0; for (int val = 0; val &lt; (1 &lt;&lt; m); ++ val) &#123; vector&lt;int&gt; has(n); for (int b = 0; b &lt; m; ++ b) &#123; if (val &gt;&gt; b &amp; 1) &#123; for (int i = 0; i &lt; n; ++ i) if (S[b][i]) &#123; has[i] = 1; &#125; &#125; &#125; int sum = accumulate(all(has), 0); if (sum == n) &#123; ++ ans; &#125; &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Step Up Robot题意思路dp[i]表示i点能否从0到达. 我用的刷表法, 每个i点更新n个新状态. 代码1234567891011121314151617181920212223242526void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int m; cin &gt;&gt; m; vector&lt;int&gt; is_trap(200&#x27;000 + 10); for (int i = 0; i &lt; m; ++ i) &#123; int x; cin &gt;&gt; x; is_trap[x] = 1; &#125; int x; cin &gt;&gt; x; vector&lt;int&gt; dp(200&#x27;000 + 10); dp[0] = 1; for (int i = 0; i &lt;= x; ++ i) &#123; if (is_trap[i]) continue; for (auto inc : a) &#123; dp[i + inc] |= dp[i]; &#125; &#125; LOG(dp[x]) if (dp[x]) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125;&#125; E. Swap Places题意思路新套路get. 难得赛时能想出这种没见过的东西. 两点绑定在一起进行 bfs. queue 的元素为/[当前a所在节点, 当前b所在节点, 已经走过的步数/] 同时用dp[i][j]表示a到i, 且同时b到j的最小步数 每个状态只会入队出队一次, 复杂度O(n2) 代码12345678910111213141516171819202122232425262728293031323334const int inf = 1e18;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; c(n); for (auto &amp;x : c) cin &gt;&gt; x; vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 0; i &lt; m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u --, v --; g[u].pb(v); g[v].pb(u); &#125; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, inf)); // dp[0][n - 1] = 0; queue&lt;array&lt;int, 3&gt;&gt; q; q.push(&#123;0, n - 1, 0&#125;); while (q.size()) &#123; auto [ca, cb, cd] = q.front(); q.pop(); if (ca == n - 1 &amp;&amp; cb == 0) &#123; cout &lt;&lt; cd &lt;&lt; endl; return; &#125; for (auto na : g[ca]) &#123; for (auto nb : g[cb]) &#123; if (c[na] == !c[nb] &amp;&amp; dp[na][nb] &gt; dp[ca][cb] + 1) &#123; dp[na][nb] = dp[ca][cb] + 1; q.push(&#123;na, nb, dp[na][nb]&#125;); &#125; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125; A. flip题意思路代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"周记 - 2023 01.30-02.05","slug":"周记 - 2023 01.30-02.05","date":"2023-02-05T16:00:00.000Z","updated":"2023-02-15T12:12:46.249Z","comments":true,"path":"2023/02/06/周记 - 2023 01.30-02.05/","link":"","permalink":"http://example.com/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/","excerpt":"","text":"02.03 周五 多云~小雨今天主要参加了晚上10点半的div4 849. 开局虽然又被E (R1100)卡了下, 不过还是很快能搞定. F题一开始想不到好做法, 本来打算写树状数组, 但是没整理板子, 区间修改之类的又得重新写, 所以就投机取巧试了试用set维护还能修改的坐标. 一交, 诶居然能过. 然后就没理了. G1和G2我一开始以为做了G2, G1也能一起交. 所以G1的罚时多了很多. G2我一开始想错了, 不过还是很快想到了二分. 并且很快写完了. 一看才400+人过. 暗自窃喜. 正式榜甚至进了首页, 表现分高达2050! zwling还觉得我能直接上蓝. 没想到小丑竟是我自己…F和G2都FST了. 早知道F老老实实写区间修改 + 单点查询 树状数组了. G2是因为二分边界l = 0写成了l = 1. 我是真的讨厌这种下标从0开始, 从1开始的臭东西. 以后想坚定做下标0-base党了. 不过看到G2居然是R1900的题, 十分震惊. 感觉其他R1900的题比他难得不止一点半点. 02.04 周六 小雨~中雨晚上有Atcoder Beginner Contest 288. 8点麻木地开打, 前两题签完到, C题经典手速慢的惊人, 一开始写toposort, 发现不对劲, 才改并查集. D题罚坐1个半小时, 一看全场就800+过, 是真的逆天. 属于那种大聪明之差分性质挖掘题. rk2000+, 直接完蛋, 不过最终-6. Atcoder yyds! 02.05 周日 小雨晚上8点 tourist场的div2. 难得不是阴间时间, 但是考虑到tourist出题, 上次div1+div2合并场的A都给我干趴下了. 这次也不例外, A1 + A2直接给我整了半个小时. B题又是上下限约束题, 想了挺久才想出来. C题贪心, 但是本来1层循环4行的东西, 我写了一堆if 的答辩东西. 还WA了一发. 一看rk2000+. 好家伙我赛前看见register人数18000+, 现在只有7000+提交, 是真的逆天. 不过还好一分没丢没涨. D结论瞎撞撞对了, 不过是真的难写. 其实主要是我的思路十分混乱, 其实只用把每个人视作多个 &lt;need char, give char&gt; 就行了. 先是恰好互补的人交换. 交换完剩下的一定只有3种人, 这3种人恰好能组成交换环. 后记回忆于：02.06日晚22点","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"笔记 - CP模板","slug":"笔记 - CP模板","date":"2023-02-05T16:00:00.000Z","updated":"2023-03-06T12:28:58.311Z","comments":true,"path":"2023/02/06/笔记 - CP模板/","link":"","permalink":"http://example.com/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"FOR MOREPlease refer to channing’s cp_library 计数模板123456789101112131415161718192021222324252627282930313233343536373839template&lt;const int T&gt;struct ModInt &#123; const static int mod = T; int x; ModInt(int x = 0) : x(x % mod) &#123;&#125; int val() &#123; return x; &#125; ModInt operator + (const ModInt &amp;a) const &#123; int x0 = x + a.x; return ModInt(x0 &lt; mod ? x0 : x0 - mod); &#125; ModInt operator - (const ModInt &amp;a) const &#123; int x0 = x - a.x; return ModInt(x0 &lt; 0 ? x0 + mod : x0); &#125; ModInt operator * (const ModInt &amp;a) const &#123; return ModInt(1LL * x * a.x % mod); &#125; ModInt operator / (const ModInt &amp;a) const &#123; return *this * a.inv(); &#125; void operator += (const ModInt &amp;a) &#123; x += a.x; if (x &gt;= mod) x -= mod; &#125; void operator -= (const ModInt &amp;a) &#123; x -= a.x; if (x &lt; 0) x += mod; &#125; void operator *= (const ModInt &amp;a) &#123; x = 1LL * x * a.x % mod; &#125; void operator /= (const ModInt &amp;a) &#123; *this = *this / a; &#125; friend ostream &amp;operator &lt;&lt; (ostream &amp;os, const ModInt &amp;a) &#123; return os &lt;&lt; a.x;&#125; friend istream &amp;operator &gt;&gt; (istream &amp;os, const ModInt &amp;a) &#123; int v; os &gt;&gt; v; a = ModInt(v); return os;&#125; ModInt pow(int n) const &#123; ModInt res(1), mul(x); while(n) &#123; if (n &amp; 1) res *= mul; mul *= mul; n &gt;&gt;= 1; &#125; return res; &#125; ModInt inv() const &#123; int a = x, b = mod, u = 1, v = 0; while (b) &#123; int t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); &#125; if (u &lt; 0) u += mod; return u; &#125;&#125;;using mint = ModInt&lt;mod&gt;; 树状数组123456789101112131415161718192021template &lt;typename T&gt;struct fenwick &#123; int n; vector&lt;T&gt; tr; fenwick(int n): n(n) &#123;tr.resize(n);&#125; int lowbit(int x) &#123; return x &amp; -x; &#125; T query(int pos) &#123; T res = 0; for (++ pos; pos &gt;= 1; pos -= lowbit(pos)) &#123; res += tr[pos]; &#125; return res; &#125; void add(int pos, T val) &#123; for (++ pos; pos &lt;= n; pos += lowbit(pos)) &#123; tr[pos] += val; &#125; &#125;&#125;; 字符串(双)哈希123456789101112131415161718192021222324252627282930using hash_t = array&lt;int, 2&gt;;const int mod0 = 1e9 + 7, mod1 = 1e9 + 9;hash_t base = &#123;13331, 23333&#125;;hash_t pw[N];hash_t operator + (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] + b[0]) % mod0, (a[1] + b[1]) % mod1&#125;; return res;&#125;hash_t operator - (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] - b[0] + mod0) % mod0, (a[1] - b[1] + mod1) % mod1&#125;; return res;&#125;hash_t operator * (hash_t a, hash_t b) &#123; return &#123;a[0] * b[0] % mod0, a[1] * b[1] % mod1&#125;;&#125;pw[0] = &#123;1, 1&#125;;for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pw[i] = pw[i - 1] * base;&#125;for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pre[i] = pre[i - 1] * base + hash_t&#123;s[i], s[i]&#125;;&#125;for (int i = 2 * n; i &gt;= 1; -- i) &#123; suf[i] = suf[i + 1] * base + hash_t&#123;s[i], s[i]&#125;;&#125; 更新日志:2023.01.18: 加入计数模板 + 字符串双哈希模板 2023.02.06: 加入朴素fenwick模板 等cf上1500 / atcoder上青名, 就着手构建自己的library","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记_模板","slug":"笔记-模板","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"}]},{"title":"题解 - Educational Round 142 (Div. 2) A-D","slug":"题解 - Educational Round 142 (Div. 2) A-D","date":"2023-02-01T16:00:00.000Z","updated":"2023-02-06T13:55:56.070Z","comments":true,"path":"2023/02/02/题解 - Educational Round 142 (Div. 2) A-D/","link":"","permalink":"http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/","excerpt":"","text":"C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射. 6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶. B. Stand-up Comedian题意Stand-up Comedian: 单口相声演员 有四种类型的笑话： 第一种: 使AB的情绪都 +1 第二种: 使A的情绪 +1, B的情绪-1 第三种: 使A的情绪 -1, B的情绪+1 第四种会使AB的情绪都-1 两人的情绪初始为0. 求在AB中某一人情绪降至0时可以讲的最大笑话数 分析又犯了经典错误之 b -= min(b, c); c -= min(b, c);. 第一种类型直接加上 所以 ans += a 第二种类型和第三种类型交替使用. 所以 ans += min(b, c) 最后时刻, 最后一类和剩下的第二第三类地位等价. 所以 ans += min(a + 1, b + c + d) 代码12345678910111213141516void solve() &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int ans = a; if (a) &#123; int dec = min(b, c); ans += dec * 2; // b -= min(b, c); // c -= min(b, c); b -= dec; c -= dec; &#125; LOG(a, b, c, d) // 此时 bc与d的地位等价 ans += min(a + 1, b + c + d); cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Min Max Sort题意一个排列p, 每次可以选两个数x和y, 将两者较小的移到开头, 较大的移到 最后时刻, 最后一类和剩下的第二第三类地位等价结尾.. 问排成增序所需最小操作次数. 分析首先可以确定操作次数上限是n/2, 即(n/2, n/2+1)…(1, n). 接下来再看怎么样能少操作几次. 例子: 1 6 3 4 2 5. (3, 4)一开始就挨在一起了, 并且是(3, 4)而不是(4, 3), 所以可以省略掉这一步, 直接考虑(2, 5). 发现(2, 5)并不分别位于(2, 3)的左右两侧. 所以这一步是必不可少的操作 如果情况是 1 2 3 4 6 5, 那么(3, 4)和(2, 5)都可以省略了. 只需要做一次(1, 6)操作就行. 结论就是 (n/2, n/2+1) 在最中间, 然后n/2-1, n/2+2分别位于(n/2, n/2+1)左右两侧, 如果某对逆序了, 或者没有位于两侧, 那么接下来的操作都不能省略. 用pos记下每个数的位置, l, r记录上一对数对的位置(注意n为奇数的情况, 此时中间只有一个数, 所以l = r) 然后从中间开始枚举, 依次判断数对的相对位置就行. 代码123456789101112131415161718192021222324252627282930void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); vector&lt;int&gt; pos(n); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; a[i] --; pos[a[i]] = i; &#125; LOG(a) // 4: // 0 1 2 3 // 5: 2 // 0 1 2 3 4 int ans = n / 2; int i = 0; int l = pos[n / 2], r = pos[n / 2]; for (; i &lt; n / 2; ++ i) &#123; int v1 = (n - 2) / 2 - i, v2 = n - 1 - v1; LOG(v1, v2) int p1 = pos[v1], p2 = pos[v2]; if (p1 &gt; p2 || !(p1 &lt;= l &amp;&amp; p2 &gt;= r)) &#123; break; &#125; l = p1, r = p2; &#125; ans -= i; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Fixed Prefix Permutations题意给定 n 个 1m 的排列a[1n]. 定义一个排列的分值为: 最大的满足 p1=1,p2=2,….,pk=k 的 k . 定义两个排列 p,q 的乘积 p×q=r 为 r[j]=q[p[j]]. 对于每个排列a[i], 求出它乘以所有这 n 个排列a[j]能得到的最大分值. 最后时刻, 最后一类和剩下的第二第三类地位等价. 分析学习(偷)了日本大神maspy的Trie板子. 固定的a[i], 记为p. a[j], 记为q. r[i] = q[p[i]] = i q[p[i]] = i. 两边同时取q^-1, 也就是取pos_q. p[i] = pos_q[i] = i. 也就是找p[i]和所有pos_q[i]最长的公共前缀. 只需要把所有的pos_q建一个Trie. 然后每次查询p[i]时, 在pos_q中找最长公共前缀的长度就行. 代码1234567891011121314151617181920212223242526void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector p(n, vector&lt;int&gt;(m)); vector pos(n, vector&lt;int&gt;(m)); Trie&lt;10&gt; tr; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = 0; j &lt; m; ++ j) &#123; cin &gt;&gt; p[i][j]; p[i][j] --; pos[i][p[i][j]] = j; &#125; tr.add&lt;vector&lt;int&gt;&gt;(pos[i], 0); &#125; for (int i = 0; i &lt; n; ++ i) &#123; LOG(pos[i]) int cv = 0, cnt = 0; for (int j = 0; j &lt; m; ++ j) &#123; cv = tr.TO[cv][p[i][j]]; LOG(cv) if (cv == -1) break; ++ cnt; &#125; cout &lt;&lt; cnt &lt;&lt; &quot; \\n&quot;[i == n - 1]; &#125;&#125; C. Min Max Sort题意分析代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数据结构","slug":"算法-数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"}]},{"title":"题解 - Codeforces Round 848 (Div. 2) A-D","slug":"题解 - Codeforces Round 848 (Div. 2) A-D","date":"2023-02-01T16:00:00.000Z","updated":"2023-02-02T08:04:42.881Z","comments":true,"path":"2023/02/02/题解 - Codeforces Round 848 (Div. 2) A-D/","link":"","permalink":"http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/","excerpt":"","text":"比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难. 补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]=dp[n-1]+1. 从而求出dp[1] A. Parallel Projection题意给定由 1 和 -1 组成的数组，你必须选择两个相邻元素，然后翻转它们的符号。 求翻转后数组的最大和。 分析对于相邻的2个数, 总共3种情况: (-1, -1) 总贡献 +4 (-1, 1) / (1, -1) 总贡献 0 只有(1, 1) 总贡献 -4 代码123456789101112131415161718void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;&amp;x : a) cin &gt;&gt; x; int ans = accumulate(all(a), 0); bool add0 = false; for (int i = 0; i &lt; n; ++ i) &#123; if (i + 1 &lt; n &amp;&amp; a[i] == -1 &amp;&amp; a[i + 1] == -1) &#123; cout &lt;&lt; ans + 4 &lt;&lt; endl; return; &#125; if (i + 1 &lt; n &amp;&amp; a[i] * a[i + 1] == -1) &#123; add0 = true; &#125; &#125; if (add0) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; ans - 4 &lt;&lt; endl;&#125; B. The Forbidden Permutation题意给定排列 p 和数组 a和正整数d. 定义a是不好数组, 如果对于所有a[1~m-1], 都有pos[a[i]] &lt; pos[a[i+1]] &lt;= pos[a[i]] + d 比如: p=[4,2,1,3,6,5] 和 d=2 a=[2,3,6] is a not good array.a=[2,6,5] is good because pos(a1)=2, pos(a2)=5, so the condition pos(a2)≤pos(a1)+d is not satisfied.a=[1,6,3] is good because pos(a2)=5, pos(a3)=4, so the condition pos(a2)&lt;pos(a3) is not satisfied. 请多次交换排列p中相邻的元素，使得a变成好数组 求最少交换次数。 分析要破坏现有满足的2个条件, 只需要破坏其中一个条件就行. 枚举每个数, 分别计算破坏左边不等式和右边不等式的代价. 取个min就行 代码123456789101112131415161718void solve() &#123; int n, m, d; cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; vector&lt;int&gt; p(n), a(m), pos(n); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; p[i]; p[i] --; pos[p[i]] = i; &#125; for (auto &amp;&amp;x : a) cin &gt;&gt; x, x --; int ans = n; LOG(a) for (int i = 0; i + 1 &lt; m; ++ i) &#123; int x = a[i], y = a[i + 1]; int px = pos[x], py = pos[y]; if (px + n - 1 - py &gt;= d - (py - px) + 1) ans = min(ans, max(d - (py - px) + 1, (int)0)); ans = min(ans, max(py - px, (int)0)); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Flexible String题意现有字符串 a,b 。请选择修改 a 中至多 k 种 字符，对于 每一个 这样的字符，都可以将其改为另一个其他字符。 求修改后 a’ 的子串以及 b 的子串中，满足 a’[l..r] = b[l..r] 的数量的最大值。保证 a 中至多有 10 种字符。 分析n(1e5), k(10). 暴力二进制枚举子集, 最高O(2^10 * 1e5), 2s能接受. 枚举每个子集, 对于a[i], 若是子集里的字母, 都替换成b[i] 代码123456789101112131415161718192021222324252627282930313233343536// 1024 * 1e5 2s 应该能过void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; string a, b; cin &gt;&gt; a &gt;&gt; b; string unique_a = a; uniq(unique_a); int m = unique_a.size(); LOG(unique_a, m) if (k &gt;= m) &#123; cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; endl; return; &#125; int ans = 0; for (int val = 0; val &lt; (1 &lt;&lt; m); ++ val) if (popcountll(val) == k) &#123; vector&lt;int&gt; change(26); for (int b = 0; b &lt; m; ++ b) &#123; if (val &gt;&gt; b &amp; 1) &#123; change[unique_a[b] - &#x27;a&#x27;] = 1; &#125; &#125; int len = 0, curr = 0; for (int i = 0; i &lt; n; ++ i) &#123; if (change[a[i] - &#x27;a&#x27;] || a[i] == b[i]) &#123; len ++; &#125; else &#123; curr += len * (len + 1) / 2; len = 0; &#125; &#125; if (len) curr += len * (len + 1) / 2; ans = max(ans, curr); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Flexible String Revisit题意给定两个二进制串 a, b. 每次随意翻转一个二进制位，求第一次使得 a=b 所需的期望次数。 分析设有 i 个二进制位不同的情况下，所需的次数是 dp[i] ，则有转移方程： dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n 其含义是，我们进行一次翻转后，有 i/n 的概率减少一个不同的位，这样就还需要 dp[i−1] 次；其他情况下将增加一个不同的位，则还需要 dp[i+1] 次。特别地， dp[0]=0， dp[n]=1+dp[n−1] 但是(しかし), 期望公式dp[i]依赖于dp[i-1]和dp[i+1]. 而我们的初始状态只有dp[0]=0. 因此需要通过解方程的方式才能得到答案 $$dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n \\ dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n \\ dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n \\ dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n) \\$$ dp[2] = dp[1] + … = k * dp[1] + b 用 dp[1] 看作已知，各个 dp[i] 表示为k * dp[1] + b. 一直到 dp[n] = 1 + dp[n - 1] dp[n] - dp[n - 1] = k * dp[1] + b = 1, 这里的k和b都是已经通过递推算出来的, 所以dp[1]的值也就算出来了. 答案就是dp[diff_cnt][0] * dp[1] + dp[diff_cnt][1] 代码1234567891011121314151617181920212223242526272829303132333435363738array&lt;mint, 2&gt; operator-(array&lt;mint, 2&gt; a, array&lt;mint, 2&gt; b) &#123; return array&lt;mint, 2&gt; &#123;a[0]-b[0], a[1]-b[1]&#125;;&#125;array&lt;mint, 2&gt; operator-(array&lt;mint, 2&gt; a, mint b) &#123; return array&lt;mint, 2&gt; &#123;a[0], a[1]-b&#125;;&#125;array&lt;mint, 2&gt; operator*(array&lt;mint, 2&gt; a, mint b) &#123; return array&lt;mint, 2&gt; &#123;a[0]*b, a[1]*b&#125;;&#125;array&lt;mint, 2&gt; operator/(array&lt;mint, 2&gt; a, mint b) &#123; return array&lt;mint, 2&gt; &#123;a[0]/b, a[1]/b&#125;;&#125;void solve() &#123; int n; cin &gt;&gt; n; string a, b; cin &gt;&gt; a &gt;&gt; b; int diff = 0; for (int i = 0; i &lt; n; ++ i) diff += (a[i] != b[i]); // dp[i]: 有i个不同之处的期望: dp[i][0] * dp[1] + dp[i][1] vector&lt;array&lt;mint, 2&gt;&gt; dp(n + 1); dp[0] = &#123;0, 0&#125;; dp[1] = &#123;1, 0&#125;; // dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n // dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n // dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n // dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n) for (int i = 2; i &lt;= n; ++ i) &#123; dp[i] = (dp[i-1] - mint(1) - dp[i-2] * mint(i-1) / mint(n)) / (mint(1) - mint(i-1)/mint(n)); &#125; // dp[n] = 1 + dp[n - 1] // dp[n] - dp[n - 1] = d[0] * dp[1][0] + d[1] = 1 // k = dp[1][0] = (1 - d[1]) / d[0] array&lt;mint, 2&gt; d = dp[n] - dp[n - 1]; mint k = (mint(1) - d[1]) / d[0]; cout &lt;&lt; dp[diff][0] * k + dp[diff][1] &lt;&lt; endl;&#125; A. Flip Flop Sum题意分析代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"},{"name":"算法_概率期望","slug":"算法-概率期望","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"}]},{"title":"题解 - AtCoder Beginner Contest 287 A-F","slug":"题解 - AtCoder Beginner Contest 287 A-F + Ex","date":"2023-01-28T16:00:00.000Z","updated":"2023-02-15T13:25:43.317Z","comments":true,"path":"2023/01/29/题解 - AtCoder Beginner Contest 287 A-F + Ex/","link":"","permalink":"http://example.com/2023/01/29/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20287%20A-F%20+%20Ex/","excerpt":"","text":"F是看似n^3, 实则n^2的树形dp, 用日语就是”二乗の木 DP”. 关键词: 树上子树dp + 连通块. 同时学到了: array&lt;int, 2&gt;比vector(2)快很多 A. Majority题意思路代码12345678910void solve() &#123; int n; cin &gt;&gt; n; int c = 0; for (int i = 0; i &lt; n; ++ i) &#123; string s; cin &gt;&gt; s; if (s == &quot;For&quot;) ++ c; &#125; if (c &gt; n / 2) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; B. Postal Card题意判断后缀串是否出现在set 中 思路代码123456789101112131415161718void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;string&gt; s(n); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; s[i]; s[i] = s[i].substr(3); &#125; set&lt;string&gt; S; for (int i = 0; i &lt; m; ++ i) &#123; string x; cin &gt;&gt; x; S.insert(x); &#125; int ans = 0; for (auto x : s) &#123; ans += S.count(x); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Path Graph?题意判断一张简单无向图是否为一条链. 思路max度数 &lt;= 2 + 连通性判断 赛时写的toposort 代码1234567891011121314151617181920212223242526272829303132333435void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; g(n); vector&lt;int&gt; deg(n); for (int i = 0; i &lt; m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u --, v --; g[u].pb(v); g[v].pb(u); ++ deg[u], ++ deg[v]; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; n; ++ i) if (deg[i] == 1) &#123; q.push(i); break; &#125; vector&lt;int&gt; st(n); while (q.size()) &#123; int cv = q.front(); q.pop(); st[cv] = 1; for (auto nv : g[cv]) if (!st[nv]) &#123; if (-- deg[nv] &lt;= 1) &#123; q.push(nv); &#125; &#125; &#125; LOG(st) for (auto x : st) &#123; if (x != 1) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;&#125; D. Match or Not题意给定字符串s(n [1, 3e5])和t(n&gt;=m [1, 3e5]). 只由’?’和小写字母组成. 每次在s前面取i个, 后面取m-i个, 拼起来组成s’. 问s’能否跟t匹配? PS: ‘?’可以替换成任意小写字母 思路前面取i个, 后面取m-i个. 想到前后缀. 统计前后缀跟t匹配的字符数量. 若前缀+后缀匹配数量 == m, 则成功 代码1234567891011121314151617181920212223242526272829void solve() &#123; string s, t; cin &gt;&gt; s &gt;&gt; t; int n = s.size(), m = t.size(); s = &quot; &quot; + s; t = &quot; &quot; + t; vector&lt;int&gt; pre(n + 2), suf(n + 2); for (int i = 1; i &lt;= m; ++ i) &#123; int ok = 0; if (s[i] == t[i]) ok = 1; if (s[i] == &#x27;?&#x27; || t[i] == &#x27;?&#x27;) ok = 1; pre[i] = pre[i - 1] + ok; &#125; for (int i = n; i &gt;= n - m + 1; -- i) &#123; int ok = 0; if (s[i] == t[i - n + m]) ok = 1; if (s[i] == &#x27;?&#x27; || t[i - n + m] == &#x27;?&#x27;) ok = 1; suf[i] = suf[i + 1] + ok; &#125; LOG(pre) LOG(suf) for (int i = 0; i &lt;= m; ++ i) &#123; int sum = pre[i] + suf[i + n - m + 1]; LOG(i, i + n - m + 1, sum) if (sum == m) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125;&#125; E. Karuta题意给n个字符串, 问每个串和其他所有串的 LCP(最长公共前缀) 的最大值 思路先把所有串建 Trie. 然后对每一个s[i]查一遍, 走到计数器只有1的时候就停, 输出当前深度, 复杂度O(∑ |s[i]| ) 赛时多写了个二分, 头脑发热了. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//son记录他的子节点 cnt记录编号为idx的节点 对应字符串数量 idx为节点唯一编号//遍历trie树 的时候注意： 终点是curr ！！！ 而不是 idx, idx不一定会被更新int son[N][26], cnt[N], idx;char str[N];void insert(char str[])&#123; //curr表示当前节点 初始是 根节点 为空 int curr = 0; for(int i = 0; str[i]; ++ i) &#123; int t = str[i] - &#x27;a&#x27;; //如果他的儿子 为空 if(!son[curr][t]) son[curr][t] = ++idx; curr = son[curr][t]; ++ cnt[curr]; &#125; //跑完在 字符串终点 ++cnt // 终点是curr ！！！ 而不是 idx, idx不一定会被更新 // ++ cnt[curr];&#125;int query(char str[])&#123; int curr = 0; for(int i = 0; str[i]; ++ i) &#123; int t = str[i] - &#x27;a&#x27;; if(!son[curr][t]) return 0; curr = son[curr][t]; &#125; return cnt[curr];&#125;void solve() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; s(n); for (auto &amp;&amp;x : s) &#123; cin &gt;&gt; x; insert(x.data()); &#125; LOG(s) LOG(query(&quot;bra&quot;)) for (int i = 0; i &lt; n; ++ i) &#123; int len = s[i].size(); int l = 0, r = len; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; bool ok = false; if (query(s[i].substr(0, mid).data()) &gt;= 2) ok = true; if (ok) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125; F. Components题意一棵树n([1, 5000]), 问有多少个点集的导出子图恰好有x = 0, 1, 2…n 个联通分量 思路日本大佬的blog 树形n^2 dp. 看似三层循环, 最坏会达到n^3, 其实应该从合并u和儿子v涉及到的边数考虑. 合并当前u的子树和孩子v的子树代价: sz[u] * sz[v], 看最终结果便是: u的子树内所有节点两两之间都考虑过转移了. 也就是一个n个点的”完全图”(实际可能有些点对间没有连边), 即n*(n-1)/2. dp[i][j][0/1]: 以i为根节点的子树, 且i 0不选/1选, 形成的连通块个数. 共[u][0], [u][1], [v][0], [v][1] 4种情况 代码12345678910111213141516171819202122232425262728293031323334353637383940void solve() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 0; i &lt; n - 1; ++ i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; a --, b --; g[a].pb(b); g[b].pb(a); &#125; // dp[i][j][0/1]: 以i为根的子树, 且选择了i, 形成j个连通块的方案数 vector dp(n, vector&lt;array&lt;mint, 2&gt;&gt;(n + 1, array&lt;mint, 2&gt;&#123;&#125;)); vector&lt;int&gt; sz(n); // function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) -&gt; void &#123; auto dfs = [&amp;](auto dfs, int u, int p) -&gt; void &#123; sz[u] = 1; dp[u][0][0] = dp[u][1][1] = 1; for (auto v : g[u]) if (v != p) &#123; dfs(dfs, v, u); // vector ndp(n + 1, vector&lt;mint&gt;(2)); vector ndp(n + 1, array&lt;mint, 2&gt;&#123;&#125;); for (int i = 0; i &lt;= sz[u]; ++ i) &#123; for (int j = 0; j &lt;= sz[v]; ++ j) &#123; ndp[i + j][0] += dp[u][i][0] * dp[v][j][0]; // u不拿, v可以拿, 也可以不拿 ndp[i + j][0] += dp[u][i][0] * dp[v][j][1]; ndp[i + j][1] += dp[u][i][1] * dp[v][j][0]; // u 拿, v必须不拿, 连通块数量才可以不-1 if (j &gt;= 1) &#123; // u 拿, v也拿, 那么u和v的2个连通块合并成1个了 ndp[i + j - 1][1] += dp[u][i][1] * dp[v][j][1]; &#125; &#125; &#125; swap(dp[u], ndp); sz[u] += sz[v]; &#125; &#125;; dfs(dfs, 0, -1); for (int i = 1; i &lt;= n; ++ i) &#123; cout &lt;&lt; (dp[0][i][0] + dp[0][i][1]).val() &lt;&lt; endl; &#125;&#125; Ex. Directed Graph and Query题意给定一张有向图g&lt;n, m&gt;(n [2, 2000]), 回答q组询问. 每组询问包括s和t, 问从s到t的路径的代价最小值. 一条路径的代价是其经过的点的编号的最大值. 思路如果n在500以内, 可以Floyd插点更新. n [2, 2000] 也可以用bitset优化的Floyd传递闭包求解. d[i][j]表示i -&gt; j可以通过 最外层枚举插点k, 如果i能够到k, 那么k能够到的点, i也能到. 1234567for (int k = 0; k &lt; n; ++ k) &#123; for (int i = 0; i &lt; n; ++ i) &#123; if (d[i][k]) &#123; d[i] |= d[k]; &#125; &#125;&#125; 每次插完一个新点k, 就遍历一下所有q, 是否能更新答案. 总复杂度O(n^3 / 64 + nq) 代码123456789101112131415161718192021222324252627282930313233343536const int inf = 1e18;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector d(n, bitset&lt;2000&gt;()); for (int i = 0; i &lt; m; ++ i) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; a --; b --; d[a].set(b); &#125; int qc; cin &gt;&gt; qc; vector&lt;array&lt;int, 3&gt;&gt; q(qc); vector&lt;int&gt; ans(qc, inf); for (int i = 0; i &lt; qc; ++ i) &#123; int s, t; cin &gt;&gt; s &gt;&gt; t; s --; t --; q[i] = &#123;s, t, i&#125;; &#125; for (int k = 0; k &lt; n; ++ k) &#123; for (int i = 0; i &lt; n; ++ i) &#123; if (d[i][k]) &#123; d[i] |= d[k]; &#125; &#125; for (auto [s, t, id] : q) &#123; if (s &gt; k || t &gt; k) continue; if (d[s][t]) &#123; ans[id] = min(ans[id], k + 1); &#125; &#125; &#125; for (auto x : ans) &#123; if (x &gt; inf / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; x &lt;&lt; endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_数据结构","slug":"算法-数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"周记 - 2023 01.16-01.29 (2023春节)","slug":"周记 - 2023 01.16-01.29 (2023春节)","date":"2023-01-23T16:00:00.000Z","updated":"2023-02-15T12:14:48.393Z","comments":true,"path":"2023/01/24/周记 - 2023 01.16-01.29 (2023春节)/","link":"","permalink":"http://example.com/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/","excerpt":"","text":"01.17 周四 大年廿八 阴下午出发前往大旺, 傍晚到达. 晚上与大伯奶奶到早茶店吃饭. 01.18 周五 大年廿九 晴早上5点半起床. 六点钟到水岸与堂哥奶奶碰面. 奶奶和我们坐一辆车, 6点10分左右启程, 中途服务区休息一次. 11点多到达村口. 全程睡过来. 01.21 周六 除夕 雨晚上8点有Atcoder Beginner Contest 286. 由于长辈聊天的原因, 我迟到了20分钟, 还好我有先见之明, 提前unrated participation了. 开局到D还是很顺利的. E一眼n=300, 鉴定为Floyd, 但是我对Floyd松弛时的更新没有深刻的理解, 导致赛后3分钟才调出E的错误. 何为”最短路松弛的理解”? 其实就是在能够松弛时, 要采取无条件赋值, 而不是取max. 这点在最短路计数上也是一样, 只不过当时是 += , 而不是赋值, 所以我忽视了这点. 本来老爸让我一定要在益罗塘山上睡一晚, 好在他在蹭网回去时改变了主意. 零点赏完烟花后入睡. 01.22 周日 新年初一 晴晚上8点有Atcoder Regular Contest 154. 考虑到昨天晚上我因为种种原因晚了20分钟才下山参加比赛, 于是今晚也是unrated participation了. 开局A题直接不会, 贪心思路很容易, 就是让俩数尽可能差的大, 主要是长度为1e5的俩数相乘取模这一点没想好. 搞了一个钟头才摸出来. 什么龟速乘, 忽略高位的数都出来了… 我果然是一急啥蠢事都干了. B题一开始看以为又是大聪明题. 但是分析了10分钟发现是可做的, WA了2发也是在半小时内搞出来了一个O(n)的做法. AB总共WA了5发, rk 1200+, 感觉还行, 至少不会掉分(要是A模数运算再熟练些会更好). 而且B题放我以前肯定是无法发现题目性质的. 可喜可贺, 希望在新的一年里思维上能有更大的进步! 01.23 周一 新年初二 雨今天要跟奶奶去拜访舅公舅婆. 从恭上村到何家, 大概有20+分钟的车程. 只能说很尬, 那么多亲戚就没几个认识的. 所以我选择和堂哥在屋外聊天. 午饭和舅公一桌, 面对一桌的酸菜, 腌菜, 我TM直接干白饭. 晚上刷了会题, 刷不动了. 继续看了&lt;尸体派对&gt;第二集. 看了2集之后, 可能是我刚进军二次元不就, 接触的作品太少, 感觉这种恐怖重口题材的挺好看的, 也挺想买steam上的尸体派对几部作品, 奈何太贵, 等骨折了入手一波. 晚上堂哥又摆出烧烤架, 我蹭了一块鸡柳 + 一条烤肠, 上一次烧烤还是在高中的某次年级出游. 01.24 周二 新年初三 晴晚上依然睡不好觉, 早上七点半起床, 开始收拾行李, 准备下山. 大约九点半时到达恭上村村口吃腌面. 饭后随堂哥驱车前往拜访南良叔. 路上得知南良叔之前的旧屋拆迁了, 据说补偿还不错. 路上被中国电信的捉急信号和高德地图的误导耽误了20分钟, 于10点半到达拜访. 寒暄过后, 11点从党溪村返回大旺, 全程500公里. 4点左右到达大旺. 到达后依然是与大伯奶奶聚餐, 饱餐一顿后送奶奶回家后便准备驱车返回广州. 返程较短, 所以我尝试开回来. 开了1小时多些, 平均时速块80, 高速上最高开到了120. 估摸着也快有1年没碰方向盘了, 感觉还行. 01.25 周三 新年初四 晴白天在家刷题. 傍晚LY vx问我去不去看电影, 原来他今天回到广州. 于是就打算看8点场的&lt;流浪地球2&gt;. 本来没打算电影有多大的惊喜, 看了看前面的部分, 感觉有些镜头挺尬的. 刚开始注意到频繁出现的摄像头, 也不知道有啥用意. 直到片尾的彩蛋说550A才是策划一系列危机的幕后黑手, 我才有点懂了. 感觉550A可能就是通过摄像头学习了很多, 在逐月计划, 太空电梯那会的某个阶段产生了意识, 但是处于一种潜伏状态. 另外就是我对于”相控阵”和550A的初衷也是挺好奇的. 不过我认为&lt;流浪地球2&gt;似乎没有&lt;星际穿越&gt;那么难懂. 01.26 周四 新年初五 晴白天在家刷题. 下午购物. 晚上刷到UP主&lt;那些无名之辈&gt;的动态最看天赋的专业之一：C9院校，同宿舍4个数学男，毕业7年后的生活现状, C9数学专业毕业生生活现状. 1个米国top10计算机读博年收入42w, 1个瑞士读博年收入30+w, 1个学而思老师转广州竞赛教练年收入20+w, 1个本校物理读博年收入5w, 毕业offer60+w. 第三个好巧不巧刚好是竞赛教练, 还是广州的. 看来当前教培改革已经对这行造成了很大的影响. 本来心里最理想的职业看来也走不通了. 我认为这辈子是真的没有遇到真正热爱的东西, 直到大三正式入坑OI(CP / ACM). 大四上学期的最后几个月, 可能是我这辈子最后一次为自己热衷的东西不计代价地追寻付出了. 万幸的是上天眷顾, 我找到了优秀的队友, 也选对了赛站, 在我的XCPC最后一舞中收获了牌子. 之前一直在抱怨高中 01.27 周五 新年初六 多云白天在家刷题. 下午购物 晚上有codeforces div3, 常规阴间时间. 本来还在想要不要打, 一看zwling已经报名了, 我也就报名了. 可以说是打得挺烂了. E题非得硬去分析二进制数位的性质, 结果还是得搞对拍. 整题搞了一个多小时, zwling说打表就行, 只花了10+min就搞定了. 妈的又是打表, 上次vp小白月赛的n(1e18)的模仿棋博弈也是没看出要打表. 不过由于cf号目前分段比较低, 所以rk1700+也+55. 01.28 周六 新年初七 晴白天不想学习, 但是又找不到想玩的. 晚上有Atcoder Beginner Contest 287. 8点麻木地开打, 前两题签完到, C直接给我干趴下了. 判断一张图是不是一条链, 我寻思着不是只用判断: “度1点数==2 &amp;&amp; 度2点==n-2 &amp;&amp; 边数==点数-1 “就行了嘛. 直接WA3发, 不过也不是第一次翻车了, 不就是经典codeforces经典卡div2 B嘛. 跳过C先做D, 一开始头脑发热又想不到, 不过好在冷静下来做出来了. 回过头看C, 我TM直接toposort总可以了吧, 于是就过了. 一看rk2000+, 如果不做出E翻盘, 那我的AT1200分青名计划就又要延期了. 看了E的题意, 涉及到前缀, “最大”长度, 我直接想到前缀数据结构Trie + 二分长度. 但是Trie的题也就acwing的模板题做过, 所以花了点时间先学, 把统计词频的代码改成了统计前缀词频, 就过了E. 结果rk1300+, 感觉还行, +21 to 1115. 此时还剩下30+分钟, F我想的是树上背包, 但是自知功力还未到. 所以直接开摆. 本来想早睡的, 但是睡前玩了会&lt;深岩银河&gt;, 又玩到12点半. 01.28 周日 新年初八 晴后记回忆于：01.24(2022春节初三)日晚22点 + 01.29","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 286 A-F","slug":"题解 - AtCoder Beginner Contest 286 A-F","date":"2023-01-21T16:00:00.000Z","updated":"2023-02-15T13:25:52.027Z","comments":true,"path":"2023/01/22/题解 - AtCoder Beginner Contest 286 A-F/","link":"","permalink":"http://example.com/2023/01/22/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20286%20A-F/","excerpt":"","text":"F还没调出来, 看到maspy大佬用自己的板子熟练得一, 余数vector和除数vector一传, 直接调用自己写的crt函数就出答案了. 感觉等我思维练得差不多了也可以开始系统地学习这种”工程式”cp了 A. Range Swap题意思路代码1 B. Cat题意思路代码1 C. Rotate and Palindrome题意给定一个字符串s(长度n: [1, 5000]). 问通过任意次以下操作使其变成回文串的最小代价. 操作1: s = rotate(s.begin(), s.begin() + 1, s.end()) 即循环左移一位. 代价为a 操作2: 将任意的s[i]修改为c. 代价为b 思路n([1, 5000]): 暴力枚举左移位数 + 修改次数 左移可以用deque. 利用了pop_front(), push_back()和顺序容器随机访存的特性. 代码12345678910111213141516171819void solve() &#123; int n, a, b; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; string s; cin &gt;&gt; s; deque&lt;char&gt; dq; for (int i = 0; i &lt; n; ++ i) dq.pb(s[i]); int best = n * b; for (int i = 0; i &lt; n; ++ i) &#123; int c_cost = (i) * a; for (int j = 0; j &lt; n / 2; ++ j) &#123; c_cost += b * (dq[j] != dq[n - j - 1]); &#125; best = min(best, c_cost); LOG(dq, (i) * a, c_cost) auto s0 = dq.front(); dq.pop_front(); dq.pb(s0); &#125; LOG(best) cout &lt;&lt; best &lt;&lt; endl;&#125; D. Money in Hand题意手头上有n([1, 50])种货币, 第i种: 价值a([1, 100])元, 且拥有b([1, 50])张, 问能否用这些货币刚好凑出x([1, 10000])元 思路暴力分组背包dp即可. O(n * x * b) 代码123456789101112131415161718192021const int N = 50 + 5, M = 1e4 + 5;int dp[N][M];int a[N], b[N];void solve() &#123; int n, x; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; dp[0][0] = 1; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 0; j &lt;= x; ++ j) &#123; for (int c = 0; c * a[i] &lt;= j &amp;&amp; c &lt;= b[i]; ++ c) &#123; dp[i][j] |= dp[i - 1][j - c * a[i]]; &#125; &#125; &#125; LOG(dp[n][x]) if (dp[n][x]) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; E. Souvenir题意有n([1, 300])个旅游目标城市, 给定这n个城市之间航班的邻接矩阵, 以及每个城市能购买的纪念品价值a[n]. 现在要求最优化以下目标: 首要: 转机次数最小化 次要: 转机次数一定时, 最大化路过城市所能购买的纪念品价值 给出q个询问. 每次询问S, T. 分别回答首要目标和次要目标. 若从S无法到达T, 输出”Impossible” 思路n([1, 300]) 一眼Floyd. 类似于最短路计数, 在最短路相同时(dist[i][j] == dist[i][k] + dist[k][j]), 不做最短路更新, 但是要做纪念品价值更新. 在最短路能更新时, 所有更新均为无条件赋值!!!. 即不能取max之类的 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int N = 300 + 10, inf = 0x3f3f3f3f3f3f3f3f;int a[N];int dp1[N][N], dp2[N][N];void solve() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; memset(dp1, 0x3f, sizeof dp1); for (int i = 1; i &lt;= n; ++ i) dp1[i][i] = 0, dp2[i][i] = a[i]; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= n; ++ j) &#123; char c; cin &gt;&gt; c; if (c == &#x27;Y&#x27;) &#123; dp1[i][j] = 1; dp2[i][j] = a[i] + a[j]; &#125; &#125; &#125; for (int k = 1; k &lt;= n; ++ k) &#123; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= n; ++ j) &#123; if (dp1[i][j] &gt; dp1[i][k] + dp1[k][j]) &#123; // 强制更新dp 不能取max dp1[i][j] = dp1[i][k] + dp1[k][j]; dp2[i][j] = dp2[i][k] + dp2[k][j] - a[k]; &#125; else if (dp1[i][j] == dp1[i][k] + dp1[k][j]) &#123; dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k][j] - a[k]); &#125; &#125; &#125; &#125; int q; cin &gt;&gt; q; while (q --) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; if (dp1[l][r] &lt; inf / 2) &#123; cout &lt;&lt; dp1[l][r] &lt;&lt; &#x27; &#x27; &lt;&lt; dp2[l][r] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; &#125; &#125;&#125; F. Guess The Number 2题意交互题 你需要猜出电脑给定的一个正整数n([1, 1e9]). 只能通过以下方式算出n: 你给出一个排列a[m] (m: [1~110]). 电脑会根据a[m]返回一个数组b. b[i] = a[ a[ a[i] ] ] … (共a[i]n次) 思路置换环 / functional graph + 中国剩余定理ChineseRemainTheory 思路其实想了大概10分钟就出了, 因为b和a的关系其实就是在functional graph走了n步所到达的点. functional graph 置换环这类题之前vp 797 div3 做过一道F. Shifting String. 所以套路肯定是循环节长度, lcm. 这里变通一下就变成了知道循环节长度和其对应的模数. 代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"},{"name":"算法_组合数学","slug":"算法-组合数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"周记 - 2023 01.09-01.15","slug":"周记 - 2023 01.09-01.15","date":"2023-01-20T16:00:00.000Z","updated":"2023-02-15T12:15:32.583Z","comments":true,"path":"2023/01/21/周记 - 2023 01.09-01.15/","link":"","permalink":"http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/","excerpt":"","text":"01.09 周一 小雨早上十点开始vp Educational Codeforces Round 141. 嗯, 只做了2题, 第二题经典构造矩阵, 做了一个多小时. 其实C题我也不会, 是一道关于最佳可能排名的贪心题. 贪心还是得多练, 正解是二分. D题dp, muggle用的记忆化搜索, 看了他的代码感觉记搜确实得熟练起来. 晚上八点20开始vp 小白月赛65. 表现依然糟糕, 只会3题. 并且这次的B题是考察字符串匹配, 其实暴力n^2就行. 我非得试着用双指针. 这也暴露出我对字符串匹配的理解误区. 要是真能双指针直接瞎搞, 那还要啥KMP呢? D题这种1e18的一眼结论题, 但是没想过打表, 比赛经验太差. 正解是”模仿棋”. E构造, F贪心 + 树形dp. 01.10 周二 小雨早上补了昨晚的DEF. 下午晚上补了我第一场牛客比赛(小白月赛34)的所有题. 基本以dp为主, 然后还有一道经典 矩阵每行取数, 求前k大的题. 堆 + 合并行贪心. 01.11 周三 中雨早上10点开始vp 843(div2). 可以算是形势逆转的一局, 虽然一开始经典卡B, 但是对拍调完C之后, 还是想出了B. 赛后发现C有1600分. 01.12 周四 小雨考虑到18号要回大埔过年, 早上先花了点时间下番&lt;更衣人偶坠入爱河&gt;, 但是没有外挂弹幕, 告辞, 晚点再来. 9点40开始vp 839(div3). 表现垃圾. 只会3道. D是拆绝对值 + 约束答案范围. 中午看到2022南京终于上了cf gym. 看到了&lt;高数100&gt;, 看到了自己和队友们的名字. 在第一页尾部, 相信很快就会被vp的大佬们压下去. 下午2点郑老师发来vx说给我发些奖励, 问我银行卡之类的信息. 01.13 周五 阴下午1点突然想看看2022南京的正解, 于是想到zwling之前说的dianhsu写的插件. 用这个插件可以在别人的submission中查看gym的代码. 之后我下了dls的A和D的代码, 然而题目都记不清了. 下午3点开组会, 和顾学长一起获得了三等奖金, 发了言. 和组里的大部分同学都不熟, 所以挺紧张的. 组会上我得知很多学长学姐都在2022年做出了A类工作. 心情十分复杂, 想搞科研, 但是心里有放不下CP. 可能是心愿还没有达成吧. 至于这个心愿, 我也不知道具体是个什么样的目标. 01.14 周六 阴vp 844(div1+2) 01.15 周日 阴后记回忆于：01.21(2022除夕)日午12点","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 89 A-D","slug":"题解 - AtCoder Beginner Contest 89 A-D","date":"2023-01-20T16:00:00.000Z","updated":"2023-01-21T03:16:42.460Z","comments":true,"path":"2023/01/21/题解 - AtCoder Beginner Contest 89 A-D/","link":"","permalink":"http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/","excerpt":"","text":"D - Practical Skill Test题意思路代码1 D - Practical Skill Test题意给定一个h * w的矩阵a, 里面不重不漏地填充着[1, h * w]的数字. 现在给定一个正整数d ([1, h * w]), 并且给出q组询问: l, r 问: a[x1][y1] == l —&gt; a[x2][y2] == l + d —&gt; … —&gt; a[xn][yn] == r 这段路所走过的曼哈顿距离是多少 曼哈顿距离: (x1, y1)与(x2, y2)的曼哈顿距离是|x1 - x2| + |y1 - y2| 思路倍增 (我的思路)既然无法记录从每个点(a值==i)出发到[i+1, n]的所有距离, 那么就可以考虑倍增 to[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走到的点 dist[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走过的路程 边界: to超出h * w的部分要特判0 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546int operator - (array&lt;int, 2&gt; a, array&lt;int, 2&gt; b) &#123; return abs(a[0] - b[0]) + abs(a[1] - b[1]);&#125;void solve() &#123; int h, w, d; cin &gt;&gt; h &gt;&gt; w &gt;&gt; d; vector&lt;vector&lt;int&gt;&gt; a(h + 1, vector&lt;int&gt;(w + 1)); vector&lt;array&lt;int, 2&gt;&gt; a2cor(h * w + 1); for (int i = 1; i &lt;= h; ++ i) &#123; for (int j = 1; j &lt;= w; ++ j) &#123; cin &gt;&gt; a[i][j]; a2cor[a[i][j]] = &#123;i, j&#125;; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; to(h * w + 1, vector&lt;int&gt;(20, 0)); vector&lt;vector&lt;int&gt;&gt; dist(h * w + 1, vector&lt;int&gt;(20, 0)); for (int u = 1; u + d &lt;= h * w; ++ u) &#123; to[u][0] = u + d; dist[u][0] = a2cor[u + d] - a2cor[u]; &#125; for (int b = 1; b &lt; 20; ++ b) &#123; for (int u = 1; u &lt;= h * w; ++ u) &#123; to[u][b] = to[to[u][b - 1]][b - 1]; dist[u][b] = dist[u][b - 1] + dist[to[u][b - 1]][b - 1]; &#125; &#125; auto binary_jump = [&amp;](int S, int T) &#123; int ans = 0; for (int b = 19; b &gt;= 0; -- b) if (to[S][b] != 0) &#123; if (to[S][b] &lt;= T) &#123; ans += dist[S][b]; S = to[S][b]; &#125; &#125; assert(S == T); return ans; &#125;; int q; cin &gt;&gt; q; while (q --) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; binary_jump(l, r) &lt;&lt; endl; &#125;&#125; 前缀和 (官方题解)pre[i] 表示a[i - kd] —&gt; a[i - (k-1)d] —&gt; a[i - d] —&gt; a[i] 的路程之和 pre[i] = pre[i - d] + dist(i - d, i) 代码1234567891011121314151617181920212223242526int operator - (array&lt;int, 2&gt; a, array&lt;int, 2&gt; b) &#123; return abs(a[0] - b[0]) + abs(a[1] - b[1]);&#125;void solve() &#123; int h, w, d; cin &gt;&gt; h &gt;&gt; w &gt;&gt; d; vector&lt;vector&lt;int&gt;&gt; a(h + 1, vector&lt;int&gt;(w + 1)); vector&lt;array&lt;int, 2&gt;&gt; a2cor(h * w + 1); for (int i = 1; i &lt;= h; ++ i) &#123; for (int j = 1; j &lt;= w; ++ j) &#123; cin &gt;&gt; a[i][j]; a2cor[a[i][j]] = &#123;i, j&#125;; &#125; &#125; vector&lt;int&gt; pre(h * w + 1); for (int i = 4; i &lt;= h * w; ++ i) &#123; pre[i] = pre[i - 4] + (a2cor[i] - a2cor[i - 4]); &#125; int q; cin &gt;&gt; q; while (q --) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; pre[r] - pre[l - 1] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数据结构","slug":"算法-数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法_倍增","slug":"算法-倍增","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%80%8D%E5%A2%9E/"}]},{"title":"题解 - AtCoder Beginner Contest 284 A-F","slug":"题解 - AtCoder Beginner Contest 284 A-F","date":"2023-01-16T16:00:00.000Z","updated":"2023-02-15T13:25:59.677Z","comments":true,"path":"2023/01/17/题解 - AtCoder Beginner Contest 284 A-F/","link":"","permalink":"http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/","excerpt":"","text":"A. Generalized ABC题意思路代码123456void solve() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; s(n); for (auto &amp;x : s) cin &gt;&gt; x; for (int i = n - 1; i &gt;= 0; -- i) cout &lt;&lt; s[i] &lt;&lt; endl;&#125; B. Multi Test Cases题意思路代码12345678910void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int ans = 0; for (auto x : a) &#123; ans += (x &amp; 1); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Count Connected Components题意思路代码123456789101112131415161718192021vector&lt;int&gt; p;int find(int x) &#123; return x == p[x] ? p[x] : p[x] = find(p[x]);&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; p.resize(n + 1); iota(all(p), 0); for (int i = 1; i &lt;= m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u = find(u), v = find(v); if (u == v) continue; p[u] = v; &#125; int wcc = 0; LOG(wcc); for (int i = 1; i &lt;= n; ++ i) &#123; wcc += (find(i) == i); &#125; cout &lt;&lt; wcc &lt;&lt; endl;&#125; D. Happy New Year 2023题意给定一个正整数n (n &lt;= 4e18), 找出两个质数p, q. 满足n = p * p * q 思路看到(n &lt;= 4e18) + 乘三次 —&gt; $(1e18)^{1/3} \\to \\ O(1e6)$ n = p * p * q 显然有min(p, q) &lt;= n^(1/3) 设x为p, q中最小的数, y为最大的数 检查x * x * y 和 x * y * y 代码1234567891011121314151617181920212223242526272829303132333435const int N = 4e6 + 10;int primes[N], cnt;bool is_p[N];void get_primes(int n) &#123; memset(is_p, 1, sizeof is_p); for (int i = 2; i &lt;= n; ++ i) &#123; if (is_p[i]) &#123; primes[cnt ++] = i; &#125; for (int j = i + i; j &lt;= n; j += i) &#123; is_p[j] = false; &#125; &#125;&#125;void solve() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; cnt; ++ i) &#123; int p = primes[i]; int p2 = p * p; if (n % p2 == 0) &#123; cout &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; n / p2 &lt;&lt; endl; return; &#125; if (n % p) continue; int val = n / p; // p * q * q int rt = sqrtl(val); if (rt * rt == val) &#123; cout &lt;&lt; rt &lt;&lt; &#x27; &#x27; &lt;&lt; p &lt;&lt; endl; return; &#125; &#125;&#125; E. Count Simple Paths题意给定G(n &lt;= 1e5, m), 统计从1出发的简单路径数目. 其中每个节点度数&lt;8. 思路简单路径数目: dfs + st[n]回溯 / bit_dp [1 &lt;&lt; n][n] 类似: C - One-stroke Path 节点数量过大 + 有节点度数保证 == dfs. cnt达到题目上限时, 在dfs过程中直接exit(0). 代码1234567891011121314151617181920212223242526272829int cnt = 0;vector&lt;bool&gt; st;vector&lt;vector&lt;int&gt;&gt; g;void dfs(int u) &#123; st[u] = true; ++ cnt; if (cnt &gt;= 1000000) &#123; cout &lt;&lt; cnt &lt;&lt; endl; exit(0); &#125; for (auto v : g[u]) &#123; if (st[v]) continue; dfs(v); &#125; st[u] = false;&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; g.resize(n); st.resize(n); for (int i = 1; i &lt;= m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u --, v --; g[u].pb(v); g[v].pb(u); &#125; dfs(0); LOG(cnt); cout &lt;&lt; cnt &lt;&lt; endl;&#125; F. ABCBAC题意给定一个字符串s[2 * n](n &lt;= 1e6), 设s1[i] = s[1, i] + s[n - (i) + 1, n], s2[i] = reverse(all(s[i + 1, n - i])) 问是否存在i, 满足s1 == s2 思路string hash: 第一次使用double hash 本质考察: 哈希拼接(base进制数理解) + 翻转哈希(后缀哈希) 哈希拼接: 前缀i + 后缀n-i 拼接. 就比如俩十进制数12, 34567 要拼接起来, 要先把12 * 100000再和后者相加, 才能变成1234567. 这里的哈希同理, 只不过换成了base进制数, 所以前者(前缀s[1, i])的哈希值先 * pw[n - i] (后缀的长度次幂), 再与后缀的哈希相加. 哈希截取: 从1234567中截取”34567”的哈希值, 要将前缀哈希1234567 - 12 * 100000. 即pre[r] - pre[l - 1] * base[r - l + 1]. 翻转哈希: s[l, r]的翻转哈希: suf[l] - suf[r + 1] * pw[r - l + 1]即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using hash_t = array&lt;int, 2&gt;;const int mod0 = 1e9 + 7, mod1 = 1e9 + 9;hash_t base = &#123;13331, 23333&#125;;hash_t pw[N];hash_t operator + (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] + b[0]) % mod0, (a[1] + b[1]) % mod1&#125;; return res;&#125;hash_t operator - (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] - b[0] + mod0) % mod0, (a[1] - b[1] + mod1) % mod1&#125;; return res;&#125;hash_t operator * (hash_t a, hash_t b) &#123; return &#123;a[0] * b[0] % mod0, a[1] * b[1] % mod1&#125;;&#125;hash_t pre[N], suf[N];void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; pw[0] = &#123;1, 1&#125;; for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pw[i] = pw[i - 1] * base; &#125; for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pre[i] = pre[i - 1] * base + hash_t&#123;s[i], s[i]&#125;; &#125; for (int i = 2 * n; i &gt;= 1; -- i) &#123; suf[i] = suf[i + 1] * base + hash_t&#123;s[i], s[i]&#125;; &#125; LOG(n, s) // s前i + s后2* n - i for (int i = 0; i &lt;= n; ++ i) &#123; // s前i + s后2* n - i 哈希拼接 // [1, i] [i + 1, i + n] [i + n + 1, 2 * n] hash_t h1 = pre[i] * pw[n - i] + (pre[2 * n] - pre[i + n + 1 - 1] * pw[n - i]) ; // [i + 1, i + n] 翻转后的哈希 hash_t h2 = suf[i + 1] - suf[(i + n) + 1] * pw[n]; if (h1 == h2) &#123; string ans = s.substr(1 + i, n); reverse(all(ans)); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_哈希","slug":"算法-哈希","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"}]},{"title":"题解 - AtCoder Beginner Contest 285 A-F","slug":"题解 - AtCoder Beginner Contest 285 A-F","date":"2023-01-16T16:00:00.000Z","updated":"2023-02-15T13:25:56.274Z","comments":true,"path":"2023/01/17/题解 - AtCoder Beginner Contest 285 A-F/","link":"","permalink":"http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/","excerpt":"","text":"A. Edge Checker 2题意思路代码12345void solve() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if (b / a == 2) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; B. Longest Uncommon Prefixs题意思路代码123456789101112131415void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; for (int i = 1; i &lt;= n - 1; ++ i) &#123; int ans = 0; for (int l = 1; i + l &lt;= n; ++ l) &#123; if (s[l] == s[l + i]) &#123; break; &#125; ans = max(ans, l); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; C. abc285_brutmhyhiizp题意将26进制数(A-Z)转成10进制数(0-9)BRUTMHYHIIZP —&gt; 10000000000000000 思路代码12345678910void solve() &#123; string s; cin &gt;&gt; s; int ans = 0; int n = s.size(); for (int i = 0; i &lt; n; ++ i) &#123; ans = ans * 26 + (s[i] - &#x27;A&#x27; + 1); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Change Usernames题意n个改名需求&lt;s[i], t[i]&gt;, 问是否能通过合理安排这n次改名的顺序, 使得改名没有冲突. 如 1234a bb cc aans: No 123a bb cans: Yes 思路其实就是map&lt;string, int&gt;哈希 + 判环. toposort就行 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n; cin &gt;&gt; n; map&lt;string, int&gt; id; int idx = 0; vector&lt;int&gt; to(2 * n + 10), ind(2 * n + 10); for (int i = 1; i &lt;= n; ++ i) &#123; string s, t; cin &gt;&gt; s &gt;&gt; t; int si, ti; if (!id.count(s)) id[s] = ++ idx; if (!id.count(t)) id[t] = ++ idx; si = id[s]; ti = id[t]; to[si] = ti; ++ ind[ti]; &#125; vector&lt;int&gt; st(2 * n + 10); bool ok = true; queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; ++ i) &#123; if (ind[i] == 0) q.push(i); &#125; while (q.size()) &#123; auto cv = q.front(); q.pop(); st[cv] = 1; if (!to[cv]) continue; auto nv = to[cv]; if (-- ind[nv] == 0) &#123; q.push(nv); &#125; &#125; for (int i = 1; i &lt;= idx; ++ i) &#123; if (!st[i]) ok = false; &#125; if (ok) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; E. Work or Rest题意一共有n(&lt;=5000)天, 每天可以是工作日 or 休息日 现在需要安排这n天, 使得工作效率之和最大化. 第i天(工作日)的工作效率定义为: 设这一天离最近的休息日距离d(把这n天视为一个环, 即第1天和第n天首尾相连), 第i天的工作效率为a[d]. 其中a[n]是给定的序列 如XOOOX (O代表工作日, X代表休息日)中: O[1] = a[min(1, 3)] O[2] = a[min(2, 2)] O[3] = a[min(3, 1)] 思路首先要将n天的安排和a[n]独立开, 毕竟我第i天是工作日不代表这天的效率就是a的某个数, 具体要看n天的安排. 又因为n天是一个环, 所以可以设第一天是工作日. 影响效率之和的因素只有休息日天数和间隔. 设某两天休息日的间隔为d, 则这两天间的工作日效率之和为: d=1: a1 d=2: 2*a1 d=3: 2*a1 + a2 记b[d]为间隔d天的效率贡献 n&lt;=5000. 可以n^2 DP 间隔数dpdp[i][j] 表示安排完了前i天, 且当前已经连续j天是工作日 dp[i][j] = dp[i][j - 1] dp[i][0] = dp[i][j] + b[j] 代码1234567891011121314151617181920212223void solve() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; a[n + 1] = 0; for (int i = 1; i &lt;= n; ++ i) b[i] = b[i - 1] + a[(i + 1) / 2]; // Why 必须初始化 负数? memset(dp, -0x3f, sizeof dp); dp[1][0] = 0; for (int i = 1; i &lt;= n + 1; ++ i) &#123; for (int j = 0; j &lt;= n - 1; ++ j) &#123; if (j - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &gt;= 0) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]); &#125; if (dp[i - 1][j] &gt;= 0) &#123; dp[i][0] = max(dp[i][0], dp[i - 1][j] + b[j]); &#125; &#125; &#125; int ans = dp[n + 1][0]; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; 完全背包dp把间隔数i + 1(连续i天工作日 + 1天休息日)视作物品i的体积, d[i]视作物品i的价值. 背包容量为n w[i] = w[i - 1] + a[i + 1 &gt;&gt; 1]; v[i] = i + 1; dp[n][n]即为所求 代码123456789101112131415161718192021222324252627void solve() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++ i) &#123; w[i] = w[i - 1] + a[i + 1 &gt;&gt; 1]; v[i] = i + 1; &#125; // for (int i = 1; i &lt;= n; ++ i) &#123; // for (int c = 0; c * v[i] &lt;= n; ++ c) &#123; // for (int j = c * v[i]; j &lt;= n; ++ j) &#123; // dp[i][j] = max(dp[i][j], dp[i - 1][j - c * v[i]] + w[i] * c); // &#125; // &#125; // &#125; for (int i = 1; i &lt;= n; ++ i) &#123; // for (int j = n; j &gt;= 0; -- j) &#123; for (int j = 0; j &lt;= n; ++ j) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j]); if (j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); &#125; &#125; // OXXXXXX OXXXXXX LOG(dp[n][n]) cout &lt;&lt; dp[n][n] &lt;&lt; endl;&#125; F. Substring of Sorted String题意小写字符串s[n], q个询问2种询问方式: 1 x c: s[x] = c 2 l r: 设t[n]=sort(all(s)), 判断s[l, r]是否为t的子串 思路 s = acbd t = abcd q = 2 1 4 NO s = abbd t = abbd q = 2 1 3 YES s = abcdc t = abccd q = 2 2 4 NO tag[i]记录s[i - 1] -&gt; s[i] 是否为非递减 seg[c].range(l, r) 记录字母c在[l, r]内出现次数 s[l, r]为t的子串, 需要满足以下两个条件: s[l + 1, r]内的字符都是递增的. 即tag.range_sum(l + 1, r) == 0 s[l + 1, r - 1]内的字符出现频数 == t对应字符出现频数. 如样例3 tag: 单点修改, 区间求和 —&gt; fenwick_tree seg: 求s[l, r]内某字符的出现频数, 支持修改 —&gt; fenwick_tree 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct fenwick_tree &#123; int n; vector&lt;int&gt; tr; fenwick_tree(int n) &#123;this-&gt;n = n; tr.resize(n + 5);&#125; int lowbit(int x) &#123;return x &amp; -x;&#125; void add(int x, int c) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; &#125; int sum(int x) &#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; &#125; int range(int l, int r) &#123; return sum(r) - sum(l - 1); &#125;&#125;;void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; int q; cin &gt;&gt; q; vector&lt;int&gt; cnt(26); vector&lt;fenwick_tree&gt; seg(26, fenwick_tree(n + 5)); fenwick_tree tag(n + 5); for (int i = 1; i &lt;= n; ++ i) &#123; cnt[s[i] - &#x27;a&#x27;] ++; seg[s[i] - &#x27;a&#x27;].add(i, 1); if (i &gt; 1) tag.add(i, s[i - 1] &gt; s[i]); &#125; while (q --) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int x; char c; cin &gt;&gt; x &gt;&gt; c; cnt[s[x] - &#x27;a&#x27;] --; seg[s[x] - &#x27;a&#x27;].add(x, -1); // s[x - 1] s[x] s[x + 1] if (x &gt; 1) &#123; tag.add(x, -(tag.range(x, x))); &#125; if (x &lt; n) &#123; tag.add(x + 1, -(tag.range(x + 1, x + 1))); &#125; s[x] = c; cnt[s[x] - &#x27;a&#x27;] ++; seg[s[x] - &#x27;a&#x27;].add(x, 1); if (x &gt; 1) &#123; tag.add(x, s[x - 1] &gt; s[x]); &#125; if (x &lt; n) &#123; tag.add(x + 1, s[x] &gt; s[x + 1]); &#125; &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int ok = true; ok &amp;= (tag.range(l + 1, r) == 0); for (int i = s[l] + 1 - &#x27;a&#x27;; i &lt;= s[r] - 1 - &#x27;a&#x27;; ++ i) &#123; ok &amp;= (seg[i].range(l, r) == cnt[i]); &#125; LOG(ok) if (ok) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D","slug":"题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D","date":"2023-01-16T16:00:00.000Z","updated":"2023-01-20T07:04:50.353Z","comments":true,"path":"2023/01/17/题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D/","link":"","permalink":"http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/","excerpt":"","text":"比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大. 补题: D因式分解 + 枚举因子 + 压缩状态 A. Parallel Projection题意房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板） 分析分别计算俩点向四个方向的墙面相连的距离, 求最小值 代码123456789101112131415void solve() &#123; int w, d, h; cin &gt;&gt; w &gt;&gt; d &gt;&gt; h; int a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g; int dist1 = min(a, f); int dist2 = min(b, g); int dist3 = w - max(a, f); int dist4 = d - max(b, g); int ans1 = 2 * dist1 + abs(a - f) + abs(b - g) + h; int ans2 = 2 * dist2 + abs(a - f) + abs(b - g) + h; int ans3 = 2 * dist3 + abs(a - f) + abs(b - g) + h; int ans4 = 2 * dist4 + abs(a - f) + abs(b - g) + h; int ans = min(&#123;ans1, ans2, ans3, ans4&#125;); LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Going to the Cinema题意有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一: 自己去,但除自己外去的人数 &lt; ai 自己不去,但除自己外去的人数&gt;= ai 问有多少种选择去的人的集合的方案,使得没有人伤心. 分析设去的人的集合A={p1,⋯,pa},不去的人的集合B={q1,⋯,qb},则A⋃B={1,⋯,n},a+b=n.​ 对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \\geq \\max_{1 \\leq i\\leq a} a_{p_i}$.​ 对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当$a &lt; \\min_{1\\leq j\\leq b} a_{q_j}$. 枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1] 代码1234567891011121314151617void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 2); for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; sort(a.begin() + 1, a.begin() + n + 1); a[n + 1] = inf; a[0] = -1; LOG(a) int ans = 0; for (int i = 0; i &lt;= n; ++ i) &#123; if (i &gt; a[i] &amp;&amp; i &lt; a[i + 1]) &#123; ++ ans; LOG(i, a[i], a[i + 1]) &#125; &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Equal Frequencies题意称一个字符串是好的,如果每种字符出现的次数都相等. n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t. 分析显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n / seg 首先将字母按照cnt[26] (字母出现频数) 降序排序, 要尽最大可能利用现有的多的字母 以下代码用来找到最小的代及cost其对应的ac 12345678910for (int d = 1; d &lt;= n; ++ d) if (n % d == 0) &#123; int now = 0, seg = n / d; if (seg &gt; 26) continue; for (int i = 0; i &lt; seg; ++ i) &#123; if (cnt[ord[i]] &lt; d) now += d - cnt[ord[i]]; &#125; if (now &lt; mn_cost) &#123; mn_cost = now; best_ac = d; &#125;&#125; 只需要统计cnt不足ac的部分就行了, 不足的部分肯定是需要其他redundant的来补充的. aim[26]表示t中每个字母的目标次数 123for (int i = 0; i &lt; best_seg; ++ i) &#123; aim[ord[i]] = best_ac;&#125; 接下来只需要看s[i]的cnt: cnt &gt; aim[s[i]], 在26个字母中找cnt还不足aim的进行替换 cnt &lt;= aim[s[i]], 跳过 代码12345678910111213141516171819202122232425262728293031323334353637383940414243void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector&lt;int&gt; cnt(26, 0); for (auto ch : s) cnt[ch - &#x27;a&#x27;] ++; vector&lt;int&gt; ord(26); iota(all(ord), 0); sort(all(ord), [&amp;](auto a, auto b) &#123; return cnt[a] &gt; cnt[b]; &#125;); // d: n的因子, 作为每个字母的出现次数 int mn_cost = n, best_ac = 1; for (int d = 1; d &lt;= n; ++ d) if (n % d == 0) &#123; int now = 0, seg = n / d; if (seg &gt; 26) continue; for (int i = 0; i &lt; seg; ++ i) &#123; if (cnt[ord[i]] &lt; d) now += d - cnt[ord[i]]; &#125; if (now &lt; mn_cost) &#123; mn_cost = now; best_ac = d; &#125; &#125; int best_seg = n / best_ac; LOG(mn_cost, best_ac, best_seg) vector&lt;int&gt; aim(26); for (int i = 0; i &lt; best_seg; ++ i) &#123; aim[ord[i]] = best_ac; &#125; LOG(aim) for (auto &amp;ch : s) &#123; if (aim[ch - &#x27;a&#x27;] &gt;= cnt[ch - &#x27;a&#x27;]) continue; for (int to = 0; to &lt; 26; ++ to) &#123; if (aim[to] &gt; cnt[to]) &#123; cnt[ch - &#x27;a&#x27;] --; ch = (char)to + &#x27;a&#x27;; cnt[ch - &#x27;a&#x27;] ++; break; &#125; &#125; &#125; LOG(s) cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;&#125; D. Many Perfect Squares题意非递减数组an. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数. 例如 11 6 13 22 90 选择 x = 3 14,9,16,25,93 4,9,16,25,93最多有4个完全平方数 分析题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x. 先sort(all(a)) 设有 $i &lt; j, a_i + x = va^2 ,a_j + x = vb^2$ 对完全平方数做差有$vb^2 - va^2 = (vb-va)(vb+va) = a_j + x - (a_i + x) = a_j - a_i$ 令 diff = aj - ai 则 (vb - va)(vb + va) = diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d = diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x = va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x. 用dp[x] |= 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意. 最后统计一下每个x的二进制1个数就行 代码12345678910111213141516171819202122232425262728293031void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; sort(all(a)); map&lt;int, int&gt; dp; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = i + 1; j &lt; n; ++ j) &#123; int diff = a[j] - a[i]; for (int div = 1; div * div &lt;= diff; ++ div) &#123; if (diff % div != 0) continue; int diva = div, divb = diff / div; if (diva % 2 != divb % 2) continue; // 12 = 2 * 6 va = 2, vb = 4 // x = va * va - a[i] int va = (divb - diva) / 2, vb = (diva + divb) / 2; int x = va * va - a[i]; if (x &lt; 0) continue; LOG(a[i], a[j], diff, va, vb) dp[x] |= (1ll &lt;&lt; i) | (1ll &lt;&lt; j); &#125; &#125; &#125; int ans = 1; // 只有1个数a, 肯定能找到x, 使得a+x是平方数 for (auto [x, val] : dp) &#123; ans = max(ans, (int)popcountll(val)); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"}]},{"title":"题解 - AtCoder Beginner Contest 134 A-F","slug":"题解 - AtCoder Beginner Contest 134 A-F","date":"2023-01-14T16:00:00.000Z","updated":"2023-01-20T07:14:17.586Z","comments":true,"path":"2023/01/15/题解 - AtCoder Beginner Contest 134 A-F/","link":"","permalink":"http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/","excerpt":"","text":"R2532橙题 F - Permutation Oddness题意设 P = (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;=50)的排列. 定义Oddness:= $\\sum |p_i - i|$. 求满足定义Oddness = k 的不同排列P的数量 思路此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解. 这里以官方题解为基础, 加以翻译并解释. 若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K dp[i][j][k][l]=表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. 因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j=k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. 状态转移方程写作：dp[i][j][k] = (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j] 当考虑第i个数与盒子的时候, 分5种情况: 数i和盒子i直接配对, 未配对的依然是j个 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j]; 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对 未配对的数-1, 盒子数-1, 所以未配对的-1个. 当前状态j, 所以上一状态j+1 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1); 数i和盒子i都不配对, 未配对的是j+1个 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j &gt;= 1) dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j]; 注意, 可能情况个数要从上一状态出发考虑 代码1234567891011121314151617181920212223242526272829303132mint dp[N][N][N * N]; // 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对// 且 当前的奇异值为k的方案数void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; dp[0][0][0] = 1; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 0; j &lt;= i; ++ j) &#123; for (int k = 2 * j; k &lt;= n * n; ++ k) &#123; // 数i和盒子i直接配对, 未配对的依然是j个 // 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j]; // 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个 // 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; // 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个 // 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; // 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对 // 未配对的数-1, 盒子数-1, 所以未配对的-1个. // 当前状态j, 所以上一状态j+1 // 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1); // 数i和盒子i都不配对, 未配对的是j+1个 // 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j &gt;= 1) dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j]; &#125; &#125; &#125; cout &lt;&lt; dp[n][0][k] &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"题解 - Codeforces Round 797 (Div. 3) A-G","slug":"题解 - Codeforces Round 797 (Div. 3) A-G","date":"2023-01-13T16:00:00.000Z","updated":"2023-01-14T04:51:41.517Z","comments":true,"path":"2023/01/14/题解 - Codeforces Round 797 (Div. 3) A-G/","link":"","permalink":"http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/","excerpt":"","text":"昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. 补题: A. Print a Pedestal (Codeforces logo?)题意分析代码12345678910111213void solve() &#123; int n; cin &gt;&gt; n; int d = n / 3; if (n % 3 == 0) &#123; cout &lt;&lt; d &lt;&lt; &#x27; &#x27; &lt;&lt; d + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125; else if (n % 3 == 1) &#123; cout &lt;&lt; d + 0 &lt;&lt; &#x27; &#x27; &lt;&lt; d + 2 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; d + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; d + 2 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125;&#125; B. Array Decrements)题意分析代码1234567891011121314151617181920212223242526272829303132void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (auto &amp;x : a) cin &gt;&gt; x; for (auto &amp;x : b) cin &gt;&gt; x; set&lt;int&gt; d0, d; for (int i = 0; i &lt; n; ++ i) &#123; int cd = b[i] - a[i]; if (b[i] == 0) &#123; d0.insert(cd); &#125; else &#123; d.insert(cd); &#125; &#125; if (d.size() &gt; 1) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; &#125; if (d.size() == 0) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; // d.size == 1 if (*d0.begin() &lt; *d.begin()) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;&#125; C. Restoring the Duration of Tasks题意分析如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d = f - s否则当前任务到来时间s &lt; 上个任务完成时间 d = f - f[i - 1] 代码12345678910111213141516void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; s(n) ,f(n); for (auto &amp;x : s) cin &gt;&gt; x; for (auto &amp;x : f) cin &gt;&gt; x; vector&lt;int&gt; ans(1, f[0] - s[0]); for (int i = 1; i &lt; n; ++ i) &#123; if (s[i] &gt; f[i - 1]) ans.pb(f[i] - s[i]); else ans.pb(f[i] - f[i - 1]); &#125; LOG(ans) for (int i = 0; i &lt; n; ++ i) &#123; cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == n - 1]; &#125;&#125; D. Black and White Stripe题意分析代码1234567891011121314151617void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; s = &quot; &quot; + s; vector&lt;int&gt; pre(n + 1); for (int i = 1; i &lt;= n; ++ i) &#123; pre[i] = pre[i - 1] + (s[i] == &#x27;B&#x27;); &#125; int ans = n; for (int i = 1; i + k - 1 &lt;= n; ++ i) &#123; int l = i, r = l + k - 1; ans = min(ans, r - l + 1 - (pre[r] - pre[l - 1])); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; E. Price Maximization题意给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以的和k, 求和最大是多少 分析每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分. 把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;=k - x, 所以lower_bound一下k - x 也可以把a排序, 然后首尾双指针搞搞 代码12345678910111213141516171819202122232425void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); int ans = 0; multiset&lt;int&gt; S; for (auto &amp;x : a) &#123; cin &gt;&gt; x; ans += x / k; x %= k; if (x) S.insert(x); &#125; while (S.size() &gt;= 2) &#123; auto itx = S.begin(); // 先取值, 再删除? int x = *itx; S.erase(itx); auto ity = S.lower_bound(k - x); if (ity != S.end()) &#123; int y = *ity; ans ++; S.erase(ity); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; F. Shifting String题意给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态 分析首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \\sqrt{n})$ 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector&lt;int&gt; p(n); for (auto &amp;x : p) &#123; cin &gt;&gt; x; x --; &#125; vector&lt;int&gt; st(n, -1); vector&lt;int&gt; len; for (int i = 0; i &lt; n; ++ i) if (st[i] == -1) &#123; int now = i; vector&lt;int&gt; loop; for (; st[now] == -1; now = p[now]) &#123; loop.pb(now); st[now] = 1; &#125; LOG(loop) deque&lt;char&gt; dq0, dq; for (auto p : loop) dq0.pb(s[p]); dq.assign(all(dq0)); int cl = 0; for (;cl &lt; loop.size(); ++ cl) &#123; auto c = dq.back(); dq.pop_back(); dq.push_front(c); if (dq == dq0) &#123; break; &#125; &#125; len.pb(cl + 1); &#125; int ans = 1; for (auto x : len) &#123; ans = lcm(ans, x); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; G. Count the Trains题意每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少 例如[10, 13, 5, 2, 6] =&gt; [10, 10, 5, 2, 2] 一共有3种不同的数 分析维护每段火车的车头位置和整节车的速度. 在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车 如果速度x &gt;= 左边的火车段的速度, 就直接把it合并到左边(erase掉it) 如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)). insert和erase的次数不会超过O(n) 代码1234567891011121314151617181920212223242526272829303132void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; mp; auto add = [&amp;](int i, int x) &#123; mp[i] = x; auto it = mp.find(i); // 根据键key查找 // 9 | 5 ---&gt; 9 10 | 5 if (it != mp.begin() &amp;&amp; prev(it)-&gt;second &lt;= x) &#123; mp.erase(it); return; &#125; // 9 | 5 | 3 | 1 ---&gt; 9 | 2 5 3 | 1 while (next(it) != mp.end() &amp;&amp; next(it)-&gt;second &gt;= x) &#123; mp.erase(next(it)); &#125; &#125;; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; for (int i = 0; i &lt; n; ++ i) &#123; add(i, a[i]); &#125; for (int i = 0; i &lt; m; ++ i) &#123; int k, d; cin &gt;&gt; k &gt;&gt; d; k --; a[k] -= d; add(k, a[k]); cout &lt;&lt; mp.size() &lt;&lt; &quot; \\n&quot;[i == m - 1]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_组合数学","slug":"算法-组合数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_双指针","slug":"算法-双指针","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"年记 - 2022","slug":"年记 - 2022","date":"2023-01-12T16:00:00.000Z","updated":"2023-01-13T08:13:08.235Z","comments":true,"path":"2023/01/13/年记 - 2022/","link":"","permalink":"http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/","excerpt":"","text":"2022 年终总结刘城君 5月开始图划分的任务: 基于标签传播思想, 优化目标主要是复制因子RF. 随机初始化种子节点的tag, 多轮多源BFS的方式进行tag, 选取邻居最多的tag进行标记. 1度点优化. 1度点对RF没有影响 tag合并(按照tag规模/tag结点重合度). 但由于块数与节点数的数量关系限制, 效果不佳. 每个一次assign多个tag(一次性覆盖) 由于传播方式存在问题, 因此负载均衡很差. 9月 - 11月期间阅读了HEP, NE等论文, 了解到Local search的策略, 以及分区boundary节点度数分布对RF的影响. 同时再次阅读了NE的源码. 为了优化负载均衡, 尝试在初始阶段就用BFS确定分区大致分布, 此阶段可以保障tag平衡. 第二阶段加入tag约束, 进行剩余节点的tag assignment. 效果较5月版本有明显进步, 数据集Lj上的表现(-p 8)为: RF=1.66-1.71 Balance = 1.05. 已经优于除NE外的其他算法. 但距离NE的1.33, 1.00仍有较大差距 12月分析RF和Tag的分区交界处节点的度数分布, 发现RF 2/3度点数量基本没有. 尝试将初始块变得更加紧密: 选k-core作为初始块. 效果一般 11月版本中第二阶段传播顺序诡异, 并且存在传播失败的可能. 尝试由当前的按照节点id顺序被动传播改成按照&lt;节点|tag|, 负载均衡, 节点度数&gt;的优先级进行BFS主动传播. 效果不如11月版本 1月 - 现在修改第一阶段BFS的策略, 加入启发式策略: 优先扩展与Core紧密的节点. 基于NE的代码进行实现, 并且尝试两种版本: 优先扩展与Core紧密的节点: RF: 1.7+, Balance: 1.00 优先扩展与Core+Boundary紧密的节点: 本质上就是NE, RF效果与NE十分接近 在修改NE代码过程中, 意识到初始分区只分配p-1块, 最后1块分配p, 从而取消第二阶段的传播. 效果可能会优于当前版本 展望idea储备不足: 阅读更多相关论文 争取在RF / 实际任务效果上取得进展","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - Codeforces Round 839 (Div. 3) A-G","slug":"题解 - Codeforces Round 839 (Div. 3) A-G","date":"2023-01-11T16:00:00.000Z","updated":"2023-02-02T08:01:05.678Z","comments":true,"path":"2023/01/12/题解 - Codeforces Round 839 (Div. 3) A-G/","link":"","permalink":"http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/","excerpt":"","text":"上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. 补题: D题要从题目限制的不等式去推出x的范围. F题发掘性质: 可染色的块一定是递减的. C. Different Differences题意分析代码1 D. Absolute Sorting题意a[n], 询问是否存在一个数x, a[i] &lt;- |a[i] - x|, 形成非单调递减序列, 如果不存在输出-1 分析假设找到了一个x满足题意. 那么就有|a[i] - x| &lt;= |a[i+1] - x|. 两边平方: $(a[i] - x)^2 \\leq (a[i+1] - x)^2$因式分解: $(a[i] - a[i+1])(a[i] + a[i+1] - 2x) \\leq 0$ 接下来逐个判断a[i] - a[i+1], 分类讨论: a[i] - a[i+1] &gt; 0: a[i] + a[i+1] - 2x &lt;= 0a[i] - a[i+1] &lt; 0: a[i] + a[i+1] - 2x &gt;= 0 即可得到x的范围 代码12345678910111213141516171819202122232425void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int mx = (int)2e9, mn = 0; // (x - y)(x + y - 2x) &lt;= 0 for (int i = 0; i + 1 &lt; n; ++ i) &#123; int x = a[i], y = a[i + 1]; if (x &gt; y) &#123; // (x + y - 2x) &lt; 0 mn = max(mn, x + y + 1 &gt;&gt; 1); &#125; else if (x &lt; y) &#123; // (x + y - 2x) &gt; 0 mx = min(mx, x + y &gt;&gt; 1); &#125; else &#123; // x没有要求 ; &#125; &#125; if (mn &lt;= mx) &#123; cout &lt;&lt; mn &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125; E. Permutation Game题意题意, 在一个序列p中, AB两人轮流操作, 每次的操作选择 将p中的某个数变为可调换位置的(涂色) 重新排列, 但只能调动可变换位置的 跳过回合 如果最后形成上升序列甲赢, 递减序列乙赢, 否则平局 分析1241 2 4 3 A要涂色的: p[3], p[4]B要涂色的: p[3], p[4], p[1], p[2] AB俩人都要涂色的: p[3], p[4]只属于A自己要涂色的: 没有只属于B自己要涂色的: p[1], p[2] 如果A把只有自己要涂色的(a)+公共涂色的都涂完了(c), B还剩下没涂, A就赢了如果B把只有自己要涂色的(b)+公共涂色的都涂完了(c), A还剩下没涂, B就赢了 但是要注意A是先手, 所以就算AB同时涂完(b+c==a), 也算A赢. 其他都是平局, 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. 代码12345678910111213141516171819202122232425262728293031void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (auto &amp;x : p) &#123; cin &gt;&gt; x; x --; &#125; int a = 0, b = 0, c = 0; for (int i = 0; i &lt; n; ++ i) &#123; if (p[i] == i) &#123; ++ b; &#125; else if (p[i] == n - i - 1) &#123; ++ a; &#125; else &#123; ++ c; &#125; &#125; LOG(a, b, c) if (a &gt; b + c) &#123; // b先翻完. 如果相等的话, 后手染色完, 下一轮到先手, 先手就直接排序了 cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl; &#125; else if (b &gt;= a + c) &#123; // a先翻完, 由于a先手, 同时ab翻完也不行 cout &lt;&lt; &quot;First&quot; &lt;&lt; endl; &#125; else &#123; // 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. cout &lt;&lt; &quot;Tie&quot; &lt;&lt; endl; &#125;&#125; F. Copy of a Copy of a Copy题意有一个n行m列的01矩阵 (3≤n,m≤30). 其中0表示白色, 1表示黑色. 每次你可以选择以下操作的中的一个: 选择一个不是边界的点 (i,j)(i≠1,i≠n,j≠1,j≠m), 并且他的上下左右的4个点, 其颜色都与之相反, 则把这个点变成相反的颜色. 创建一个当前矩阵的拷贝. 执行了 k(k≤100)次拷贝操作. 现在给出制作的所有 k 个拷贝. 此外, 还有初始的矩阵. 然而, 所有k+1个矩阵的顺序被打乱了. 因为找出初始版本, 并且输出经过了哪些操作. 分析一旦对某个单元格涂色, 就再也不能重新涂色了. 这是因为不能对它的邻居也重新涂色, 因为它们中的每一个都有至少一个相同颜色的邻居——这个单元格本身 这给了我们副本的顺序. 只需按照当前可以进行的重新涂色操作数量的降序对它们进行排序即可. 如果数字相同, 则副本必须相等, 因此它们的顺序无关紧要. 排序后, 考虑一对相邻图片的所有不同单元格. 不可能有两个不同的单元格彼此相邻. 因此, 任何操作都不能干扰另一个操作. 所以制作副本的时候, 随便顺序操作就行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void solve() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ++ k; vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt; a(k + 1, vector&lt;vector&lt;char&gt;&gt;(n, vector&lt;char&gt;(m))); for (int id = 1; id &lt;= k; ++ id) &#123; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = 0; j &lt; m; ++ j) &#123; cin &gt;&gt; a[id][i][j]; &#125; &#125; &#125; vector&lt;array&lt;int, 2&gt;&gt; cnt(k + 1); vector&lt;int&gt; dx&#123;-1, 0, 1, 0&#125;, dy&#123;0, 1, 0, -1&#125;; for (int id = 1; id &lt;= k; ++ id) &#123; cnt[id][1] = id; for (int i = 1; i &lt; n - 1; ++ i) &#123; for (int j = 1; j &lt; m - 1; ++ j) &#123; int diff = 0; auto cc = a[id][i][j]; for (int dir = 0; dir &lt; 4; ++ dir) &#123; auto nc = a[id][i + dx[dir]][j + dy[dir]]; diff += (cc != nc); &#125; cnt[id][0] += (diff == 4); &#125; &#125; &#125; // LOG(cnt) sort(begin(cnt) + 1, end(cnt), greater&lt;array&lt;int, 2&gt;&gt;()); vector&lt;array&lt;int, 2&gt;&gt; ans; for (int i = 2; i &lt;= k; ++ i) &#123; auto g0 = a[cnt[i - 1][1]], g1 = a[cnt[i][1]]; for (int j = 0; j &lt; n; ++ j) &#123; for (int l = 0; l &lt; m; ++ l) &#123; if (g0[j][l] != g1[j][l]) &#123; ans.pb(&#123;j, l&#125;); &#125; &#125; &#125; ans.pb(&#123;-1, cnt[i][1]&#125;); &#125; cout &lt;&lt; cnt[1][1] &lt;&lt; endl; cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto [x, y] : ans) &#123; if (x == -1) &#123; cout &lt;&lt; 2 &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 1 &lt;&lt; &#x27; &#x27; &lt;&lt; x + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; y + 1 &lt;&lt; endl; &#125; &#125;&#125; G. Gaining Rating题意你在一个网站上下棋 , 初始你的等级为$x(x \\le 10^{12})$ , 你想要升级到 y$(x &lt; y \\le 10^{12})$你有$n(n \\le 2 * 10^5)$个对手, 第i个队友的等级为 a[i]$(a[i] \\le 10^{12})$ . 你需要与这些对手对战, 如果你的等级大于等于对手的等级, 你将获胜, 并且等级加1. 否则等级减1. 注意, 对手的等级不会发生变化. 为了防止你一直打最低等级的对手的, 网站有一个规定. 如果你要与对手 i 对战, 则应该没有其他对手 j, 使得你与 i 的比赛次数多于与 j 的比赛次数. 问你需要打多少局, 才能升到等级y, 如果不能输出-1. 分析要想rating++, 肯定是先跟a[i]小于自己x的人先打, rating打上去了, 再找之前打不过的复仇, 从他们身上赚rating. 所以要先按照a升序排序. 先判断最开始一轮, rating能不能有所长进, 如果不能, 那就不行 算完第一轮的长进change之后, 开始逐个找之前打不过的人a[i]. 自己需要加win_t轮change, 最后第win_t + 1轮到达a[i]面前时, 我已经有了x + win_t * change + i的rating. 即 $x + win_t * change + i \\geq a[i]$. 取个ceil就可以算出复仇a[i]的轮数了 但是有可能在打败a[i]之前, 就已经达到了y的目标, 所以要算出suc_t = ceil(y - x - i, change). 如果win_t &gt;= suc_t, 就要进入最后一轮, 直到x&gt;=y. 直到最后全部a都能击败后, 直接随便挑对手就行了. 即ans += y - x(当前的rating) 注意上述的x, change和ans都是会实时更新的 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; vector&lt;int&gt; a(n), b(n); // b: 是否可以击败i for (auto &amp;x : a) cin &gt;&gt; x; sort(all(a)); int change = 0, ans = 0; for (int i = 0; i &lt; n; ++ i) &#123; if (x &gt;= a[i]) ++ x, ++ change, ++ ans, b[i] = 1; else -- x, -- change, ++ ans, b[i] = -1; if (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl; return;&#125; &#125; if (change &lt;= 0) &#123;cout &lt;&lt; -1 &lt;&lt; endl; return;&#125; auto ceil = [&amp;](int a, int b) -&gt; int &#123; if (a &lt; 0) return 0; return (a + b - 1) / b; &#125;; for (int i = 0; i &lt; n; ++ i) if (b[i] == -1) &#123; // x + win_t * change + i &gt;= a[i] // (a[i] - x - i) / change &lt;= win_t int win_t = ceil(a[i] - x - i, change); // x + suc_t * change + i &gt;= y // (y - x - i) / change &lt;= suc_t int suc_t = ceil(y - x - i, change); if (win_t &gt;= suc_t) &#123; ans += suc_t * n; x += suc_t * change; for (int j = 0; j &lt; n; ++ j) &#123; if (x &gt;= a[j]) ++ x, ++ ans; else -- x, ++ ans; if (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl; return;&#125; &#125; &#125; ans += win_t * n; x += win_t * change; b[i] = 1; change += 2; &#125; LOG(ans) cout &lt;&lt; ans + y - x &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"题解 - Codeforces Round 685 (Div. 2) A-E","slug":"题解 - Codeforces Round 685 (Div. 2) A-E","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-14T04:52:30.069Z","comments":true,"path":"2023/01/11/题解 - Codeforces Round 685 (Div. 2) A-E/","link":"","permalink":"http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/","excerpt":"","text":"做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了 C. String Equality题意给两个字符串a和b, 问a能不能通过无限次操作到b. 第一种操作, 相邻交换字符: 第二种操作, 选取区间长度为k的子串,而且子串中的字母都 &lt;’z’, 每一个字母都加一（比如S0=’a’ 操作后,S0=’b’) 分析代码1 D. Circle Game题意给一个d和R,A和B轮流操作, 从(0,0)开始移动, 可以选择 x+=d 或者 y+=d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候, 那个人就输了 分析代码1 E. Bitwise Queries (Hard Version)题意有一个长度为 n 的数组(n 是 2 的幂) , 有 3 种操作, AND OR XOR, 可以获得数组两个元素的 AND OR XOR 值, 仅限 n+1 次操作求原数组 分析首先考虑以 $a_1$ 为基准求出 $a_1 \\oplus a_k$, 这样只要求出 $a_1$ 就可以求出整个数组, 这一步需要 $n-1$ 次操作. 因为只有 $n$ 个元素, 元素的范围是 $[0,n-1]$, 所以可以进行分类讨论： 1.所有元素并不是互不相同. 也就是说有重复的元素, 这样只要找到相同的元素, 对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值）, 又因为知道了所有元素和 $a_1$ 的 XOR, 所以可以直接算出整个数组. 考虑如何找到相同的元素, 可以开个桶记录每个元素出现的次数. 取最大的出现次数（这种情况下至少两次）, 然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素, 任意取两个询问 AND 就可以了. 不过这里有个要注意的, 如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素, 取 $1$ 询问即可. 2.所有元素互不相同. 也就是是 $[0,n-1]$ 的全排列. 考虑 XOR 的性质, 相同就是 $0$, 也就是说可以选择 $1$ 这个数, 只有最后一位是 $1$, 其他都是 $0$, 也就是说如果 $a_1\\oplus a_k=1$, $a_1$ 和 $a_k$ 只有最后一位不一样, 可以通过 AND 操作求出前 $\\log n-1$ 位. 同理如果 $a_1\\oplus a_k=\\frac n2$, $a_1$ 和 $a_k$ 只有第一位不一样, 可以通过 AND 操作求出后 $\\log n-1$ 位. 把两个结果组合一下（直接或起来）就可以得到 $a_1$. 其实不一定要选择 $1$ 和 $\\frac n2$, 只要保证这两个数二进制下每位都至少有个数是 $0$ 就行. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int AND(int x, int y) &#123; cout &lt;&lt; &quot;AND &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; int res; cin &gt;&gt; res; return res;&#125;int XOR(int x, int y) &#123; cout &lt;&lt; &quot;XOR &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; int res; cin &gt;&gt; res; return res;&#125;void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; xr(n + 1); vector&lt;int&gt; cnt(n + 1, 0); cnt[0] ++; for (int i = 2; i &lt;= n; ++ i) &#123; xr[i] = XOR(1, i); cnt[xr[i]] ++; &#125; int a1, mx_show_xr = max_element(all(cnt)) - cnt.begin(); // mx_show_xr: 出现最多的xr值 if (cnt[mx_show_xr] &gt; 1) &#123; // n个数中有重复的 vector&lt;int&gt; dulplicate_pos; for (int i = 2; i &lt;= n; ++ i) &#123; // if (cnt[xr[i]] == cnt[mx_show_xr]) &#123; // X!!! cnt一致的xr值可能有多个!!! if (xr[i] == mx_show_xr) &#123; dulplicate_pos.pb(i); &#125; &#125; LOG(dulplicate_pos) // assert(dulplicate_pos.size() &gt; 1); int a_dulplicate; if (dulplicate_pos.size() == 1) &#123; a_dulplicate = AND(1, dulplicate_pos.back()); &#125; else &#123; a_dulplicate = AND(dulplicate_pos.front(), dulplicate_pos.back()); &#125; a1 = a_dulplicate ^ mx_show_xr; cout &lt;&lt; &quot;! &quot; &lt;&lt; a1 &lt;&lt; &#x27; &#x27;; for (int i = 2; i &lt;= n; ++ i) &#123; cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; &#x27; &#x27;; &#125; &#125; // 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次 else &#123; // n个数无重复, 就是[0, n-1]的全排列 int px = find(all(xr), 1) - xr.begin(); // a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同 int py = find(all(xr), n / 2) - xr.begin(); a1 = AND(1, px) | AND(1, py); cout &lt;&lt; &quot;! &quot; &lt;&lt; a1 &lt;&lt; &#x27; &#x27;; for (int i = 2; i &lt;= n; ++ i) &#123; cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; &#x27; &#x27;; &#125; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"题解 - Codeforces Round 843 (Div. 2) A-E","slug":"题解 - Codeforces Round 843 (Div. 2) A-E","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-21T04:28:02.707Z","comments":true,"path":"2023/01/11/题解 - Codeforces Round 843 (Div. 2) A-E/","link":"","permalink":"http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/","excerpt":"","text":"次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了. 补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题 A. Gardener and the Capybaras题意将仅包含a和b的字符串s分成三部分s=s1+s2+s3, 使得s2是这三个部分的一个最值（最大值或最小值, 按字典序比较） 分析s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;=s3 s2为min: 直接拿一个a就行 代码123456789101112131415161718void solve() &#123; string s; cin &gt;&gt; s; int n = s.size(); for (int i = 1; i &lt; n - 1; ++ i) &#123; if (s[i] == &#x27;a&#x27;) &#123; cout &lt;&lt; s.substr(0, i) &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27;a&#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; s.substr(i + 1) &lt;&lt; endl; return; &#125; &#125; // aaaabaaab for (int i = 1; i &lt; n - 1; ++ i) &#123; if (s[i] == &#x27;b&#x27;) &#123; cout &lt;&lt; s.substr(0, i) &lt;&lt; &#x27; &#x27; &lt;&lt; s.substr(i, n - i - 1) &lt;&lt; &#x27; &#x27; &lt;&lt; s.back() &lt;&lt; endl; return; &#125; &#125;&#125; B. Gardener and the Array题意记 f(a) 是 a 数组中, 所有数的按位或. 现有 n 个数 c1,c2…cn组成的数组, 询问是否有两个不同的子数组 a 和 b , 使得 f(a)=f(b) 数据保证所有数的二进制中 1 的数量之和不超过$10^5$ 分析如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci | cj | ck) = f(cj | ck). 如下样例: 123433 1 2 42 2 34 3 4 ci: 2 3 cj: 1 2 4 ck: 3 4 所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1 代码12345678910111213141516171819202122232425262728void solve() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; c(n); // vector&lt;int&gt; cnt(200000 + 10, 0); map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; ++ i) &#123; int k; cin &gt;&gt; k; for (int j = 0; j &lt; k; ++ j) &#123; int x; cin &gt;&gt; x; c[i].pb(x); cnt[x] ++; &#125; // sort(all(c[i])); &#125; for (int i = 0; i &lt; n; ++ i) &#123; auto &amp;v = c[i]; bool suc = true; for (auto x : v) &#123; suc &amp;= (cnt[x] &gt; 1); &#125; if (suc) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;&#125; C. Interesting Sequence题意对于n, 求最小的m, 使得 n&amp;(n+1)&amp;…&amp;m = x 分析获取x的二进制长度: floor(log2(x)) + 1 每一二进制位上, 只可能从无0变成有0所以x只可能是n的二进制子集某一二进制位经历从1变成0, 全部低位肯定全部经历过全0所以: x只能保留n高位1的子集他的高一位也要经历翻转所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行 n: 0000110111100000101 101101011001110100111011001000000000000000000x: 0000110111100000101 000000000000000000000000000000000000000000000ans: -1 (公共前缀最后一位是1) n: 000011011110000010 1101101011001110100111011001000000000000000000x: 000011011110000010 1000000000000000000000000000000000000000000000ans: 000011011110000011 n: 000011011110000010 1101101011001110100111011001000000000000000000x: 000011011110000010 1000010000000000000000000000000000000000000000ans: -1 (mask &amp; x != x) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void solve() &#123; int n, x; cin &gt;&gt; n &gt;&gt; x; if (x &gt; n) &#123; // &amp; 只会变小 cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; if (x == n) &#123; cout &lt;&lt; n &lt;&lt; endl; return; &#125; if (x == 0) &#123; int bit = floor(log2(n)) + 1; cout &lt;&lt; (1ll &lt;&lt; bit) &lt;&lt; endl; return; &#125; int mask = 0, last = 0; int b = 62; for (; b &gt;= 0; -- b) &#123; if ((x &gt;&gt; b &amp; 1) == (n &gt;&gt; b &amp; 1)) &#123; mask |= (int)(x &gt;&gt; b &amp; 1) &lt;&lt; b; last = (x &gt;&gt; b &amp; 1); &#125; else if ((n &gt;&gt; b &amp; 1) == 0 &amp;&amp; (x &gt;&gt; b &amp; 1) == 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; else &#123; break; &#125; &#125; if (last == 1 || (mask &amp; x) != x) &#123; // 1011 -&gt; 1010 cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; // 最后1个1的位置 b += 1; mask |= 1ll &lt;&lt; (b); cout &lt;&lt; mask &lt;&lt; endl;&#125; 附上对拍数据 1234567891011mt19937 mrand(random_device&#123;&#125;()); int rnd(int x) &#123;return mrand() % x + 1; &#125; // [1, x]void solve() &#123; int n = 10000; cout &lt;&lt; n &lt;&lt; endl; vector pw&#123;0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;; for (int i = 1; i &lt;= n; ++ i) &#123; int a = rnd(1000), b = pw[rnd(pw.size()) - 1] + pw[rnd(pw.size()) - 1]; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; endl; &#125;&#125; D. Friendly Spiders题意现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边. 请找到 s 和 t 的最短路径. $1\\le n, a_i\\le 3\\times 10^5$ 分析边权01 -&gt; 01bfs 建图问题: 每一次遇到一个数时, 即使它只有一条边, 我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图 图的边数很多, 没有办法快速求解 从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n 最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \\sqrt{n})$. bfs复杂度$O(n + n \\sqrt{n})$ 坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int inf = 0x3f3f3f3f3f3f3f3f;void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); vector&lt;vector&lt;int&gt;&gt; v2id(300000 + 10); int idx = 0; for (auto &amp;x : a) &#123; cin &gt;&gt; x; v2id[x].pb(++ idx); &#125; int s, t; cin &gt;&gt; s &gt;&gt; t; vector&lt;vector&lt;array&lt;int, 2&gt;&gt;&gt; g(600000 + 10); vector&lt;bool&gt; is_p(300000 + 10, true); for (int i = 2; i &lt;= 300000; ++ i) &#123; // if (st[i]) continue; if (!is_p[i]) continue; // 2, 4, 6, 8, 10...之间连边 打电话式建图n^2 // 交换机式建图 for (int j = i; j &lt;= 300000; j += i) &#123; if (j != i) is_p[j] = false; if (v2id[j].size()) &#123; for (auto uid : v2id[j]) &#123; g[uid].pb(&#123;i + 300000, 0&#125;); g[i + 300000].pb(&#123;uid, 1&#125;); &#125; &#125; &#125; &#125; deque&lt;array&lt;int, 2&gt;&gt; dq; vector&lt;int&gt; dist(600000 + 10, inf); vector&lt;int&gt; pre(600000 + 10, -1); dist[s] = 0; dq.pb(&#123;0, s&#125;); while (dq.size()) &#123; auto [cd, cv] = dq.front(); dq.pop_front(); if (cd &gt; dist[cv]) continue; if (cv == t) break; for (auto [nv, w] : g[cv]) &#123; LOG(cv, nv, w) if (dist[nv] &gt; dist[cv] + w) &#123; dist[nv] = dist[cv] + w; pre[nv] = cv; if (w == 1) &#123; dq.pb(&#123;dist[nv], nv&#125;); &#125; else &#123; dq.push_front(&#123;dist[nv], nv&#125;); &#125; &#125; &#125; &#125; LOG(dist[t]) if (dist[t] &gt; inf / 2) &#123; cout &lt;&lt; -1 &lt;&lt; endl;; return; &#125; int now = t; vector&lt;int&gt; path; while (now != -1) &#123; if (now &lt;= 300000) &#123; path.pb(now); &#125; now = pre[now]; &#125; reverse(all(path)); LOG(path) cout &lt;&lt; path.size() &lt;&lt; endl; for (auto u : path) cout &lt;&lt; u &lt;&lt; &#x27; &#x27;;&#125; E. The Human Equation题意给一个序列a[n] (n&lt;=2e5), 要通过下面的两种操作, 最终全部变成0, 最少需要操作几次 操作1: 选a的一个子序列, 然后子序列奇数位+1, 偶数位-1操作2: 选a的一个子序列, 然后子序列奇数位-1, 偶数位+1 如[1,4,2,8,5,7,3,6,9] -&gt; [4,2,5,6]用操作1-&gt; [1,5,1,8,6,7,3,5,9] 分析pre[n]: a[n]的前缀和数组 a[i] + 1, a[j] - 1 相当于pre[i ~ j - 1] + 1a[3] + 1, a[4] - 1 相当于pre[3] + 1a[3] + 1, a[5] - 1 相当于pre[3 ~ 4] + 1 最终状态: pre全部为0 所以一次操作, 可以把pre上任何位置上的数+1 / -1 只需要记录前缀和中的mn和mx, 答案分类讨论下就行 代码1234567891011121314151617void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int cs = 0, mx = -2e9, mn = 2e9, ans = 0; for (int i = 0; i &lt; n; ++ i) &#123; cs += a[i]; mx = max(mx, cs); mn = min(mn, cs); &#125; if (mx &lt; 0) ans = abs(mn); else if (mn &gt; 0) ans = abs(mx); else ans = mx - mn; LOG(ans, mn, mx) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"题解 - 牛客小白月赛65 A-F","slug":"题解 - 牛客小白月赛65 A-F","date":"2023-01-08T16:00:00.000Z","updated":"2023-01-14T11:49:48.027Z","comments":true,"path":"2023/01/09/题解 - 牛客小白月赛65 A-F/","link":"","permalink":"http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/","excerpt":"","text":"B - 牛牛写情书题意 + 分析判断模式串T是否是给定串S的子串.瞎写双指针 XKMP / 双哈希 V5e3: 直接substr暴力$n^2$ 代码12345678910111213141516171819void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; string os, k; cin &gt;&gt; os &gt;&gt; k; string s; for (int i = 0; i &lt; n; ++ i) &#123; if (islower(os[i])) &#123; s.pb(os[i]); &#125; &#125; LOG(s) n = s.size(); for (int i = 0; i + m - 1 &lt; n; ++ i) &#123; if (s.substr(i, m) == k) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;&#125; C - 牛牛排队伍题意有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面. 老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c =&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？ 一共会有 k 次操作, 每次会执行下面的一种： 把 x 叫走 求排在 x 前面的是谁 分析pre, nxt模拟双向链表 代码1234567891011121314151617181920212223242526void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; pre(n + 1, 0); vector&lt;int&gt; nxt(n + 1, 0); for (int i = 1; i &lt;= n; ++ i) &#123; if (i &gt; 1) &#123; pre[i] = i - 1; &#125; if (i &lt; n) &#123; nxt[i] = i + 1; &#125; &#125; while (k --) &#123; int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) &#123; int a = pre[x], b = nxt[x]; pre[x] = nxt[x] = 0; nxt[a] = b; pre[b] = a; &#125; else &#123; cout &lt;&lt; pre[x] &lt;&lt; endl; &#125; &#125;&#125; D - 牛牛取石子题意两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取： 第一堆取 1 个, 第二堆取 2 个第一堆取 2 个, 第二堆取 1 个 谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？ 分析1e18: 打表找规律 模仿是博弈里面的一个重要的策略, 主要思想:断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法 a, b两堆石子, 必败态是: min(a, b) % 3 == 0. 因为后手总是可以控制min(a, b)在一轮下来-3B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:A: 5 4B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输原因在于: 若min(a, b) % 3 != 0 A总是可以把min(a, b) % 3 == 0的局面给B 代码123456789const int C = 15;vector&lt;vector&lt;int&gt;&gt; awin(C + 1, vector&lt;int&gt;(C + 1, 0));awin[1][2] = awin[2][1] = 1;for (int i = 0; i &lt;= C; ++ i) &#123; for (int j = 0; j &lt;= C; ++ j) &#123; if (i &gt;= 1 &amp;&amp; j &gt;= 2) awin[i][j] |= !awin[i - 1][j - 2]; if (i &gt;= 2 &amp;&amp; j &gt;= 1) awin[i][j] |= !awin[i - 2][j - 1]; &#125;&#125; 123456789101112131415161718int solve(int a, int b) &#123; if (a &gt; b) swap(a, b); int r = a / 3; // ab互走r轮对称棋 b = b - r * 3; a = a - r * 3; if (min(a, b) != 0) &#123; if (a == b &amp;&amp; a == 1) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125;&#125; E - 牛牛的构造题意构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \\leq i&lt;j \\leq n$ &amp;&amp; $a_i - a_j = 2^x(x\\in N)(1\\le n \\le 10^6, 1\\le k \\le 10^9)$ 分析考虑降序的排列: 9 8 7 6 5 4 3 2 1 f[x]: 降序排列时, x对xi-xj=2^k 的贡献f[9]: 4f[8]: 3f[7]: 3f[6]: 3f[5]: 3f[4]: 2f[3]: 2f[2]: 1f[1]: 0 先降序, 后升序降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0​ 代码1234567891011121314151617181920212223242526void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; f(n + 1, 0); for (int i = 1; i &lt;= n; ++ i) &#123; f[i] = f[i - 1] + (popcountll(i - 1) == 1); &#125; LOG(f) int mxk = accumulate(all(f), (int)0); if (mxk &lt; k) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; vector&lt;int&gt; dec, inc; for (int i = n; i &gt;= 1; -- i) &#123; if (k &gt;= f[i]) &#123; dec.pb(i); k -= f[i]; &#125; else &#123; inc.pb(i); &#125; &#125; reverse(all(inc)); for (auto x : dec) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; for (auto x : inc) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;&#125; F - 牛牛的考试题意有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟. 分析树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间 对于同一门课而言:双开时间可以转成单开时间, 即双开可以反悔成单开.但是单开不能转成双开, 否则说明同时用手机电脑学同一门课. 所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间. 代码123456789101112131415161718192021222324252627282930313233343536vector&lt;vector&lt;int&gt;&gt; g;vector&lt;array&lt;int, 2&gt;&gt; dp; // dp[i][0] : 双开时间, dp[i][1] : 单开时间vector&lt;int&gt; a;array&lt;int, 2&gt; add(array&lt;int, 2&gt; a, array&lt;int, 2&gt; b) &#123; // &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125; // &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125; // &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125; if (a[1] &gt; b[1]) swap(a, b); int d = min(a[0], b[1] - a[1] &gt;&gt; 1); a[0] -= d, a[1] += 2 * d; return &#123;a[0] + b[0] + min(a[1], b[1]), max(a[1], b[1]) - min(a[1], b[1])&#125;; // 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的 // return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;&#125;void dfs(int u, int fa) &#123; for (auto v : g[u]) &#123; if (v == fa) continue; dfs(v, u); dp[u] = add(dp[u], dp[v]); &#125; dp[u][1] += a[u];&#125;void solve() &#123; int n; cin &gt;&gt; n; g.resize(n); dp.resize(n); a.resize(n); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt; n; ++ i) &#123; int x; cin &gt;&gt; x; x--; g[i].pb(x); g[x].pb(i); &#125; dfs(0, -1); cout &lt;&lt; dp[0][0] + dp[0][1] &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"周记 - 2022 12.19-12.25","slug":"周记 - 2022 12.19-12.25","date":"2022-12-28T16:00:00.000Z","updated":"2023-01-21T01:42:30.097Z","comments":true,"path":"2022/12/29/周记 - 2022 12.19-12.25/","link":"","permalink":"http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/","excerpt":"","text":"12.19 周一 晴今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我. 虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;, 12.20 周二 晴感染第一天: 流鼻涕 12.21 周三 晴待填 12.22 周四 多云12.23 周五 阴待填 12.24 周六 晴今天是考研第一天 晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了. 12.25 周日 晴后记回忆于：12.29日晚22点","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2022 12.12-12.18","slug":"周记 - 2022 12.12-12.18","date":"2022-12-19T16:00:00.000Z","updated":"2023-01-21T01:43:26.456Z","comments":true,"path":"2022/12/20/周记 - 2022 12.12-12.18/","link":"","permalink":"http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/","excerpt":"","text":"12.12 周一 晴早上刷题. 下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》, 同时刷题. 主要是《D. Range = √Sum》这题, 1800构造, 只能想出偶数的构造方法, 奇数情况还是过于抽象了. 晚上吃师生缘的煎饼果子, 看完了《剃须. 然后捡到高中生》. 个人认为这番其实还算治愈番, 但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩. 可能是这还只是我正式进军二次元后看的第二部番, 姑且还觉得不错, 挺期待剃须出第二部的. 晚上跟zzm及他同学联机深岩银河. 12.13 周二 晴日程基本同周一. 12.14 周三 晴日程基本同周一. 下番《辉夜大小姐想让我告白》全部三季. 晚餐尝试了步步高门口街道上的潼关肉夹馍, 10块量少但味道不错. 12.15 周四 多云今天9:45-11:45 是《高性能计算》的期末考试. 虽然线上考试并且开卷, 但我仍觉得很难. 老师也觉得很难, 所以又延长了10分钟到11:55. 我12点整把试卷拍照上传助教邮箱. 挺无语的, 本来就一限选, 还搞严格的签到、实验和线上考试. 晚上zwling发消息说南京站的物资到了, 惊喜的是外套居然还带ICPC标. 相比之下沈阳的廉价格子衫就是屑了. 12.16 周五 阴待填 12.17 周六 晴今天14:00-16:00是ICPC南京站的热身赛. 10点半不到我就吃了午餐, 午餐在师生缘吃的自助. 同样还是12点小睡了30分钟到1点起床. 我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合, 一起前往院楼. 看得出zwling似乎有些生病, 不过都拼到这一步了, 我相信大家都是想让本科的ICPC生涯有始有终的. 走到天马公寓门口时, 后面一位好心的小姐姐提醒了我书包在漏水. 听到她的提醒我先是愣了下, 随后立马把笔记本电脑拿了出来. 之前其实也发生过水壶漏水的事故, 并且电脑都没啥事. 但是这次漏水偏偏赶在热身赛赛前1小时不到, 并且还刚好是3人3机位. 一看到电脑朝下的那一边湿了一大片, 内心也凉了大半截. 不过好在有初中毕业游手机进水的经验, 这次还是学聪明了：虽然很想知道电脑是否还健在, 也很想知道明天的正式赛会不会受到影响, 我也还是忍住没按下开机键, 在路上全称用手拎着电脑边甩边让风吹, 到院楼放在门口晒了20分钟. 热身赛马上就要开始了, 我只能按下开机键, 已经做好了最坏的打算. 电脑也跟我开了个玩笑, 开机成功后自己又重启了, 不过好在这只是系统更新. 最后电脑开是能开, 但是左下角的屏幕就暗一片亮一片. 热身赛开始阶段我们跟着榜, 着力于过题数最多的B, 却发现只能想到6次方（n=20）的做法. 我的想法是每次直接找第一个1, 然后BFS到另外一个1, 将轨迹应用于全图. 这样每次至少减少1个1, 复杂度虽然不会超, 但是却无法保证轨迹总长度不超过50000, 所以也没敢上机写. 可是诡异的是很多支队伍都很快通过了. 前1小时我们都还是1题没过. 直到姜哥看到D题题面有对B题随机化解法的代码, 才发现这是往年南京站原题. 于是姜哥很快把D题签了, 然后把D题的代码直接复制到B, 至此B也过了. 最后的A题我和zwling想出了二分的假算法, 前期一直没找到钱越多买的书越多的反例, 因此也就因此WA. 姜哥及时提出了反例, 并且给出了正确的贪心做法, 只不过此时已经接近结束了. 虽说我们热身赛封榜前一道没过, 排在了300名左右. 在回宿舍的路上, 姜哥还说他隔壁宿舍有人羊了. 按照我一直奉为圭臬的人品守恒定律, 我已经看到了明天的结果：高数100将在南京站修成正果. 首先是队长zwling生病疑似阳性, 然后又是我电脑进水. 接下来又是姜哥附近与有人确诊. 这无疑给了我莫大的鼓舞. 回到园区后, zwling还是去门口核酸亭做了混检. 晚上打了atcoder Beginner Contest 282, 直接D题罚坐. rk2000+, 看来青名又要离我远去了. 12.18 周日 晴仍是凌晨1点睡, 只不过早上9:30起床, 10:00前进餐完毕, 只吃了肉松饼和上次CCSP发的零食, 睡了20来分钟. 10:00出发去院楼参加南京正式赛. 开题签到题I, 在我们迟疑的功夫, 已经过了快300人了. 第二题G贪心, 姜哥首先发现要贪心0前半段要取1, 后半段取-1, 随后我提出了二分分界线. 姜哥提出可以O(n)做, 但是写挂了, 于是我就上机开始二分了. 又到了经典二分分界线环节, 我还被这个分界线在最左边的情况卡了10分钟, 不愧是我…不过好在在姜哥提醒下, 很快就写完了. 幸运地一发A了. 第三题看着像计算几何, 姜哥一开始就说这题很简单, 只需要判断v型就行了, 我和zwling都是懵的. 随后姜哥画了几下就上机码了, 第一发没过. 随后过了10来分钟他想出了corner case, 交上去居然直接过了. 当然我们也只是开心了一下, 毕竟从此到结束, 我们都再也没能过一道题. 第四题大模拟二维前缀和, 我们还剩2小时的时间. 我想的是用将轨迹表示成一个01矩阵, 然后再用这个矩阵和最后袋鼠组成的矩形, 做类似求交算移入移出了多少. 姜哥表示应该确实就只是二维前缀和, 随后就开始码. 但是最后因为查不出哪里越界, 一直段错误. 结束后, 虽然zwling觉得可能还是打铁, 但我和姜哥都觉得铜牌概率蛮大. 5:30开始滚榜, 当看到《高数100》出现在铜牌区时, 我意识到本科的算法竞赛已经没有遗憾了. 我觉得这次铜牌不仅幸运女神站在我们这边, 更重要的是队伍的实力确实有所上升, 毕竟这次zwling生病了. 如果他没生病, 我估计我们能将A题调出来. 最后本科的所有XCPC至此都告一段落了, 希望zwling能在BUAA找到更强的队友, 继续在算法竞赛上取得更高的成就, 也希望姜哥顺利上岸, 在研究生阶段继续发挥他过人的思维优势. 最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家. 接下来就是修改《软件工程》课程大作业的报告, 并且收拾行李, 准备第二天9点的高铁了. 要好好放松下了, 首先得先把剩下的2集麻衣学姐看完hh. 后记回忆于：12.20日晚22点 BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐 我把《高数100》的队牌带回了宿舍, 跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起. 这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事.","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - 牛客小白月赛59 D-F","slug":"题解 - 牛客练习赛105 D","date":"2022-11-06T16:00:00.000Z","updated":"2023-01-20T07:04:06.206Z","comments":true,"path":"2022/11/07/题解 - 牛客练习赛105 D/","link":"","permalink":"http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/","excerpt":"","text":"比赛链接 Dijkstra 松弛的理解“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比. 最初, 最短路径的成本被高估了, 就像延伸的弹簧一样. 当找到更短的路径时, 估计的成本会降低, 弹簧会放松. 最终, 找到了最短的路径（如果存在）, 并且弹簧已经松弛到其静止长度. D - 点分治分点题意G&lt;n, m&gt;, 且$n, m \\leq 1e5$, 定义一条简单路径的 low 值为其路径上的边权的最小值, d(u, v) 为从 u 到 v 所有简单路径的最大 low 值. 对于给定的s, u 从 1 到 n 输出 d(s, u), 如果没有任何一条简单路径则输出 -1. 分析点边数1e5 -&gt; Dijkstra变形套路 dist[i]: s-&gt;i的每条路径最短边中的最大值 松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. 代码123456789101112131415161718192021222324252627282930313233343536373839const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f;int n, m, s;vector&lt;array&lt;int, 2&gt;&gt; G[N];int dist[N]; // s-&gt;i 每条路径最短边中的最大值void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; ++ i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].pb(&#123;v, w&#125;); &#125; priority_queue&lt;array&lt;int, 2&gt;&gt; pq; memset(dist, -0x3f, sizeof dist); dist[s] = inf; pq.push(&#123;inf, s&#125;); while (pq.size()) &#123; auto [cd, cv] = pq.top(); pq.pop(); if (dist[cv] &gt; cd) continue; // cerr &lt;&lt; cv &lt;&lt; endl; for (auto [nv, w] : G[cv]) &#123; if (dist[nv] &lt; min(dist[cv], w)) &#123; dist[nv] = min(dist[cv], w); pq.push(&#123;dist[nv], nv&#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) &#123; if (dist[i] &lt; -inf / 2 || dist[i] &gt; inf / 2) &#123; dist[i] = -1; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) &#123; cout &lt;&lt; dist[i] &lt;&lt; &quot; \\n&quot;[i == n]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"题解 - 第八届“图灵杯”个人赛","slug":"题解 - 第八届“图灵杯”个人赛","date":"2022-11-06T16:00:00.000Z","updated":"2023-01-20T07:03:54.261Z","comments":true,"path":"2022/11/07/题解 - 第八届“图灵杯”个人赛/","link":"","permalink":"http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/","excerpt":"","text":"比赛链接 贪吃的派蒙题意在每一次的排队中, 编号为i的角色领取上限为Ai, 这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内. 当一个角色领完本次的甜甜花酿鸡, 他/她就会回到队列的末尾, 直到所有甜甜花酿鸡都被吃完为止. 当轮到一个角色领取时, 如果所有的甜甜花酿鸡都被领完, 那么他/她就要帮大家刷盘子. 贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小, 那么他就把剩下的都吃完). 我们很容易找到派蒙的编号, Ax比其他所有的Ai都要大. 大家都想让派蒙最后留下来刷盘子, 请你写一个程序来判断这是否可能. 分析代码1 Seek the Joker II题意两堆石子, 一堆k-1, 另一堆n-k, 先取到任意一堆的最后一个输 分析代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"周记 - 2022 10.31-11.6","slug":"周记 - 2022 10.31-11.6","date":"2022-11-05T16:00:00.000Z","updated":"2023-01-14T11:50:43.861Z","comments":true,"path":"2022/11/06/周记 - 2022 10.31-11.6/","link":"","permalink":"http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/","excerpt":"","text":"11.3 周四 晴今天一早起来就看到知乎推送《多地核酸开始自费》, 又了解到大舅那边前几天已经开始自费了, 收费是4元/次. 不禁联想到昨天还吐槽核酸检测人员的高收入. 早十有《高性能计算》, 依旧是平平无奇地上半节课签到, 课间从复邻舍401后门溜回宿舍. 不过今天罗HZ老师提到了签到的问题, 在课上指出了缺课达3次需要补卡. 我想起上上周自己因为没看课表, 直接漏掉了一次签到. 不料午饭后, 有同学在课程群里问有没有爬山组队. 这才知道所谓的补卡其实是跟LHZ爬岳麓山, 好感度++. 自己也得找个机会把缺的这次签到补回来. 下午依旧是赛前的日常刷题. 晚饭步步高挑香小面. 晚九点打算继续昨晚的师大天马宿舍之行. 虽然没有大门大开, 但是也只是扫个码就放行了. 漫步在师大宿舍园区, 我和ZZM都明显感觉到和湖大天马宿舍不同的地方. 简单来说就是中南南校区和这里都更加具有校园的氛围, 体现在绿化, 路旁的人行道, 路旁的宣传栏, 也体现在这里建筑的杂乱. 11.4 周五 晴8点30分第一个下床. 刷题. 干午饭. 学委此时也发了关于毕设导师的通知了, 毕设郑老师之前提过, 但是目前又没了消息. 我最担心的是找不到愿意挂名的导师. 下午第三节有《软件工程》, 课上做了些2022辽宁省赛的题目, 发现题目难度不大. 做了可莉的五子棋和画画. 图的分割和栈与公约数暂时没想到做法. 晚上有例行的每周大组会, 我问了WSH, 发现大家都找了毕设的导师, 所以我也打算把当前进度汇报一下, 顺便问问毕设的事情. 于是跟老师和彭Z约了明天晚上讨论进度. 11.5 周六 晴今天14:00-16:00是ICPC沈阳站的热身赛. 所以10点半不到就吃了午餐, 休息小睡了20分钟后. 便在阜埠河公交站和zwl骑车去院楼105准备上机环境. 在比赛开始时, zwl的后置录像手机夹住了关机键, 手机直接关机了, 所以我们整场比赛都没法正常交题. 不过还是能看题面, A题签到, B题是输出 (随机生成)满足条件的a序列的期望. 公式是$\\frac{(n!)^2}{n^n}$. 就是不知道double的精度能否满足要求. C题是类似石子合并的DP题. 但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$, 所以最后只能写一个假算法. 赛后问了SJ, 得知是四边形不等式决策单调性相关, 打扰了. 晚上的Atcoder只打了半小时. 11.6 周日 晴总结: 遗憾打铁仍是凌晨1点睡, 8:30起床, 10:30前进餐完毕, 睡了10来分钟. 11:30到院楼参加沈阳正式赛. 开题签到题, 统计字符串中T和D的个数, WA了一发.第二题找规律题, 姜哥首先发现r取越大越好, 但是只考虑a[i]作为左端点, 没加上右端点的情况, WA了一发 第三题构造题, 我首先用子矩阵数量公式判断出了无解情况. ZWL打表, 发现了长相特殊的合法情况, 所以尝试将二维压缩为一维. 问题转换成把一个数分解成若干个$\\frac{i \\times (i+1)}{2}$表示. 我提出从i从高到低贪心, 二分i的位置, 上机同时姜哥找反例. 姜哥发现没有反例并且提出可以线性, 但是我写到后面犯傻, 直接神志不清, 并不清楚线性的意思. 于是姜哥接过来完成算法. 第一发TLE, endl原因. 第二发WA, 爆long long. 最后过了 第四题大模拟暴搜, 题意没读懂, 其实就是炉石随从攻击的逻辑, 奈何没玩过. 调试1个半小时, 没能调对第二个样例. 以为是精度问题. 最后Rank290+无奈打铁.","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 275 A-F","slug":"题解 - AtCoder Beginner Contest 275 A-F","date":"2022-11-03T16:00:00.000Z","updated":"2023-01-14T04:54:00.853Z","comments":true,"path":"2022/11/04/题解 - AtCoder Beginner Contest 275 A-F/","link":"","permalink":"http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/","excerpt":"","text":"C题意一个$r \\times c (r, c\\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数. 如 123456789##.......##.......................#......#...........#......#.................... 具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子. 具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子. 因此, 答案是 2. 思路枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标. 向量[x, y]顺时针旋转90°: [y, -x] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rot(array&lt;int, 2&gt; &amp; v) &#123; auto [x, y] = v; v = &#123;y, -x&#125;;&#125;bool check(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= 9 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 9;&#125;void solve()&#123; for (int i = 1; i &lt;= 9; ++ i) for (int j = 1; j &lt;= 9; ++ j) cin &gt;&gt; g[i][j]; cerr &lt;&lt; g[5][5] &lt;&lt; endl; cerr &lt;&lt; g[5][7] &lt;&lt; endl; set&lt;set&lt;array&lt;int, 2&gt;&gt;&gt; S; for (int ci = 1; ci &lt;= 9; ++ ci) for (int cj = 1; cj &lt;= 9; ++ cj) &#123; for (int ni = 1; ni &lt;= 9; ++ ni) &#123; for (int nj = 1; nj &lt;= 9; ++ nj) if (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == &#x27;#&#x27; &amp;&amp; g[ni][nj] == &#x27;#&#x27;) &#123; array&lt;int, 2&gt; v = &#123;ni - ci, nj - cj&#125;; rot(v); int i3 = ni + v[0], j3 = nj + v[1]; rot(v); int i4 = i3 + v[0], j4 = j3 + v[1]; // if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7) cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl; if (check(i3, j3) &amp;&amp; check(i4, j4) &amp;&amp; g[i3][j3] == &#x27;#&#x27; &amp;&amp; g[i4][j4] == &#x27;#&#x27;) &#123; // cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl; set&lt;array&lt;int, 2&gt;&gt; s; s.insert(&#123;ci, cj&#125;); s.insert(&#123;ni, nj&#125;); s.insert(&#123;i3, j3&#125;); s.insert(&#123;i4, j4&#125;); S.insert(s); &#125; &#125; &#125; &#125; cerr &lt;&lt; S.size() &lt;&lt; endl; cout &lt;&lt; S.size() &lt;&lt; endl;&#125; D题意为非负整数 x 定义的函数 f(x) 满足以下条件： $f(0) = 1$ $f(k) = f(\\lfloor \\frac{k}{2}\\rfloor) + f(\\lfloor \\frac{k}{3}\\rfloor)$ 对于任何正整数 k 然后找到 $f(N), N\\in[0, 1^{18}]$. 分析最多需要$log_2n \\times log_3n$这么多个数的f值. 标准记搜 代码123456789101112131415int n;unordered_map&lt;int, int&gt; dp;int dfs(int u) &#123; if (dp.count(u)) return dp[u]; return dp[u] = dfs(u / 2) + dfs(u / 3);&#125;void solve()&#123; cin &gt;&gt; n; dp[0] = 1; cout &lt;&lt; dfs(n) &lt;&lt; endl; cerr &lt;&lt; dp.size() &lt;&lt; endl;&#125; E题意一个一维的棋盘上有 N + 1 个格子, 下标从 0 到 N , 玩家要从 0 这个点出发, 前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子, 每个骰面上都有不同的数字, 值域是 $[1, M]$ , 扔出每个面的概率都是 $\\frac{1}{M}$ . 玩家需要根据要出来的骰面前进, 如果预计前进之后走出了棋盘, 就需要退回多走出的步数, 如果在终点停了下来, 游戏就胜利了, 不能再扔骰子. 问 K 回合后, 玩家胜利的概率. 将结果对 998244353 取模. $0 \\le M \\le N \\le 1000, M \\in [1, 10], K \\in [1, 1000]$ . 分析令 dp[i][j] 为扔第 j 次骰子后, 玩家到达下标为 i 的格子的概率. 对于每一个 dp[i][j] $dp[next_i][j + 1] = dp[i][j] \\times \\frac{1}{M}$. 注意如果走出了棋盘, 要特殊讨论停下来的下标. 已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了 代码1234567891011121314151617181920212223242526272829303132333435363738394041const int N = 1000 + 10, mod = 998244353;int n, m, k;int dp[N][N]; // 到达第i格, 共走了j步的所有情况之和// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]int qmi(int a, int k)&#123; int res = 1 % mod; while (k) &#123; if (k &amp; 1) res = res * a % mod; a = a * a % mod; k &gt;&gt;= 1; &#125; return res;&#125;void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; dp[0][0] = 1; int m_1 = qmi(m , mod - 2); for (int j = 0; j &lt; k; ++ j) &#123; for (int i = 0; i &lt; n; ++ i) &#123; for (int len = 1; len &lt;= m; ++ len) &#123; int ni = i + len; if (ni &gt; n) &#123; ni = n - (ni - n); &#125; // if (next_i &lt;= i) &#123; // cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl; // &#125; dp[ni][j + 1] += (dp[i][j] * m_1) % mod; dp[ni][j + 1] %= mod; &#125; &#125; dp[n][j + 1] += dp[n][j]; dp[n][j + 1] %= mod; &#125; cerr &lt;&lt; dp[n][k] &lt;&lt; endl; cout &lt;&lt; dp[n][k] &lt;&lt; endl;&#125; F题意给定一个数组 A , 定义一次操作的内容是, 删除 A 中一段连续的序列. 问对于 1, 2, …, M 中的每个数 s , 分别至少要操作多少次, 才能使得 A 中剩下的数和为 s , 如果不可能就输出 -1 . $0 \\le N \\le M \\le 3000, 1 \\le a_i \\le 3000$ 思路数组分段式的DP, 用一个维度表示当前元素是否在分段中 dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中 如果a[i]不计入总和: dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); 如果a[i]计入总和: dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); 代码123456789101112131415161718192021222324252627282930const int N = 3e3 + 10;int n, m;int a[N];int dp[N][N][2]; // 前i个数, 构成总和为j, 且第i个数是否在总和中void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++ i) dp[i][0][0] = 1; dp[0][0][1] = 0; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= m; ++ j) &#123; dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); if (j - a[i] &gt;= 0) &#123; dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); &#125; &#125; &#125; // cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl; for (int j = 1; j &lt;= m; ++ j) &#123; int ans = min(&#123;dp[n][j][0], dp[n][j][1]&#125;); if (ans &gt; 0x3f3f3f3f3f3f3f3f / 2) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 评价这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的 C 模拟 + 向量旋转 D 记忆化搜索 E 概率DP F DP + 数组划分 / 选取子段","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_搜索","slug":"算法-搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"}]},{"title":"题解 - AtCoder Beginner Contest 192 D-F","slug":"题解 - AtCoder Beginner Contest 192 D-F","date":"2022-11-02T16:00:00.000Z","updated":"2023-01-14T04:53:36.470Z","comments":true,"path":"2022/11/03/题解 - AtCoder Beginner Contest 192 D-F/","link":"","permalink":"http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/","excerpt":"","text":"D题意给定整数 $X, X \\in [1, 10^{60}]$和 $M, M \\in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. 求对于所有的 $a&gt;d,a \\in \\mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\\le M$. 分析首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. 注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. 同时, long long 相乘可能会爆, 必须乘乘数base之前判断当前val &gt; target / base . 或者用 __int128AtCoder 支持 或龟速乘. 代码123456789101112131415161718192021222324252627282930313233343536string x;int m;void solve()&#123; cin &gt;&gt; x &gt;&gt; m; signed mx = 0; for (auto &amp;ch : x) mx = max(mx, ch - &#x27;0&#x27;); if (x.size() == 1) &#123; // 特判: 因为题目要求不同的数 if (mx &lt;= m) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; auto check = [&amp;](int base) -&gt; bool &#123; int val = 0; for (int i = 0; i &lt; x.size(); ++ i) &#123; if (val &gt; m / base) &#123; // 每次 + *base 之前 跟目标 /base 作比较 防止溢出 return false; &#125; int b = x[i] - &#x27;0&#x27;; val *= base; val += b; &#125; return (val &lt;= m); &#125;; int l = mx, r = 1e18 + 10; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; cerr &lt;&lt; l &lt;&lt; endl; cout &lt;&lt; l - mx &lt;&lt; endl;&#125; E题意$G(N, M), N, M \\leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\\in\\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \\in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 -1. 分析注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. 代码12345678910111213141516171819202122232425262728293031323334const int N = 1e5 + 10;int n, m, x, y;vector&lt;array&lt;int, 3&gt;&gt; G[N];int dist[N];void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= m; ++ i) &#123; int a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k; G[a].pb(&#123;b, t, k&#125;); G[b].pb(&#123;a, t, k&#125;); &#125; priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, greater&lt;array&lt;int, 2&gt;&gt;&gt; pq; memset(dist, 0x3f, sizeof dist); dist[x] = 0; pq.push(&#123;0, x&#125;); while (pq.size()) &#123; auto [cd, cv] = pq.top(); pq.pop(); if (cd &gt; dist[cv]) continue; // cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl; for (auto [nv, t, k] : G[cv]) &#123; int nd = (cd + k - 1) / k * k; nd = nd + t; // cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl; if (nd &lt; dist[nv]) &#123; dist[nv] = nd; pq.push(&#123;nd, nv&#125;); &#125; &#125; &#125; cerr &lt;&lt; dist[y] &lt;&lt; endl; if (dist[y] &gt;= 0x3f3f3f3f3f3f3f3f / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dist[y] &lt;&lt; endl;&#125; F题意给定数组a[N], $a[i] \\leq 1e7$和$X \\in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. 思路100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数 枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值 不拿第k个物品: dp[k][i][j] = dp[k - 1][i][j]; 拿第k个物品: dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); 总复杂度 $\\mathcal{O}(n^4)$. 代码12345678910111213141516171819202122232425262728293031323334353637383940const int N = 100 + 10;int n, x;int a[N], w[N];int dp[N][N][N]; void solve()&#123; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; int ans = 1e18; for (int choose = 1; choose &lt;= n; ++ choose) &#123; int m = x % choose; for (int i = 1; i &lt;= n; ++ i) w[i] = a[i] % choose; memset(dp, -1, sizeof dp); // dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值 dp[0][0][0] = 0; for (int k = 1; k &lt;= n; ++ k) &#123; for (int i = 1; i &lt;= min(k, choose); ++ i) &#123; for (int j = 0; j &lt; choose; ++ j) &#123; if (~dp[k - 1][i][j]) &#123; dp[k][i][j] = dp[k - 1][i][j]; &#125; if (~dp[k - 1][i - 1][(j - w[k] + choose) % choose]) &#123; dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); &#125; &#125; &#125; &#125; // 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose if (~dp[n][choose][m]) &#123; ans = min(ans, (x - dp[n][choose][m]) / choose); &#125; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; 评价D 考察乘法溢出, 各种边界讨论比较繁琐 E 最短路变形, 松弛边权做一下变化即可 F 背包+模数, 在外层套一层for模数choose, 状态表示加一个维度表示当前总和mod choose的值","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"题解 - 牛客小白月赛34 A-H","slug":"题解 - 牛客小白月赛34 A-H","date":"2022-10-31T16:00:00.000Z","updated":"2023-01-16T12:00:43.760Z","comments":true,"path":"2022/11/01/题解 - 牛客小白月赛34 A-H/","link":"","permalink":"http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/","excerpt":"","text":"这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题). A - dd爱科学1.0+2.0题意数组a[n](1≤n≤1000000, isupper(a[i]) == true). 求通过修改变成不下降序列的最小代价, 每次修改一个数x为y的代价为1(2.0版本为|x - y|). 1.0 ACEBF -&gt; ACEEF 代价 = 12.0 AEEBC -&gt; AEEEE 代价 = 偏移量总和为|B-E|+|C-E|=3+2=5 分析dp[i][j]表示改至第i位为止, 最后一位为j的最小代价(或者理解成最后一位&lt;=j也行) 12345for(int j = 1; j &lt;= 26; ++ j) &#123; // 当前字符为curr for(int k = 1; k &lt;= j; ++ k) &#123; // 从上一字符转移而来 f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j)); &#125;&#125; 注意到: min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了. 这样可以少O(26)的复杂度 123for(int j = 1; j &lt;= 26; ++ j) &#123; f[i][j] = min(f[i][j - 1], f[i - 1][j] + abs(curr - j));&#125; 代码123456789101112131415161718192021222324int main()&#123; ios::sync_with_stdio(false); cin.tie(0); memset(f, 0x3f, sizeof f); scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, &amp;str[1]); for(int i = 1; i &lt;= 26; ++ i) f[0][i] = 0; for(int i = 1; i &lt;= n; ++ i) &#123; int curr = str[i] - &#x27;A&#x27; + 1; //当前字符改成 for(int j = 1; j &lt;= 26; ++ j) &#123; //从上一字符转移而来 // for(int k = 1; k &lt;= j; ++ k) // f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j)); // min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了 f[i][j] = min(f[i][j - 1], f[i - 1][j] + abs(curr - j)); &#125; &#125; for(int i = 0; i &lt; 26; ++ i) ans = min(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B - dd爱探险题意有n(3≤n≤16)个空间站, 任意两个空间站间可以相互跳跃, 由空间站x跳跃到空间站y所需要的代价为P[x][y],注意不保证p[x][y]=p[y][x], dd可以任意选择出发的空间站, 并通过恰好n-1次跳跃把所有空间站跳完, 并且dd必须选择2次跳跃, 其中一次跳跃中进行重力加速, 另一次跳跃中进行反重力加速, 重力加速会导致当前跳跃代价变为0, 反重力加速会导致当前跳跃代价翻倍(乘2), 问跳完所有空间站所需要最小代价 分析状压DP. 经典TSP likedp[1 &lt;&lt; N][N][2][2]: 走过了i中为1的点,且当前最后到达j, g, rg是否用了重力 / 反重力 代码12345678910111213141516171819202122232425262728293031323334const int N = 16;int dp[1 &lt;&lt; N][N][2][2]; // 是否用了重力 / 反重力int n; int w[N][N];void solve() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = 0; j &lt; n; ++ j) &#123; cin &gt;&gt; w[i][j]; &#125; &#125; memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt; n; ++ i) &#123; dp[1 &lt;&lt; i][i][0][0] = 0; &#125; for (int val = 0; val &lt; (1 &lt;&lt; n); ++ val) &#123; // 1e5 for (int from = 0; from &lt; n; ++ from) &#123; // 10 for (int to = 0; to &lt; n; ++ to) &#123; // 10 if ((val &gt;&gt; to &amp; 1) &amp;&amp; (val &gt;&gt; from &amp; 1)) &#123; dp[val][to][0][0] = min(&#123;dp[val][to][0][0], dp[val ^ 1 &lt;&lt; to][from][0][0] + w[from][to]&#125;); dp[val][to][0][1] = min(&#123;dp[val][to][0][1], dp[val ^ 1 &lt;&lt; to][from][0][0] + 0, dp[val ^ 1 &lt;&lt; to][from][0][1] + w[from][to]&#125;); dp[val][to][1][0] = min(&#123;dp[val][to][1][0], dp[val ^ 1 &lt;&lt; to][from][0][0] + w[from][to] * 2, dp[val ^ 1 &lt;&lt; to][from][1][0] + w[from][to]&#125;); dp[val][to][1][1] = min(&#123;dp[val][to][1][1], dp[val ^ 1 &lt;&lt; to][from][1][0] + 0, dp[val ^ 1 &lt;&lt; to][from][0][1] + w[from][to] * 2, dp[val ^ 1 &lt;&lt; to][from][1][1] + w[from][to]&#125;); &#125; &#125; &#125; &#125; int ans = 0x3f3f3f3f3f3f3f3f; for (int i = 0; i &lt; n; ++ i) &#123; ans = min(ans, dp[(1 &lt;&lt; n) - 1][i][1][1]); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D - dd爱矩阵题意给一个n∗n的矩阵, 每行各选一个数字, 把选出来的n个数字相加, 一共有$n^{n}$ 种可行答案, 输出前n大 分析优先队列 + 动态前k大 + 数组合并 类似: P2085 最小函数值 先把问题简化一下, 如果两行, 每行 n个数, 怎么选把两行分别降序 sort, 令第一行为数组 a, 第二行为数组 b则可得到最大值为 a[0]+b[0], 并且得到 a[i]+b[j-1]&gt;a[i]+b[j]&gt;a[i]+b[j+1]所以可以把 a[0]+b[i]全部推入优先队列当中, 并且标记对应的 i,每次取出 top, 再把 a[0]+b[i+1]推入优先队列当中, n次操作即可得到前 n大复杂度 O(nlogn)回到这个题目, 由于是 n行, 可以每次处理两行, 并成一行新的, n-1次操作把 n行并成一行, 复杂度 O(n^2 logn) 代码1234567891011121314151617181920212223242526272829303132void merge()&#123; for(int i = 0; i &lt; n; ++ i) heap.push(&#123;a[0] + b[i], 0&#125;); for(int i = 0; i &lt; n; ++ i) &#123; auto top = heap.top(); heap.pop(); int sum = top.first, idx = top.second; heap.push(&#123;sum - a[idx] + a[idx + 1], idx + 1&#125;); t[i] = sum; &#125; for(int i = 0; i &lt; n; ++ i) a[i] = t[i];&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; ++ i) &#123; for(int j = 0; j &lt; n; ++ j) cin &gt;&gt; b[j]; merge(); &#125; for(int i = 0; i &lt; n; ++ i) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; return 0;&#125; E - dd爱旋转题意读入一个n∗n的矩阵, 对于一个矩阵有以下两种操作1:顺时针旋180° [1 2] =&gt; [4 3][3 4] [2 1] 2:关于行镜像 [1 2] =&gt; [3 4][3 4] [1 2] 给出q个操作, 输出操作完的矩阵 分析操作1: 相当于行镜像, 列镜像各做一次操作2: 相当于行镜像做一次 只用看操作1和操作2的奇偶性就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void op1()&#123; memset(vis, false, sizeof vis); for(int i = 1; i &lt;= n; ++ i) for(int j = 1; j &lt;= n; ++ j) if(!vis[i][j]) &#123; vis[i][j] = vis[n + 1 - i][n + 1 - j] = true; swap(m[i][j], m[n + 1 - i][n + 1 - j]); &#125;&#125;void op2()&#123; for(int i = 1; i &lt;= n / 2; ++ i) swap(m[i], m[n + 1 - i]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++ i) for(int j = 1; j &lt;= n; ++ j) cin &gt;&gt; m[i][j]; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; op; if(op == 1) ++ cnt1; else ++ cnt2; &#125; if(cnt1 % 2) op1(); if(cnt2 % 2) op2(); for(int i = 1; i &lt;= n; ++ i) &#123; for(int j = 1; j &lt;= n; ++ j) cout &lt;&lt; m[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; return 0;&#125; F - dd爱框框题意读入n(1≤n≤10000000),x(1≤x≤10000),给出n个数a[1],a[2],……,求最小的区间[l,r], 使a[l]+a[l+1]+……+a[r]≥x, 若存在相同长度区间, 输出l最小的那个 分析二分区间长度 + 前缀和check + 二分内更新答案OR 滑动窗口(不会) 代码1234567891011121314151617181920212223242526272829303132bool check(ll len)&#123; for(ll i = 1; i + len &lt;= n; ++ i) if(s[i + len] - s[i - 1] &gt;= x) &#123; lbound = i, rbound = i + len; return true; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; x; for(ll i = 1; i &lt;= n; ++ i) &#123; ll t; cin &gt;&gt; t; s[i] = s[i - 1] + t; &#125; int l = 1, r = n; while(l &lt; r) &#123; ll mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; lbound &lt;&lt; &quot; &quot; &lt;&lt; rbound &lt;&lt; endl; return 0;&#125; G - dd爱捣乱题意一个完美串(islower == true)应该满足该串中任意长度≥2≥2的子串都不是回文串, 把一个字符从xx变成yy的代价是min(|x-y|,26-|x-y|),(|x-y|为ascii码差值), 问把一个串变成完美串的最小代价 分析首先讨论完美串满足条件, 如果是奇串, 则每一位前后两位不同, 即 a[i-1]≠a[i+1]如果是偶串, 则相邻两位不同 a[i]≠a[i-1]综上, 只要任意连续三位都满足两两不同, 就是一个完美串那么一个很显然的想法, 枚举每一位的情况, 保证再枚举前两位情况, 保证不同的情况下更新答案复杂度 O(n×26^3), 显然不可接受所以进一步想, 每一位最多只会受前两位和后两位的影响, 所以最差情况下五个字母全部不同(abccd, 中间的c要+=2. 如果只有±1,0就不行了). 实际上相邻三个字符各自改变量最多只有五种情况: ±2,±1,0. )所以对于每一位只要枚举改变量就行了, dp[i][j][k]表示把第 i-1位的改变量是 j, 第 i位的改变量是 k的最小代价dp[i][j][k]←dp[i-1][l][j]最后枚举最后两位改变量 min(dp[n][i][j])就是答案复杂度 O(n×5^3) 代码123456789101112131415161718192021222324252627282930313233343536373839const int N = 1e2 + 10, offset = 2;int dp[N][6][6]; // 第i-1位的改变量为j, 第i位的改变量为kint a[N], n;void solve() &#123; cin &gt;&gt; n; string s; cin &gt;&gt; s; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++ i) a[i] = s[i - 1] - &#x27;a&#x27;; for (int j = -2; j &lt;= 2; ++ j) &#123; for (int k = -2; k &lt;= 2; ++ k) &#123; if ((a[1] + j + 26) % 26 != (a[2] + k + 26) % 26) &#123; dp[2][j + offset][k + offset] = min(dp[2][j + offset][k + offset], abs(j) + abs(k)); &#125; &#125; &#125; for (int i = 3; i &lt;= n; ++ i) &#123; for (int j = -2; j &lt;= 2; ++ j) &#123; // i-1 for (int k = -2; k &lt;= 2; ++ k) &#123; // i if ((a[i] + k + 26) % 26 != (a[i - 1] + j + 26) % 26) &#123; // dp[i][j][k] for (int l = -2; l &lt;= 2; ++ l) &#123; // i-2 if ( ((a[i - 1] + j + 26) % 26 != (a[i - 2] + l + 26) % 26) &amp;&amp; ((a[i] + k + 26) % 26 != (a[i - 2] + l + 26) % 26)) &#123; // dp[i - 1][l][j] dp[i][j + offset][k + offset] = min(dp[i][j + offset][k + offset], dp[i - 1][l + offset][j + offset] + abs(k)); &#125; &#125; &#125; &#125; &#125; &#125; int ans = 0x3f3f3f3f; for (int j = -2; j &lt;= 2; ++ j) &#123; for (int k = -2; k &lt;= 2; ++ k) &#123; ans = min(ans, dp[n][j + offset][k + offset]); &#125; &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; H - dd爱整齐题意当k=1时abababab, k=2时abbabbabb, k=3时abbbabbb这种类型的是优美序列, 现在给你一个数组a[n]和k((1≤k≤n≤1000000)), 每次你可以让数组中的数减1, 问你最少的操作次数使得n数组为k优美序列. 当然不一定就是abbabb, bbabba这个也是2的优美序列. 只要是优美序列的一段(子串)就行. 同时要保证a&gt;=b. 分析看到循环结构 / 循环节, 要往模数上想目标序列作为k优美序列的子串, 注意到当len(目标序列) &gt;= k时, 每k个数就会固定有一个a, k-1个b, 所以只需要确认a的位置就行. 把位置i对 k+1取余, 余数相等的位置的值必然相等. 因为给定了限制条件 a≥b, 所以通过简单贪心+前缀和计算把第i + Z*k位置上的数改变成a, 其他变成b的代价. 复杂度 O(n) 代码1234567891011121314151617181920212223const int inf = 1e18;void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; ++ k; vector&lt;int&gt; a(n), sum(k), cnt(k), mn(k, inf); int mna = 1e18, suma = 0; for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; mna = min(mna, a[i]); suma += a[i]; &#125; for (int i = 0; i &lt; n; ++ i) &#123; sum[i % k] += a[i]; cnt[i % k] ++; mn[i % k] = min(mn[i % k], a[i]); &#125; int ans = inf; for (int i = 0; i &lt; k; ++ i) &#123; // 把第i个数变成a, 其他的数变成b int val = sum[i] - cnt[i] * mn[i] + (suma - sum[i]) - (n - cnt[i]) * mna; ans = min(ans, val); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"}]},{"title":"题解 - 牛客小白月赛59 D-F","slug":"题解 - 牛客小白月赛59 D-F","date":"2022-10-31T16:00:00.000Z","updated":"2023-01-20T07:04:15.103Z","comments":true,"path":"2022/11/01/题解 - 牛客小白月赛59 D-F/","link":"","permalink":"http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/","excerpt":"","text":"D - 国际象棋题意n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋) 分析每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\\“四个方向上已经连了几个了. 注意不能分8个方向 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 1e3 + 10;int n, m, k, t;int h[N], g[N][N];int dx[] = &#123;1, -1, 1, -1, 0, 0, -1, 1&#125;, dy[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;;int solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t; memset(g, -1, sizeof g); for (int tt = 1; tt &lt;= t; ++ tt) &#123; int col, x = tt % 2; cin &gt;&gt; col; g[++ h[col]][col] = x; int cx = h[col], cy = col;// cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;// for (int i = n; i &gt;= 1; -- i) for (int j = 1; j &lt;= m; ++ j) cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \\n&quot;[j == m]; int cnt = 1; while (cx + 1 &lt;= n &amp;&amp; g[cx + 1][cy] == x) ++ cx, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy] == x) -- cx, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cy + 1 &lt;= m &amp;&amp; g[cx][cy + 1] == x) ++ cy, ++ cnt; cx = h[col], cy = col; while (cy - 1 &gt;= 1 &amp;&amp; g[cx][cy - 1] == x) -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy + 1 &lt;= m &amp;&amp; g[cx + 1][cy + 1] == x) ++ cx, ++ cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy - 1] == x) -- cx, -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx + 1][cy - 1] == x) ++ cx, -- cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy + 1 &gt;= 1 &amp;&amp; g[cx - 1][cy + 1] == x) -- cx, ++ cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; \\\\ &quot; &lt;&lt; cnt &lt;&lt; endl; &#125; return t;&#125; E - 弹珠碰撞题意长度为 n 的线段上, 有 m 颗弹珠在匀速以1单位/s 左右滚动. 弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. 两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动, 并交换两颗弹珠滚动的方向. 一颗弹珠可以反复发生碰撞, 如果在停滞中受到碰撞, 则停滞时间会累加. 如果一颗弹珠滚到了位置 0 或位置 n+1, 那么这颗弹珠就滚出了线段. 问最后一颗弹珠在什么时候滚出线段？ 分析a -&gt; &lt;- b 左右两个弹珠相撞后 &lt;-a b -&gt; &lt;-b a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的 算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行. ​ 代码123456789101112131415161718192021222324252627const int N = 1e6 + 10;int n, m;struct &#123; int d, p;&#125; ball[N];int pre1[N]; // -&gt;int suf0[N]; // &lt;-void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].d; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].p; sort(ball + 1, ball + 1 + m, [&amp;](auto &amp;a, auto &amp;b) &#123; return a.p &lt; b.p; &#125;); for (int i = 1; i &lt;= m; ++ i) pre1[i] = pre1[i - 1] + (ball[i].d == 1); for (int i = m; i &gt;= 1; -- i) suf0[i] = suf0[i + 1] + (ball[i].d == 0); int ans = 0; for (int i = 1; i &lt;= m; ++ i) &#123; auto [d, p] = ball[i]; int t = (d ? (n + 1 - p) + suf0[i] : p + pre1[i]); // cerr &lt;&lt; t &lt;&lt; endl; ans = max(t, ans); &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; F - 困难卷积题意给定整数序列 a[n], b[n], 求：$$\\sum_{i=1}^n\\sum_{j=1}^n\\Big\\lfloor\\sqrt{|a_i-b_j|}\\Big\\rfloor$$ 其中 $\\lfloor x\\rfloor$表示不超过 x 的最大整数, 例如 $\\lfloor 3.5\\rfloor=3,\\lfloor\\sqrt 2\\rfloor =1$. $1≤n≤10^6, 0\\leq a_i,b_i\\leq 3\\times 10^6, \\sum a_i,\\sum b_i\\leq 10^7$. 分析3e6 排除暴力. 注意到$\\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行 代码1234567891011121314151617const int N = 1e6 + 10;int a[N], b[N];int n;void solve()&#123; cin &gt;&gt; n; map&lt;int, int&gt; cnta, cntb; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i], cnta[a[i]] ++; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; b[i], cntb[b[i]] ++; int ans = 0; for (auto [va, ca] : cnta) for (auto [vb, cb] : cntb) &#123; ans += floor(sqrt(abs(va - vb))) * ca * cb; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-31T11:31:34.473Z","updated":"2022-10-31T11:29:53.845Z","comments":true,"path":"2022/10/31/hello-world/","link":"","permalink":"http://example.com/2022/10/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Linux - Ubuntu 下使用 Clash 代理","slug":"Linux - Ubuntu 下使用 Clash 代理","date":"2022-02-01T16:00:00.000Z","updated":"2023-02-14T14:00:11.516Z","comments":true,"path":"2022/02/02/Linux - Ubuntu 下使用 Clash 代理/","link":"","permalink":"http://example.com/2022/02/02/Linux%20-%20Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/","excerpt":"","text":"Ubuntu科学上网 在 https://github.com/Dreamacro/clash/releases 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash. 添加执行权限（sudo chmod + x clash），将 clash 放到 /usr/bin/ 目录下（sudo cp clash /usr/bin/）. 在终端中运行 clash，会在 ~/.config/clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件. 用商家提供的替换这两个文件，重新运行 clash. 设置系统代理： 用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响. 将clash进程加入开机自启动","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]}],"categories":[{"name":"记录","slug":"记录","permalink":"http://example.com/categories/%E8%AE%B0%E5%BD%95/"},{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Cheatsheet","slug":"Cheatsheet","permalink":"http://example.com/tags/Cheatsheet/"},{"name":"Spark","slug":"Spark","permalink":"http://example.com/tags/Spark/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"笔记_模板","slug":"笔记-模板","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"},{"name":"算法_数据结构","slug":"算法-数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法_字符串","slug":"算法-字符串","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"},{"name":"算法_概率期望","slug":"算法-概率期望","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_组合数学","slug":"算法-组合数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"算法_倍增","slug":"算法-倍增","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%80%8D%E5%A2%9E/"},{"name":"算法_哈希","slug":"算法-哈希","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"},{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_双指针","slug":"算法-双指针","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"},{"name":"算法_搜索","slug":"算法-搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"},{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"}]}