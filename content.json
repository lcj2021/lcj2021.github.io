{"meta":{"title":"Liucj's Harbour","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于博主","date":"2023-01-13T02:52:05.000Z","updated":"2023-01-13T02:52:09.962Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"刘城君，男，汉族，2001年5月出生，共青团员，湖南大学计算机科学与技术专业2019级学生。研究兴趣为图计算，图挖掘，图数据库优化。CP(Competitive Programming)爱好者。国内首例rCPD治愈患者 [^1]。 R-CPD 逆行性环咽肌功能障碍[^2]这是一种由于环咽肌功能失调，不能自下而上的通过食管入口把气体排出来的罕见疾病，主要临床表现为不能打嗝。 本人为国内首例rCPD治愈患者，希望能帮助到rCPD病友，可以查看本人求医治愈经历，联系本人微信13352891273 Awards Entry Time Organizer Bronze Award 47th ACM-ICPC Nanjing Dec,2022 ICPC Foundation Silver Award(Rank 12) CCSP[^3] Central China Oct,2021 China Computer Federation Third Prize of 湖南省大学生数学竞赛 Oct,2021 Third Prize of 全国大学生数学建模大赛湖南赛区 Sep,2021 University Merit Student of HNU December,2020 Hunan University Second Prize(Rank 44) of HNU Mathematic Competition May,2020 Hunan University First &amp; Second Prize Scholarships Hunan University For more infoMore info about me can be found in CV and CV-zh [^1]: 2021年4月30日中午1时，中山大学附属第三医院窦祖林教授 主刀[^2]: 首次被Robert Bastian定义于Inability to Belch and Associated Symptoms Due to Retrograde Cricopharyngeus Dysfunction: Diagnosis and Treatment[^3]: The CCF College Computer Systems &amp; Programming Contest"}],"posts":[{"title":"笔记 - CP模板","slug":"笔记 - CP模板","date":"2023-01-17T16:00:00.000Z","updated":"2023-01-20T02:58:29.940Z","comments":true,"path":"2023/01/18/笔记 - CP模板/","link":"","permalink":"http://example.com/2023/01/18/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"计数模板123456789101112131415161718192021222324252627282930313233343536373839template&lt;const int T&gt;struct ModInt &#123; const static int mod = T; int x; ModInt(int x = 0) : x(x % mod) &#123;&#125; int val() &#123; return x; &#125; ModInt operator + (const ModInt &amp;a) const &#123; int x0 = x + a.x; return ModInt(x0 &lt; mod ? x0 : x0 - mod); &#125; ModInt operator - (const ModInt &amp;a) const &#123; int x0 = x - a.x; return ModInt(x0 &lt; 0 ? x0 + mod : x0); &#125; ModInt operator * (const ModInt &amp;a) const &#123; return ModInt(1LL * x * a.x % mod); &#125; ModInt operator / (const ModInt &amp;a) const &#123; return *this * a.inv(); &#125; void operator += (const ModInt &amp;a) &#123; x += a.x; if (x &gt;= mod) x -= mod; &#125; void operator -= (const ModInt &amp;a) &#123; x -= a.x; if (x &lt; 0) x += mod; &#125; void operator *= (const ModInt &amp;a) &#123; x = 1LL * x * a.x % mod; &#125; void operator /= (const ModInt &amp;a) &#123; *this = *this / a; &#125; friend ostream &amp;operator &lt;&lt; (ostream &amp;os, const ModInt &amp;a) &#123; return os &lt;&lt; a.x;&#125; friend istream &amp;operator &gt;&gt; (istream &amp;os, const ModInt &amp;a) &#123; int v; os &gt;&gt; v; a = ModInt(v); return os;&#125; ModInt pow(int n) const &#123; ModInt res(1), mul(x); while(n) &#123; if (n &amp; 1) res *= mul; mul *= mul; n &gt;&gt;= 1; &#125; return res; &#125; ModInt inv() const &#123; int a = x, b = mod, u = 1, v = 0; while (b) &#123; int t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); &#125; if (u &lt; 0) u += mod; return u; &#125;&#125;;using mint = ModInt&lt;mod&gt;; 字符串(双)哈希123456789101112131415161718192021222324252627282930using hash_t = array&lt;int, 2&gt;;const int mod0 = 1e9 + 7, mod1 = 1e9 + 9;hash_t base = &#123;13331, 23333&#125;;hash_t pw[N];hash_t operator + (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] + b[0]) % mod0, (a[1] + b[1]) % mod1&#125;; return res;&#125;hash_t operator - (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] - b[0] + mod0) % mod0, (a[1] - b[1] + mod1) % mod1&#125;; return res;&#125;hash_t operator * (hash_t a, hash_t b) &#123; return &#123;a[0] * b[0] % mod0, a[1] * b[1] % mod1&#125;;&#125;pw[0] = &#123;1, 1&#125;;for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pw[i] = pw[i - 1] * base;&#125;for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pre[i] = pre[i - 1] * base + hash_t&#123;s[i], s[i]&#125;;&#125;for (int i = 2 * n; i &gt;= 1; -- i) &#123; suf[i] = suf[i + 1] * base + hash_t&#123;s[i], s[i]&#125;;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记_模板","slug":"笔记-模板","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"}]},{"title":"题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D","slug":"题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D","date":"2023-01-16T16:00:00.000Z","updated":"2023-01-20T07:04:50.353Z","comments":true,"path":"2023/01/17/题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D/","link":"","permalink":"http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/","excerpt":"","text":"比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大. 补题: D因式分解 + 枚举因子 + 压缩状态 A. Parallel Projection题意房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板） 分析分别计算俩点向四个方向的墙面相连的距离, 求最小值 代码123456789101112131415void solve() &#123; int w, d, h; cin &gt;&gt; w &gt;&gt; d &gt;&gt; h; int a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g; int dist1 = min(a, f); int dist2 = min(b, g); int dist3 = w - max(a, f); int dist4 = d - max(b, g); int ans1 = 2 * dist1 + abs(a - f) + abs(b - g) + h; int ans2 = 2 * dist2 + abs(a - f) + abs(b - g) + h; int ans3 = 2 * dist3 + abs(a - f) + abs(b - g) + h; int ans4 = 2 * dist4 + abs(a - f) + abs(b - g) + h; int ans = min(&#123;ans1, ans2, ans3, ans4&#125;); LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; B. Going to the Cinema题意有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一: 自己去,但除自己外去的人数 &lt; ai 自己不去,但除自己外去的人数&gt;= ai 问有多少种选择去的人的集合的方案,使得没有人伤心. 分析设去的人的集合A={p1,⋯,pa},不去的人的集合B={q1,⋯,qb},则A⋃B={1,⋯,n},a+b=n.​ 对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \\geq \\max_{1 \\leq i\\leq a} a_{p_i}$.​ 对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当$a &lt; \\min_{1\\leq j\\leq b} a_{q_j}$. 枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1] 代码1234567891011121314151617void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 2); for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; sort(a.begin() + 1, a.begin() + n + 1); a[n + 1] = inf; a[0] = -1; LOG(a) int ans = 0; for (int i = 0; i &lt;= n; ++ i) &#123; if (i &gt; a[i] &amp;&amp; i &lt; a[i + 1]) &#123; ++ ans; LOG(i, a[i], a[i + 1]) &#125; &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Equal Frequencies题意称一个字符串是好的,如果每种字符出现的次数都相等. n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t. 分析显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n / seg 首先将字母按照cnt[26] (字母出现频数) 降序排序, 要尽最大可能利用现有的多的字母 以下代码用来找到最小的代及cost其对应的ac 12345678910for (int d = 1; d &lt;= n; ++ d) if (n % d == 0) &#123; int now = 0, seg = n / d; if (seg &gt; 26) continue; for (int i = 0; i &lt; seg; ++ i) &#123; if (cnt[ord[i]] &lt; d) now += d - cnt[ord[i]]; &#125; if (now &lt; mn_cost) &#123; mn_cost = now; best_ac = d; &#125;&#125; 只需要统计cnt不足ac的部分就行了, 不足的部分肯定是需要其他redundant的来补充的. aim[26]表示t中每个字母的目标次数 123for (int i = 0; i &lt; best_seg; ++ i) &#123; aim[ord[i]] = best_ac;&#125; 接下来只需要看s[i]的cnt: cnt &gt; aim[s[i]], 在26个字母中找cnt还不足aim的进行替换 cnt &lt;= aim[s[i]], 跳过 代码12345678910111213141516171819202122232425262728293031323334353637383940414243void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector&lt;int&gt; cnt(26, 0); for (auto ch : s) cnt[ch - &#x27;a&#x27;] ++; vector&lt;int&gt; ord(26); iota(all(ord), 0); sort(all(ord), [&amp;](auto a, auto b) &#123; return cnt[a] &gt; cnt[b]; &#125;); // d: n的因子, 作为每个字母的出现次数 int mn_cost = n, best_ac = 1; for (int d = 1; d &lt;= n; ++ d) if (n % d == 0) &#123; int now = 0, seg = n / d; if (seg &gt; 26) continue; for (int i = 0; i &lt; seg; ++ i) &#123; if (cnt[ord[i]] &lt; d) now += d - cnt[ord[i]]; &#125; if (now &lt; mn_cost) &#123; mn_cost = now; best_ac = d; &#125; &#125; int best_seg = n / best_ac; LOG(mn_cost, best_ac, best_seg) vector&lt;int&gt; aim(26); for (int i = 0; i &lt; best_seg; ++ i) &#123; aim[ord[i]] = best_ac; &#125; LOG(aim) for (auto &amp;ch : s) &#123; if (aim[ch - &#x27;a&#x27;] &gt;= cnt[ch - &#x27;a&#x27;]) continue; for (int to = 0; to &lt; 26; ++ to) &#123; if (aim[to] &gt; cnt[to]) &#123; cnt[ch - &#x27;a&#x27;] --; ch = (char)to + &#x27;a&#x27;; cnt[ch - &#x27;a&#x27;] ++; break; &#125; &#125; &#125; LOG(s) cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;&#125; D. Many Perfect Squares题意非递减数组an. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数. 例如 11 6 13 22 90 选择 x = 3 14,9,16,25,93 4,9,16,25,93最多有4个完全平方数 分析题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x. 先sort(all(a)) 设有 $i &lt; j, a_i + x = va^2 ,a_j + x = vb^2$ 对完全平方数做差有$vb^2 - va^2 = (vb-va)(vb+va) = a_j + x - (a_i + x) = a_j - a_i$ 令 diff = aj - ai 则 (vb - va)(vb + va) = diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d = diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x = va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x. 用dp[x] |= 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意. 最后统计一下每个x的二进制1个数就行 代码12345678910111213141516171819202122232425262728293031void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; sort(all(a)); map&lt;int, int&gt; dp; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = i + 1; j &lt; n; ++ j) &#123; int diff = a[j] - a[i]; for (int div = 1; div * div &lt;= diff; ++ div) &#123; if (diff % div != 0) continue; int diva = div, divb = diff / div; if (diva % 2 != divb % 2) continue; // 12 = 2 * 6 va = 2, vb = 4 // x = va * va - a[i] int va = (divb - diva) / 2, vb = (diva + divb) / 2; int x = va * va - a[i]; if (x &lt; 0) continue; LOG(a[i], a[j], diff, va, vb) dp[x] |= (1ll &lt;&lt; i) | (1ll &lt;&lt; j); &#125; &#125; &#125; int ans = 1; // 只有1个数a, 肯定能找到x, 使得a+x是平方数 for (auto [x, val] : dp) &#123; ans = max(ans, (int)popcountll(val)); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"},{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"}]},{"title":"题解 - AtCoder Beginner Contest 134 F","slug":"题解 - AtCoder Beginner Contest 134 A-F","date":"2023-01-14T16:00:00.000Z","updated":"2023-01-20T07:04:41.616Z","comments":true,"path":"2023/01/15/题解 - AtCoder Beginner Contest 134 A-F/","link":"","permalink":"http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/","excerpt":"","text":"R2532橙题 F - Permutation Oddness题意设 P = (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;=50)的排列. 定义Oddness:= $\\sum |p_i - i|$. 求满足定义Oddness = k 的不同排列P的数量 思路此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解. 这里以官方题解为基础, 加以翻译并解释. 若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K dp[i][j][k][l]=表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. 因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j=k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. 状态转移方程写作：dp[i][j][k] = (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j] 当考虑第i个数与盒子的时候, 分5种情况: 数i和盒子i直接配对, 未配对的依然是j个 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j]; 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对 未配对的数-1, 盒子数-1, 所以未配对的-1个. 当前状态j, 所以上一状态j+1 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1); 数i和盒子i都不配对, 未配对的是j+1个 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j &gt;= 1) dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j]; 注意, 可能情况个数要从上一状态出发考虑 代码1234567891011121314151617181920212223242526272829303132mint dp[N][N][N * N]; // 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对// 且 当前的奇异值为k的方案数void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; dp[0][0][0] = 1; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 0; j &lt;= i; ++ j) &#123; for (int k = 2 * j; k &lt;= n * n; ++ k) &#123; // 数i和盒子i直接配对, 未配对的依然是j个 // 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j]; // 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个 // 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; // 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个 // 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j; // 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对 // 未配对的数-1, 盒子数-1, 所以未配对的-1个. // 当前状态j, 所以上一状态j+1 // 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1); // 数i和盒子i都不配对, 未配对的是j+1个 // 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了 if (j &gt;= 1) dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j]; &#125; &#125; &#125; cout &lt;&lt; dp[n][0][k] &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"}]},{"title":"题解 - Codeforces Round 797 (Div. 3) A-G","slug":"题解 - Codeforces Round 797 (Div. 3) A-G","date":"2023-01-13T16:00:00.000Z","updated":"2023-01-14T04:51:41.517Z","comments":true,"path":"2023/01/14/题解 - Codeforces Round 797 (Div. 3) A-G/","link":"","permalink":"http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/","excerpt":"","text":"昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. 补题: A. Print a Pedestal (Codeforces logo?)题意分析代码12345678910111213void solve() &#123; int n; cin &gt;&gt; n; int d = n / 3; if (n % 3 == 0) &#123; cout &lt;&lt; d &lt;&lt; &#x27; &#x27; &lt;&lt; d + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125; else if (n % 3 == 1) &#123; cout &lt;&lt; d + 0 &lt;&lt; &#x27; &#x27; &lt;&lt; d + 2 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; d + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; d + 2 &lt;&lt; &#x27; &#x27; &lt;&lt; d - 1 &lt;&lt; endl; &#125;&#125; B. Array Decrements)题意分析代码1234567891011121314151617181920212223242526272829303132void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n), b(n); for (auto &amp;x : a) cin &gt;&gt; x; for (auto &amp;x : b) cin &gt;&gt; x; set&lt;int&gt; d0, d; for (int i = 0; i &lt; n; ++ i) &#123; int cd = b[i] - a[i]; if (b[i] == 0) &#123; d0.insert(cd); &#125; else &#123; d.insert(cd); &#125; &#125; if (d.size() &gt; 1) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; &#125; if (d.size() == 0) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; // d.size == 1 if (*d0.begin() &lt; *d.begin()) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;&#125; C. Restoring the Duration of Tasks题意分析如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d = f - s否则当前任务到来时间s &lt; 上个任务完成时间 d = f - f[i - 1] 代码12345678910111213141516void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; s(n) ,f(n); for (auto &amp;x : s) cin &gt;&gt; x; for (auto &amp;x : f) cin &gt;&gt; x; vector&lt;int&gt; ans(1, f[0] - s[0]); for (int i = 1; i &lt; n; ++ i) &#123; if (s[i] &gt; f[i - 1]) ans.pb(f[i] - s[i]); else ans.pb(f[i] - f[i - 1]); &#125; LOG(ans) for (int i = 0; i &lt; n; ++ i) &#123; cout &lt;&lt; ans[i] &lt;&lt; &quot; \\n&quot;[i == n - 1]; &#125;&#125; D. Black and White Stripe题意分析代码1234567891011121314151617void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; s = &quot; &quot; + s; vector&lt;int&gt; pre(n + 1); for (int i = 1; i &lt;= n; ++ i) &#123; pre[i] = pre[i - 1] + (s[i] == &#x27;B&#x27;); &#125; int ans = n; for (int i = 1; i + k - 1 &lt;= n; ++ i) &#123; int l = i, r = l + k - 1; ans = min(ans, r - l + 1 - (pre[r] - pre[l - 1])); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; E. Price Maximization题意给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以的和k, 求和最大是多少 分析每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分. 把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;=k - x, 所以lower_bound一下k - x 也可以把a排序, 然后首尾双指针搞搞 代码12345678910111213141516171819202122232425void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); int ans = 0; multiset&lt;int&gt; S; for (auto &amp;x : a) &#123; cin &gt;&gt; x; ans += x / k; x %= k; if (x) S.insert(x); &#125; while (S.size() &gt;= 2) &#123; auto itx = S.begin(); // 先取值, 再删除? int x = *itx; S.erase(itx); auto ity = S.lower_bound(k - x); if (ity != S.end()) &#123; int y = *ity; ans ++; S.erase(ity); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; F. Shifting String题意给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态 分析首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \\sqrt{n})$ 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; vector&lt;int&gt; p(n); for (auto &amp;x : p) &#123; cin &gt;&gt; x; x --; &#125; vector&lt;int&gt; st(n, -1); vector&lt;int&gt; len; for (int i = 0; i &lt; n; ++ i) if (st[i] == -1) &#123; int now = i; vector&lt;int&gt; loop; for (; st[now] == -1; now = p[now]) &#123; loop.pb(now); st[now] = 1; &#125; LOG(loop) deque&lt;char&gt; dq0, dq; for (auto p : loop) dq0.pb(s[p]); dq.assign(all(dq0)); int cl = 0; for (;cl &lt; loop.size(); ++ cl) &#123; auto c = dq.back(); dq.pop_back(); dq.push_front(c); if (dq == dq0) &#123; break; &#125; &#125; len.pb(cl + 1); &#125; int ans = 1; for (auto x : len) &#123; ans = lcm(ans, x); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; G. Count the Trains题意每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少 例如[10, 13, 5, 2, 6] =&gt; [10, 10, 5, 2, 2] 一共有3种不同的数 分析维护每段火车的车头位置和整节车的速度. 在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车 如果速度x &gt;= 左边的火车段的速度, 就直接把it合并到左边(erase掉it) 如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)). insert和erase的次数不会超过O(n) 代码1234567891011121314151617181920212223242526272829303132void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; mp; auto add = [&amp;](int i, int x) &#123; mp[i] = x; auto it = mp.find(i); // 根据键key查找 // 9 | 5 ---&gt; 9 10 | 5 if (it != mp.begin() &amp;&amp; prev(it)-&gt;second &lt;= x) &#123; mp.erase(it); return; &#125; // 9 | 5 | 3 | 1 ---&gt; 9 | 2 5 3 | 1 while (next(it) != mp.end() &amp;&amp; next(it)-&gt;second &gt;= x) &#123; mp.erase(next(it)); &#125; &#125;; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; for (int i = 0; i &lt; n; ++ i) &#123; add(i, a[i]); &#125; for (int i = 0; i &lt; m; ++ i) &#123; int k, d; cin &gt;&gt; k &gt;&gt; d; k --; a[k] -= d; add(k, a[k]); cout &lt;&lt; mp.size() &lt;&lt; &quot; \\n&quot;[i == m - 1]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_双指针","slug":"算法-双指针","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"算法_组合数学","slug":"算法-组合数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"年记 - 2022","slug":"年记 - 2022","date":"2023-01-12T16:00:00.000Z","updated":"2023-01-13T08:13:08.235Z","comments":true,"path":"2023/01/13/年记 - 2022/","link":"","permalink":"http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/","excerpt":"","text":"2022 年终总结刘城君 5月开始图划分的任务: 基于标签传播思想, 优化目标主要是复制因子RF. 随机初始化种子节点的tag, 多轮多源BFS的方式进行tag, 选取邻居最多的tag进行标记. 1度点优化. 1度点对RF没有影响 tag合并(按照tag规模/tag结点重合度). 但由于块数与节点数的数量关系限制, 效果不佳. 每个一次assign多个tag(一次性覆盖) 由于传播方式存在问题, 因此负载均衡很差. 9月 - 11月期间阅读了HEP, NE等论文, 了解到Local search的策略, 以及分区boundary节点度数分布对RF的影响. 同时再次阅读了NE的源码. 为了优化负载均衡, 尝试在初始阶段就用BFS确定分区大致分布, 此阶段可以保障tag平衡. 第二阶段加入tag约束, 进行剩余节点的tag assignment. 效果较5月版本有明显进步, 数据集Lj上的表现(-p 8)为: RF=1.66-1.71 Balance = 1.05. 已经优于除NE外的其他算法. 但距离NE的1.33, 1.00仍有较大差距 12月分析RF和Tag的分区交界处节点的度数分布, 发现RF 2/3度点数量基本没有. 尝试将初始块变得更加紧密: 选k-core作为初始块. 效果一般 11月版本中第二阶段传播顺序诡异, 并且存在传播失败的可能. 尝试由当前的按照节点id顺序被动传播改成按照&lt;节点|tag|, 负载均衡, 节点度数&gt;的优先级进行BFS主动传播. 效果不如11月版本 1月 - 现在修改第一阶段BFS的策略, 加入启发式策略: 优先扩展与Core紧密的节点. 基于NE的代码进行实现, 并且尝试两种版本: 优先扩展与Core紧密的节点: RF: 1.7+, Balance: 1.00 优先扩展与Core+Boundary紧密的节点: 本质上就是NE, RF效果与NE十分接近 在修改NE代码过程中, 意识到初始分区只分配p-1块, 最后1块分配p, 从而取消第二阶段的传播. 效果可能会优于当前版本 展望idea储备不足: 阅读更多相关论文 争取在RF / 实际任务效果上取得进展","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - Codeforces Round 839 (Div. 3) A-G","slug":"题解 - Codeforces Round 839 (Div. 3) A-G","date":"2023-01-11T16:00:00.000Z","updated":"2023-01-14T11:50:06.534Z","comments":true,"path":"2023/01/12/题解 - Codeforces Round 839 (Div. 3) A-G/","link":"","permalink":"http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/","excerpt":"","text":"上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. 补题: D题要从题目限制的不等式去推出x的范围. F题发掘性质: 可染色的块一定是递减的. C. Different Differences题意分析代码1 D. Absolute Sorting题意a[n], 询问是否存在一个数x, a[i] &lt;- |a[i] - x|, 形成非单调递减序列, 如果不存在输出-1 分析假设找到了一个x满足题意. 那么就有|a[i] - x| &lt;= |a[i+1] - x|. 两边平方: $(a[i] - x)^2 \\leq (a[i+1] - x)^2$因式分解: $(a[i] - a[i+1])(a[i] + a[i+1] - 2x) \\leq 0$ 接下来逐个判断a[i] - a[i+1], 分类讨论: a[i] - a[i+1] &gt; 0: a[i] + a[i+1] - 2x &lt;= 0a[i] - a[i+1] &lt; 0: a[i] + a[i+1] - 2x &gt;= 0 即可得到x的范围 代码12345678910111213141516171819202122232425void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int mx = (int)2e9, mn = 0; // (x - y)(x + y - 2x) &lt;= 0 for (int i = 0; i + 1 &lt; n; ++ i) &#123; int x = a[i], y = a[i + 1]; if (x &gt; y) &#123; // (x + y - 2x) &lt; 0 mn = max(mn, x + y + 1 &gt;&gt; 1); &#125; else if (x &lt; y) &#123; // (x + y - 2x) &gt; 0 mx = min(mx, x + y &gt;&gt; 1); &#125; else &#123; // x没有要求 ; &#125; &#125; if (mn &lt;= mx) &#123; cout &lt;&lt; mn &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125;&#125; E. Permutation Game题意题意, 在一个序列p中, AB两人轮流操作, 每次的操作选择 将p中的某个数变为可调换位置的(涂色) 重新排列, 但只能调动可变换位置的 跳过回合 如果最后形成上升序列甲赢, 递减序列乙赢, 否则平局 分析1241 2 4 3 A要涂色的: p[3], p[4]B要涂色的: p[3], p[4], p[1], p[2] AB俩人都要涂色的: p[3], p[4]只属于A自己要涂色的: 没有只属于B自己要涂色的: p[1], p[2] 如果A把只有自己要涂色的(a)+公共涂色的都涂完了(c), B还剩下没涂, A就赢了如果B把只有自己要涂色的(b)+公共涂色的都涂完了(c), A还剩下没涂, B就赢了 但是要注意A是先手, 所以就算AB同时涂完(b+c==a), 也算A赢. 其他都是平局, 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. 代码12345678910111213141516171819202122232425262728293031void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; p(n); for (auto &amp;x : p) &#123; cin &gt;&gt; x; x --; &#125; int a = 0, b = 0, c = 0; for (int i = 0; i &lt; n; ++ i) &#123; if (p[i] == i) &#123; ++ b; &#125; else if (p[i] == n - i - 1) &#123; ++ a; &#125; else &#123; ++ c; &#125; &#125; LOG(a, b, c) if (a &gt; b + c) &#123; // b先翻完. 如果相等的话, 后手染色完, 下一轮到先手, 先手就直接排序了 cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl; &#125; else if (b &gt;= a + c) &#123; // a先翻完, 由于a先手, 同时ab翻完也不行 cout &lt;&lt; &quot;First&quot; &lt;&lt; endl; &#125; else &#123; // 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. cout &lt;&lt; &quot;Tie&quot; &lt;&lt; endl; &#125;&#125; F. Copy of a Copy of a Copy题意有一个n行m列的01矩阵 (3≤n,m≤30). 其中0表示白色, 1表示黑色. 每次你可以选择以下操作的中的一个: 选择一个不是边界的点 (i,j)(i≠1,i≠n,j≠1,j≠m), 并且他的上下左右的4个点, 其颜色都与之相反, 则把这个点变成相反的颜色. 创建一个当前矩阵的拷贝. 执行了 k(k≤100)次拷贝操作. 现在给出制作的所有 k 个拷贝. 此外, 还有初始的矩阵. 然而, 所有k+1个矩阵的顺序被打乱了. 因为找出初始版本, 并且输出经过了哪些操作. 分析一旦对某个单元格涂色, 就再也不能重新涂色了. 这是因为不能对它的邻居也重新涂色, 因为它们中的每一个都有至少一个相同颜色的邻居——这个单元格本身 这给了我们副本的顺序. 只需按照当前可以进行的重新涂色操作数量的降序对它们进行排序即可. 如果数字相同, 则副本必须相等, 因此它们的顺序无关紧要. 排序后, 考虑一对相邻图片的所有不同单元格. 不可能有两个不同的单元格彼此相邻. 因此, 任何操作都不能干扰另一个操作. 所以制作副本的时候, 随便顺序操作就行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void solve() &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; ++ k; vector&lt;vector&lt;vector&lt;char&gt;&gt;&gt; a(k + 1, vector&lt;vector&lt;char&gt;&gt;(n, vector&lt;char&gt;(m))); for (int id = 1; id &lt;= k; ++ id) &#123; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = 0; j &lt; m; ++ j) &#123; cin &gt;&gt; a[id][i][j]; &#125; &#125; &#125; vector&lt;array&lt;int, 2&gt;&gt; cnt(k + 1); vector&lt;int&gt; dx&#123;-1, 0, 1, 0&#125;, dy&#123;0, 1, 0, -1&#125;; for (int id = 1; id &lt;= k; ++ id) &#123; cnt[id][1] = id; for (int i = 1; i &lt; n - 1; ++ i) &#123; for (int j = 1; j &lt; m - 1; ++ j) &#123; int diff = 0; auto cc = a[id][i][j]; for (int dir = 0; dir &lt; 4; ++ dir) &#123; auto nc = a[id][i + dx[dir]][j + dy[dir]]; diff += (cc != nc); &#125; cnt[id][0] += (diff == 4); &#125; &#125; &#125; // LOG(cnt) sort(begin(cnt) + 1, end(cnt), greater&lt;array&lt;int, 2&gt;&gt;()); vector&lt;array&lt;int, 2&gt;&gt; ans; for (int i = 2; i &lt;= k; ++ i) &#123; auto g0 = a[cnt[i - 1][1]], g1 = a[cnt[i][1]]; for (int j = 0; j &lt; n; ++ j) &#123; for (int l = 0; l &lt; m; ++ l) &#123; if (g0[j][l] != g1[j][l]) &#123; ans.pb(&#123;j, l&#125;); &#125; &#125; &#125; ans.pb(&#123;-1, cnt[i][1]&#125;); &#125; cout &lt;&lt; cnt[1][1] &lt;&lt; endl; cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto [x, y] : ans) &#123; if (x == -1) &#123; cout &lt;&lt; 2 &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 1 &lt;&lt; &#x27; &#x27; &lt;&lt; x + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; y + 1 &lt;&lt; endl; &#125; &#125;&#125; G. Gaining Rating题意你在一个网站上下棋 , 初始你的等级为$x(x \\le 10^{12})$ , 你想要升级到 y$(x &lt; y \\le 10^{12})$你有$n(n \\le 2 * 10^5)$个对手, 第i个队友的等级为 a[i]$(a[i] \\le 10^{12})$ . 你需要与这些对手对战, 如果你的等级大于等于对手的等级, 你将获胜, 并且等级加1. 否则等级减1. 注意, 对手的等级不会发生变化. 为了防止你一直打最低等级的对手的, 网站有一个规定. 如果你要与对手 i 对战, 则应该没有其他对手 j, 使得你与 i 的比赛次数多于与 j 的比赛次数. 问你需要打多少局, 才能升到等级y, 如果不能输出-1. 分析要想rating++, 肯定是先跟a[i]小于自己x的人先打, rating打上去了, 再找之前打不过的复仇, 从他们身上赚rating. 所以要先按照a升序排序. 先判断最开始一轮, rating能不能有所长进, 如果不能, 那就不行 算完第一轮的长进change之后, 开始逐个找之前打不过的人a[i]. 自己需要加win_t轮change, 最后第win_t + 1轮到达a[i]面前时, 我已经有了x + win_t * change + i的rating. 即$x + win_t * change + i \\geq a[i]$. 取个ceil就可以算出复仇a[i]的轮数了 但是有可能在打败a[i]之前, 就已经达到了y的目标, 所以要算出suc_t = ceil(y - x - i, change). 如果win_t &gt;= suc_t, 就要进入最后一轮, 直到x&gt;=y. 直到最后全部a都能击败后, 直接随便挑对手就行了. 即ans += y - x(当前的rating) 注意上述的x, change和ans都是会实时更新的 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; vector&lt;int&gt; a(n), b(n); // b: 是否可以击败i for (auto &amp;x : a) cin &gt;&gt; x; sort(all(a)); int change = 0, ans = 0; for (int i = 0; i &lt; n; ++ i) &#123; if (x &gt;= a[i]) ++ x, ++ change, ++ ans, b[i] = 1; else -- x, -- change, ++ ans, b[i] = -1; if (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl; return;&#125; &#125; if (change &lt;= 0) &#123;cout &lt;&lt; -1 &lt;&lt; endl; return;&#125; auto ceil = [&amp;](int a, int b) -&gt; int &#123; if (a &lt; 0) return 0; return (a + b - 1) / b; &#125;; for (int i = 0; i &lt; n; ++ i) if (b[i] == -1) &#123; // x + win_t * change + i &gt;= a[i] // (a[i] - x - i) / change &lt;= win_t int win_t = ceil(a[i] - x - i, change); // x + suc_t * change + i &gt;= y // (y - x - i) / change &lt;= suc_t int suc_t = ceil(y - x - i, change); if (win_t &gt;= suc_t) &#123; ans += suc_t * n; x += suc_t * change; for (int j = 0; j &lt; n; ++ j) &#123; if (x &gt;= a[j]) ++ x, ++ ans; else -- x, ++ ans; if (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl; return;&#125; &#125; &#125; ans += win_t * n; x += win_t * change; b[i] = 1; change += 2; &#125; LOG(ans) cout &lt;&lt; ans + y - x &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"题解 - Codeforces Round 685 (Div. 2) A-E","slug":"题解 - Codeforces Round 685 (Div. 2) A-E","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-14T04:52:30.069Z","comments":true,"path":"2023/01/11/题解 - Codeforces Round 685 (Div. 2) A-E/","link":"","permalink":"http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/","excerpt":"","text":"做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了 C. String Equality题意给两个字符串a和b, 问a能不能通过无限次操作到b. 第一种操作, 相邻交换字符: 第二种操作, 选取区间长度为k的子串,而且子串中的字母都 &lt;’z’, 每一个字母都加一（比如S0=’a’ 操作后,S0=’b’) 分析代码1 D. Circle Game题意给一个d和R,A和B轮流操作, 从(0,0)开始移动, 可以选择 x+=d 或者 y+=d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候, 那个人就输了 分析代码1 E. Bitwise Queries (Hard Version)题意有一个长度为 n 的数组(n 是 2 的幂) , 有 3 种操作, AND OR XOR, 可以获得数组两个元素的 AND OR XOR 值, 仅限 n+1 次操作求原数组 分析首先考虑以 $a_1$ 为基准求出 $a_1 \\oplus a_k$, 这样只要求出 $a_1$ 就可以求出整个数组, 这一步需要 $n-1$ 次操作. 因为只有 $n$ 个元素, 元素的范围是 $[0,n-1]$, 所以可以进行分类讨论： 1.所有元素并不是互不相同. 也就是说有重复的元素, 这样只要找到相同的元素, 对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值）, 又因为知道了所有元素和 $a_1$ 的 XOR, 所以可以直接算出整个数组. 考虑如何找到相同的元素, 可以开个桶记录每个元素出现的次数. 取最大的出现次数（这种情况下至少两次）, 然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素, 任意取两个询问 AND 就可以了. 不过这里有个要注意的, 如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素, 取 $1$ 询问即可. 2.所有元素互不相同. 也就是是 $[0,n-1]$ 的全排列. 考虑 XOR 的性质, 相同就是 $0$, 也就是说可以选择 $1$ 这个数, 只有最后一位是 $1$, 其他都是 $0$, 也就是说如果 $a_1\\oplus a_k=1$, $a_1$ 和 $a_k$ 只有最后一位不一样, 可以通过 AND 操作求出前 $\\log n-1$ 位. 同理如果 $a_1\\oplus a_k=\\frac n2$, $a_1$ 和 $a_k$ 只有第一位不一样, 可以通过 AND 操作求出后 $\\log n-1$ 位. 把两个结果组合一下（直接或起来）就可以得到 $a_1$. 其实不一定要选择 $1$ 和 $\\frac n2$, 只要保证这两个数二进制下每位都至少有个数是 $0$ 就行. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int AND(int x, int y) &#123; cout &lt;&lt; &quot;AND &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; int res; cin &gt;&gt; res; return res;&#125;int XOR(int x, int y) &#123; cout &lt;&lt; &quot;XOR &quot; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; int res; cin &gt;&gt; res; return res;&#125;void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; xr(n + 1); vector&lt;int&gt; cnt(n + 1, 0); cnt[0] ++; for (int i = 2; i &lt;= n; ++ i) &#123; xr[i] = XOR(1, i); cnt[xr[i]] ++; &#125; int a1, mx_show_xr = max_element(all(cnt)) - cnt.begin(); // mx_show_xr: 出现最多的xr值 if (cnt[mx_show_xr] &gt; 1) &#123; // n个数中有重复的 vector&lt;int&gt; dulplicate_pos; for (int i = 2; i &lt;= n; ++ i) &#123; // if (cnt[xr[i]] == cnt[mx_show_xr]) &#123; // X!!! cnt一致的xr值可能有多个!!! if (xr[i] == mx_show_xr) &#123; dulplicate_pos.pb(i); &#125; &#125; LOG(dulplicate_pos) // assert(dulplicate_pos.size() &gt; 1); int a_dulplicate; if (dulplicate_pos.size() == 1) &#123; a_dulplicate = AND(1, dulplicate_pos.back()); &#125; else &#123; a_dulplicate = AND(dulplicate_pos.front(), dulplicate_pos.back()); &#125; a1 = a_dulplicate ^ mx_show_xr; cout &lt;&lt; &quot;! &quot; &lt;&lt; a1 &lt;&lt; &#x27; &#x27;; for (int i = 2; i &lt;= n; ++ i) &#123; cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; &#x27; &#x27;; &#125; &#125; // 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次 else &#123; // n个数无重复, 就是[0, n-1]的全排列 int px = find(all(xr), 1) - xr.begin(); // a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同 int py = find(all(xr), n / 2) - xr.begin(); a1 = AND(1, px) | AND(1, py); cout &lt;&lt; &quot;! &quot; &lt;&lt; a1 &lt;&lt; &#x27; &#x27;; for (int i = 2; i &lt;= n; ++ i) &#123; cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; &#x27; &#x27;; &#125; &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"题解 - Codeforces Round #843 (Div. 2) A-E","slug":"题解 - Codeforces Round 843 (Div. 2) A-E","date":"2023-01-10T16:00:00.000Z","updated":"2023-01-14T11:50:21.412Z","comments":true,"path":"2023/01/11/题解 - Codeforces Round 843 (Div. 2) A-E/","link":"","permalink":"http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/","excerpt":"","text":"次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了. 补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题 A. Gardener and the Capybaras题意将仅包含a和b的字符串s分成三部分s=s1+s2+s3, 使得s2是这三个部分的一个最值（最大值或最小值, 按字典序比较） 分析s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;=s3 s2为min: 直接拿一个a就行 代码123456789101112131415161718void solve() &#123; string s; cin &gt;&gt; s; int n = s.size(); for (int i = 1; i &lt; n - 1; ++ i) &#123; if (s[i] == &#x27;a&#x27;) &#123; cout &lt;&lt; s.substr(0, i) &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27;a&#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; s.substr(i + 1) &lt;&lt; endl; return; &#125; &#125; // aaaabaaab for (int i = 1; i &lt; n - 1; ++ i) &#123; if (s[i] == &#x27;b&#x27;) &#123; cout &lt;&lt; s.substr(0, i) &lt;&lt; &#x27; &#x27; &lt;&lt; s.substr(i, n - i - 1) &lt;&lt; &#x27; &#x27; &lt;&lt; s.back() &lt;&lt; endl; return; &#125; &#125;&#125; B. Gardener and the Array题意记 f(a) 是 a 数组中, 所有数的按位或. 现有 n 个数 c1,c2…cn组成的数组, 询问是否有两个不同的子数组 a 和 b , 使得 f(a)=f(b)数据保证所有数的二进制中 1 的数量之和不超过$10^5$ 分析如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci) = f(cj | ck). 如下样例: 123443 1 2 42 2 34 3 4 所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1 代码12345678910111213141516171819202122232425262728void solve() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; c(n); // vector&lt;int&gt; cnt(200000 + 10, 0); map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; ++ i) &#123; int k; cin &gt;&gt; k; for (int j = 0; j &lt; k; ++ j) &#123; int x; cin &gt;&gt; x; c[i].pb(x); cnt[x] ++; &#125; // sort(all(c[i])); &#125; for (int i = 0; i &lt; n; ++ i) &#123; auto &amp;v = c[i]; bool suc = true; for (auto x : v) &#123; suc &amp;= (cnt[x] &gt; 1); &#125; if (suc) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;&#125; C. Interesting Sequence题意对于n, 求最小的m, 使得 n&amp;(n+1)&amp;…&amp;m = x 分析获取x的二进制长度: floor(log2(x)) + 1 每一二进制位上, 只可能从无0变成有0所以x只可能是n的二进制子集某一二进制位经历从1变成0, 全部低位肯定全部经历过全0所以: x只能保留n高位1的子集他的高一位也要经历翻转所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行 n: 0000110111100000101 101101011001110100111011001000000000000000000x: 0000110111100000101 000000000000000000000000000000000000000000000ans: -1 (公共前缀最后一位是1) n: 000011011110000010 1101101011001110100111011001000000000000000000x: 000011011110000010 1000000000000000000000000000000000000000000000ans: 000011011110000011 n: 000011011110000010 1101101011001110100111011001000000000000000000x: 000011011110000010 1000010000000000000000000000000000000000000000ans: -1 (mask &amp; x != x) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void solve() &#123; int n, x; cin &gt;&gt; n &gt;&gt; x; if (x &gt; n) &#123; // &amp; 只会变小 cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; if (x == n) &#123; cout &lt;&lt; n &lt;&lt; endl; return; &#125; if (x == 0) &#123; int bit = floor(log2(n)) + 1; cout &lt;&lt; (1ll &lt;&lt; bit) &lt;&lt; endl; return; &#125; int mask = 0, last = 0; int b = 62; for (; b &gt;= 0; -- b) &#123; if ((x &gt;&gt; b &amp; 1) == (n &gt;&gt; b &amp; 1)) &#123; mask |= (int)(x &gt;&gt; b &amp; 1) &lt;&lt; b; last = (x &gt;&gt; b &amp; 1); &#125; else if ((n &gt;&gt; b &amp; 1) == 0 &amp;&amp; (x &gt;&gt; b &amp; 1) == 1) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; else &#123; break; &#125; &#125; if (last == 1 || (mask &amp; x) != x) &#123; // 1011 -&gt; 1010 cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; // 最后1个1的位置 b += 1; mask |= 1ll &lt;&lt; (b); cout &lt;&lt; mask &lt;&lt; endl;&#125; 附上对拍数据 1234567891011mt19937 mrand(random_device&#123;&#125;()); int rnd(int x) &#123;return mrand() % x + 1; &#125; // [1, x]void solve() &#123; int n = 10000; cout &lt;&lt; n &lt;&lt; endl; vector pw&#123;0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;; for (int i = 1; i &lt;= n; ++ i) &#123; int a = rnd(1000), b = pw[rnd(pw.size()) - 1] + pw[rnd(pw.size()) - 1]; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; endl; &#125;&#125; D. Friendly Spiders题意现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边. 请找到 s 和 t 的最短路径. $1\\le n, a_i\\le 3\\times 10^5$ 分析边权01 -&gt; 01bfs 建图问题: 每一次遇到一个数时, 即使它只有一条边, 我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图 图的边数很多, 没有办法快速求解 从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n 最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \\sqrt{n})$. bfs复杂度$O(n + n \\sqrt{n})$ 坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int inf = 0x3f3f3f3f3f3f3f3f;void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); vector&lt;vector&lt;int&gt;&gt; v2id(300000 + 10); int idx = 0; for (auto &amp;x : a) &#123; cin &gt;&gt; x; v2id[x].pb(++ idx); &#125; int s, t; cin &gt;&gt; s &gt;&gt; t; vector&lt;vector&lt;array&lt;int, 2&gt;&gt;&gt; g(600000 + 10); vector&lt;bool&gt; is_p(300000 + 10, true); for (int i = 2; i &lt;= 300000; ++ i) &#123; // if (st[i]) continue; if (!is_p[i]) continue; // 2, 4, 6, 8, 10...之间连边 打电话式建图n^2 // 交换机式建图 for (int j = i; j &lt;= 300000; j += i) &#123; if (j != i) is_p[j] = false; if (v2id[j].size()) &#123; for (auto uid : v2id[j]) &#123; g[uid].pb(&#123;i + 300000, 0&#125;); g[i + 300000].pb(&#123;uid, 1&#125;); &#125; &#125; &#125; &#125; deque&lt;array&lt;int, 2&gt;&gt; dq; vector&lt;int&gt; dist(600000 + 10, inf); vector&lt;int&gt; pre(600000 + 10, -1); dist[s] = 0; dq.pb(&#123;0, s&#125;); while (dq.size()) &#123; auto [cd, cv] = dq.front(); dq.pop_front(); if (cd &gt; dist[cv]) continue; if (cv == t) break; for (auto [nv, w] : g[cv]) &#123; LOG(cv, nv, w) if (dist[nv] &gt; dist[cv] + w) &#123; dist[nv] = dist[cv] + w; pre[nv] = cv; if (w == 1) &#123; dq.pb(&#123;dist[nv], nv&#125;); &#125; else &#123; dq.push_front(&#123;dist[nv], nv&#125;); &#125; &#125; &#125; &#125; LOG(dist[t]) if (dist[t] &gt; inf / 2) &#123; cout &lt;&lt; -1 &lt;&lt; endl;; return; &#125; int now = t; vector&lt;int&gt; path; while (now != -1) &#123; if (now &lt;= 300000) &#123; path.pb(now); &#125; now = pre[now]; &#125; reverse(all(path)); LOG(path) cout &lt;&lt; path.size() &lt;&lt; endl; for (auto u : path) cout &lt;&lt; u &lt;&lt; &#x27; &#x27;;&#125; E. The Human Equation题意给一个序列a[n] (n&lt;=2e5), 要通过下面的两种操作, 最终全部变成0, 最少需要操作几次 操作1: 选a的一个子序列, 然后子序列奇数位+1, 偶数位-1操作2: 选a的一个子序列, 然后子序列奇数位-1, 偶数位+1 如[1,4,2,8,5,7,3,6,9] -&gt; [4,2,5,6]用操作1-&gt; [1,5,1,8,6,7,3,5,9] 分析pre[n]: a[n]的前缀和数组 a[i] + 1, a[j] - 1 相当于pre[i ~ j - 1] + 1a[3] + 1, a[4] - 1 相当于pre[3] + 1a[3] + 1, a[5] - 1 相当于pre[3 ~ 4] + 1 最终状态: pre全部为0 所以一次操作, 可以把pre上任何位置上的数+1 / -1 只需要记录前缀和中的mn和mx, 答案分类讨论下就行 代码1234567891011121314151617void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int cs = 0, mx = -2e9, mn = 2e9, ans = 0; for (int i = 0; i &lt; n; ++ i) &#123; cs += a[i]; mx = max(mx, cs); mn = min(mn, cs); &#125; if (mx &lt; 0) ans = abs(mn); else if (mn &gt; 0) ans = abs(mx); else ans = mx - mn; LOG(ans, mn, mx) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"题解 - 牛客小白月赛65 A-F","slug":"题解 - 牛客小白月赛65 A-F","date":"2023-01-08T16:00:00.000Z","updated":"2023-01-14T11:49:48.027Z","comments":true,"path":"2023/01/09/题解 - 牛客小白月赛65 A-F/","link":"","permalink":"http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/","excerpt":"","text":"B - 牛牛写情书题意 + 分析判断模式串T是否是给定串S的子串.瞎写双指针 XKMP / 双哈希 V5e3: 直接substr暴力$n^2$ 代码12345678910111213141516171819void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; string os, k; cin &gt;&gt; os &gt;&gt; k; string s; for (int i = 0; i &lt; n; ++ i) &#123; if (islower(os[i])) &#123; s.pb(os[i]); &#125; &#125; LOG(s) n = s.size(); for (int i = 0; i + m - 1 &lt; n; ++ i) &#123; if (s.substr(i, m) == k) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;&#125; C - 牛牛排队伍题意有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面. 老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c =&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？ 一共会有 k 次操作, 每次会执行下面的一种： 把 x 叫走 求排在 x 前面的是谁 分析pre, nxt模拟双向链表 代码1234567891011121314151617181920212223242526void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; pre(n + 1, 0); vector&lt;int&gt; nxt(n + 1, 0); for (int i = 1; i &lt;= n; ++ i) &#123; if (i &gt; 1) &#123; pre[i] = i - 1; &#125; if (i &lt; n) &#123; nxt[i] = i + 1; &#125; &#125; while (k --) &#123; int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) &#123; int a = pre[x], b = nxt[x]; pre[x] = nxt[x] = 0; nxt[a] = b; pre[b] = a; &#125; else &#123; cout &lt;&lt; pre[x] &lt;&lt; endl; &#125; &#125;&#125; D - 牛牛取石子题意两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取： 第一堆取 1 个, 第二堆取 2 个第一堆取 2 个, 第二堆取 1 个 谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？ 分析1e18: 打表找规律 模仿是博弈里面的一个重要的策略, 主要思想:断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法 a, b两堆石子, 必败态是: min(a, b) % 3 == 0. 因为后手总是可以控制min(a, b)在一轮下来-3B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:A: 5 4B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输原因在于: 若min(a, b) % 3 != 0 A总是可以把min(a, b) % 3 == 0的局面给B 代码123456789const int C = 15;vector&lt;vector&lt;int&gt;&gt; awin(C + 1, vector&lt;int&gt;(C + 1, 0));awin[1][2] = awin[2][1] = 1;for (int i = 0; i &lt;= C; ++ i) &#123; for (int j = 0; j &lt;= C; ++ j) &#123; if (i &gt;= 1 &amp;&amp; j &gt;= 2) awin[i][j] |= !awin[i - 1][j - 2]; if (i &gt;= 2 &amp;&amp; j &gt;= 1) awin[i][j] |= !awin[i - 2][j - 1]; &#125;&#125; 123456789101112131415161718int solve(int a, int b) &#123; if (a &gt; b) swap(a, b); int r = a / 3; // ab互走r轮对称棋 b = b - r * 3; a = a - r * 3; if (min(a, b) != 0) &#123; if (a == b &amp;&amp; a == 1) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125;&#125; E - 牛牛的构造题意构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \\leq i&lt;j \\leq n$ &amp;&amp; $a_i - a_j = 2^x(x\\in N)(1\\le n \\le 10^6, 1\\le k \\le 10^9)$ 分析考虑降序的排列: 9 8 7 6 5 4 3 2 1 f[x]: 降序排列时, x对xi-xj=2^k 的贡献f[9]: 4f[8]: 3f[7]: 3f[6]: 3f[5]: 3f[4]: 2f[3]: 2f[2]: 1f[1]: 0 先降序, 后升序降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0​ 代码1234567891011121314151617181920212223242526void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; f(n + 1, 0); for (int i = 1; i &lt;= n; ++ i) &#123; f[i] = f[i - 1] + (popcountll(i - 1) == 1); &#125; LOG(f) int mxk = accumulate(all(f), (int)0); if (mxk &lt; k) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return; &#125; vector&lt;int&gt; dec, inc; for (int i = n; i &gt;= 1; -- i) &#123; if (k &gt;= f[i]) &#123; dec.pb(i); k -= f[i]; &#125; else &#123; inc.pb(i); &#125; &#125; reverse(all(inc)); for (auto x : dec) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; for (auto x : inc) cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;&#125; F - 牛牛的考试题意有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟. 分析树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间 对于同一门课而言:双开时间可以转成单开时间, 即双开可以反悔成单开.但是单开不能转成双开, 否则说明同时用手机电脑学同一门课. 所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间. 代码123456789101112131415161718192021222324252627282930313233343536vector&lt;vector&lt;int&gt;&gt; g;vector&lt;array&lt;int, 2&gt;&gt; dp; // dp[i][0] : 双开时间, dp[i][1] : 单开时间vector&lt;int&gt; a;array&lt;int, 2&gt; add(array&lt;int, 2&gt; a, array&lt;int, 2&gt; b) &#123; // &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125; // &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125; // &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125; if (a[1] &gt; b[1]) swap(a, b); int d = min(a[0], b[1] - a[1] &gt;&gt; 1); a[0] -= d, a[1] += 2 * d; return &#123;a[0] + b[0] + min(a[1], b[1]), max(a[1], b[1]) - min(a[1], b[1])&#125;; // 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的 // return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;&#125;void dfs(int u, int fa) &#123; for (auto v : g[u]) &#123; if (v == fa) continue; dfs(v, u); dp[u] = add(dp[u], dp[v]); &#125; dp[u][1] += a[u];&#125;void solve() &#123; int n; cin &gt;&gt; n; g.resize(n); dp.resize(n); a.resize(n); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt; n; ++ i) &#123; int x; cin &gt;&gt; x; x--; g[i].pb(x); g[x].pb(i); &#125; dfs(0, -1); cout &lt;&lt; dp[0][0] + dp[0][1] &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"}]},{"title":"周记 - 2022 12.19-12.25","slug":"周记 - 2022 12.19-12.25","date":"2022-12-28T16:00:00.000Z","updated":"2023-01-11T09:16:19.938Z","comments":true,"path":"2022/12/29/周记 - 2022 12.19-12.25/","link":"","permalink":"http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/","excerpt":"","text":"12.19 周一 晴今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我. 虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;, 12.20 周二 晴待填 12.21 周三 晴待填 12.22 周四 多云12.23 周五 阴待填 12.24 周六 晴今天是考研第一天 晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了. 12.25 周日 晴后记回忆于：12.29日晚22点","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"周记 - 2022 12.12-12.18","slug":"周记 - 2022 12.12-12.18","date":"2022-12-19T16:00:00.000Z","updated":"2023-01-14T11:51:03.138Z","comments":true,"path":"2022/12/20/周记 - 2022 12.12-12.18/","link":"","permalink":"http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/","excerpt":"","text":"12.12 周一 晴早上刷题. 下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》, 同时刷题. 主要是《D. Range = √Sum》这题, 1800构造, 只能想出偶数的构造方法, 奇数情况还是过于抽象了. 晚上吃师生缘的煎饼果子, 看完了《剃须. 然后捡到高中生》. 个人认为这番其实还算治愈番, 但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩. 可能是这还只是我正式进军二次元后看的第二部番, 姑且还觉得不错, 挺期待剃须出第二部的. 晚上跟zzm及他同学联机深岩银河. 12.13 周二 晴日程基本同周一. 12.14 周三 晴日程基本同周一. 下番《辉夜大小姐想让我告白》全部三季. 晚餐尝试了步步高门口街道上的潼关肉夹馍, 10块量少但味道不错. 12.15 周四 多云今天9:45-11:45 是《高性能计算》的期末考试. 虽然线上考试并且开卷, 但我仍觉得很难. 老师也觉得很难, 所以又延长了10分钟到11:55. 我12点整把试卷拍照上传助教邮箱. 挺无语的, 本来就一限选, 还搞严格的签到、实验和线上考试. 晚上zwling发消息说南京站的物资到了, 惊喜的是外套居然还带ICPC标. 相比之下沈阳的廉价格子衫就是屑了. 12.16 周五 阴待填 12.17 周六 晴今天14:00-16:00是ICPC南京站的热身赛. 10点半不到我就吃了午餐, 午餐在师生缘吃的自助. 同样还是12点小睡了30分钟到1点起床. 我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合, 一起前往院楼. 看得出zwling似乎有些生病, 不过都拼到这一步了, 我相信大家都是想让本科的ICPC生涯有始有终的. 走到天马公寓门口时, 后面一位好心的小姐姐提醒了我书包在漏水. 听到她的提醒我先是愣了下, 随后立马把笔记本电脑拿了出来. 之前其实也发生过水壶漏水的事故, 并且电脑都没啥事. 但是这次漏水偏偏赶在热身赛赛前1小时不到, 并且还刚好是3人3机位. 一看到电脑朝下的那一边湿了一大片, 内心也凉了大半截. 不过好在有初中毕业游手机进水的经验, 这次还是学聪明了：虽然很想知道电脑是否还健在, 也很想知道明天的正式赛会不会受到影响, 我也还是忍住没按下开机键, 在路上全称用手拎着电脑边甩边让风吹, 到院楼放在门口晒了20分钟. 热身赛马上就要开始了, 我只能按下开机键, 已经做好了最坏的打算. 电脑也跟我开了个玩笑, 开机成功后自己又重启了, 不过好在这只是系统更新. 最后电脑开是能开, 但是左下角的屏幕就暗一片亮一片. 热身赛开始阶段我们跟着榜, 着力于过题数最多的B, 却发现只能想到6次方（n=20）的做法. 我的想法是每次直接找第一个1, 然后BFS到另外一个1, 将轨迹应用于全图. 这样每次至少减少1个1, 复杂度虽然不会超, 但是却无法保证轨迹总长度不超过50000, 所以也没敢上机写. 可是诡异的是很多支队伍都很快通过了. 前1小时我们都还是1题没过. 直到姜哥看到D题题面有对B题随机化解法的代码, 才发现这是往年南京站原题. 于是姜哥很快把D题签了, 然后把D题的代码直接复制到B, 至此B也过了. 最后的A题我和zwling想出了二分的假算法, 前期一直没找到钱越多买的书越多的反例, 因此也就因此WA. 姜哥及时提出了反例, 并且给出了正确的贪心做法, 只不过此时已经接近结束了. 虽说我们热身赛封榜前一道没过, 排在了300名左右. 在回宿舍的路上, 姜哥还说他隔壁宿舍有人羊了. 按照我一直奉为圭臬的人品守恒定律, 我已经看到了明天的结果：高数100将在南京站修成正果. 首先是队长zwling生病疑似阳性, 然后又是我电脑进水. 接下来又是姜哥附近与有人确诊. 这无疑给了我莫大的鼓舞. 回到园区后, zwling还是去门口核酸亭做了混检. 晚上打了atcoder Beginner Contest 282, 直接D题罚坐. rk2000+, 看来青名又要离我远去了. 12.18 周日 晴仍是凌晨1点睡, 只不过早上9:30起床, 10:00前进餐完毕, 只吃了肉松饼和上次CCSP发的零食, 睡了20来分钟. 10:00出发去院楼参加南京正式赛. 开题签到题I, 在我们迟疑的功夫, 已经过了快300人了. 第二题G贪心, 姜哥首先发现要贪心0前半段要取1, 后半段取-1, 随后我提出了二分分界线. 姜哥提出可以O(n)做, 但是写挂了, 于是我就上机开始二分了. 又到了经典二分分界线环节, 我还被这个分界线在最左边的情况卡了10分钟, 不愧是我……不过好在在姜哥提醒下, 很快就写完了. 幸运地一发A了. 第三题看着像计算几何, 姜哥一开始就说这题很简单, 只需要判断v型就行了, 我和zwling都是懵的. 随后姜哥画了几下就上机码了, 第一发没过. 随后过了10来分钟他想出了corner case, 交上去居然直接过了. 当然我们也只是开心了一下, 毕竟从此到结束, 我们都再也没能过一道题. 第四题大模拟二维前缀和, 我们还剩2小时的时间. 我想的是用将轨迹表示成一个01矩阵, 然后再用这个矩阵和最后袋鼠组成的矩形, 做类似求交算移入移出了多少. 姜哥表示应该确实就只是二维前缀和, 随后就开始码. 但是最后因为查不出哪里越界, 一直段错误. 结束后, 虽然zwling觉得可能还是打铁, 但我和姜哥都觉得铜牌概率蛮大. 5:30开始滚榜, 当看到《高数100》出现在铜牌区时, 我意识到本科的算法竞赛已经没有遗憾了. 我觉得这次铜牌不仅幸运女神站在我们这边, 更重要的是队伍的实力确实有所上升, 毕竟这次zwling生病了. 如果他没生病, 我估计我们能将A题调出来. 最后本科的所有XCPC至此都告一段落了, 希望zwling能在BUAA找到更强的队友, 继续在算法竞赛上取得更高的成就, 也希望姜哥顺利上岸, 在研究生阶段继续发挥他过人的思维优势. 最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家. 接下来就是修改《软件工程》课程大作业的报告, 并且收拾行李, 准备第二天9点的高铁了. 要好好放松下了, 首先得先把剩下的2集麻衣学姐看完hh. 后记回忆于：12.20日晚22点 BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐 我把《高数100》的队牌带回了宿舍, 跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起. 这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事.","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - 第八届“图灵杯”个人赛","slug":"题解 - 第八届“图灵杯”个人赛","date":"2022-11-06T16:00:00.000Z","updated":"2023-01-20T07:03:54.261Z","comments":true,"path":"2022/11/07/题解 - 第八届“图灵杯”个人赛/","link":"","permalink":"http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/","excerpt":"","text":"比赛链接 贪吃的派蒙题意在每一次的排队中, 编号为i的角色领取上限为Ai, 这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内. 当一个角色领完本次的甜甜花酿鸡, 他/她就会回到队列的末尾, 直到所有甜甜花酿鸡都被吃完为止. 当轮到一个角色领取时, 如果所有的甜甜花酿鸡都被领完, 那么他/她就要帮大家刷盘子. 贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小, 那么他就把剩下的都吃完). 我们很容易找到派蒙的编号, Ax比其他所有的Ai都要大. 大家都想让派蒙最后留下来刷盘子, 请你写一个程序来判断这是否可能. 分析代码1 Seek the Joker II题意两堆石子, 一堆k-1, 另一堆n-k, 先取到任意一堆的最后一个输 分析代码1","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"题解 - 牛客小白月赛59 D-F","slug":"题解 - 牛客练习赛105 D","date":"2022-11-06T16:00:00.000Z","updated":"2023-01-20T07:04:06.206Z","comments":true,"path":"2022/11/07/题解 - 牛客练习赛105 D/","link":"","permalink":"http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/","excerpt":"","text":"比赛链接 Dijkstra 松弛的理解“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比. 最初, 最短路径的成本被高估了, 就像延伸的弹簧一样. 当找到更短的路径时, 估计的成本会降低, 弹簧会放松. 最终, 找到了最短的路径（如果存在）, 并且弹簧已经松弛到其静止长度. D - 点分治分点题意G&lt;n, m&gt;, 且$n, m \\leq 1e5$, 定义一条简单路径的 low 值为其路径上的边权的最小值, d(u, v) 为从 u 到 v 所有简单路径的最大 low 值. 对于给定的s, u 从 1 到 n 输出 d(s, u), 如果没有任何一条简单路径则输出 -1. 分析点边数1e5 -&gt; Dijkstra变形套路 dist[i]: s-&gt;i的每条路径最短边中的最大值 松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. 代码123456789101112131415161718192021222324252627282930313233343536373839const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f;int n, m, s;vector&lt;array&lt;int, 2&gt;&gt; G[N];int dist[N]; // s-&gt;i 每条路径最短边中的最大值void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 1; i &lt;= m; ++ i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].pb(&#123;v, w&#125;); &#125; priority_queue&lt;array&lt;int, 2&gt;&gt; pq; memset(dist, -0x3f, sizeof dist); dist[s] = inf; pq.push(&#123;inf, s&#125;); while (pq.size()) &#123; auto [cd, cv] = pq.top(); pq.pop(); if (dist[cv] &gt; cd) continue; // cerr &lt;&lt; cv &lt;&lt; endl; for (auto [nv, w] : G[cv]) &#123; if (dist[nv] &lt; min(dist[cv], w)) &#123; dist[nv] = min(dist[cv], w); pq.push(&#123;dist[nv], nv&#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) &#123; if (dist[i] &lt; -inf / 2 || dist[i] &gt; inf / 2) &#123; dist[i] = -1; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) &#123; cout &lt;&lt; dist[i] &lt;&lt; &quot; \\n&quot;[i == n]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"周记 - 2022 10.31-11.6","slug":"周记 - 2022 10.31-11.6","date":"2022-11-05T16:00:00.000Z","updated":"2023-01-14T11:50:43.861Z","comments":true,"path":"2022/11/06/周记 - 2022 10.31-11.6/","link":"","permalink":"http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/","excerpt":"","text":"11.3 周四 晴今天一早起来就看到知乎推送《多地核酸开始自费》, 又了解到大舅那边前几天已经开始自费了, 收费是4元/次. 不禁联想到昨天还吐槽核酸检测人员的高收入. 早十有《高性能计算》, 依旧是平平无奇地上半节课签到, 课间从复邻舍401后门溜回宿舍. 不过今天罗HZ老师提到了签到的问题, 在课上指出了缺课达3次需要补卡. 我想起上上周自己因为没看课表, 直接漏掉了一次签到. 不料午饭后, 有同学在课程群里问有没有爬山组队. 这才知道所谓的补卡其实是跟LHZ爬岳麓山, 好感度++. 自己也得找个机会把缺的这次签到补回来. 下午依旧是赛前的日常刷题. 晚饭步步高挑香小面. 晚九点打算继续昨晚的师大天马宿舍之行. 虽然没有大门大开, 但是也只是扫个码就放行了. 漫步在师大宿舍园区, 我和ZZM都明显感觉到和湖大天马宿舍不同的地方. 简单来说就是中南南校区和这里都更加具有校园的氛围, 体现在绿化, 路旁的人行道, 路旁的宣传栏, 也体现在这里建筑的杂乱. 11.4 周五 晴8点30分第一个下床. 刷题. 干午饭. 学委此时也发了关于毕设导师的通知了, 毕设郑老师之前提过, 但是目前又没了消息. 我最担心的是找不到愿意挂名的导师. 下午第三节有《软件工程》, 课上做了些2022辽宁省赛的题目, 发现题目难度不大. 做了可莉的五子棋和画画. 图的分割和栈与公约数暂时没想到做法. 晚上有例行的每周大组会, 我问了WSH, 发现大家都找了毕设的导师, 所以我也打算把当前进度汇报一下, 顺便问问毕设的事情. 于是跟老师和彭Z约了明天晚上讨论进度. 11.5 周六 晴今天14:00-16:00是ICPC沈阳站的热身赛. 所以10点半不到就吃了午餐, 休息小睡了20分钟后. 便在阜埠河公交站和zwl骑车去院楼105准备上机环境. 在比赛开始时, zwl的后置录像手机夹住了关机键, 手机直接关机了, 所以我们整场比赛都没法正常交题. 不过还是能看题面, A题签到, B题是输出 (随机生成)满足条件的a序列的期望. 公式是$\\frac{(n!)^2}{n^n}$. 就是不知道double的精度能否满足要求. C题是类似石子合并的DP题. 但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$, 所以最后只能写一个假算法. 赛后问了SJ, 得知是四边形不等式决策单调性相关, 打扰了. 晚上的Atcoder只打了半小时. 11.6 周日 晴总结: 遗憾打铁仍是凌晨1点睡, 8:30起床, 10:30前进餐完毕, 睡了10来分钟. 11:30到院楼参加沈阳正式赛. 开题签到题, 统计字符串中T和D的个数, WA了一发.第二题找规律题, 姜哥首先发现r取越大越好, 但是只考虑a[i]作为左端点, 没加上右端点的情况, WA了一发 第三题构造题, 我首先用子矩阵数量公式判断出了无解情况. ZWL打表, 发现了长相特殊的合法情况, 所以尝试将二维压缩为一维. 问题转换成把一个数分解成若干个$\\frac{i \\times (i+1)}{2}$表示. 我提出从i从高到低贪心, 二分i的位置, 上机同时姜哥找反例. 姜哥发现没有反例并且提出可以线性, 但是我写到后面犯傻, 直接神志不清, 并不清楚线性的意思. 于是姜哥接过来完成算法. 第一发TLE, endl原因. 第二发WA, 爆long long. 最后过了 第四题大模拟暴搜, 题意没读懂, 其实就是炉石随从攻击的逻辑, 奈何没玩过. 调试1个半小时, 没能调对第二个样例. 以为是精度问题. 最后Rank290+无奈打铁.","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"题解 - AtCoder Beginner Contest 275 A-F","slug":"题解 - AtCoder Beginner Contest 275 A-F","date":"2022-11-03T16:00:00.000Z","updated":"2023-01-14T04:54:00.853Z","comments":true,"path":"2022/11/04/题解 - AtCoder Beginner Contest 275 A-F/","link":"","permalink":"http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/","excerpt":"","text":"C题意一个$r \\times c (r, c\\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数. 如 123456789##.......##.......................#......#...........#......#.................... 具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子. 具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子. 因此, 答案是 2. 思路枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标. 向量[x, y]顺时针旋转90°: [y, -x] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546void rot(array&lt;int, 2&gt; &amp; v) &#123; auto [x, y] = v; v = &#123;y, -x&#125;;&#125;bool check(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= 9 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 9;&#125;void solve()&#123; for (int i = 1; i &lt;= 9; ++ i) for (int j = 1; j &lt;= 9; ++ j) cin &gt;&gt; g[i][j]; cerr &lt;&lt; g[5][5] &lt;&lt; endl; cerr &lt;&lt; g[5][7] &lt;&lt; endl; set&lt;set&lt;array&lt;int, 2&gt;&gt;&gt; S; for (int ci = 1; ci &lt;= 9; ++ ci) for (int cj = 1; cj &lt;= 9; ++ cj) &#123; for (int ni = 1; ni &lt;= 9; ++ ni) &#123; for (int nj = 1; nj &lt;= 9; ++ nj) if (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == &#x27;#&#x27; &amp;&amp; g[ni][nj] == &#x27;#&#x27;) &#123; array&lt;int, 2&gt; v = &#123;ni - ci, nj - cj&#125;; rot(v); int i3 = ni + v[0], j3 = nj + v[1]; rot(v); int i4 = i3 + v[0], j4 = j3 + v[1]; // if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7) cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl; if (check(i3, j3) &amp;&amp; check(i4, j4) &amp;&amp; g[i3][j3] == &#x27;#&#x27; &amp;&amp; g[i4][j4] == &#x27;#&#x27;) &#123; // cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl; set&lt;array&lt;int, 2&gt;&gt; s; s.insert(&#123;ci, cj&#125;); s.insert(&#123;ni, nj&#125;); s.insert(&#123;i3, j3&#125;); s.insert(&#123;i4, j4&#125;); S.insert(s); &#125; &#125; &#125; &#125; cerr &lt;&lt; S.size() &lt;&lt; endl; cout &lt;&lt; S.size() &lt;&lt; endl;&#125; D题意为非负整数 x 定义的函数 f(x) 满足以下条件： $f(0) = 1$ $f(k) = f(\\lfloor \\frac{k}{2}\\rfloor) + f(\\lfloor \\frac{k}{3}\\rfloor)$ 对于任何正整数 k 然后找到 $f(N), N\\in[0, 1^{18}]$. 分析最多需要$log_2n \\times log_3n$这么多个数的f值. 标准记搜 代码123456789101112131415int n;unordered_map&lt;int, int&gt; dp;int dfs(int u) &#123; if (dp.count(u)) return dp[u]; return dp[u] = dfs(u / 2) + dfs(u / 3);&#125;void solve()&#123; cin &gt;&gt; n; dp[0] = 1; cout &lt;&lt; dfs(n) &lt;&lt; endl; cerr &lt;&lt; dp.size() &lt;&lt; endl;&#125; E题意一个一维的棋盘上有 N + 1 个格子, 下标从 0 到 N , 玩家要从 0 这个点出发, 前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子, 每个骰面上都有不同的数字, 值域是 $[1, M]$ , 扔出每个面的概率都是 $\\frac{1}{M}$ . 玩家需要根据要出来的骰面前进, 如果预计前进之后走出了棋盘, 就需要退回多走出的步数, 如果在终点停了下来, 游戏就胜利了, 不能再扔骰子. 问 K 回合后, 玩家胜利的概率. 将结果对 998244353 取模. $0 \\le M \\le N \\le 1000, M \\in [1, 10], K \\in [1, 1000]$ . 分析令 dp[i][j] 为扔第 j 次骰子后, 玩家到达下标为 i 的格子的概率. 对于每一个 dp[i][j] $dp[next_i][j + 1] = dp[i][j] \\times \\frac{1}{M}$. 注意如果走出了棋盘, 要特殊讨论停下来的下标. 已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了 代码1234567891011121314151617181920212223242526272829303132333435363738394041const int N = 1000 + 10, mod = 998244353;int n, m, k;int dp[N][N]; // 到达第i格, 共走了j步的所有情况之和// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]int qmi(int a, int k)&#123; int res = 1 % mod; while (k) &#123; if (k &amp; 1) res = res * a % mod; a = a * a % mod; k &gt;&gt;= 1; &#125; return res;&#125;void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; dp[0][0] = 1; int m_1 = qmi(m , mod - 2); for (int j = 0; j &lt; k; ++ j) &#123; for (int i = 0; i &lt; n; ++ i) &#123; for (int len = 1; len &lt;= m; ++ len) &#123; int ni = i + len; if (ni &gt; n) &#123; ni = n - (ni - n); &#125; // if (next_i &lt;= i) &#123; // cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl; // &#125; dp[ni][j + 1] += (dp[i][j] * m_1) % mod; dp[ni][j + 1] %= mod; &#125; &#125; dp[n][j + 1] += dp[n][j]; dp[n][j + 1] %= mod; &#125; cerr &lt;&lt; dp[n][k] &lt;&lt; endl; cout &lt;&lt; dp[n][k] &lt;&lt; endl;&#125; F题意给定一个数组 A , 定义一次操作的内容是, 删除 A 中一段连续的序列. 问对于 1, 2, …, M 中的每个数 s , 分别至少要操作多少次, 才能使得 A 中剩下的数和为 s , 如果不可能就输出 -1 . $0 \\le N \\le M \\le 3000, 1 \\le a_i \\le 3000$ 思路数组分段式的DP, 用一个维度表示当前元素是否在分段中 dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中 如果a[i]不计入总和: dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); 如果a[i]计入总和: dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); 代码123456789101112131415161718192021222324252627282930const int N = 3e3 + 10;int n, m;int a[N];int dp[N][N][2]; // 前i个数, 构成总和为j, 且第i个数是否在总和中void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++ i) dp[i][0][0] = 1; dp[0][0][1] = 0; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= m; ++ j) &#123; dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;); if (j - a[i] &gt;= 0) &#123; dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;); &#125; &#125; &#125; // cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl; for (int j = 1; j &lt;= m; ++ j) &#123; int ans = min(&#123;dp[n][j][0], dp[n][j][1]&#125;); if (ans &gt; 0x3f3f3f3f3f3f3f3f / 2) ans = -1; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 评价这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的 C 模拟 + 向量旋转 D 记忆化搜索 E 概率DP F DP + 数组划分 / 选取子段","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_搜索","slug":"算法-搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"}]},{"title":"题解 - AtCoder Beginner Contest 192 D-F","slug":"题解 - AtCoder Beginner Contest 192 D-F","date":"2022-11-02T16:00:00.000Z","updated":"2023-01-14T04:53:36.470Z","comments":true,"path":"2022/11/03/题解 - AtCoder Beginner Contest 192 D-F/","link":"","permalink":"http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/","excerpt":"","text":"D题意给定整数 $X, X \\in [1, 10^{60}]$和 $M, M \\in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. 求对于所有的 $a&gt;d,a \\in \\mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\\le M$. 分析首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. 注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. 同时, long long 相乘可能会爆, 必须乘乘数base之前判断当前val &gt; target / base . 或者用 __int128AtCoder 支持 或龟速乘. 代码123456789101112131415161718192021222324252627282930313233343536string x;int m;void solve()&#123; cin &gt;&gt; x &gt;&gt; m; signed mx = 0; for (auto &amp;ch : x) mx = max(mx, ch - &#x27;0&#x27;); if (x.size() == 1) &#123; // 特判: 因为题目要求不同的数 if (mx &lt;= m) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return; &#125; auto check = [&amp;](int base) -&gt; bool &#123; int val = 0; for (int i = 0; i &lt; x.size(); ++ i) &#123; if (val &gt; m / base) &#123; // 每次 + *base 之前 跟目标 /base 作比较 防止溢出 return false; &#125; int b = x[i] - &#x27;0&#x27;; val *= base; val += b; &#125; return (val &lt;= m); &#125;; int l = mx, r = 1e18 + 10; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; cerr &lt;&lt; l &lt;&lt; endl; cout &lt;&lt; l - mx &lt;&lt; endl;&#125; E题意$G(N, M), N, M \\leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\\in\\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \\in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 -1. 分析注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. 代码12345678910111213141516171819202122232425262728293031323334const int N = 1e5 + 10;int n, m, x, y;vector&lt;array&lt;int, 3&gt;&gt; G[N];int dist[N];void solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= m; ++ i) &#123; int a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k; G[a].pb(&#123;b, t, k&#125;); G[b].pb(&#123;a, t, k&#125;); &#125; priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, greater&lt;array&lt;int, 2&gt;&gt;&gt; pq; memset(dist, 0x3f, sizeof dist); dist[x] = 0; pq.push(&#123;0, x&#125;); while (pq.size()) &#123; auto [cd, cv] = pq.top(); pq.pop(); if (cd &gt; dist[cv]) continue; // cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl; for (auto [nv, t, k] : G[cv]) &#123; int nd = (cd + k - 1) / k * k; nd = nd + t; // cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl; if (nd &lt; dist[nv]) &#123; dist[nv] = nd; pq.push(&#123;nd, nv&#125;); &#125; &#125; &#125; cerr &lt;&lt; dist[y] &lt;&lt; endl; if (dist[y] &gt;= 0x3f3f3f3f3f3f3f3f / 2) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dist[y] &lt;&lt; endl;&#125; F题意给定数组a[N], $a[i] \\leq 1e7$和$X \\in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. 思路100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数 枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值 不拿第k个物品: dp[k][i][j] = dp[k - 1][i][j]; 拿第k个物品: dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); 总复杂度 $\\mathcal{O}(n^4)$. 代码12345678910111213141516171819202122232425262728293031323334353637383940const int N = 100 + 10;int n, x;int a[N], w[N];int dp[N][N][N]; void solve()&#123; cin &gt;&gt; n &gt;&gt; x; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; int ans = 1e18; for (int choose = 1; choose &lt;= n; ++ choose) &#123; int m = x % choose; for (int i = 1; i &lt;= n; ++ i) w[i] = a[i] % choose; memset(dp, -1, sizeof dp); // dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值 dp[0][0][0] = 0; for (int k = 1; k &lt;= n; ++ k) &#123; for (int i = 1; i &lt;= min(k, choose); ++ i) &#123; for (int j = 0; j &lt; choose; ++ j) &#123; if (~dp[k - 1][i][j]) &#123; dp[k][i][j] = dp[k - 1][i][j]; &#125; if (~dp[k - 1][i - 1][(j - w[k] + choose) % choose]) &#123; dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]); &#125; &#125; &#125; &#125; // 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose if (~dp[n][choose][m]) &#123; ans = min(ans, (x - dp[n][choose][m]) / choose); &#125; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; 评价D 考察乘法溢出, 各种边界讨论比较繁琐 E 最短路变形, 松弛边权做一下变化即可 F 背包+模数, 在外层套一层for模数choose, 状态表示加一个维度表示当前总和mod choose的值","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"题解 - 牛客小白月赛34 A-H","slug":"题解 - 牛客小白月赛34 A-H","date":"2022-10-31T16:00:00.000Z","updated":"2023-01-16T12:00:43.760Z","comments":true,"path":"2022/11/01/题解 - 牛客小白月赛34 A-H/","link":"","permalink":"http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/","excerpt":"","text":"这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题). A - dd爱科学1.0+2.0题意数组a[n](1≤n≤1000000, isupper(a[i]) == true). 求通过修改变成不下降序列的最小代价, 每次修改一个数x为y的代价为1(2.0版本为|x - y|). 1.0 ACEBF -&gt; ACEEF 代价 = 12.0 AEEBC -&gt; AEEEE 代价 = 偏移量总和为|B-E|+|C-E|=3+2=5 分析dp[i][j]表示改至第i位为止, 最后一位为j的最小代价(或者理解成最后一位&lt;=j也行) 12345for(int j = 1; j &lt;= 26; ++ j) &#123; // 当前字符为curr for(int k = 1; k &lt;= j; ++ k) &#123; // 从上一字符转移而来 f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j)); &#125;&#125; 注意到: min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了. 这样可以少O(26)的复杂度 123for(int j = 1; j &lt;= 26; ++ j) &#123; f[i][j] = min(f[i][j - 1], f[i - 1][j] + abs(curr - j));&#125; 代码123456789101112131415161718192021222324int main()&#123; ios::sync_with_stdio(false); cin.tie(0); memset(f, 0x3f, sizeof f); scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, &amp;str[1]); for(int i = 1; i &lt;= 26; ++ i) f[0][i] = 0; for(int i = 1; i &lt;= n; ++ i) &#123; int curr = str[i] - &#x27;A&#x27; + 1; //当前字符改成 for(int j = 1; j &lt;= 26; ++ j) &#123; //从上一字符转移而来 // for(int k = 1; k &lt;= j; ++ k) // f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j)); // min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了 f[i][j] = min(f[i][j - 1], f[i - 1][j] + abs(curr - j)); &#125; &#125; for(int i = 0; i &lt; 26; ++ i) ans = min(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; B - dd爱探险题意有n(3≤n≤16)个空间站, 任意两个空间站间可以相互跳跃, 由空间站x跳跃到空间站y所需要的代价为P[x][y],注意不保证p[x][y]=p[y][x], dd可以任意选择出发的空间站, 并通过恰好n-1次跳跃把所有空间站跳完, 并且dd必须选择2次跳跃, 其中一次跳跃中进行重力加速, 另一次跳跃中进行反重力加速, 重力加速会导致当前跳跃代价变为0, 反重力加速会导致当前跳跃代价翻倍(乘2), 问跳完所有空间站所需要最小代价 分析状压DP. 经典TSP likedp[1 &lt;&lt; N][N][2][2]: 走过了i中为1的点,且当前最后到达j, g, rg是否用了重力 / 反重力 代码12345678910111213141516171819202122232425262728293031323334const int N = 16;int dp[1 &lt;&lt; N][N][2][2]; // 是否用了重力 / 反重力int n; int w[N][N];void solve() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) &#123; for (int j = 0; j &lt; n; ++ j) &#123; cin &gt;&gt; w[i][j]; &#125; &#125; memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt; n; ++ i) &#123; dp[1 &lt;&lt; i][i][0][0] = 0; &#125; for (int val = 0; val &lt; (1 &lt;&lt; n); ++ val) &#123; // 1e5 for (int from = 0; from &lt; n; ++ from) &#123; // 10 for (int to = 0; to &lt; n; ++ to) &#123; // 10 if ((val &gt;&gt; to &amp; 1) &amp;&amp; (val &gt;&gt; from &amp; 1)) &#123; dp[val][to][0][0] = min(&#123;dp[val][to][0][0], dp[val ^ 1 &lt;&lt; to][from][0][0] + w[from][to]&#125;); dp[val][to][0][1] = min(&#123;dp[val][to][0][1], dp[val ^ 1 &lt;&lt; to][from][0][0] + 0, dp[val ^ 1 &lt;&lt; to][from][0][1] + w[from][to]&#125;); dp[val][to][1][0] = min(&#123;dp[val][to][1][0], dp[val ^ 1 &lt;&lt; to][from][0][0] + w[from][to] * 2, dp[val ^ 1 &lt;&lt; to][from][1][0] + w[from][to]&#125;); dp[val][to][1][1] = min(&#123;dp[val][to][1][1], dp[val ^ 1 &lt;&lt; to][from][1][0] + 0, dp[val ^ 1 &lt;&lt; to][from][0][1] + w[from][to] * 2, dp[val ^ 1 &lt;&lt; to][from][1][1] + w[from][to]&#125;); &#125; &#125; &#125; &#125; int ans = 0x3f3f3f3f3f3f3f3f; for (int i = 0; i &lt; n; ++ i) &#123; ans = min(ans, dp[(1 &lt;&lt; n) - 1][i][1][1]); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D - dd爱矩阵题意给一个n∗n的矩阵, 每行各选一个数字, 把选出来的n个数字相加, 一共有$n^{n}$ 种可行答案, 输出前n大 分析优先队列 + 动态前k大 + 数组合并 类似: P2085 最小函数值 先把问题简化一下, 如果两行, 每行 n个数, 怎么选把两行分别降序 sort, 令第一行为数组 a, 第二行为数组 b则可得到最大值为 a[0]+b[0], 并且得到 a[i]+b[j-1]&gt;a[i]+b[j]&gt;a[i]+b[j+1]所以可以把 a[0]+b[i]全部推入优先队列当中, 并且标记对应的 i,每次取出 top, 再把 a[0]+b[i+1]推入优先队列当中, n次操作即可得到前 n大复杂度 O(nlogn)回到这个题目, 由于是 n行, 可以每次处理两行, 并成一行新的, n-1次操作把 n行并成一行, 复杂度 O(n^2 logn) 代码1234567891011121314151617181920212223242526272829303132void merge()&#123; for(int i = 0; i &lt; n; ++ i) heap.push(&#123;a[0] + b[i], 0&#125;); for(int i = 0; i &lt; n; ++ i) &#123; auto top = heap.top(); heap.pop(); int sum = top.first, idx = top.second; heap.push(&#123;sum - a[idx] + a[idx + 1], idx + 1&#125;); t[i] = sum; &#125; for(int i = 0; i &lt; n; ++ i) a[i] = t[i];&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; ++ i) &#123; for(int j = 0; j &lt; n; ++ j) cin &gt;&gt; b[j]; merge(); &#125; for(int i = 0; i &lt; n; ++ i) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; return 0;&#125; E - dd爱旋转题意读入一个n∗n的矩阵, 对于一个矩阵有以下两种操作1:顺时针旋180° [1 2] =&gt; [4 3][3 4] [2 1] 2:关于行镜像 [1 2] =&gt; [3 4][3 4] [1 2] 给出q个操作, 输出操作完的矩阵 分析操作1: 相当于行镜像, 列镜像各做一次操作2: 相当于行镜像做一次 只用看操作1和操作2的奇偶性就行了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344void op1()&#123; memset(vis, false, sizeof vis); for(int i = 1; i &lt;= n; ++ i) for(int j = 1; j &lt;= n; ++ j) if(!vis[i][j]) &#123; vis[i][j] = vis[n + 1 - i][n + 1 - j] = true; swap(m[i][j], m[n + 1 - i][n + 1 - j]); &#125;&#125;void op2()&#123; for(int i = 1; i &lt;= n / 2; ++ i) swap(m[i], m[n + 1 - i]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++ i) for(int j = 1; j &lt;= n; ++ j) cin &gt;&gt; m[i][j]; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; op; if(op == 1) ++ cnt1; else ++ cnt2; &#125; if(cnt1 % 2) op1(); if(cnt2 % 2) op2(); for(int i = 1; i &lt;= n; ++ i) &#123; for(int j = 1; j &lt;= n; ++ j) cout &lt;&lt; m[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; return 0;&#125; F - dd爱框框题意读入n(1≤n≤10000000),x(1≤x≤10000),给出n个数a[1],a[2],……,求最小的区间[l,r], 使a[l]+a[l+1]+……+a[r]≥x, 若存在相同长度区间, 输出l最小的那个 分析二分区间长度 + 前缀和check + 二分内更新答案OR 滑动窗口(不会) 代码1234567891011121314151617181920212223242526272829303132bool check(ll len)&#123; for(ll i = 1; i + len &lt;= n; ++ i) if(s[i + len] - s[i - 1] &gt;= x) &#123; lbound = i, rbound = i + len; return true; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; x; for(ll i = 1; i &lt;= n; ++ i) &#123; ll t; cin &gt;&gt; t; s[i] = s[i - 1] + t; &#125; int l = 1, r = n; while(l &lt; r) &#123; ll mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; lbound &lt;&lt; &quot; &quot; &lt;&lt; rbound &lt;&lt; endl; return 0;&#125; G - dd爱捣乱题意一个完美串(islower == true)应该满足该串中任意长度≥2≥2的子串都不是回文串, 把一个字符从xx变成yy的代价是min(|x-y|,26-|x-y|),(|x-y|为ascii码差值), 问把一个串变成完美串的最小代价 分析首先讨论完美串满足条件, 如果是奇串, 则每一位前后两位不同, 即 a[i-1]≠a[i+1]如果是偶串, 则相邻两位不同 a[i]≠a[i-1]综上, 只要任意连续三位都满足两两不同, 就是一个完美串那么一个很显然的想法, 枚举每一位的情况, 保证再枚举前两位情况, 保证不同的情况下更新答案复杂度 O(n×26^3), 显然不可接受所以进一步想, 每一位最多只会受前两位和后两位的影响, 所以最差情况下五个字母全部不同(abccd, 中间的c要+=2. 如果只有±1,0就不行了). 实际上相邻三个字符各自改变量最多只有五种情况: ±2,±1,0. )所以对于每一位只要枚举改变量就行了, dp[i][j][k]表示把第 i-1位的改变量是 j, 第 i位的改变量是 k的最小代价dp[i][j][k]←dp[i-1][l][j]最后枚举最后两位改变量 min(dp[n][i][j])就是答案复杂度 O(n×5^3) 代码123456789101112131415161718192021222324252627282930313233343536373839const int N = 1e2 + 10, offset = 2;int dp[N][6][6]; // 第i-1位的改变量为j, 第i位的改变量为kint a[N], n;void solve() &#123; cin &gt;&gt; n; string s; cin &gt;&gt; s; memset(dp, 0x3f, sizeof dp); for (int i = 1; i &lt;= n; ++ i) a[i] = s[i - 1] - &#x27;a&#x27;; for (int j = -2; j &lt;= 2; ++ j) &#123; for (int k = -2; k &lt;= 2; ++ k) &#123; if ((a[1] + j + 26) % 26 != (a[2] + k + 26) % 26) &#123; dp[2][j + offset][k + offset] = min(dp[2][j + offset][k + offset], abs(j) + abs(k)); &#125; &#125; &#125; for (int i = 3; i &lt;= n; ++ i) &#123; for (int j = -2; j &lt;= 2; ++ j) &#123; // i-1 for (int k = -2; k &lt;= 2; ++ k) &#123; // i if ((a[i] + k + 26) % 26 != (a[i - 1] + j + 26) % 26) &#123; // dp[i][j][k] for (int l = -2; l &lt;= 2; ++ l) &#123; // i-2 if ( ((a[i - 1] + j + 26) % 26 != (a[i - 2] + l + 26) % 26) &amp;&amp; ((a[i] + k + 26) % 26 != (a[i - 2] + l + 26) % 26)) &#123; // dp[i - 1][l][j] dp[i][j + offset][k + offset] = min(dp[i][j + offset][k + offset], dp[i - 1][l + offset][j + offset] + abs(k)); &#125; &#125; &#125; &#125; &#125; &#125; int ans = 0x3f3f3f3f; for (int j = -2; j &lt;= 2; ++ j) &#123; for (int k = -2; k &lt;= 2; ++ k) &#123; ans = min(ans, dp[n][j + offset][k + offset]); &#125; &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; H - dd爱整齐题意当k=1时abababab, k=2时abbabbabb, k=3时abbbabbb这种类型的是优美序列, 现在给你一个数组a[n]和k((1≤k≤n≤1000000)), 每次你可以让数组中的数减1, 问你最少的操作次数使得n数组为k优美序列. 当然不一定就是abbabb, bbabba这个也是2的优美序列. 只要是优美序列的一段(子串)就行. 同时要保证a&gt;=b. 分析看到循环结构 / 循环节, 要往模数上想目标序列作为k优美序列的子串, 注意到当len(目标序列) &gt;= k时, 每k个数就会固定有一个a, k-1个b, 所以只需要确认a的位置就行. 把位置i对 k+1取余, 余数相等的位置的值必然相等. 因为给定了限制条件 a≥b, 所以通过简单贪心+前缀和计算把第i + Z*k位置上的数改变成a, 其他变成b的代价. 复杂度 O(n) 代码1234567891011121314151617181920212223const int inf = 1e18;void solve() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; ++ k; vector&lt;int&gt; a(n), sum(k), cnt(k), mn(k, inf); int mna = 1e18, suma = 0; for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; mna = min(mna, a[i]); suma += a[i]; &#125; for (int i = 0; i &lt; n; ++ i) &#123; sum[i % k] += a[i]; cnt[i % k] ++; mn[i % k] = min(mn[i % k], a[i]); &#125; int ans = inf; for (int i = 0; i &lt; k; ++ i) &#123; // 把第i个数变成a, 其他的数变成b int val = sum[i] - cnt[i] * mn[i] + (suma - sum[i]) - (n - cnt[i]) * mna; ans = min(ans, val); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"}]},{"title":"题解 - 牛客小白月赛59 D-F","slug":"题解 - 牛客小白月赛59 D-F","date":"2022-10-31T16:00:00.000Z","updated":"2023-01-20T07:04:15.103Z","comments":true,"path":"2022/11/01/题解 - 牛客小白月赛59 D-F/","link":"","permalink":"http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/","excerpt":"","text":"D - 国际象棋题意n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋) 分析每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\\“四个方向上已经连了几个了. 注意不能分8个方向 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 1e3 + 10;int n, m, k, t;int h[N], g[N][N];int dx[] = &#123;1, -1, 1, -1, 0, 0, -1, 1&#125;, dy[] = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;;int solve()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t; memset(g, -1, sizeof g); for (int tt = 1; tt &lt;= t; ++ tt) &#123; int col, x = tt % 2; cin &gt;&gt; col; g[++ h[col]][col] = x; int cx = h[col], cy = col;// cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;// for (int i = n; i &gt;= 1; -- i) for (int j = 1; j &lt;= m; ++ j) cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \\n&quot;[j == m]; int cnt = 1; while (cx + 1 &lt;= n &amp;&amp; g[cx + 1][cy] == x) ++ cx, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy] == x) -- cx, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cy + 1 &lt;= m &amp;&amp; g[cx][cy + 1] == x) ++ cy, ++ cnt; cx = h[col], cy = col; while (cy - 1 &gt;= 1 &amp;&amp; g[cx][cy - 1] == x) -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy + 1 &lt;= m &amp;&amp; g[cx + 1][cy + 1] == x) ++ cx, ++ cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx - 1][cy - 1] == x) -- cx, -- cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl; cx = h[col], cy = col; cnt = 1; while (cx + 1 &lt;= n &amp;&amp; cy - 1 &gt;= 1 &amp;&amp; g[cx + 1][cy - 1] == x) ++ cx, -- cy, ++ cnt; cx = h[col], cy = col; while (cx - 1 &gt;= 1 &amp;&amp; cy + 1 &gt;= 1 &amp;&amp; g[cx - 1][cy + 1] == x) -- cx, ++ cy, ++ cnt; if (cnt &gt;= k) return tt;// cerr &lt;&lt; &quot; \\\\ &quot; &lt;&lt; cnt &lt;&lt; endl; &#125; return t;&#125; E - 弹珠碰撞题意长度为 n 的线段上, 有 m 颗弹珠在匀速以1单位/s 左右滚动. 弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. 两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动, 并交换两颗弹珠滚动的方向. 一颗弹珠可以反复发生碰撞, 如果在停滞中受到碰撞, 则停滞时间会累加. 如果一颗弹珠滚到了位置 0 或位置 n+1, 那么这颗弹珠就滚出了线段. 问最后一颗弹珠在什么时候滚出线段？ 分析a -&gt; &lt;- b 左右两个弹珠相撞后 &lt;-a b -&gt; &lt;-b a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的 算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行. ​ 代码123456789101112131415161718192021222324252627const int N = 1e6 + 10;int n, m;struct &#123; int d, p;&#125; ball[N];int pre1[N]; // -&gt;int suf0[N]; // &lt;-void solve()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].d; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; ball[i].p; sort(ball + 1, ball + 1 + m, [&amp;](auto &amp;a, auto &amp;b) &#123; return a.p &lt; b.p; &#125;); for (int i = 1; i &lt;= m; ++ i) pre1[i] = pre1[i - 1] + (ball[i].d == 1); for (int i = m; i &gt;= 1; -- i) suf0[i] = suf0[i + 1] + (ball[i].d == 0); int ans = 0; for (int i = 1; i &lt;= m; ++ i) &#123; auto [d, p] = ball[i]; int t = (d ? (n + 1 - p) + suf0[i] : p + pre1[i]); // cerr &lt;&lt; t &lt;&lt; endl; ans = max(t, ans); &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125; F - 困难卷积题意给定整数序列 a[n], b[n], 求：$$\\sum_{i=1}^n\\sum_{j=1}^n\\Big\\lfloor\\sqrt{|a_i-b_j|}\\Big\\rfloor$$ 其中 $\\lfloor x\\rfloor$表示不超过 x 的最大整数, 例如 $\\lfloor 3.5\\rfloor=3,\\lfloor\\sqrt 2\\rfloor =1$. $1≤n≤10^6, 0\\leq a_i,b_i\\leq 3\\times 10^6, \\sum a_i,\\sum b_i\\leq 10^7$. 分析3e6 排除暴力. 注意到$\\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行 代码1234567891011121314151617const int N = 1e6 + 10;int a[N], b[N];int n;void solve()&#123; cin &gt;&gt; n; map&lt;int, int&gt; cnta, cntb; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i], cnta[a[i]] ++; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; b[i], cntb[b[i]] ++; int ans = 0; for (auto [va, ca] : cnta) for (auto [vb, cb] : cntb) &#123; ans += floor(sqrt(abs(va - vb))) * ca * cb; &#125; cerr &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-31T11:31:34.473Z","updated":"2022-10-31T11:29:53.845Z","comments":true,"path":"2022/10/31/hello-world/","link":"","permalink":"http://example.com/2022/10/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Ubuntu 下使用 Clash 代理","slug":"Ubuntu 下使用 Clash 代理","date":"2022-02-01T16:00:00.000Z","updated":"2023-01-14T11:51:12.221Z","comments":true,"path":"2022/02/02/Ubuntu 下使用 Clash 代理/","link":"","permalink":"http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/","excerpt":"","text":"Ubuntu科学上网 在 https://github.com/Dreamacro/clash/releases 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash. 添加执行权限（sudo chmod + x clash），将 clash 放到 /usr/bin/ 目录下（sudo cp clash /usr/bin/）. 在终端中运行 clash，会在 ~/.config/clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件. 用商家提供的替换这两个文件，重新运行 clash. 设置系统代理： 用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响. 将clash进程加入开机自启动","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"}]},{"title":"题解 - AtCoder Beginner Contest 285 A-F","slug":"题解 - AtCoder Beginner Contest 284 A-F","date":"2022-01-16T16:00:00.000Z","updated":"2023-01-20T06:02:03.786Z","comments":true,"path":"2022/01/17/题解 - AtCoder Beginner Contest 284 A-F/","link":"","permalink":"http://example.com/2022/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/","excerpt":"","text":"A. Generalized ABC题意思路代码123456void solve() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; s(n); for (auto &amp;x : s) cin &gt;&gt; x; for (int i = n - 1; i &gt;= 0; -- i) cout &lt;&lt; s[i] &lt;&lt; endl;&#125; B. Multi Test Cases题意思路代码12345678910void solve() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (auto &amp;x : a) cin &gt;&gt; x; int ans = 0; for (auto x : a) &#123; ans += (x &amp; 1); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; C. Count Connected Components题意思路代码123456789101112131415161718192021vector&lt;int&gt; p;int find(int x) &#123; return x == p[x] ? p[x] : p[x] = find(p[x]);&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; p.resize(n + 1); iota(all(p), 0); for (int i = 1; i &lt;= m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u = find(u), v = find(v); if (u == v) continue; p[u] = v; &#125; int wcc = 0; LOG(wcc); for (int i = 1; i &lt;= n; ++ i) &#123; wcc += (find(i) == i); &#125; cout &lt;&lt; wcc &lt;&lt; endl;&#125; D. Happy New Year 2023题意给定一个正整数n (n &lt;= 4e18), 找出两个质数p, q. 满足n = p * p * q 思路看到(n &lt;= 4e18) + 乘三次 —&gt; $(1e18)^{1/3} \\to \\ O(1e6)$ n = p * p * q 显然有min(p, q) &lt;= n^(1/3) 设x为p, q中最小的数, y为最大的数 检查x * x * y 和 x * y * y 代码1234567891011121314151617181920212223242526272829303132333435const int N = 4e6 + 10;int primes[N], cnt;bool is_p[N];void get_primes(int n) &#123; memset(is_p, 1, sizeof is_p); for (int i = 2; i &lt;= n; ++ i) &#123; if (is_p[i]) &#123; primes[cnt ++] = i; &#125; for (int j = i + i; j &lt;= n; j += i) &#123; is_p[j] = false; &#125; &#125;&#125;void solve() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; cnt; ++ i) &#123; int p = primes[i]; int p2 = p * p; if (n % p2 == 0) &#123; cout &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; n / p2 &lt;&lt; endl; return; &#125; if (n % p) continue; int val = n / p; // p * q * q int rt = sqrtl(val); if (rt * rt == val) &#123; cout &lt;&lt; rt &lt;&lt; &#x27; &#x27; &lt;&lt; p &lt;&lt; endl; return; &#125; &#125;&#125; E. Count Simple Paths题意给定G(n &lt;= 1e5, m), 统计从1出发的简单路径数目. 其中每个节点度数&lt;8. 思路简单路径数目: dfs + st[n]回溯 / bit_dp [1 &lt;&lt; n][n] 节点数量过大 + 有节点度数保证 == dfs. 代码1234567891011121314151617181920212223242526272829int cnt = 0;vector&lt;bool&gt; st;vector&lt;vector&lt;int&gt;&gt; g;void dfs(int u) &#123; st[u] = true; ++ cnt; if (cnt &gt;= 1000000) &#123; cout &lt;&lt; cnt &lt;&lt; endl; exit(0); &#125; for (auto v : g[u]) &#123; if (st[v]) continue; dfs(v); &#125; st[u] = false;&#125;void solve() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; g.resize(n); st.resize(n); for (int i = 1; i &lt;= m; ++ i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; u --, v --; g[u].pb(v); g[v].pb(u); &#125; dfs(0); LOG(cnt); cout &lt;&lt; cnt &lt;&lt; endl;&#125; F. ABCBAC题意给定一个字符串s[2 * n](n &lt;= 1e6), 设s1[i] = s[1, i] + s[n - (i) + 1, n], s2[i] = reverse(all(s[i + 1, n - i])) 问是否存在i, 满足s1 == s2 思路string hash: 第一次使用double hash 本质考察: 哈希拼接(base进制数理解) + 翻转哈希(后缀哈希) 哈希拼接: 前缀i + 后缀n-i 拼接. 就比如俩十进制数12, 34567 要拼接起来, 要先把12 * 100000再和后者相加, 才能变成1234567. 这里的哈希同理, 只不过换成了base进制数, 所以前者(前缀s[1, i])的哈希值先 * pw[n - i] (后缀的长度次幂), 再与后缀的哈希相加. 哈希截取: 从1234567中截取”34567”的哈希值, 要将前缀哈希1234567 - 12 * 100000. 即pre[r] - pre[l - 1] * base[r - l + 1]. 翻转哈希: s[l, r]的翻转哈希: suf[l] - suf[r + 1] * pw[r - l + 1]即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using hash_t = array&lt;int, 2&gt;;const int mod0 = 1e9 + 7, mod1 = 1e9 + 9;hash_t base = &#123;13331, 23333&#125;;hash_t pw[N];hash_t operator + (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] + b[0]) % mod0, (a[1] + b[1]) % mod1&#125;; return res;&#125;hash_t operator - (hash_t a, hash_t b) &#123; hash_t res = &#123;(a[0] - b[0] + mod0) % mod0, (a[1] - b[1] + mod1) % mod1&#125;; return res;&#125;hash_t operator * (hash_t a, hash_t b) &#123; return &#123;a[0] * b[0] % mod0, a[1] * b[1] % mod1&#125;;&#125;hash_t pre[N], suf[N];void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; pw[0] = &#123;1, 1&#125;; for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pw[i] = pw[i - 1] * base; &#125; for (int i = 1; i &lt;= 2 * n; ++ i) &#123; pre[i] = pre[i - 1] * base + hash_t&#123;s[i], s[i]&#125;; &#125; for (int i = 2 * n; i &gt;= 1; -- i) &#123; suf[i] = suf[i + 1] * base + hash_t&#123;s[i], s[i]&#125;; &#125; LOG(n, s) // s前i + s后2* n - i for (int i = 0; i &lt;= n; ++ i) &#123; // s前i + s后2* n - i 哈希拼接 // [1, i] [i + 1, i + n] [i + n + 1, 2 * n] hash_t h1 = pre[i] * pw[n - i] + (pre[2 * n] - pre[i + n + 1 - 1] * pw[n - i]) ; // [i + 1, i + n] 翻转后的哈希 hash_t h2 = suf[i + 1] - suf[(i + n) + 1] * pw[n]; if (h1 == h2) &#123; string ans = s.substr(1 + i, n); reverse(all(ans)); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_哈希","slug":"算法-哈希","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"}]},{"title":"题解 - AtCoder Beginner Contest 285 A-F","slug":"题解 - AtCoder Beginner Contest 285 A-F","date":"2022-01-16T16:00:00.000Z","updated":"2023-01-20T07:01:36.862Z","comments":true,"path":"2022/01/17/题解 - AtCoder Beginner Contest 285 A-F/","link":"","permalink":"http://example.com/2022/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/","excerpt":"","text":"A. Edge Checker 2题意思路代码12345void solve() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if (b / a == 2) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; B. Longest Uncommon Prefixs题意思路代码123456789101112131415void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; for (int i = 1; i &lt;= n - 1; ++ i) &#123; int ans = 0; for (int l = 1; i + l &lt;= n; ++ l) &#123; if (s[l] == s[l + i]) &#123; break; &#125; ans = max(ans, l); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; C. abc285_brutmhyhiizp题意将26进制数(A-Z)转成10进制数(0-9)BRUTMHYHIIZP —&gt; 10000000000000000 思路代码12345678910void solve() &#123; string s; cin &gt;&gt; s; int ans = 0; int n = s.size(); for (int i = 0; i &lt; n; ++ i) &#123; ans = ans * 26 + (s[i] - &#x27;A&#x27; + 1); &#125; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; D. Change Usernames题意n个改名需求&lt;s[i], t[i]&gt;, 问是否能通过合理安排这n次改名的顺序, 使得改名没有冲突. 如 1234a bb cc aans: No 123a bb cans: Yes 思路其实就是map&lt;string, int&gt;哈希 + 判环. toposort就行 代码123456789101112131415161718192021222324252627282930313233343536373839void solve() &#123; int n; cin &gt;&gt; n; map&lt;string, int&gt; id; int idx = 0; vector&lt;int&gt; to(2 * n + 10), ind(2 * n + 10); for (int i = 1; i &lt;= n; ++ i) &#123; string s, t; cin &gt;&gt; s &gt;&gt; t; int si, ti; if (!id.count(s)) id[s] = ++ idx; if (!id.count(t)) id[t] = ++ idx; si = id[s]; ti = id[t]; to[si] = ti; ++ ind[ti]; &#125; vector&lt;int&gt; st(2 * n + 10); bool ok = true; queue&lt;int&gt; q; for (int i = 1; i &lt;= idx; ++ i) &#123; if (ind[i] == 0) q.push(i); &#125; while (q.size()) &#123; auto cv = q.front(); q.pop(); st[cv] = 1; if (!to[cv]) continue; auto nv = to[cv]; if (-- ind[nv] == 0) &#123; q.push(nv); &#125; &#125; for (int i = 1; i &lt;= idx; ++ i) &#123; if (!st[i]) ok = false; &#125; if (ok) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125; E. Work or Rest题意一共有n(&lt;=5000)天, 每天可以是工作日 or 休息日 现在需要安排这n天, 使得工作效率之和最大化. 第i天(工作日)的工作效率定义为: 设这一天离最近的休息日距离d(把这n天视为一个环, 即第1天和第n天首尾相连), 第i天的工作效率为a[d]. 其中a[n]是给定的序列 如XOOOX (O代表工作日, X代表休息日)中: O[1] = a[min(1, 3)] O[2] = a[min(2, 2)] O[3] = a[min(3, 1)] 思路首先要将n天的安排和a[n]独立开, 毕竟我第i天是工作日不代表这天的效率就是a的某个数, 具体要看n天的安排. 又因为n天是一个环, 所以可以设第一天是工作日. 影响效率之和的因素只有休息日天数和间隔. 设某两天休息日的间隔为d, 则这两天间的工作日效率之和为: d=1: a1 d=2: 2*a1 d=3: 2*a1 + a2 记b[d]为间隔d天的效率贡献 n&lt;=5000. 可以n^2 DP 间隔数dpdp[i][j] 表示安排完了前i天, 且当前已经连续j天是工作日 dp[i][j] = dp[i][j - 1] dp[i][0] = dp[i][j] + b[j] 代码1234567891011121314151617181920212223void solve() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; a[n + 1] = 0; for (int i = 1; i &lt;= n; ++ i) b[i] = b[i - 1] + a[(i + 1) / 2]; // Why 必须初始化 负数? memset(dp, -0x3f, sizeof dp); dp[1][0] = 0; for (int i = 1; i &lt;= n + 1; ++ i) &#123; for (int j = 0; j &lt;= n - 1; ++ j) &#123; if (j - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1] &gt;= 0) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]); &#125; if (dp[i - 1][j] &gt;= 0) &#123; dp[i][0] = max(dp[i][0], dp[i - 1][j] + b[j]); &#125; &#125; &#125; int ans = dp[n + 1][0]; LOG(ans) cout &lt;&lt; ans &lt;&lt; endl;&#125; 完全背包dp把间隔数i + 1(连续i天工作日 + 1天休息日)视作物品i的体积, d[i]视作物品i的价值. 背包容量为n w[i] = w[i - 1] + a[i + 1 &gt;&gt; 1]; v[i] = i + 1; dp[n][n]即为所求 代码123456789101112131415161718192021222324252627void solve() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++ i) &#123; w[i] = w[i - 1] + a[i + 1 &gt;&gt; 1]; v[i] = i + 1; &#125; // for (int i = 1; i &lt;= n; ++ i) &#123; // for (int c = 0; c * v[i] &lt;= n; ++ c) &#123; // for (int j = c * v[i]; j &lt;= n; ++ j) &#123; // dp[i][j] = max(dp[i][j], dp[i - 1][j - c * v[i]] + w[i] * c); // &#125; // &#125; // &#125; for (int i = 1; i &lt;= n; ++ i) &#123; // for (int j = n; j &gt;= 0; -- j) &#123; for (int j = 0; j &lt;= n; ++ j) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j]); if (j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); &#125; &#125; // OXXXXXX OXXXXXX LOG(dp[n][n]) cout &lt;&lt; dp[n][n] &lt;&lt; endl;&#125; F. Substring of Sorted String题意小写字符串s[n], q个询问2种询问方式: 1 x c: s[x] = c 2 l r: 设t[n]=sort(all(s)), 判断s[l, r]是否为t的子串 思路 s = acbd t = abcd q = 2 1 4 NO s = abbd t = abbd q = 2 1 3 YES s = abcdc t = abccd q = 2 2 4 NO tag[i]记录s[i - 1] -&gt; s[i] 是否为非递减 seg[c].range(l, r) 记录字母c在[l, r]内出现次数 s[l, r]为t的子串, 需要满足以下两个条件: s[l + 1, r]内的字符都是递增的. 即tag.range_sum(l + 1, r) == 0 s[l + 1, r - 1]内的字符出现频数 == t对应字符出现频数. 如样例3 tag: 单点修改, 区间求和 —&gt; fenwick_tree seg: 求s[l, r]内某字符的出现频数, 支持修改 —&gt; fenwick_tree 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct fenwick_tree &#123; int n; vector&lt;int&gt; tr; fenwick_tree(int n) &#123;this-&gt;n = n; tr.resize(n + 5);&#125; int lowbit(int x) &#123;return x &amp; -x;&#125; void add(int x, int c) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; &#125; int sum(int x) &#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; &#125; int range(int l, int r) &#123; return sum(r) - sum(l - 1); &#125;&#125;;void solve() &#123; int n; cin &gt;&gt; n; string s; cin &gt;&gt; s; s = &quot; &quot; + s; int q; cin &gt;&gt; q; vector&lt;int&gt; cnt(26); vector&lt;fenwick_tree&gt; seg(26, fenwick_tree(n + 5)); fenwick_tree tag(n + 5); for (int i = 1; i &lt;= n; ++ i) &#123; cnt[s[i] - &#x27;a&#x27;] ++; seg[s[i] - &#x27;a&#x27;].add(i, 1); if (i &gt; 1) tag.add(i, s[i - 1] &gt; s[i]); &#125; while (q --) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int x; char c; cin &gt;&gt; x &gt;&gt; c; cnt[s[x] - &#x27;a&#x27;] --; seg[s[x] - &#x27;a&#x27;].add(x, -1); // s[x - 1] s[x] s[x + 1] if (x &gt; 1) &#123; tag.add(x, -(tag.range(x, x))); &#125; if (x &lt; n) &#123; tag.add(x + 1, -(tag.range(x + 1, x + 1))); &#125; s[x] = c; cnt[s[x] - &#x27;a&#x27;] ++; seg[s[x] - &#x27;a&#x27;].add(x, 1); if (x &gt; 1) &#123; tag.add(x, s[x - 1] &gt; s[x]); &#125; if (x &lt; n) &#123; tag.add(x + 1, s[x] &gt; s[x + 1]); &#125; &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int ok = true; ok &amp;= (tag.range(l + 1, r) == 0); for (int i = s[l] + 1 - &#x27;a&#x27;; i &lt;= s[r] - 1 - &#x27;a&#x27;; ++ i) &#123; ok &amp;= (seg[i].range(l, r) == cnt[i]); &#125; LOG(ok) if (ok) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"},{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"笔记_模板","slug":"笔记-模板","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"},{"name":"算法_实现","slug":"算法-实现","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"},{"name":"算法_数论","slug":"算法-数论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"},{"name":"算法_构造","slug":"算法-构造","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"},{"name":"算法_位运算","slug":"算法-位运算","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法_数学","slug":"算法-数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"},{"name":"算法_暴力","slug":"算法-暴力","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"},{"name":"算法_DP","slug":"算法-DP","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"},{"name":"算法_贪心","slug":"算法-贪心","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"},{"name":"算法_双指针","slug":"算法-双指针","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"算法_组合数学","slug":"算法-组合数学","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"算法_博弈","slug":"算法-博弈","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"},{"name":"算法_最短路","slug":"算法-最短路","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"算法_搜索","slug":"算法-搜索","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"},{"name":"算法_二分","slug":"算法-二分","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"},{"name":"Network","slug":"Network","permalink":"http://example.com/tags/Network/"},{"name":"算法_并查集","slug":"算法-并查集","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法_图论","slug":"算法-图论","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"},{"name":"算法_哈希","slug":"算法-哈希","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"}]}