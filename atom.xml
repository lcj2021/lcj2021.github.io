<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liucj&#39;s Harbour</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-11T15:06:22.192Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题解 - Codeforces Round 685 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-11T15:06:22.192Z</updated>
    
    <content type="html"><![CDATA[<p>做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了</p><h2 id="C-String-Equality"><a href="#C-String-Equality" class="headerlink" title="C. String Equality"></a><a href="https://codeforces.com/contest/1451/problem/C">C. String Equality</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给两个字符串a和b，问a能不能通过无限次操作到b.</p><p>第一种操作，相邻交换字符；</p><p>第二种操作，选取区间长度为k的子串,而且子串中的字母都 &lt;’z’，每一个字母都加一（比如S0=’a’ 操作后,S0=’b’) </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Circle-Game"><a href="#D-Circle-Game" class="headerlink" title="D. Circle Game"></a><a href="https://codeforces.com/contest/1451/problem/D">D. Circle Game</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一个d和R,A和B轮流操作，从(0,0)开始移动，可以选择 x+=d 或者 y+=d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候，那个人就输了</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-Bitwise-Queries-Hard-Version"><a href="#E-Bitwise-Queries-Hard-Version" class="headerlink" title="E. Bitwise Queries (Hard Version)"></a><a href="https://codeforces.com/contest/1451/problem/E2">E. Bitwise Queries (Hard Version)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 n 的数组(n 是 2 的幂) ，有 3 种操作，AND OR XOR，可以获得数组两个元素的 AND OR XOR 值，仅限 n+1 次操作求原数组</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先考虑以 $a_1$ 为基准求出 $a_1 \oplus a_k$，这样只要求出 $a_1$ 就可以求出整个数组，这一步需要 $n-1$ 次操作。</p><p>因为只有 $n$ 个元素，元素的范围是 $[0,n-1]$，所以可以进行分类讨论：</p><p>1.所有元素并不是互不相同。也就是说有重复的元素，这样只要找到相同的元素，对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值），又因为知道了所有元素和 $a_1$ 的 XOR，所以可以直接算出整个数组。考虑如何找到相同的元素，可以开个桶记录每个元素出现的次数。取最大的出现次数（这种情况下至少两次），然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素，任意取两个询问 AND 就可以了。不过这里有个要注意的，如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素，取 $1$ 询问即可。</p><p>2.所有元素互不相同。也就是是 $[0,n-1]$ 的全排列。考虑 XOR 的性质，相同就是 $0$，也就是说可以选择 $1$ 这个数，只有最后一位是 $1$，其他都是 $0$，也就是说如果 $a_1\oplus a_k=1$，$a_1$ 和 $a_k$ 只有最后一位不一样，可以通过 AND 操作求出前 $\log n-1$ 位。同理如果 $a_1\oplus a_k=\frac n2$，$a_1$ 和 $a_k$ 只有第一位不一样，可以通过 AND 操作求出后 $\log n-1$ 位。把两个结果组合一下（直接或起来）就可以得到 $a_1$。其实不一定要选择 $1$ 和 $\frac n2$，只要保证这两个数二进制下每位都至少有个数是 $0$ 就行。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AND</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;AND &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">XOR</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XOR &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  cnt[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        xr[i] = <span class="built_in">XOR</span>(<span class="number">1</span>, i);</span><br><span class="line">        cnt[xr[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a1, mx_show_xr = <span class="built_in">max_element</span>(<span class="built_in">all</span>(cnt)) - cnt.<span class="built_in">begin</span>(); <span class="comment">// mx_show_xr: 出现最多的xr值</span></span><br><span class="line">    <span class="keyword">if</span> (cnt[mx_show_xr] &gt; <span class="number">1</span>) &#123;        <span class="comment">// n个数中有重复的</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dulplicate_pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123; </span><br><span class="line">            <span class="comment">// if (cnt[xr[i]] == cnt[mx_show_xr]) &#123;         // X!!! cnt一致的xr值可能有多个!!!</span></span><br><span class="line">            <span class="keyword">if</span> (xr[i] == mx_show_xr) &#123;</span><br><span class="line">                dulplicate_pos.<span class="built_in">pb</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(dulplicate_pos)</span><br><span class="line">        <span class="comment">// assert(dulplicate_pos.size() &gt; 1);</span></span><br><span class="line">        <span class="type">int</span> a_dulplicate;</span><br><span class="line">        <span class="keyword">if</span> (dulplicate_pos.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(<span class="number">1</span>, dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(dulplicate_pos.<span class="built_in">front</span>(), dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        a1 = a_dulplicate ^ mx_show_xr;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// n个数无重复, 就是[0, n-1]的全排列 </span></span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), <span class="number">1</span>) - xr.<span class="built_in">begin</span>();         <span class="comment">// a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同</span></span><br><span class="line">        <span class="type">int</span> py = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), n / <span class="number">2</span>) - xr.<span class="built_in">begin</span>();</span><br><span class="line">        a1 = <span class="built_in">AND</span>(<span class="number">1</span>, px) | <span class="built_in">AND</span>(<span class="number">1</span>, py);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了&lt;/p&gt;
&lt;h2 id=&quot;C-String-Equality&quot;&gt;&lt;a href=&quot;#C-String-Equality&quot; class=&quot;headerlink&quot; title=&quot;C. String Equ</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round #843 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-11T09:15:22.450Z</updated>
    
    <content type="html"><![CDATA[<p>次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.</p><p>补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题</p><h2 id="A-Gardener-and-the-Capybaras"><a href="#A-Gardener-and-the-Capybaras" class="headerlink" title="A. Gardener and the Capybaras"></a><a href="https://codeforces.com/contest/1775/problem/A2">A. Gardener and the Capybaras</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将仅包含a和b的字符串s分成三部分s=s1+s2+s3，使得s2是这三个部分的一个最值（最大值或最小值，按字典序比较）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;=s3</p><p>s2为min: 直接拿一个a就行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">substr</span>(i + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aaaabaaab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>  &lt;&lt; s.<span class="built_in">substr</span>(i, n - i - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a><a href="https://codeforces.com/contest/1775/problem/B">B. Gardener and the Array</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>记 f(a) 是 a 数组中，所有数的按位或。现有 n 个数 c1,c2…cn组成的数组，询问是否有两个不同的子数组 a 和 b ，使得 f(a)=f(b)数据保证所有数的二进制中 1 的数量之和不超过$10^5$</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci) = f(cj | ck). 如下样例:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 2 4</span><br><span class="line">2 2 3</span><br><span class="line">4 3 4 </span><br></pre></td></tr></table></figure><p>所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(n);</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; cnt(200000 + 10, 0);</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k;  cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            c[i].<span class="built_in">pb</span>(x);</span><br><span class="line">            cnt[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(all(c[i]));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = c[i];</span><br><span class="line">        <span class="type">bool</span> suc = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">            suc &amp;= (cnt[x] &gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Interesting-Sequence"><a href="#C-Interesting-Sequence" class="headerlink" title="C. Interesting Sequence"></a><a href="https://codeforces.com/contest/1775/problem/C">C. Interesting Sequence</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于n，求最小的m，使得 n&amp;(n+1)&amp;…&amp;m = x</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>获取x的二进制长度: floor(log2(x)) + 1</strong></p><p>每一二进制位上, 只可能从无0变成有0<br>所以x只可能是n的二进制子集<br>某一二进制位经历从1变成0, 全部低位肯定全部经历过全0<br>所以: x只能保留n高位1的子集<br>他的高一位也要经历翻转<br>所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行<br>注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行</p><p>n: 0000110111100000101 101101011001110100111011001000000000000000000<br>x: 0000110111100000101 000000000000000000000000000000000000000000000<br>ans: -1 (公共前缀最后一位是1)</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000000000000000000000000000000000000000000000<br>ans: 000011011110000011</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000010000000000000000000000000000000000000000<br>ans: -1 (mask &amp; x != x)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) &#123;        <span class="comment">// &amp; 只会变小</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> bit = <span class="built_in">floor</span>(<span class="built_in">log2</span>(n)) + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; (<span class="number">1ll</span> &lt;&lt; bit) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">62</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b &gt;= <span class="number">0</span>; -- b) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; b &amp; <span class="number">1</span>) == (n &gt;&gt; b &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            mask |= (<span class="type">int</span>)(x &gt;&gt; b &amp; <span class="number">1</span>) &lt;&lt; b;</span><br><span class="line">            last = (x &gt;&gt; b &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (x &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;  </span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">1</span> || (mask &amp; x) != x) &#123;            <span class="comment">// 1011 -&gt; 1010</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后1个1的位置</span></span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    mask |= <span class="number">1ll</span> &lt;&lt; (b);</span><br><span class="line">    cout &lt;&lt; mask &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上对拍数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span>  </span>&#123;<span class="keyword">return</span> <span class="built_in">mrand</span>() % x + <span class="number">1</span>; &#125;   <span class="comment">// [1, x]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    vector pw&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rnd</span>(<span class="number">1000</span>), b = pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>] + pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>];</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-D-Friendly-Spiders"><a href="#D-D-Friendly-Spiders" class="headerlink" title="D. D. Friendly Spiders"></a><a href="https://codeforces.com/contest/1775/problem/D">D. D. Friendly Spiders</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边。请找到 s 和 t 的最短路径. $1\le n, a_i\le 3\times 10^5$</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>边权01 -&gt; 01bfs</p><p>建图问题:</p><ul><li>每一次遇到一个数时，即使它只有一条边，我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图</li><li>图的边数很多，没有办法快速求解</li></ul><p>从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n</p><p>最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \sqrt{n})$. bfs复杂度$O(n + n \sqrt{n})$</p><p>坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建.</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v2id</span>(<span class="number">300000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v2id[x].<span class="built_in">pb</span>(++ idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; <span class="built_in">g</span>(<span class="number">600000</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_p</span><span class="params">(<span class="number">300000</span> + <span class="number">10</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300000</span>; ++ i) &#123;</span><br><span class="line">        <span class="comment">// if (st[i])      continue;</span></span><br><span class="line">        <span class="keyword">if</span> (!is_p[i])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 2, 4, 6, 8, 10...之间连边 打电话式建图n^2</span></span><br><span class="line">        <span class="comment">// 交换机式建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">300000</span>; j += i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j != i)     is_p[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v2id[j].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> uid : v2id[j]) &#123;</span><br><span class="line">                    g[uid].<span class="built_in">pb</span>(&#123;i + <span class="number">300000</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                    g[i + <span class="number">300000</span>].<span class="built_in">pb</span>(&#123;uid, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dq;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, inf)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;                        dq.<span class="built_in">pb</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (dq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = dq.<span class="built_in">front</span>();     dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cv == t) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : g[cv]) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(cv, nv, w)</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &gt; dist[cv] + w) &#123;</span><br><span class="line">                dist[nv] = dist[cv] + w;</span><br><span class="line">                pre[nv] = cv;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">                    dq.<span class="built_in">pb</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.<span class="built_in">push_front</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(dist[t])</span><br><span class="line">    <span class="keyword">if</span> (dist[t] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> now = t;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">while</span> (now != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt;= <span class="number">300000</span>) &#123;</span><br><span class="line">            path.<span class="built_in">pb</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        now = pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(path));</span><br><span class="line">    <span class="built_in">LOG</span>(path)</span><br><span class="line">    cout &lt;&lt; path.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : path) cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-E-The-Human-Equation"><a href="#E-E-The-Human-Equation" class="headerlink" title="E. E. The Human Equation"></a><a href="https://codeforces.com/contest/1775/problem/E">E. E. The Human Equation</a></h2><p>晚上再补</p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.&lt;/p&gt;
&lt;p&gt;补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛65 A-F</title>
    <link href="http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/"/>
    <id>http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/</id>
    <published>2023-01-08T16:00:00.000Z</published>
    <updated>2023-01-10T12:18:49.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-牛牛写情书"><a href="#B-牛牛写情书" class="headerlink" title="B - 牛牛写情书"></a><a href="https://ac.nowcoder.com/acm/contest/49888/B">B - 牛牛写情书</a></h2><h3 id="题意-分析"><a href="#题意-分析" class="headerlink" title="题意 + 分析"></a>题意 + 分析</h3><p>判断模式串T是否是给定串S的子串.<br>瞎写双指针      X<br>KMP / 双哈希            V<br>5e3: 直接substr暴力$n^2$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string os, k;    cin &gt;&gt; os &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(os[i])) &#123;</span><br><span class="line">            s.<span class="built_in">pb</span>(os[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m - <span class="number">1</span> &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, m) == k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-牛牛排队伍"><a href="#C-牛牛排队伍" class="headerlink" title="C - 牛牛排队伍"></a><a href="https://ac.nowcoder.com/acm/contest/49888/C">C - 牛牛排队伍</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面。老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c =&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？</p><p>一共会有 k 次操作, 每次会执行下面的一种：</p><ol><li>把 x 叫走</li><li>求排在 x 前面的是谁</li></ol><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pre, nxt模拟双向链表</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            nxt[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;  cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = pre[x], b = nxt[x];</span><br><span class="line">            pre[x] = nxt[x] = <span class="number">0</span>;</span><br><span class="line">            nxt[a] = b;</span><br><span class="line">            pre[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; pre[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-牛牛取石子"><a href="#D-牛牛取石子" class="headerlink" title="D - 牛牛取石子"></a><a href="https://ac.nowcoder.com/acm/contest/49888/D">D - 牛牛取石子</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取：</p><blockquote><p>第一堆取 1 个, 第二堆取 2 个<br>第一堆取 2 个, 第二堆取 1 个</p></blockquote><p>谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1e18: 打表找规律</p><p>模仿是博弈里面的一个重要的策略, 主要思想:<br>断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法</p><p>a, b两堆石子, 必败态是: min(a, b) % 3 == 0. 因为后手总是可以控制min(a, b)在一轮下来-3<br>B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1<br>B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:<br>A: 5 4<br>B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输<br>原因在于: 若min(a, b) % 3 != 0     A总是可以把min(a, b) % 3 == 0的局面给B</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> C = <span class="number">15</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">awin</span>(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(C + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">awin[<span class="number">1</span>][<span class="number">2</span>] = awin[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= C; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= C; ++ j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span>)   awin[i][j] |= !awin[i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">1</span>)   awin[i][j] |= !awin[i - <span class="number">2</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)  <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> r = a / <span class="number">3</span>;      <span class="comment">// ab互走r轮对称棋</span></span><br><span class="line">    b = b - r * <span class="number">3</span>;</span><br><span class="line">    a = a - r * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span>(a, b) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-牛牛的构造"><a href="#E-牛牛的构造" class="headerlink" title="E - 牛牛的构造"></a><a href="https://ac.nowcoder.com/acm/contest/49888/E">E - 牛牛的构造</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \leq i&lt;j \leq n$ &amp;&amp; $a_i - a_j = 2^x(x\in N)(1\le n \le 10^6, 1\le k \le 10^9)$</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>考虑降序的排列: 9 8 7 6 5 4 3 2 1</p><blockquote><p>f[x]: 降序排列时, x对xi-xj=2^k 的贡献<br>f[9]: 4<br>f[8]: 3<br>f[7]: 3<br>f[6]: 3<br>f[5]: 3<br>f[4]: 2<br>f[3]: 2<br>f[2]: 1<br>f[1]: 0</p></blockquote><p>先降序, 后升序<br>降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]<br>升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0<br>​</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="built_in">popcountll</span>(i - <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(f)</span><br><span class="line">    <span class="type">int</span> mxk = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(f), (<span class="type">int</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mxk &lt; k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dec, inc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= f[i]) &#123;</span><br><span class="line">            dec.<span class="built_in">pb</span>(i);</span><br><span class="line">            k -= f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            inc.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(inc));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : dec)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : inc)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-牛牛的考试"><a href="#F-牛牛的考试" class="headerlink" title="F -  牛牛的考试"></a><a href="https://ac.nowcoder.com/acm/contest/49888/F">F -  牛牛的考试</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？<br>若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟.</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间</p><blockquote><p>对于同一门课而言:<br>双开时间可以转成单开时间, 即双开可以反悔成单开.<br>但是单开不能转成双开, 否则说明同时用手机电脑学同一门课.</p></blockquote><p>所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dp;   <span class="comment">// dp[i][0] : 双开时间, dp[i][1] : 单开时间</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>, 2&gt; <span class="title">add</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125;</span></span><br><span class="line">    <span class="comment">// &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125;</span></span><br><span class="line">    <span class="comment">// &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>])    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">min</span>(a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] -= d, a[<span class="number">1</span>] += <span class="number">2</span> * d;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] + b[<span class="number">0</span>] + <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]), <span class="built_in">max</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]) - <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;;</span><br><span class="line">    <span class="comment">// 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的</span></span><br><span class="line">    <span class="comment">// return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u] = <span class="built_in">add</span>(dp[u], dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][<span class="number">1</span>] += a[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    g.<span class="built_in">resize</span>(n);    dp.<span class="built_in">resize</span>(n);   a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;   x--;</span><br><span class="line">        g[i].<span class="built_in">pb</span>(x); g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-牛牛写情书&quot;&gt;&lt;a href=&quot;#B-牛牛写情书&quot; class=&quot;headerlink&quot; title=&quot;B - 牛牛写情书&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/49888/B&quot;&gt;B - 牛牛写情书</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.19-12.25</title>
    <link href="http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/"/>
    <id>http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2023-01-11T09:16:19.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-19-周一-晴"><a href="#12-19-周一-晴" class="headerlink" title="12.19 周一  晴"></a>12.19 周一  晴</h2><p>今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我.</p><p>虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;,</p><h2 id="12-20-周二-晴"><a href="#12-20-周二-晴" class="headerlink" title="12.20 周二  晴"></a>12.20 周二  晴</h2><p>待填</p><h2 id="12-21-周三-晴"><a href="#12-21-周三-晴" class="headerlink" title="12.21 周三  晴"></a>12.21 周三  晴</h2><p>待填</p><h2 id="12-22-周四-多云"><a href="#12-22-周四-多云" class="headerlink" title="12.22 周四  多云"></a>12.22 周四  多云</h2><h2 id="12-23-周五-阴"><a href="#12-23-周五-阴" class="headerlink" title="12.23 周五 阴"></a>12.23 周五 阴</h2><p>待填</p><h2 id="12-24-周六-晴"><a href="#12-24-周六-晴" class="headerlink" title="12.24 周六 晴"></a>12.24 周六 晴</h2><p>今天是考研第一天</p><p>晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了.</p><h2 id="12-25-周日-晴"><a href="#12-25-周日-晴" class="headerlink" title="12.25 周日 晴"></a>12.25 周日 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.29日晚22点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-19-周一-晴&quot;&gt;&lt;a href=&quot;#12-19-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.19 周一  晴&quot;&gt;&lt;/a&gt;12.19 周一  晴&lt;/h2&gt;&lt;p&gt;今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.12-12.18</title>
    <link href="http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/"/>
    <id>http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/</id>
    <published>2022-12-19T16:00:00.000Z</published>
    <updated>2023-01-11T09:16:29.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-12-周一-晴"><a href="#12-12-周一-晴" class="headerlink" title="12.12 周一  晴"></a>12.12 周一  晴</h2><p>早上刷题。</p><p>下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》，同时刷题。主要是《D. Range = √Sum》这题，1800构造，只能想出偶数的构造方法，奇数情况还是过于抽象了。</p><p>晚上吃师生缘的煎饼果子，看完了《剃须。然后捡到高中生》。个人认为这番其实还算治愈番，但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩。可能是这还只是我正式进军二次元后看的第二部番，姑且还觉得不错，挺期待剃须出第二部的。</p><p>晚上跟zzm及他同学联机深岩银河。</p><h2 id="12-13-周二-晴"><a href="#12-13-周二-晴" class="headerlink" title="12.13 周二  晴"></a>12.13 周二  晴</h2><p>日程基本同周一。</p><h2 id="12-14-周三-晴"><a href="#12-14-周三-晴" class="headerlink" title="12.14 周三  晴"></a>12.14 周三  晴</h2><p>日程基本同周一。下番《辉夜大小姐想让我告白》全部三季。晚餐尝试了步步高门口街道上的潼关肉夹馍，10块量少但味道不错。</p><h2 id="12-15-周四-多云"><a href="#12-15-周四-多云" class="headerlink" title="12.15 周四  多云"></a>12.15 周四  多云</h2><p>今天9:45-11:45 是《高性能计算》的期末考试。虽然线上考试并且开卷，但我仍觉得很难。老师也觉得很难，所以又延长了10分钟到11:55。我12点整把试卷拍照上传助教邮箱。挺无语的，本来就一限选，还搞严格的签到、实验和线上考试。</p><p>晚上zwling发消息说南京站的物资到了，惊喜的是外套居然还带ICPC标。相比之下沈阳的廉价格子衫就是屑了。</p><h2 id="12-16-周五-阴"><a href="#12-16-周五-阴" class="headerlink" title="12.16 周五 阴"></a>12.16 周五 阴</h2><p>待填</p><h2 id="12-17-周六-晴"><a href="#12-17-周六-晴" class="headerlink" title="12.17 周六 晴"></a>12.17 周六 晴</h2><p>今天14:00-16:00是ICPC南京站的热身赛。10点半不到我就吃了午餐，午餐在师生缘吃的自助。同样还是12点小睡了30分钟到1点起床。我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合，一起前往院楼。看得出zwling似乎有些生病，不过都拼到这一步了，我相信大家都是想让本科的ICPC生涯有始有终的。</p><p>走到天马公寓门口时，后面一位好心的小姐姐提醒了我书包在漏水。听到她的提醒我先是愣了下，随后立马把笔记本电脑拿了出来。之前其实也发生过水壶漏水的事故，并且电脑都没啥事。但是这次漏水偏偏赶在热身赛赛前1小时不到，并且还刚好是3人3机位。一看到电脑朝下的那一边湿了一大片，内心也凉了大半截。不过好在有初中毕业游手机进水的经验，这次还是学聪明了：虽然很想知道电脑是否还健在，也很想知道明天的正式赛会不会受到影响，我也还是忍住没按下开机键，在路上全称用手拎着电脑边甩边让风吹，到院楼放在门口晒了20分钟。热身赛马上就要开始了，我只能按下开机键，已经做好了最坏的打算。电脑也跟我开了个玩笑，开机成功后自己又重启了，不过好在这只是系统更新。最后电脑开是能开，但是左下角的屏幕就暗一片亮一片。</p><p>热身赛开始阶段我们跟着榜，着力于过题数最多的B，却发现只能想到6次方（n=20）的做法。我的想法是每次直接找第一个1，然后BFS到另外一个1，将轨迹应用于全图。这样每次至少减少1个1，复杂度虽然不会超，但是却无法保证轨迹总长度不超过50000，所以也没敢上机写。可是诡异的是很多支队伍都很快通过了。前1小时我们都还是1题没过。直到姜哥看到D题题面有对B题随机化解法的代码，才发现这是往年南京站原题。于是姜哥很快把D题签了，然后把D题的代码直接复制到B，至此B也过了。最后的A题我和zwling想出了二分的假算法，前期一直没找到钱越多买的书越多的反例，因此也就因此WA。姜哥及时提出了反例，并且给出了正确的贪心做法，只不过此时已经接近结束了。</p><p>虽说我们热身赛封榜前一道没过，排在了300名左右。在回宿舍的路上，姜哥还说他隔壁宿舍有人羊了。按照我一直奉为圭臬的人品守恒定律，我已经看到了明天的结果：高数100将在南京站修成正果。首先是队长zwling生病疑似阳性，然后又是我电脑进水。接下来又是姜哥附近与有人确诊。这无疑给了我莫大的鼓舞。回到园区后，zwling还是去门口核酸亭做了混检。</p><p>晚上打了atcoder Beginner Contest 282，直接D题罚坐。rk2000+，看来青名又要离我远去了。</p><h2 id="12-18-周日-晴"><a href="#12-18-周日-晴" class="headerlink" title="12.18 周日 晴"></a>12.18 周日 晴</h2><p>仍是凌晨1点睡，只不过早上9:30起床，10:00前进餐完毕，只吃了肉松饼和上次CCSP发的零食，睡了20来分钟。10:00出发去院楼参加南京正式赛。</p><p>开题签到题I，在我们迟疑的功夫，已经过了快300人了。</p><p>第二题G贪心，姜哥首先发现要贪心0前半段要取1，后半段取-1，随后我提出了二分分界线。姜哥提出可以O(n)做，但是写挂了，于是我就上机开始二分了。又到了经典二分分界线环节，我还被这个分界线在最左边的情况卡了10分钟，不愧是我……不过好在在姜哥提醒下，很快就写完了。幸运地一发A了。</p><p>第三题看着像计算几何，姜哥一开始就说这题很简单，只需要判断v型就行了，我和zwling都是懵的。随后姜哥画了几下就上机码了，第一发没过。随后过了10来分钟他想出了corner case，交上去居然直接过了。当然我们也只是开心了一下，毕竟从此到结束，我们都再也没能过一道题。</p><p>第四题大模拟二维前缀和，我们还剩2小时的时间。我想的是用将轨迹表示成一个01矩阵，然后再用这个矩阵和最后袋鼠组成的矩形，做类似求交算移入移出了多少。姜哥表示应该确实就只是二维前缀和，随后就开始码。但是最后因为查不出哪里越界，一直段错误。</p><p>结束后，虽然zwling觉得可能还是打铁，但我和姜哥都觉得铜牌概率蛮大。</p><p>5:30开始滚榜，当看到《高数100》出现在铜牌区时，我意识到本科的算法竞赛已经没有遗憾了。我觉得这次铜牌不仅幸运女神站在我们这边，更重要的是队伍的实力确实有所上升，毕竟这次zwling生病了。如果他没生病，我估计我们能将A题调出来。最后本科的所有XCPC至此都告一段落了，希望zwling能在BUAA找到更强的队友，继续在算法竞赛上取得更高的成就，也希望姜哥顺利上岸，在研究生阶段继续发挥他过人的思维优势。最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家。</p><p>接下来就是修改《软件工程》课程大作业的报告，并且收拾行李，准备第二天9点的高铁了。要好好放松下了，首先得先把剩下的2集麻衣学姐看完hh。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.20日晚22点</p><p>BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐</p><p>我把《高数100》的队牌带回了宿舍，跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起。这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-12-周一-晴&quot;&gt;&lt;a href=&quot;#12-12-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.12 周一  晴&quot;&gt;&lt;/a&gt;12.12 周一  晴&lt;/h2&gt;&lt;p&gt;早上刷题。&lt;/p&gt;
&lt;p&gt;下午和zzm在综楼二楼教员休息室下番《冰菓》《</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2022-11-07T16:03:22.710Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/44749">比赛链接</a></p><h2 id="Dijkstra-松弛的理解"><a href="#Dijkstra-松弛的理解" class="headerlink" title="Dijkstra 松弛的理解"></a>Dijkstra 松弛的理解</h2><p>“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比。最初，最短路径的成本被高估了，就像延伸的弹簧一样。当找到更短的路径时，估计的成本会降低，弹簧会放松。最终，找到了最短的路径（如果存在），并且弹簧已经松弛到其静止长度。</p><h2 id="D-点分治分点"><a href="#D-点分治分点" class="headerlink" title="D - 点分治分点"></a>D - 点分治分点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>G&lt;n, m&gt;, 且$n, m \leq 1e5$，定义一条简单路径的 low 值为其路径上的边权的最小值，d(u, v) 为从 u 到 v 所有简单路径的最大 low 值。对于给定的s，u 从 1 到 n 输出 d(s, u)，如果没有任何一条简单路径则输出 -1。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>点边数1e5 -&gt; Dijkstra变形套路</p><p>dist[i]: s-&gt;i的每条路径最短边中的最大值</p><p>松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">// s-&gt;i 每条路径最短边中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[s] = inf;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;inf, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dist[cv] &gt; cd) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : G[cv]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &lt; <span class="built_in">min</span>(dist[cv], w)) &#123;</span><br><span class="line">                dist[nv] = <span class="built_in">min</span>(dist[cv], w);</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &lt; -inf / <span class="number">2</span> || dist[i] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">            dist[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/44749&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Dijkstra-松弛的理解&quot;&gt;&lt;a href=&quot;#Dijkstra-松弛的理解&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 第八届“图灵杯”个人赛</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2023-01-11T09:16:08.174Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/11746">比赛链接</a></p><h2 id="贪吃的派蒙"><a href="#贪吃的派蒙" class="headerlink" title="贪吃的派蒙"></a><a href="https://ac.nowcoder.com/acm/contest/11746/G">贪吃的派蒙</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在每一次的排队中，编号为i的角色领取上限为Ai，这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内。当一个角色领完本次的甜甜花酿鸡，他/她就会回到队列的末尾，直到所有甜甜花酿鸡都被吃完为止。当轮到一个角色领取时，如果所有的甜甜花酿鸡都被领完，那么他/她就要帮大家刷盘子。</p><p>贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小，那么他就把剩下的都吃完)。我们很容易找到派蒙的编号，Ax比其他所有的Ai都要大。大家都想让派蒙最后留下来刷盘子，请你写一个程序来判断这是否可能。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Seek-the-Joker-II"><a href="#Seek-the-Joker-II" class="headerlink" title="Seek the Joker II"></a><a href="https://ac.nowcoder.com/acm/contest/11746/E">Seek the Joker II</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子，一堆k-1，另一堆n-k，先取到任意一堆的最后一个输</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11746&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;贪吃的派蒙&quot;&gt;&lt;a href=&quot;#贪吃的派蒙&quot; class=&quot;headerlink&quot; title=&quot;贪吃的派蒙&quot;&gt;&lt;/a&gt;&lt;a </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 10.31-11.6</title>
    <link href="http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/"/>
    <id>http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/</id>
    <published>2022-11-05T16:00:00.000Z</published>
    <updated>2022-12-20T12:49:11.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-3-周四-晴"><a href="#11-3-周四-晴" class="headerlink" title="11.3 周四 晴"></a>11.3 周四 晴</h2><p>今天一早起来就看到知乎推送《多地核酸开始自费》，又了解到大舅那边前几天已经开始自费了，收费是4元/次。不禁联想到昨天还吐槽核酸检测人员的高收入。</p><p>早十有《高性能计算》，依旧是平平无奇地上半节课签到，课间从复邻舍401后门溜回宿舍。不过今天罗HZ老师提到了签到的问题，在课上指出了缺课达3次需要补卡。我想起上上周自己因为没看课表，直接漏掉了一次签到。不料午饭后，有同学在课程群里问有没有爬山组队。这才知道所谓的补卡其实是跟LHZ爬岳麓山，好感度++。自己也得找个机会把缺的这次签到补回来。</p><p>下午依旧是赛前的日常刷题。</p><p>晚饭步步高挑香小面。晚九点打算继续昨晚的师大天马宿舍之行。虽然没有大门大开，但是也只是扫个码就放行了。漫步在师大宿舍园区，我和ZZM都明显感觉到和湖大天马宿舍不同的地方。简单来说就是中南南校区和这里都更加具有校园的氛围，体现在绿化，路旁的人行道，路旁的宣传栏，也体现在这里建筑的杂乱。</p><h2 id="11-4-周五-晴"><a href="#11-4-周五-晴" class="headerlink" title="11.4 周五 晴"></a>11.4 周五 晴</h2><p>8点30分第一个下床。刷题。干午饭。学委此时也发了关于毕设导师的通知了，毕设郑老师之前提过，但是目前又没了消息。我最担心的是找不到愿意挂名的导师。</p><p>下午第三节有《软件工程》，课上做了些2022辽宁省赛的题目，发现题目难度不大。做了<a href="https://ac.nowcoder.com/acm/contest/43937/B">可莉的五子棋</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/M">画画</a>。<a href="https://ac.nowcoder.com/acm/contest/43937/I">图的分割</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/G">栈与公约数</a>暂时没想到做法。</p><p>晚上有例行的每周大组会，我问了WSH，发现大家都找了毕设的导师，所以我也打算把当前进度汇报一下，顺便问问毕设的事情。于是跟老师和彭Z约了明天晚上讨论进度。</p><h2 id="11-5-周六-晴"><a href="#11-5-周六-晴" class="headerlink" title="11.5 周六 晴"></a>11.5 周六 晴</h2><p>今天14:00-16:00是ICPC沈阳站的热身赛。所以10点半不到就吃了午餐，休息小睡了20分钟后。便在阜埠河公交站和zwl骑车去院楼105准备上机环境。</p><p>在比赛开始时，zwl的后置录像手机夹住了关机键，手机直接关机了，所以我们整场比赛都没法正常交题。不过还是能看题面，A题签到，B题是输出 (随机生成)满足条件的a序列的期望。公式是$\frac{(n!)^2}{n^n}$。就是不知道<code>double</code>的精度能否满足要求。C题是类似石子合并的DP题。但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$，所以最后只能写一个假算法。赛后问了SJ，得知是四边形不等式决策单调性相关，打扰了。</p><p>晚上的Atcoder只打了半小时。</p><h2 id="11-6-周日-晴"><a href="#11-6-周日-晴" class="headerlink" title="11.6 周日 晴"></a>11.6 周日 晴</h2><p>总结: 遗憾打铁<br>仍是凌晨1点睡，8:30起床，10:30前进餐完毕，睡了10来分钟。11:30到院楼参加沈阳正式赛。</p><p>开题签到题，统计字符串中T和D的个数，WA了一发。<br>第二题找规律题，姜哥首先发现r取越大越好，但是只考虑a[i]作为左端点，没加上右端点的情况，WA了一发</p><p>第三题构造题，我首先用子矩阵数量公式判断出了无解情况。ZWL打表，发现了长相特殊的合法情况，所以尝试将二维压缩为一维。问题转换成把一个数分解成若干个$\frac{i \times (i+1)}{2}$表示。我提出从i从高到低贪心，二分i的位置，上机同时姜哥找反例。姜哥发现没有反例并且提出可以线性，但是我写到后面犯傻，直接神志不清，并不清楚线性的意思。于是姜哥接过来完成算法。第一发TLE，<code>endl</code>原因。第二发WA，爆<code>long long</code>。最后过了</p><p>第四题大模拟暴搜，题意没读懂，其实就是炉石随从攻击的逻辑，奈何没玩过。调试1个半小时，没能调对第二个样例。以为是精度问题。最后Rank290+无奈打铁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;11-3-周四-晴&quot;&gt;&lt;a href=&quot;#11-3-周四-晴&quot; class=&quot;headerlink&quot; title=&quot;11.3 周四 晴&quot;&gt;&lt;/a&gt;11.3 周四 晴&lt;/h2&gt;&lt;p&gt;今天一早起来就看到知乎推送《多地核酸开始自费》，又了解到大舅那边前几天已经开始自费了</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 275 A-F</title>
    <link href="http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/"/>
    <id>http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/</id>
    <published>2022-11-03T16:00:00.000Z</published>
    <updated>2023-01-10T10:30:15.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个$r \times c (r, c\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数.</p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##.......</span><br><span class="line">##.......</span><br><span class="line">.........</span><br><span class="line">.......#.</span><br><span class="line">.....#...</span><br><span class="line">........#</span><br><span class="line">......#..</span><br><span class="line">.........</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子.</p><p>具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子.</p><p>因此，答案是 2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标.</p><p>向量<code>[x, y]</code>顺时针旋转90°: <code>[y, -x]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rot</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = v;</span><br><span class="line">    v = &#123;y, -x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">9</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j) </span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">7</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ci = <span class="number">1</span>; ci &lt;= <span class="number">9</span>; ++ ci) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cj = <span class="number">1</span>; cj &lt;= <span class="number">9</span>; ++ cj) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ni = <span class="number">1</span>; ni &lt;= <span class="number">9</span>; ++ ni) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> nj = <span class="number">1</span>; nj &lt;= <span class="number">9</span>; ++ nj) </span><br><span class="line">                    <span class="keyword">if</span> (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[ni][nj] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                        array&lt;<span class="type">int</span>, 2&gt; v = &#123;ni - ci, nj - cj&#125;;</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i3 = ni + v[<span class="number">0</span>], j3 = nj + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i4 = i3 + v[<span class="number">0</span>], j4 = j3 + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7)   cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">check</span>(i3, j3) &amp;&amp; <span class="built_in">check</span>(i4, j4)</span><br><span class="line">                        &amp;&amp; g[i3][j3] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[i4][j4] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl;</span></span><br><span class="line">                            set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; s;</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ci, cj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ni, nj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i3, j3&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i4, j4&#125;);</span><br><span class="line">                            S.<span class="built_in">insert</span>(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>为非负整数 x 定义的函数 f(x) 满足以下条件：</p><ul><li><p>$f(0) = 1$</p></li><li><p>$f(k) = f(\lfloor \frac{k}{2}\rfloor) + f(\lfloor \frac{k}{3}\rfloor)$ 对于任何正整数 k</p></li></ul><p>然后找到 $f(N), N\in[0, 1^{18}]$.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>最多需要$log_2n \times log_3n$这么多个数的f值. 标准记搜</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.<span class="built_in">count</span>(u))    <span class="keyword">return</span> dp[u];</span><br><span class="line">    <span class="keyword">return</span> dp[u] = <span class="built_in">dfs</span>(u / <span class="number">2</span>) + <span class="built_in">dfs</span>(u / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; dp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个一维的棋盘上有 N + 1 个格子，下标从 0 到 N ，玩家要从 0 这个点出发，前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子，每个骰面上都有不同的数字，值域是 $[1, M]$ ，扔出每个面的概率都是 $\frac{1}{M}$ . 玩家需要根据要出来的骰面前进，如果预计前进之后走出了棋盘，就需要退回多走出的步数，如果在终点停了下来，游戏就胜利了，不能再扔骰子. 问 K 回合后，玩家胜利的概率. 将结果对 998244353 取模.</p><p>$0 \le M \le N \le 1000, M \in [1, 10], K \in [1, 1000]$ .</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令 dp[i][j] 为扔第 j 次骰子后，玩家到达下标为 i 的格子的概率.</p><p>对于每一个 dp[i][j]  $dp[next_i][j + 1] = dp[i][j] \times \frac{1}{M}$. 注意如果走出了棋盘，要特殊讨论停下来的下标.</p><p>已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dp[N][N];       <span class="comment">// 到达第i格, 共走了j步的所有情况之和</span></span><br><span class="line"><span class="comment">// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m_1 = <span class="built_in">qmi</span>(m , mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= m; ++ len) &#123;</span><br><span class="line">                <span class="type">int</span> ni = i + len;</span><br><span class="line">                <span class="keyword">if</span> (ni &gt; n) &#123;</span><br><span class="line">                    ni = n - (ni - n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// if (next_i &lt;= i) &#123;</span></span><br><span class="line">                <span class="comment">//     cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                dp[ni][j + <span class="number">1</span>] += (dp[i][j] * m_1) % mod;</span><br><span class="line">                dp[ni][j + <span class="number">1</span>] %= mod;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][j + <span class="number">1</span>] += dp[n][j];</span><br><span class="line">        dp[n][j + <span class="number">1</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 A ，定义一次操作的内容是，删除 A 中一段连续的序列.</p><p>问对于 1, 2, …, M 中的每个数 s ，分别至少要操作多少次， 才能使得 A 中剩下的数和为 s ，如果不可能就输出 -1 .</p><p>$0 \le N \le M \le 3000， 1 \le a_i \le 3000$</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组分段式的DP, 用一个维度表示当前元素是否在分段中</p><p>dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中</p><p>如果a[i]不计入总和: <code>dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;);</code></p><p>如果a[i]计入总和: <code>dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;);</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];            <span class="comment">// 前i个数, 构成总和为j, 且第i个数是否在总和中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (j - a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;dp[n][j][<span class="number">0</span>], dp[n][j][<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)   ans = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的</p><p>C 模拟 + 向量旋转</p><p>D 记忆化搜索</p><p>E 概率DP</p><p>F DP + 数组划分 / 选取子段</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;一个$r \t</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_实现" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法_搜索" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 192 D-F</title>
    <link href="http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/"/>
    <id>http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/</id>
    <published>2022-11-02T16:00:00.000Z</published>
    <updated>2023-01-10T10:31:15.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定整数 $X, X \in [1, 10^{60}]$和 $M, M \in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. </p><p>求对于所有的 $a&gt;d,a \in \mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\le M$. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. </p><p>注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. </p><p>同时, <code>long long</code> 相乘可能会爆, 必须乘乘数<code>base</code>之前判断当前<code>val &gt; target / base </code>. 或者用 <code>__int128</code>AtCoder 支持 或龟速乘. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string x;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    <span class="type">signed</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : x)  mx = <span class="built_in">max</span>(mx, ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;                        <span class="comment">// 特判: 因为题目要求不同的数</span></span><br><span class="line">        <span class="keyword">if</span> (mx &lt;= m)    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> base) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; m / base) &#123;               <span class="comment">// 每次 + *base 之前 跟目标 /base 作比较 防止溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> b = x[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            val *= base;</span><br><span class="line">            val += b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (val &lt;= m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = mx, r = <span class="number">1e18</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))         l = mid;</span><br><span class="line">        <span class="keyword">else</span>                    r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; l - mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$G(N, M), N, M \leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\in\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 <code>-1</code>. </p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k;</span><br><span class="line">        G[a].<span class="built_in">pb</span>(&#123;b, t, k&#125;);</span><br><span class="line">        G[b].<span class="built_in">pb</span>(&#123;a, t, k&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;, vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;, greater&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x] = <span class="number">0</span>;    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, x&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, t, k] : G[cv]) &#123;</span><br><span class="line">            <span class="type">int</span> nd = (cd + k - <span class="number">1</span>) / k * k;</span><br><span class="line">            nd = nd + t;</span><br><span class="line">            <span class="comment">// cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (nd &lt; dist[nv]) &#123;</span><br><span class="line">                dist[nv] = nd;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;nd, nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (dist[y] &gt;= <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)  cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>                                    cout &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定数组a[N], $a[i] \leq 1e7$和$X \in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数</p><p>枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. </p><p><code>dp[k][i][j]</code> = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值</p><p>不拿第k个物品: <code>dp[k][i][j] = dp[k - 1][i][j];</code></p><p>拿第k个物品: <code>dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]);</code></p><p>总复杂度 $\mathcal{O}(n^4)$. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">int</span> a[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][N];        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> choose = <span class="number">1</span>; choose &lt;= n; ++ choose) &#123;</span><br><span class="line">        <span class="type">int</span> m = x % choose;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   w[i] = a[i] % choose;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">// dp[k][i][j] = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(k, choose); ++ i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; choose; ++ j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i][j]) &#123;</span><br><span class="line">                        dp[k][i][j] = dp[k - <span class="number">1</span>][i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose]) &#123;</span><br><span class="line">                        dp[k][i][j] = <span class="built_in">max</span>(dp[k][i][j], dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose] + a[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose</span></span><br><span class="line">        <span class="keyword">if</span> (~dp[n][choose][m]) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (x - dp[n][choose][m]) / choose);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>D 考察乘法溢出, 各种边界讨论比较繁琐</p><p>E 最短路变形, 松弛边权做一下变化即可</p><p>F 背包+模数, 在外层套一层for模数<code>choose</code>, 状态表示加一个维度表示当前总和mod <code>choose</code>的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定整数 $X</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_二分" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛34 A-H</title>
    <link href="http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/"/>
    <id>http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-01-10T15:52:59.228Z</updated>
    
    <content type="html"><![CDATA[<p>这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题).</p><h2 id="A-dd爱科学1-0-2-0"><a href="#A-dd爱科学1-0-2-0" class="headerlink" title="A - dd爱科学1.0+2.0"></a><a href="https://ac.nowcoder.com/acm/contest/11211/A">A - dd爱科学1.0</a><a href="https://ac.nowcoder.com/acm/contest/11211/C">+2.0</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>数组a[n](1≤n≤1000000, isupper(a[i]) == true). 求通过修改变成不下降序列的最小代价, 每次修改一个数x为y的代价为1(2.0版本为|x - y|).</p><blockquote><p>1.0 ACEBF -&gt; ACEEF 代价 = 1<br>2.0 AEEBC -&gt; AEEEE 代价 = 偏移量总和为|B-E|+|C-E|=3+2=5</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>dp[i][j]表示改至第i位为止, 最后一位为j的最小代价(或者理解成最后一位&lt;=j也行)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;         <span class="comment">// 当前字符为curr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; ++ k) &#123;      <span class="comment">// 从上一字符转移而来</span></span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][k] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到: min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了. 这样可以少O(26)的复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;</span><br><span class="line">    f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i)    f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> curr = str[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前字符改成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;</span><br><span class="line">            <span class="comment">//从上一字符转移而来</span></span><br><span class="line">            <span class="comment">// for(int k = 1; k &lt;= j; ++ k)</span></span><br><span class="line">                <span class="comment">// f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j));</span></span><br><span class="line">            <span class="comment">// min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)    ans = <span class="built_in">min</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-dd爱探险"><a href="#B-dd爱探险" class="headerlink" title="B - dd爱探险"></a><a href="https://ac.nowcoder.com/acm/contest/11211/B">B - dd爱探险</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n(3≤n≤16)个空间站, 任意两个空间站间可以相互跳跃, 由空间站x跳跃到空间站y所需要的代价为P[x][y],注意不保证p[x][y]=p[y][x], dd可以任意选择出发的空间站, 并通过恰好n-1次跳跃把所有空间站跳完, 并且dd必须选择2次跳跃, 其中一次跳跃中进行重力加速, 另一次跳跃中进行反重力加速, 重力加速会导致当前跳跃代价变为0, 反重力加速会导致当前跳跃代价翻倍(乘2), 问跳完所有空间站所需要最小代价</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>状压DP. 经典TSP like<br>dp[1 &lt;&lt; N][N][2][2]: 走过了i中为1的点,且当前最后到达j, g, rg是否用了重力 / 反重力</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span> &lt;&lt; N][N][<span class="number">2</span>][<span class="number">2</span>];        <span class="comment">// 是否用了重力 / 反重力</span></span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; i][i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">0</span>; val &lt; (<span class="number">1</span> &lt;&lt; n); ++ val) &#123;         <span class="comment">// 1e5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> from = <span class="number">0</span>; from &lt; n; ++ from) &#123;         <span class="comment">// 10</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; n; ++ to) &#123;           <span class="comment">// 10</span></span><br><span class="line">                <span class="keyword">if</span> ((val &gt;&gt; to &amp; <span class="number">1</span>) &amp;&amp; (val &gt;&gt; from &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[val][to][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">0</span>][<span class="number">0</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">0</span>][<span class="number">1</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">0</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">1</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">1</span>][<span class="number">0</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + w[from][to] * <span class="number">2</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">0</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">1</span>][<span class="number">1</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">0</span>] + <span class="number">0</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">1</span>] + w[from][to] * <span class="number">2</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">1</span>] + w[from][to]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-dd爱矩阵"><a href="#D-dd爱矩阵" class="headerlink" title="D - dd爱矩阵"></a><a href="https://ac.nowcoder.com/acm/contest/11211/D">D - dd爱矩阵</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给一个n∗n的矩阵，每行各选一个数字，把选出来的n个数字相加，一共有$n^{n}$ 种可行答案，输出前n大</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>优先队列 + 动态前k大 + 数组合并<br>先把问题简化一下，如果两行，每行 n个数，怎么选<br>把两行分别降序 sort，令第一行为数组 a，第二行为数组 b<br>则可得到最大值为 a[0]+b[0]，并且得到 a[i]+b[j-1]&gt;a[i]+b[j]&gt;a[i]+b[j+1]<br>所以可以把 a[0]+b[i]全部推入优先队列当中，并且标记对应的 i,每次取出 top，再把 a[0]+b[i+1]推入优先队列当中， n次操作即可得到前 n大<br>复杂度 O(nlogn)<br>回到这个题目，由于是 n行，可以每次处理两行，并成一行新的， n-1次操作把 n行并成一行，复杂度 O(n^2 logn)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;a[<span class="number">0</span>] + b[i], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> top = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> sum = top.first, idx = top.second;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;sum - a[idx] + a[idx + <span class="number">1</span>], idx + <span class="number">1</span>&#125;);</span><br><span class="line">        t[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)     cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) cin &gt;&gt; b[j];</span><br><span class="line">        <span class="built_in">merge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-dd爱旋转"><a href="#E-dd爱旋转" class="headerlink" title="E - dd爱旋转"></a><a href="https://ac.nowcoder.com/acm/contest/11211/E">E - dd爱旋转</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>读入一个n∗n的矩阵, 对于一个矩阵有以下两种操作<br>1:顺时针旋180°</p><blockquote><p>[1 2] =&gt; [4 3]<br>[3 4]    [2 1]</p></blockquote><p>2:关于行镜像</p><blockquote><p>[1 2] =&gt; [3 4]<br>[3 4]    [1 2]</p></blockquote><p>给出q个操作, 输出操作完的矩阵</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>操作1: 相当于行镜像, 列镜像各做一次<br>操作2: 相当于行镜像做一次</p><p>只用看操作1和操作2的奇偶性就行了</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">op1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j] = vis[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j] =  <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">swap</span>(m[i][j], m[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">op2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++ i)</span><br><span class="line">        <span class="built_in">swap</span>(m[i], m[n + <span class="number">1</span> - i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            cin &gt;&gt; m[i][j];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) ++ cnt1;</span><br><span class="line">        <span class="keyword">else</span>        ++ cnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1 % <span class="number">2</span>)    <span class="built_in">op1</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt2 % <span class="number">2</span>)    <span class="built_in">op2</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            cout &lt;&lt;  m[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-dd爱框框"><a href="#F-dd爱框框" class="headerlink" title="F - dd爱框框"></a><a href="https://ac.nowcoder.com/acm/contest/11211/F">F - dd爱框框</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>读入n(1≤n≤10000000),x(1≤x≤10000),给出n个数a[1],a[2],……,求最小的区间[l,r], 使a[l]+a[l+1]+……+a[r]≥x, 若存在相同长度区间, 输出l最小的那个</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>二分区间长度 + 前缀和check + 二分内更新答案<br>OR 滑动窗口(不会)</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i + len &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(s[i + len] - s[i - <span class="number">1</span>] &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            lbound = i, rbound = i + len;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">    &#123;</span><br><span class="line">        ll t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))    r = mid;</span><br><span class="line">        <span class="keyword">else</span>    l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; lbound &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rbound &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-dd爱捣乱"><a href="#G-dd爱捣乱" class="headerlink" title="G - dd爱捣乱"></a><a href="https://ac.nowcoder.com/acm/contest/11211/G">G - dd爱捣乱</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一个完美串(islower == true)应该满足该串中任意长度≥2≥2的子串都不是回文串, 把一个字符从xx变成yy的代价是min(|x-y|,26-|x-y|),(|x-y|为ascii码差值), 问把一个串变成完美串的最小代价</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先讨论完美串满足条件, 如果是奇串, 则每一位前后两位不同, 即 a[i-1]≠a[i+1]<br>如果是偶串, 则相邻两位不同 a[i]≠a[i-1]<br>综上, 只要<strong>任意连续三位都满足两两不同</strong>, 就是一个完美串<br>那么一个很显然的想法, 枚举每一位的情况, 保证再枚举前两位情况, 保证不同的情况下更新答案<br>复杂度 O(n×26^3), 显然不可接受<br>所以进一步想, 每一位最多只会受前两位和后两位的影响, 所以最差情况下五个字母全部不同(abccd, 中间的c要+=2. 如果只有±1,0就不行了). 实际上相邻三个字符各自改变量最多只有五种情况: ±2,±1,0. )<br>所以对于每一位只要枚举改变量就行了,  dp[i][j][k]表示把第 i-1位的改变量是 j, 第 i位的改变量是 k的最小代价<br>dp[i][j][k]←dp[i-1][l][j]<br>最后枚举最后两位改变量 min(dp[n][i][j])就是答案<br>复杂度 O(n×5^3)</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">10</span>, offset = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">6</span>][<span class="number">6</span>];    <span class="comment">// 第i-1位的改变量为j, 第i位的改变量为k</span></span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   a[i] = s[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[<span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span> != (a[<span class="number">2</span>] + k + <span class="number">26</span>) % <span class="number">26</span>) &#123;</span><br><span class="line">                dp[<span class="number">2</span>][j + offset][k + offset] = <span class="built_in">min</span>(dp[<span class="number">2</span>][j + offset][k + offset], <span class="built_in">abs</span>(j) + <span class="built_in">abs</span>(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;    <span class="comment">// i-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;        <span class="comment">// i</span></span><br><span class="line">                <span class="keyword">if</span> ((a[i] + k + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span>) &#123; <span class="comment">// dp[i][j][k]</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-2</span>; l &lt;= <span class="number">2</span>; ++ l) &#123;            <span class="comment">// i-2</span></span><br><span class="line">                        <span class="keyword">if</span> ( ((a[i - <span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">2</span>] + l + <span class="number">26</span>) % <span class="number">26</span>) </span><br><span class="line">                            &amp;&amp; ((a[i] + k + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">2</span>] + l + <span class="number">26</span>) % <span class="number">26</span>)) &#123;     <span class="comment">// dp[i - 1][l][j] </span></span><br><span class="line">                            dp[i][j + offset][k + offset] = <span class="built_in">min</span>(dp[i][j + offset][k + offset], dp[i - <span class="number">1</span>][l + offset][j + offset] + <span class="built_in">abs</span>(k));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[n][j + offset][k + offset]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-dd爱整齐"><a href="#H-dd爱整齐" class="headerlink" title="H - dd爱整齐"></a><a href="https://ac.nowcoder.com/acm/contest/11211/H">H - dd爱整齐</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>当k=1时abababab，k=2时abbabbabb，k=3时abbbabbb这种类型的是优美序列，现在给你一个数组a[n]和k((1≤k≤n≤1000000))，每次你可以让数组中的数减1，问你最少的操作次数使得n数组为k优美序列。当然不一定就是abbabb，bbabba这个也是2的优美序列。只要是优美序列的一段(子串)就行。同时要保证a&gt;=b。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>看到循环结构 / 循环节, 要往模数上想<br>目标序列作为k优美序列的子串, 注意到当len(目标序列) &gt;= k时, 每k个数就会固定有一个a, k-1个b, 所以只需要确认a的位置就行. </p><p>把位置i对 k+1取余，余数相等的位置的值必然相等. 因为给定了限制条件 a≥b, 所以通过简单贪心+前缀和计算把第i + Z*k位置上的数改变成a, 其他变成b的代价. 复杂度 O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;  </span><br><span class="line">    ++ k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">sum</span><span class="params">(k)</span>, <span class="title">cnt</span><span class="params">(k)</span>, <span class="title">mn</span><span class="params">(k, inf)</span></span>;</span><br><span class="line">    <span class="type">int</span> mna = <span class="number">1e18</span>, suma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];    mna = <span class="built_in">min</span>(mna, a[i]);   suma += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        sum[i % k] += a[i];</span><br><span class="line">        cnt[i % k] ++;</span><br><span class="line">        mn[i % k] = <span class="built_in">min</span>(mn[i % k], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;      <span class="comment">// 把第i个数变成a, 其他的数变成b</span></span><br><span class="line">        <span class="type">int</span> val = sum[i] - cnt[i] * mn[i] + (suma - sum[i]) - (n - cnt[i]) * mna;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题).&lt;/p&gt;
&lt;h2 id=&quot;A-dd爱科学1-0-2-0&quot;&gt;&lt;a href=&quot;#A-dd爱科学1-0-2-0&quot; class=&quot;headerlink&quot; title=&quot;A - dd爱科学1.</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/"/>
    <id>http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-01-10T10:30:54.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-国际象棋"><a href="#D-国际象棋" class="headerlink" title="D - 国际象棋"></a>D - 国际象棋</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\“四个方向上已经连了几个了.</p><p>注意不能分8个方向</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, t;</span><br><span class="line"><span class="type">int</span> h[N], g[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tt = <span class="number">1</span>; tt &lt;= t; ++ tt) &#123;</span><br><span class="line">        <span class="type">int</span> col, x = tt % <span class="number">2</span>;    cin &gt;&gt; col;</span><br><span class="line">        g[++ h[col]][col] = x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cx = h[col], cy = col;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//         for (int i = n; i &gt;= 1; -- i)   for (int j = 1; j &lt;= m; ++ j)   cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \n&quot;[j == m];</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; g[cx + <span class="number">1</span>][cy] == x)   ++ cx, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy] == x)   -- cx, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx][cy + <span class="number">1</span>] == x)   ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col; </span><br><span class="line">        <span class="keyword">while</span> (cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx][cy - <span class="number">1</span>] == x)   -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx + <span class="number">1</span>][cy + <span class="number">1</span>] == x)   ++ cx, ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy - <span class="number">1</span>] == x)   -- cx, -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx + <span class="number">1</span>][cy - <span class="number">1</span>] == x)   ++ cx, -- cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy + <span class="number">1</span>] == x)   -- cx, ++ cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; \\ &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-弹珠碰撞"><a href="#E-弹珠碰撞" class="headerlink" title="E - 弹珠碰撞"></a>E - 弹珠碰撞</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>长度为 n 的线段上，有 m 颗弹珠在匀速以1单位/s 左右滚动。弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. </p><p>两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动，并交换两颗弹珠滚动的方向。一颗弹珠可以反复发生碰撞，如果在停滞中受到碰撞，则停滞时间会累加。</p><p>如果一颗弹珠滚到了位置 0 或位置 n+1，那么这颗弹珠就滚出了线段。问最后一颗弹珠在什么时候滚出线段？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>a -&gt;  &lt;- b 左右两个弹珠相撞后</p><p>&lt;-a   b -&gt; </p><p>&lt;-b   a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的</p><p>算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行.</p><p>​    </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d, p;</span><br><span class="line">&#125; ball[N];</span><br><span class="line"><span class="type">int</span> pre1[N];        <span class="comment">// -&gt;</span></span><br><span class="line"><span class="type">int</span> suf0[N];        <span class="comment">// &lt;-</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].p;</span><br><span class="line">    <span class="built_in">sort</span>(ball + <span class="number">1</span>, ball + <span class="number">1</span> + m, [&amp;](<span class="keyword">auto</span> &amp;a, <span class="keyword">auto</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   pre1[i] = pre1[i - <span class="number">1</span>] + (ball[i].d == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; -- i)   suf0[i] = suf0[i + <span class="number">1</span>] + (ball[i].d == <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, p] = ball[i];</span><br><span class="line">        <span class="type">int</span> t = (d ? (n + <span class="number">1</span> - p) + suf0[i] : p + pre1[i]);</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-困难卷积"><a href="#F-困难卷积" class="headerlink" title="F - 困难卷积"></a>F - 困难卷积</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定整数序列 a[n], b[n]，求：<br>$$<br>\sum_{i=1}^n\sum_{j=1}^n\Big\lfloor\sqrt{|a_i-b_j|}\Big\rfloor<br>$$</p><p>其中 $\lfloor x\rfloor$表示不超过 x 的最大整数，例如 $\lfloor 3.5\rfloor=3,\lfloor\sqrt 2\rfloor =1$。</p><p>$1≤n≤10^6，0\leq a_i,b_i\leq 3\times 10^6，\sum a_i,\sum b_i\leq 10^7$。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>3e6 排除暴力. 注意到$\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnta, cntb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i], cnta[a[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; b[i], cntb[b[i]] ++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [va, ca] : cnta) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [vb, cb] : cntb) &#123;</span><br><span class="line">            ans += <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">abs</span>(va - vb))) * ca * cb;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-国际象棋&quot;&gt;&lt;a href=&quot;#D-国际象棋&quot; class=&quot;headerlink&quot; title=&quot;D - 国际象棋&quot;&gt;&lt;/a&gt;D - 国际象棋&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/31/hello-world/"/>
    <id>http://example.com/2022/10/31/hello-world/</id>
    <published>2022-10-31T11:31:34.473Z</published>
    <updated>2022-10-31T11:29:53.845Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 下使用 Clash 代理</title>
    <link href="http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-10-31T16:21:23.581Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu科学上网</p><ol><li> 在 <a href="https://link.zhihu.com/?target=https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a> 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash。</li><li> 添加执行权限（sudo chmod + x clash），将 clash 放到 /usr/bin/ 目录下（sudo cp clash /usr/bin/）。</li><li> 在终端中运行 clash，会在 ~/.config/clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件。用商家提供的替换这两个文件，重新运行 clash。</li><li>设置系统代理：<br> <img src="/images/2022-02-02-clash-on-Ubuntu_1.png" alt="1"></li></ol><blockquote><ol><li>用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响。</li><li>将clash进程加入开机自启动</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ubuntu科学上网&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 在 &lt;a href=&quot;https://link.zhihu.com/?target=https://github.com/Dreamacro/clash/releases&quot;&gt;https://github.com/Dreama</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Network" scheme="http://example.com/tags/Network/"/>
    
  </entry>
  
</feed>
