<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liucj&#39;s Harbour</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-22T02:56:09.823Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周记 - 2023 01.09-01.15</title>
    <link href="http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/"/>
    <id>http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-01-22T02:56:09.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-09-周一-晴"><a href="#01-09-周一-晴" class="headerlink" title="01.09 周一  晴"></a>01.09 周一  晴</h2><p>早上十点开始vp Educational Codeforces Round 141. 嗯, 只做了2题, 第二题经典构造矩阵, 做了一个多小时. 其实C题我也不会, 是一道关于最佳可能排名的贪心题. 贪心还是得多练, 正解是二分. D题dp, muggle用的记忆化搜索, 看了他的代码感觉记搜确实得熟练起来. </p><p>晚上八点20开始vp 小白月赛65. 表现依然糟糕, 只会3题. 并且这次的B题是考察字符串匹配, 其实暴力n^2就行. 我非得试着用双指针. 这也暴露出我对字符串匹配的理解误区. 要是真能双指针直接瞎搞, 那还要啥KMP呢? D题这种1e18的一眼结论题, 但是没想过打表, 比赛经验太差. 正解是”模仿棋”. E构造, F贪心 + 树形dp. </p><h2 id="01-10-周二-晴"><a href="#01-10-周二-晴" class="headerlink" title="01.10 周二  晴"></a>01.10 周二  晴</h2><p>早上补了昨晚的DEF. </p><p>下午晚上补了我第一场牛客比赛(小白月赛34)的所有题. 基本以dp为主, 然后还有一道经典 矩阵每行取数, 求前k大的题. 堆 + 合并行贪心. </p><h2 id="01-11-周三-晴"><a href="#01-11-周三-晴" class="headerlink" title="01.11 周三  晴"></a>01.11 周三  晴</h2><p>早上10点开始vp 843(div2). 可以算是形势逆转的一局, 虽然一开始经典卡B, 但是对拍调完C之后, 还是想出了B. 赛后发现C有1600分. </p><h2 id="01-12-周四-晴"><a href="#01-12-周四-晴" class="headerlink" title="01.12 周四  晴"></a>01.12 周四  晴</h2><p>考虑到18号要回大埔过年, 早上先花了点时间下番&lt;更衣人偶坠入爱河&gt;, 但是没有外挂弹幕, 告辞, 晚点再来. 9点40开始vp 839(div3). 表现垃圾. 只会3道. D是拆绝对值 + 约束答案范围. </p><p>中午看到2022南京终于上了cf gym. 看到了&lt;高数100&gt;, 看到了自己和队友们的名字. 在第一页尾部, 相信很快就会被vp的大佬们压下去.  </p><p>下午2点郑老师发来vx说给我发些奖励, 问我银行卡之类的信息. </p><h2 id="01-13-周五-晴"><a href="#01-13-周五-晴" class="headerlink" title="01.13 周五  晴"></a>01.13 周五  晴</h2><p>下午1点突然想看看2022南京的正解, 于是想到zwling之前说的dianhsu写的插件. 用这个插件可以在别人的submission中查看gym的代码. 之后我下了dls的A和D的代码, 然而题目都记不清了. </p><p>下午3点开组会, 和顾学长一起获得了三等奖金, 发了言. 和组里的大部分同学都不熟, 所以挺紧张的. </p><p>组会上我得知很多学长学姐都在2022年做出了A类工作. 心情十分复杂, 想搞科研, 但是心里有放不下CP. 可能是心愿还没有达成吧. 至于这个心愿, 我也不知道具体是个什么样的目标. </p><h2 id="01-14-周六-晴"><a href="#01-14-周六-晴" class="headerlink" title="01.14 周六  晴"></a>01.14 周六  晴</h2><p>vp 844(div1+2)</p><h2 id="01-15-周七-晴"><a href="#01-15-周七-晴" class="headerlink" title="01.15 周七  晴"></a>01.15 周七  晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.21(2022除夕)日午12点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-09-周一-晴&quot;&gt;&lt;a href=&quot;#01-09-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;01.09 周一  晴&quot;&gt;&lt;/a&gt;01.09 周一  晴&lt;/h2&gt;&lt;p&gt;早上十点开始vp Educational Codeforces Roun</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 89 A-D</title>
    <link href="http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/"/>
    <id>http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-01-21T03:16:42.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-Practical-Skill-Test"><a href="#D-Practical-Skill-Test" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Practical-Skill-Test-1"><a href="#D-Practical-Skill-Test-1" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个h * w的矩阵a, 里面不重不漏地填充着[1, h * w]的数字. 现在给定一个正整数d ([1, h * w]), 并且给出q组询问: </p><blockquote><p>l, r</p><p>问: a[x1][y1] == l —&gt; a[x2][y2] == l + d —&gt; … —&gt; a[xn][yn] == r</p><p>这段路所走过的曼哈顿距离是多少</p></blockquote><blockquote><p>曼哈顿距离: (x1, y1)与(x2, y2)的曼哈顿距离是|x1 - x2| + |y1 - y2|</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="倍增-我的思路"><a href="#倍增-我的思路" class="headerlink" title="倍增 (我的思路)"></a>倍增 (我的思路)</h4><p>既然无法记录从每个点(a值==i)出发到[i+1, n]的所有距离, 那么就可以考虑倍增</p><p>to[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走到的点</p><p>dist[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走过的路程</p><p>边界: to超出h * w的部分要特判0</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">to</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u + d &lt;= h * w; ++ u) &#123;</span><br><span class="line">        to[u][<span class="number">0</span>] = u + d;</span><br><span class="line">        dist[u][<span class="number">0</span>] = a2cor[u + d] - a2cor[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt; <span class="number">20</span>; ++ b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= h * w; ++ u) &#123;</span><br><span class="line">            to[u][b] = to[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">            dist[u][b] = dist[u][b - <span class="number">1</span>] + dist[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> binary_jump = [&amp;](<span class="type">int</span> S, <span class="type">int</span> T) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">19</span>; b &gt;= <span class="number">0</span>; -- b) <span class="keyword">if</span> (to[S][b] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to[S][b] &lt;= T) &#123;</span><br><span class="line">                ans += dist[S][b];</span><br><span class="line">                S = to[S][b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(S == T);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">binary_jump</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前缀和-官方题解"><a href="#前缀和-官方题解" class="headerlink" title="前缀和 (官方题解)"></a>前缀和 (官方题解)</h4><p>pre[i] 表示a[i - kd] —&gt; a[i - (k-1)d] —&gt; a[i - d] —&gt; a[i] 的路程之和</p><p>pre[i] = pre[i - d] + dist(i - d, i)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(h * w + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= h * w; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">4</span>] + (a2cor[i] - a2cor[i - <span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; pre[r] - pre[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-Practical-Skill-Test&quot;&gt;&lt;a href=&quot;#D-Practical-Skill-Test&quot; class=&quot;headerlink&quot; title=&quot;D - Practical Skill Test&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://a</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_倍增" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>笔记 - CP模板</title>
    <link href="http://example.com/2023/01/18/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2023/01/18/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-01-17T16:00:00.000Z</published>
    <updated>2023-01-20T02:58:29.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计数模板"><a href="#计数模板" class="headerlink" title="计数模板"></a>计数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> + (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> - (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> * (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> / (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *= (<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> /= (<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="type">int</span> v; os &gt;&gt; v; a = <span class="built_in">ModInt</span>(v); <span class="keyword">return</span> os;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b; <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>) u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;mod&gt;;</span><br></pre></td></tr></table></figure><h2 id="字符串-双-哈希"><a href="#字符串-双-哈希" class="headerlink" title="字符串(双)哈希"></a>字符串(双)哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">hash_t</span> = array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod0 = <span class="number">1e9</span> + <span class="number">7</span>, mod1 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">hash_t</span> base = &#123;<span class="number">13331</span>, <span class="number">23333</span>&#125;;</span><br><span class="line"><span class="type">hash_t</span> pw[N];</span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> + (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] + b[<span class="number">0</span>]) % mod0, (a[<span class="number">1</span>] + b[<span class="number">1</span>]) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> - (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] - b[<span class="number">0</span>] + mod0) % mod0, (a[<span class="number">1</span>] - b[<span class="number">1</span>] + mod1) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> * (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] * b[<span class="number">0</span>] % mod0, a[<span class="number">1</span>] * b[<span class="number">1</span>] % mod1&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pw[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pre[i] = pre[i - <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">    suf[i] = suf[i + <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计数模板&quot;&gt;&lt;a href=&quot;#计数模板&quot; class=&quot;headerlink&quot; title=&quot;计数模板&quot;&gt;&lt;/a&gt;计数模板&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记_模板" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D</title>
    <link href="http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/"/>
    <id>http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/</id>
    <published>2023-01-16T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:50.353Z</updated>
    
    <content type="html"><![CDATA[<p>比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.</p><p>补题: D因式分解 + 枚举因子 + 压缩状态</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分别计算俩点向四个方向的墙面相连的距离, 求最小值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w, d, h;    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class="line">    <span class="type">int</span> a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> dist1 = <span class="built_in">min</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist2 = <span class="built_in">min</span>(b, g);</span><br><span class="line">    <span class="type">int</span> dist3 = w - <span class="built_in">max</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist4 = d - <span class="built_in">max</span>(b, g);</span><br><span class="line">    <span class="type">int</span> ans1 = <span class="number">2</span> * dist1 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans2 = <span class="number">2</span> * dist2 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans3 = <span class="number">2</span> * dist3 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans4 = <span class="number">2</span> * dist4 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;ans1, ans2, ans3, ans4&#125;);</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Going-to-the-Cinema"><a href="#B-Going-to-the-Cinema" class="headerlink" title="B. Going to the Cinema"></a><a href="https://codeforces.com/contest/1782/problem/B">B. Going to the Cinema</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一: </p><ol><li>自己去,但除自己外去的人数 &lt; ai</li><li>自己不去,但除自己外去的人数&gt;= ai</li></ol><p>问有多少种选择去的人的集合的方案,使得没有人伤心.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>设去的人的集合A={p1,⋯,pa},不去的人的集合B={q1,⋯,qb},则A⋃B={1,⋯,n},a+b=n.​</p><ol><li>对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \geq \max_{1 \leq i\leq a} a_{p_i}$.​    </li><li>对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当<br>$a &lt; \min_{1\leq j\leq b} a_{q_j}$.</li></ol><p>枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1]</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + n + <span class="number">1</span>);</span><br><span class="line">    a[n + <span class="number">1</span>] = inf; a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; a[i] &amp;&amp; i &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++ ans;</span><br><span class="line">            <span class="built_in">LOG</span>(i, a[i], a[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Equal-Frequencies"><a href="#C-Equal-Frequencies" class="headerlink" title="C. Equal Frequencies"></a><a href="https://codeforces.com/contest/1782/problem/C">C. Equal Frequencies</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>称一个字符串是好的,如果每种字符出现的次数都相等. </p><p>n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t.</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n / seg</p><p>首先将字母按照cnt[26] (字母出现频数) 降序排序, 要<strong>尽最大可能利用现有的多的字母</strong></p><p>以下代码用来找到最小的代及cost其对应的ac</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">    <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">        mn_cost = now;          best_ac = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要统计<strong>cnt不足ac的部分</strong>就行了, 不足的部分肯定是需要其他redundant的来补充的. </p><p>aim[26]表示t中每个字母的目标次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">    aim[ord[i]] = best_ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来只需要看s[i]的cnt: </p><ol><li>cnt &gt;  aim[s[i]], 在26个字母中找cnt还不足aim的进行替换</li><li>cnt &lt;= aim[s[i]], 跳过</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)   cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ord</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(<span class="built_in">all</span>(ord), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(ord), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt[a] &gt; cnt[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// d: n的因子, 作为每个字母的出现次数</span></span><br><span class="line">    <span class="type">int</span> mn_cost = n, best_ac = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">        <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">            mn_cost = now;          best_ac = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> best_seg = n / best_ac;</span><br><span class="line">    <span class="built_in">LOG</span>(mn_cost, best_ac, best_seg)</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">aim</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">        aim[ord[i]] = best_ac;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(aim)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aim[ch - <span class="string">&#x27;a&#x27;</span>] &gt;= cnt[ch - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; <span class="number">26</span>; ++ to) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aim[to] &gt; cnt[to]) &#123;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">                ch = (<span class="type">char</span>)to + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Many-Perfect-Squares"><a href="#D-Many-Perfect-Squares" class="headerlink" title="D. Many Perfect Squares"></a><a href="https://codeforces.com/contest/1782/problem/D">D. Many Perfect Squares</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>非递减数组a<a href="1%E2%89%A4n%E2%89%A450">n</a>. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数. </p><p>例如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 13 22 90</span><br></pre></td></tr></table></figure><p>选择 x = 3</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4,9,16,25,93</span><br></pre></td></tr></table></figure><p>4,9,16,25,93<br>最多有4个完全平方数</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x. </p><p>先sort(all(a))</p><p>设有 $i &lt; j, a_i + x = va^2 ,a_j + x = vb^2$ </p><p>对完全平方数做差有$vb^2 - va^2 = (vb-va)(vb+va) = a_j + x - (a_i + x) = a_j - a_i$</p><p>令 diff = aj - ai</p><p>则 (vb - va)(vb + va) = diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d = diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x = va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x. </p><p>用dp[x] |= 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意. </p><p>最后统计一下每个x的二进制1个数就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> diff = a[j] - a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> div = <span class="number">1</span>; div * div &lt;= diff; ++ div) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff % div != <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> diva = div, divb = diff / div;</span><br><span class="line">                <span class="keyword">if</span> (diva % <span class="number">2</span> != divb % <span class="number">2</span>)     <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 12 = 2 * 6       va = 2, vb = 4    </span></span><br><span class="line">                <span class="comment">// x = va * va - a[i]</span></span><br><span class="line">                <span class="type">int</span> va = (divb - diva) / <span class="number">2</span>, vb = (diva + divb) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> x = va * va - a[i];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>)                      <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">LOG</span>(a[i], a[j], diff, va, vb)</span><br><span class="line">                dp[x] |= (<span class="number">1ll</span> &lt;&lt; i) | (<span class="number">1ll</span> &lt;&lt; j);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;        <span class="comment">// 只有1个数a, 肯定能找到x, 使得a+x是平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, val] : dp) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)<span class="built_in">popcountll</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.&lt;/p&gt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_实现" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="算法_数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 134 A-F</title>
    <link href="http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/"/>
    <id>http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/</id>
    <published>2023-01-14T16:00:00.000Z</published>
    <updated>2023-01-20T07:14:17.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="R2532橙题-F-Permutation-Oddness"><a href="#R2532橙题-F-Permutation-Oddness" class="headerlink" title="R2532橙题 F - Permutation Oddness"></a>R2532橙题 <a href="https://atcoder.jp/contests/abc134/tasks/abc134_f">F - Permutation Oddness</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>设 P = (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;=50)的排列. 定义Oddness:= $\sum |p_i - i|$. 求满足定义Oddness = k 的不同排列P的数量</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解.</p><p>这里以<a href="https://img.atcoder.jp/abc134/editorial.pdf">官方题解</a>为基础, 加以翻译并解释. </p><blockquote><p>若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K</p></blockquote><p>dp[i][j][k][l]=表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. </p><p>因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j=k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. </p><p>状态转移方程写作：<br>dp[i][j][k] = (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j]</p><p>当考虑第i个数与盒子的时候, 分5种情况: </p><blockquote><p>数i和盒子i直接配对, 未配对的依然是j个</p><p>但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j];</p></blockquote><blockquote><p>数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</p><p>未配对的数-1, 盒子数-1, 所以未配对的-1个. </p><p>当前状态j, 所以上一状态j+1</p><p>有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1);</p></blockquote><blockquote><p>数i和盒子i都不配对, 未配对的是j+1个</p><p>有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j &gt;= 1)     dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j];</p></blockquote><p>注意, 可能情况个数要从上一状态出发考虑</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mint dp[N][N][N * N];    </span><br><span class="line"><span class="comment">// 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对</span></span><br><span class="line"><span class="comment">// 且 当前的奇异值为k的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * j; k &lt;= n * n; ++ k) &#123;</span><br><span class="line">                <span class="comment">// 数i和盒子i直接配对, 未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j];</span><br><span class="line">                <span class="comment">// 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</span></span><br><span class="line">                <span class="comment">// 未配对的数-1, 盒子数-1, 所以未配对的-1个. </span></span><br><span class="line">                <span class="comment">// 当前状态j, 所以上一状态j+1</span></span><br><span class="line">                <span class="comment">// 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= i) dp[i][j][k] += dp[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">2</span> * j] * (j + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 数i和盒子i都不配对, 未配对的是j+1个</span></span><br><span class="line">                <span class="comment">// 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span>)     dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">2</span> * j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;R2532橙题-F-Permutation-Oddness&quot;&gt;&lt;a href=&quot;#R2532橙题-F-Permutation-Oddness&quot; class=&quot;headerlink&quot; title=&quot;R2532橙题 F - Permutation Oddness&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 797 (Div. 3) A-G</title>
    <link href="http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/"/>
    <id>http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/</id>
    <published>2023-01-13T16:00:00.000Z</published>
    <updated>2023-01-14T04:51:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. </p><p>补题: </p><h2 id="A-Print-a-Pedestal-Codeforces-logo"><a href="#A-Print-a-Pedestal-Codeforces-logo" class="headerlink" title="A. Print a Pedestal (Codeforces logo?)"></a><a href="https://codeforces.com/contest/1690/problem/A">A. Print a Pedestal (Codeforces logo?)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> d = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Array-Decrements"><a href="#B-Array-Decrements" class="headerlink" title="B. Array Decrements)"></a><a href="https://codeforces.com/contest/1690/problem/B">B. Array Decrements)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; d0, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> cd = b[i] - a[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            d0.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d.size == 1</span></span><br><span class="line">    <span class="keyword">if</span> (*d0.<span class="built_in">begin</span>() &lt; *d.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Restoring-the-Duration-of-Tasks"><a href="#C-Restoring-the-Duration-of-Tasks" class="headerlink" title="C. Restoring the Duration of Tasks"></a><a href="https://codeforces.com/contest/1690/problem/C">C. Restoring the Duration of Tasks</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d = f - s<br>否则当前任务到来时间s &lt; 上个任务完成时间 d = f - f[i - 1]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span> ,<span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : f)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span>, f[<span class="number">0</span>] - s[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; f[i - <span class="number">1</span>])    ans.<span class="built_in">pb</span>(f[i] - s[i]);</span><br><span class="line">        <span class="keyword">else</span>                    ans.<span class="built_in">pb</span>(f[i] - f[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Black-and-White-Stripe"><a href="#D-Black-and-White-Stripe" class="headerlink" title="D. Black and White Stripe"></a><a href="https://codeforces.com/contest/1690/problem/D">D. Black and White Stripe</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;   cin &gt;&gt; s;   s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = l + k - <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span> - (pre[r] - pre[l - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Price-Maximization"><a href="#E-Price-Maximization" class="headerlink" title="E. Price Maximization"></a><a href="https://codeforces.com/contest/1690/problem/E">E. Price Maximization</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以<br>的和k, 求和最大是多少</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分. </p><p>把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;=k - x, 所以lower_bound一下k - x</p><p>也可以把a排序, 然后首尾双指针搞搞</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ans += x / k;</span><br><span class="line">        x %= k;</span><br><span class="line">        <span class="keyword">if</span> (x)  S.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (S.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> itx = S.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 先取值, 再删除? </span></span><br><span class="line">        <span class="type">int</span> x = *itx;</span><br><span class="line">        S.<span class="built_in">erase</span>(itx);</span><br><span class="line">        <span class="keyword">auto</span> ity = S.<span class="built_in">lower_bound</span>(k - x);</span><br><span class="line">        <span class="keyword">if</span> (ity != S.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> y = *ity;</span><br><span class="line">            ans ++;</span><br><span class="line">            S.<span class="built_in">erase</span>(ity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Shifting-String"><a href="#F-Shifting-String" class="headerlink" title="F. Shifting String"></a><a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \sqrt{n})$</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;      cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        x --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (st[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = i;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line">        <span class="keyword">for</span> (; st[now] == <span class="number">-1</span>; now = p[now]) &#123;</span><br><span class="line">            loop.<span class="built_in">pb</span>(now);</span><br><span class="line">            st[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(loop)</span><br><span class="line">        deque&lt;<span class="type">char</span>&gt; dq0, dq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : loop) dq0.<span class="built_in">pb</span>(s[p]);</span><br><span class="line">        dq.<span class="built_in">assign</span>(<span class="built_in">all</span>(dq0));</span><br><span class="line">        <span class="type">int</span> cl = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (;cl &lt; loop.<span class="built_in">size</span>(); ++ cl) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = dq.<span class="built_in">back</span>(); dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            dq.<span class="built_in">push_front</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (dq == dq0) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len.<span class="built_in">pb</span>(cl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : len) &#123;</span><br><span class="line">        ans = <span class="built_in">lcm</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Count-the-Trains"><a href="#G-Count-the-Trains" class="headerlink" title="G. Count the Trains"></a><a href="https://codeforces.com/contest/1690/problem/G">G. Count the Trains</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少</p><p>例如[10, 13, 5, 2, 6] =&gt; [10, 10, 5, 2, 2] 一共有3种不同的数</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>维护每段火车的车头位置和整节车的速度. </p><p>在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车</p><p>如果速度x &gt;= 左边的火车段的速度, 就直接把it合并到左边(erase掉it)</p><p>如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)).</p><p>insert和erase的次数不会超过O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> i, <span class="type">int</span> x) &#123;</span><br><span class="line">        mp[i] = x;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(i);       <span class="comment">// 根据键key查找</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5    ---&gt; 9 10 | 5</span></span><br><span class="line">        <span class="keyword">if</span> (it != mp.<span class="built_in">begin</span>() &amp;&amp; <span class="built_in">prev</span>(it)-&gt;second &lt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5 | 3 | 1  ---&gt; 9 | 2 5 3 | 1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">next</span>(it) != mp.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it)-&gt;second &gt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(<span class="built_in">next</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k, d;   cin &gt;&gt; k &gt;&gt; d;      k --;</span><br><span class="line">        a[k] -= d;</span><br><span class="line">        <span class="built_in">add</span>(k, a[k]);</span><br><span class="line">        cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. &lt;/p&gt;
</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_组合数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_双指针" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>年记 - 2022</title>
    <link href="http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/"/>
    <id>http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/</id>
    <published>2023-01-12T16:00:00.000Z</published>
    <updated>2023-01-13T08:13:08.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-年终总结"><a href="#2022-年终总结" class="headerlink" title="2022 年终总结"></a>2022 年终总结</h1><p>刘城君</p><hr><h1 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h1><p>开始图划分的任务: 基于标签传播思想, 优化目标主要是复制因子RF. </p><p>随机初始化种子节点的tag, 多轮多源BFS的方式进行tag, 选取邻居最多的tag进行标记. </p><p>1度点优化. 1度点对RF没有影响</p><p>tag合并(按照tag规模/tag结点重合度). 但由于块数与节点数的数量关系限制, 效果不佳.</p><p>每个一次assign多个tag(一次性覆盖)</p><p>由于传播方式存在问题, 因此负载均衡很差. </p><hr><h1 id="9月-11月"><a href="#9月-11月" class="headerlink" title="9月 - 11月"></a>9月 - 11月</h1><p>期间阅读了HEP, NE等论文, 了解到Local search的策略, 以及分区boundary节点度数分布对RF的影响. 同时再次阅读了NE的源码. </p><p>为了优化负载均衡, 尝试在初始阶段就用BFS确定分区大致分布, 此阶段可以保障tag平衡. 第二阶段加入tag约束, 进行剩余节点的tag assignment. </p><p>效果较5月版本有明显进步, 数据集Lj上的表现(-p 8)为: RF=1.66-1.71 Balance = 1.05. 已经优于除NE外的其他算法. 但距离NE的1.33, 1.00仍有较大差距</p><hr><h1 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h1><p>分析RF和Tag的分区交界处节点的度数分布, 发现RF 2/3度点数量基本没有. </p><p>尝试将初始块变得更加紧密: 选k-core作为初始块. 效果一般</p><p>11月版本中第二阶段传播顺序诡异, 并且存在传播失败的可能. </p><p>尝试由当前的按照节点id顺序被动传播改成按照&lt;节点|tag|, 负载均衡, 节点度数&gt;的优先级进行BFS主动传播. 效果不如11月版本</p><hr><h1 id="1月-现在"><a href="#1月-现在" class="headerlink" title="1月 - 现在"></a>1月 - 现在</h1><p>修改第一阶段BFS的策略, 加入启发式策略: 优先扩展与Core紧密的节点. </p><p>基于NE的代码进行实现, 并且尝试两种版本: </p><blockquote><p>优先扩展与Core紧密的节点: RF: 1.7+, Balance: 1.00</p><p>优先扩展与Core+Boundary紧密的节点: 本质上就是NE, RF效果与NE十分接近</p></blockquote><p>在修改NE代码过程中, 意识到初始分区只分配p-1块, 最后1块分配p, 从而取消第二阶段的传播. 效果可能会优于当前版本</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>idea储备不足: 阅读更多相关论文</p><p>争取在RF / 实际任务效果上取得进展</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-年终总结&quot;&gt;&lt;a href=&quot;#2022-年终总结&quot; class=&quot;headerlink&quot; title=&quot;2022 年终总结&quot;&gt;&lt;/a&gt;2022 年终总结&lt;/h1&gt;&lt;p&gt;刘城君&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;5月&quot;&gt;&lt;a href=&quot;#5月&quot; cla</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 839 (Div. 3) A-G</title>
    <link href="http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/"/>
    <id>http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-01-14T11:50:06.534Z</updated>
    
    <content type="html"><![CDATA[<p>上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. </p><p>补题: D题要从题目限制的不等式去推出x的范围. F题发掘性质: 可染色的块一定是递减的. </p><h2 id="C-Different-Differences"><a href="#C-Different-Differences" class="headerlink" title="C. Different Differences"></a><a href="https://codeforces.com/contest/1772/problem/C">C. Different Differences</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Absolute-Sorting"><a href="#D-Absolute-Sorting" class="headerlink" title="D. Absolute Sorting"></a><a href="https://codeforces.com/contest/1772/problem/D">D. Absolute Sorting</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>a[n], 询问是否存在一个数x, a[i] &lt;- |a[i] - x|, 形成非单调递减序列, 如果不存在输出-1</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>假设找到了一个x满足题意. 那么就有|a[i] - x| &lt;= |a[i+1] - x|. </p><p>两边平方: $(a[i] - x)^2 \leq (a[i+1] - x)^2$<br>因式分解: $(a[i] - a[i+1])(a[i] + a[i+1] - 2x) \leq 0$</p><p>接下来逐个判断a[i] - a[i+1], 分类讨论: </p><blockquote><p>a[i] - a[i+1] &gt; 0: a[i] + a[i+1] - 2x &lt;= 0<br>a[i] - a[i+1] &lt; 0: a[i] + a[i+1] - 2x &gt;= 0</p></blockquote><p>即可得到x的范围</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> mx = (<span class="type">int</span>)<span class="number">2e9</span>, mn = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// (x - y)(x + y - 2x) &lt;= 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;    <span class="comment">// (x + y - 2x) &lt; 0</span></span><br><span class="line">            mn = <span class="built_in">max</span>(mn, x + y + <span class="number">1</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; y) &#123;   <span class="comment">// (x + y - 2x) &gt; 0</span></span><br><span class="line">            mx = <span class="built_in">min</span>(mx, x + y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;      <span class="comment">// x没有要求</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mn &lt;= mx) &#123;</span><br><span class="line">        cout &lt;&lt; mn &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Permutation-Game"><a href="#E-Permutation-Game" class="headerlink" title="E. Permutation Game"></a><a href="https://codeforces.com/contest/1772/problem/E">E. Permutation Game</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>题意, 在一个序列p中, AB两人轮流操作, 每次的操作选择</p><ol><li>将p中的某个数变为可调换位置的(涂色)</li><li>重新排列, 但只能调动可变换位置的</li><li>跳过回合</li></ol><p>如果最后形成上升序列甲赢, 递减序列乙赢, 否则平局</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><p>A要涂色的: p[3], p[4]<br>B要涂色的: p[3], p[4], p[1], p[2]</p><p>AB俩人都要涂色的: p[3], p[4]<br>只属于A自己要涂色的: 没有<br>只属于B自己要涂色的: p[1], p[2]</p><p>如果A把只有自己要涂色的(a)+公共涂色的都涂完了(c), B还剩下没涂, A就赢了<br>如果B把只有自己要涂色的(b)+公共涂色的都涂完了(c), A还剩下没涂, B就赢了</p><p>但是要注意A是先手, 所以就算AB同时涂完(b+c==a), 也算A赢. 其他都是平局, 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        x --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            ++ b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[i] == n - i - <span class="number">1</span>) &#123;</span><br><span class="line">            ++ a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++ c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a, b, c)</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b + c) &#123;    <span class="comment">// b先翻完. 如果相等的话, 后手染色完, 下一轮到先手, 先手就直接排序了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Second&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= a + c) &#123;   <span class="comment">// a先翻完, 由于a先手, 同时ab翻完也不行</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tie&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Copy-of-a-Copy-of-a-Copy"><a href="#F-Copy-of-a-Copy-of-a-Copy" class="headerlink" title="F. Copy of a Copy of a Copy"></a><a href="https://codeforces.com/contest/1772/problem/F">F. Copy of a Copy of a Copy</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个n行m列的01矩阵 (3≤n,m≤30). 其中0表示白色, 1表示黑色. 每次你可以选择以下操作的中的一个:</p><ol><li>选择一个不是边界的点 (i,j)(i≠1,i≠n,j≠1,j≠m), 并且他的上下左右的4个点, 其颜色都与之相反, 则把这个点变成相反的颜色. </li><li>创建一个当前矩阵的拷贝. </li></ol><p>执行了 k(k≤100)次拷贝操作. 现在给出制作的所有 k 个拷贝. 此外, 还有初始的矩阵.  然而, 所有k+1个矩阵的顺序被打乱了. 因为找出初始版本, 并且输出经过了哪些操作. </p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>一旦对某个单元格涂色, 就再也不能重新涂色了. 这是因为不能对它的邻居也重新涂色, 因为它们中的每一个都有至少一个相同颜色的邻居——这个单元格本身</p><p>这给了我们副本的顺序. 只需按照当前可以进行的重新涂色操作数量的降序对它们进行排序即可. 如果数字相同, 则副本必须相等, 因此它们的顺序无关紧要. </p><p>排序后, 考虑一对相邻图片的所有不同单元格. 不可能有两个不同的单元格彼此相邻. 因此, 任何操作都不能干扰另一个操作. 所以制作副本的时候, 随便顺序操作就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ++ k;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&gt; <span class="built_in">a</span>(k + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(m)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= k; ++ id) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">                cin &gt;&gt; a[id][i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">cnt</span>(k + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= k; ++ id) &#123;</span><br><span class="line">        cnt[id][<span class="number">1</span>] = id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">auto</span> cc = a[id][i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; ++ dir) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> nc = a[id][i + dx[dir]][j + dy[dir]];</span><br><span class="line">                    diff += (cc != nc);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[id][<span class="number">0</span>] += (diff == <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LOG(cnt)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(cnt) + <span class="number">1</span>, <span class="built_in">end</span>(cnt), greater&lt;array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt;());</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> g0 = a[cnt[i - <span class="number">1</span>][<span class="number">1</span>]], g1 = a[cnt[i][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; m; ++ l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g0[j][l] != g1[j][l]) &#123;</span><br><span class="line">                    ans.<span class="built_in">pb</span>(&#123;j, l&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pb</span>(&#123;<span class="number">-1</span>, cnt[i][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Gaining-Rating"><a href="#G-Gaining-Rating" class="headerlink" title="G. Gaining Rating"></a><a href="https://codeforces.com/contest/1772/problem/G">G. Gaining Rating</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>你在一个网站上下棋 , 初始你的等级为$x(x \le 10^{12})$ , 你想要升级到 y$(x &lt; y \le 10^{12})$你有$n(n \le 2 * 10^5)$个对手, 第i个队友的等级为 a[i]$(a[i] \le 10^{12})$ . 你需要与这些对手对战, 如果你的等级大于等于对手的等级, 你将获胜, 并且等级加1. 否则等级减1. </p><p>注意, 对手的等级不会发生变化. </p><p>为了防止你一直打最低等级的对手的, 网站有一个规定. 如果你要与对手 i 对战, 则应该没有其他对手 j, 使得你与 i 的比赛次数多于与 j 的比赛次数. 问你需要打多少局, 才能升到等级y, 如果不能输出-1. </p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>要想rating++, 肯定是先跟a[i]小于自己x的人先打, rating打上去了, 再找之前打不过的复仇, 从他们身上赚rating. 所以要先按照a升序排序. </p><p>先判断最开始一轮, rating能不能有所长进, 如果不能, 那就不行</p><p>算完第一轮的长进change之后, 开始逐个找之前打不过的人a[i]. 自己需要加win_t轮change, 最后第win_t + 1轮到达a[i]面前时, 我已经有了x + win_t * change + i的rating. 即$x + win_t * change + i \geq a[i]$. 取个ceil就可以算出复仇a[i]的轮数了</p><p>但是有可能在打败a[i]之前, 就已经达到了y的目标, 所以要算出suc_t = ceil(y - x - i, change). 如果win_t &gt;= suc_t, 就要进入最后一轮, 直到x&gt;=y. </p><p>直到最后全部a都能击败后, 直接随便挑对手就行了. 即ans += y - x(当前的rating)</p><p>注意上述的x, change和ans都是会实时更新的</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y;  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>; <span class="comment">// b: 是否可以击败i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;   <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    <span class="type">int</span> change = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= a[i])  ++ x, ++ change, ++ ans, b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>            -- x, -- change, ++ ans, b[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= y)     &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (change &lt;= <span class="number">0</span>)    &#123;cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">auto</span> ceil = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (b[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// x + win_t * change + i &gt;= a[i]</span></span><br><span class="line">        <span class="comment">// (a[i] - x - i) / change &lt;= win_t</span></span><br><span class="line">        <span class="type">int</span> <span class="type">win_t</span> = <span class="built_in">ceil</span>(a[i] - x - i, change);</span><br><span class="line">        <span class="comment">// x + suc_t * change + i &gt;= y</span></span><br><span class="line">        <span class="comment">// (y - x - i) / change &lt;= suc_t</span></span><br><span class="line">        <span class="type">int</span> <span class="type">suc_t</span> = <span class="built_in">ceil</span>(y - x - i, change);</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">win_t</span> &gt;= <span class="type">suc_t</span>) &#123;</span><br><span class="line">            ans += <span class="type">suc_t</span> * n;</span><br><span class="line">            x += <span class="type">suc_t</span> * change;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= a[j])  ++ x, ++ ans;</span><br><span class="line">                <span class="keyword">else</span>            -- x, ++ ans;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="keyword">return</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="type">win_t</span> * n;</span><br><span class="line">        x += <span class="type">win_t</span> * change;</span><br><span class="line">        b[i] = <span class="number">1</span>;</span><br><span class="line">        change += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans + y - x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. &lt;/p&gt;
&lt;p&gt;补题:</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 685 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-14T04:52:30.069Z</updated>
    
    <content type="html"><![CDATA[<p>做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了</p><h2 id="C-String-Equality"><a href="#C-String-Equality" class="headerlink" title="C. String Equality"></a><a href="https://codeforces.com/contest/1451/problem/C">C. String Equality</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给两个字符串a和b, 问a能不能通过无限次操作到b.</p><p>第一种操作, 相邻交换字符: </p><p>第二种操作, 选取区间长度为k的子串,而且子串中的字母都 &lt;’z’, 每一个字母都加一（比如S0=’a’ 操作后,S0=’b’) </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Circle-Game"><a href="#D-Circle-Game" class="headerlink" title="D. Circle Game"></a><a href="https://codeforces.com/contest/1451/problem/D">D. Circle Game</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一个d和R,A和B轮流操作, 从(0,0)开始移动, 可以选择 x+=d 或者 y+=d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候, 那个人就输了</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-Bitwise-Queries-Hard-Version"><a href="#E-Bitwise-Queries-Hard-Version" class="headerlink" title="E. Bitwise Queries (Hard Version)"></a><a href="https://codeforces.com/contest/1451/problem/E2">E. Bitwise Queries (Hard Version)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 n 的数组(n 是 2 的幂) , 有 3 种操作, AND OR XOR, 可以获得数组两个元素的 AND OR XOR 值, 仅限 n+1 次操作求原数组</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先考虑以 $a_1$ 为基准求出 $a_1 \oplus a_k$, 这样只要求出 $a_1$ 就可以求出整个数组, 这一步需要 $n-1$ 次操作. </p><p>因为只有 $n$ 个元素, 元素的范围是 $[0,n-1]$, 所以可以进行分类讨论：</p><p>1.所有元素并不是互不相同. 也就是说有重复的元素, 这样只要找到相同的元素, 对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值）, 又因为知道了所有元素和 $a_1$ 的 XOR, 所以可以直接算出整个数组. 考虑如何找到相同的元素, 可以开个桶记录每个元素出现的次数. 取最大的出现次数（这种情况下至少两次）, 然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素, 任意取两个询问 AND 就可以了. 不过这里有个要注意的, 如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素, 取 $1$ 询问即可. </p><p>2.所有元素互不相同. 也就是是 $[0,n-1]$ 的全排列. 考虑 XOR 的性质, 相同就是 $0$, 也就是说可以选择 $1$ 这个数, 只有最后一位是 $1$, 其他都是 $0$, 也就是说如果 $a_1\oplus a_k=1$, $a_1$ 和 $a_k$ 只有最后一位不一样, 可以通过 AND 操作求出前 $\log n-1$ 位. 同理如果 $a_1\oplus a_k=\frac n2$, $a_1$ 和 $a_k$ 只有第一位不一样, 可以通过 AND 操作求出后 $\log n-1$ 位. 把两个结果组合一下（直接或起来）就可以得到 $a_1$. 其实不一定要选择 $1$ 和 $\frac n2$, 只要保证这两个数二进制下每位都至少有个数是 $0$ 就行. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AND</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;AND &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">XOR</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XOR &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  cnt[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        xr[i] = <span class="built_in">XOR</span>(<span class="number">1</span>, i);</span><br><span class="line">        cnt[xr[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a1, mx_show_xr = <span class="built_in">max_element</span>(<span class="built_in">all</span>(cnt)) - cnt.<span class="built_in">begin</span>(); <span class="comment">// mx_show_xr: 出现最多的xr值</span></span><br><span class="line">    <span class="keyword">if</span> (cnt[mx_show_xr] &gt; <span class="number">1</span>) &#123;        <span class="comment">// n个数中有重复的</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dulplicate_pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123; </span><br><span class="line">            <span class="comment">// if (cnt[xr[i]] == cnt[mx_show_xr]) &#123;         // X!!! cnt一致的xr值可能有多个!!!</span></span><br><span class="line">            <span class="keyword">if</span> (xr[i] == mx_show_xr) &#123;</span><br><span class="line">                dulplicate_pos.<span class="built_in">pb</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(dulplicate_pos)</span><br><span class="line">        <span class="comment">// assert(dulplicate_pos.size() &gt; 1);</span></span><br><span class="line">        <span class="type">int</span> a_dulplicate;</span><br><span class="line">        <span class="keyword">if</span> (dulplicate_pos.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(<span class="number">1</span>, dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(dulplicate_pos.<span class="built_in">front</span>(), dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        a1 = a_dulplicate ^ mx_show_xr;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// n个数无重复, 就是[0, n-1]的全排列 </span></span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), <span class="number">1</span>) - xr.<span class="built_in">begin</span>();         <span class="comment">// a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同</span></span><br><span class="line">        <span class="type">int</span> py = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), n / <span class="number">2</span>) - xr.<span class="built_in">begin</span>();</span><br><span class="line">        a1 = <span class="built_in">AND</span>(<span class="number">1</span>, px) | <span class="built_in">AND</span>(<span class="number">1</span>, py);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了&lt;/p&gt;
&lt;h2 id=&quot;C-String-Equality&quot;&gt;&lt;a href=&quot;#C-String-Equality&quot; class=&quot;headerlink&quot; title=&quot;C. String Equ</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 843 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-21T04:28:02.707Z</updated>
    
    <content type="html"><![CDATA[<p>次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.</p><p>补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题</p><h2 id="A-Gardener-and-the-Capybaras"><a href="#A-Gardener-and-the-Capybaras" class="headerlink" title="A. Gardener and the Capybaras"></a><a href="https://codeforces.com/contest/1775/problem/A2">A. Gardener and the Capybaras</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将仅包含a和b的字符串s分成三部分s=s1+s2+s3, 使得s2是这三个部分的一个最值（最大值或最小值, 按字典序比较）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;=s3</p><p>s2为min: 直接拿一个a就行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">substr</span>(i + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aaaabaaab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>  &lt;&lt; s.<span class="built_in">substr</span>(i, n - i - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a><a href="https://codeforces.com/contest/1775/problem/B">B. Gardener and the Array</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>记 f(a) 是 a 数组中, 所有数的按位或. </p><p>现有 n 个数 c1,c2…cn组成的数组, 询问是否有两个不同的子数组 a 和 b , 使得 f(a)=f(b)</p><p>数据保证所有数的二进制中 1 的数量之和不超过$10^5$</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci | cj | ck) = f(cj | ck). 如下样例:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2 4</span><br><span class="line">2 2 3</span><br><span class="line">4 3 4 </span><br></pre></td></tr></table></figure><p>ci: 2 3</p><p>cj: 1 2 4</p><p>ck: 3 4</p><p>所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(n);</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; cnt(200000 + 10, 0);</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k;  cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            c[i].<span class="built_in">pb</span>(x);</span><br><span class="line">            cnt[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(all(c[i]));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = c[i];</span><br><span class="line">        <span class="type">bool</span> suc = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">            suc &amp;= (cnt[x] &gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Interesting-Sequence"><a href="#C-Interesting-Sequence" class="headerlink" title="C. Interesting Sequence"></a><a href="https://codeforces.com/contest/1775/problem/C">C. Interesting Sequence</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于n, 求最小的m, 使得 n&amp;(n+1)&amp;…&amp;m = x</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>获取x的二进制长度: floor(log2(x)) + 1</strong></p><p>每一二进制位上, 只可能从无0变成有0<br>所以x只可能是n的二进制子集<br>某一二进制位经历从1变成0, 全部低位肯定全部经历过全0<br>所以: x只能保留n高位1的子集<br>他的高一位也要经历翻转<br>所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行<br>注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行</p><p>n: 0000110111100000101 101101011001110100111011001000000000000000000<br>x: 0000110111100000101 000000000000000000000000000000000000000000000<br>ans: -1 (公共前缀最后一位是1)</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000000000000000000000000000000000000000000000<br>ans: 000011011110000011</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000010000000000000000000000000000000000000000<br>ans: -1 (mask &amp; x != x)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) &#123;        <span class="comment">// &amp; 只会变小</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> bit = <span class="built_in">floor</span>(<span class="built_in">log2</span>(n)) + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; (<span class="number">1ll</span> &lt;&lt; bit) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">62</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b &gt;= <span class="number">0</span>; -- b) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; b &amp; <span class="number">1</span>) == (n &gt;&gt; b &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            mask |= (<span class="type">int</span>)(x &gt;&gt; b &amp; <span class="number">1</span>) &lt;&lt; b;</span><br><span class="line">            last = (x &gt;&gt; b &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (x &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;  </span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">1</span> || (mask &amp; x) != x) &#123;            <span class="comment">// 1011 -&gt; 1010</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后1个1的位置</span></span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    mask |= <span class="number">1ll</span> &lt;&lt; (b);</span><br><span class="line">    cout &lt;&lt; mask &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上对拍数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span>  </span>&#123;<span class="keyword">return</span> <span class="built_in">mrand</span>() % x + <span class="number">1</span>; &#125;   <span class="comment">// [1, x]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    vector pw&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rnd</span>(<span class="number">1000</span>), b = pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>] + pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>];</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Friendly-Spiders"><a href="#D-Friendly-Spiders" class="headerlink" title="D. Friendly Spiders"></a><a href="https://codeforces.com/contest/1775/problem/D">D. Friendly Spiders</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边. 请找到 s 和 t 的最短路径. $1\le n, a_i\le 3\times 10^5$</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>边权01 -&gt; 01bfs</p><p>建图问题:</p><ul><li>每一次遇到一个数时, 即使它只有一条边, 我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图</li><li>图的边数很多, 没有办法快速求解</li></ul><p>从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n</p><p>最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \sqrt{n})$. bfs复杂度$O(n + n \sqrt{n})$</p><p>坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建.</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v2id</span>(<span class="number">300000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v2id[x].<span class="built_in">pb</span>(++ idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; <span class="built_in">g</span>(<span class="number">600000</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_p</span><span class="params">(<span class="number">300000</span> + <span class="number">10</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300000</span>; ++ i) &#123;</span><br><span class="line">        <span class="comment">// if (st[i])      continue;</span></span><br><span class="line">        <span class="keyword">if</span> (!is_p[i])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 2, 4, 6, 8, 10...之间连边 打电话式建图n^2</span></span><br><span class="line">        <span class="comment">// 交换机式建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">300000</span>; j += i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j != i)     is_p[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v2id[j].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> uid : v2id[j]) &#123;</span><br><span class="line">                    g[uid].<span class="built_in">pb</span>(&#123;i + <span class="number">300000</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                    g[i + <span class="number">300000</span>].<span class="built_in">pb</span>(&#123;uid, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dq;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, inf)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;                        dq.<span class="built_in">pb</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (dq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = dq.<span class="built_in">front</span>();     dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cv == t) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : g[cv]) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(cv, nv, w)</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &gt; dist[cv] + w) &#123;</span><br><span class="line">                dist[nv] = dist[cv] + w;</span><br><span class="line">                pre[nv] = cv;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">                    dq.<span class="built_in">pb</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.<span class="built_in">push_front</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(dist[t])</span><br><span class="line">    <span class="keyword">if</span> (dist[t] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> now = t;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">while</span> (now != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt;= <span class="number">300000</span>) &#123;</span><br><span class="line">            path.<span class="built_in">pb</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        now = pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(path));</span><br><span class="line">    <span class="built_in">LOG</span>(path)</span><br><span class="line">    cout &lt;&lt; path.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : path) cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-The-Human-Equation"><a href="#E-The-Human-Equation" class="headerlink" title="E. The Human Equation"></a><a href="https://codeforces.com/contest/1775/problem/E">E. The Human Equation</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给一个序列a[n] (n&lt;=2e5), 要通过下面的两种操作, 最终全部变成0, 最少需要操作几次</p><blockquote><p>操作1: 选a的一个子序列, 然后子序列奇数位+1, 偶数位-1<br>操作2: 选a的一个子序列, 然后子序列奇数位-1, 偶数位+1</p></blockquote><p>如[1,4,2,8,5,7,3,6,9] -&gt; [4,2,5,6]用操作1<br>-&gt; [1,5,1,8,6,7,3,5,9]</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>pre[n]: a[n]的前缀和数组</p><p>a[i] + 1, a[j] - 1 相当于pre[i ~ j - 1] + 1<br>a[3] + 1, a[4] - 1 相当于pre[3] + 1<br>a[3] + 1, a[5] - 1 相当于pre[3 ~ 4] + 1</p><p>最终状态: pre全部为0</p><p>所以一次操作, 可以把pre上任何位置上的数+1 / -1</p><p>只需要记录前缀和中的mn和mx, 答案分类讨论下就行</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cs = <span class="number">0</span>, mx = <span class="number">-2e9</span>, mn = <span class="number">2e9</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cs += a[i];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, cs);</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx &lt; <span class="number">0</span>)         ans = <span class="built_in">abs</span>(mn);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mn &gt; <span class="number">0</span>)    ans = <span class="built_in">abs</span>(mx);</span><br><span class="line">    <span class="keyword">else</span>                ans = mx - mn;</span><br><span class="line">    <span class="built_in">LOG</span>(ans, mn, mx)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.&lt;/p&gt;
&lt;p&gt;补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛65 A-F</title>
    <link href="http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/"/>
    <id>http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/</id>
    <published>2023-01-08T16:00:00.000Z</published>
    <updated>2023-01-14T11:49:48.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-牛牛写情书"><a href="#B-牛牛写情书" class="headerlink" title="B - 牛牛写情书"></a><a href="https://ac.nowcoder.com/acm/contest/49888/B">B - 牛牛写情书</a></h2><h3 id="题意-分析"><a href="#题意-分析" class="headerlink" title="题意 + 分析"></a>题意 + 分析</h3><p>判断模式串T是否是给定串S的子串.<br>瞎写双指针      X<br>KMP / 双哈希            V<br>5e3: 直接substr暴力$n^2$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string os, k;    cin &gt;&gt; os &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(os[i])) &#123;</span><br><span class="line">            s.<span class="built_in">pb</span>(os[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m - <span class="number">1</span> &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, m) == k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-牛牛排队伍"><a href="#C-牛牛排队伍" class="headerlink" title="C - 牛牛排队伍"></a><a href="https://ac.nowcoder.com/acm/contest/49888/C">C - 牛牛排队伍</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面. 老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c =&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？</p><p>一共会有 k 次操作, 每次会执行下面的一种：</p><ol><li>把 x 叫走</li><li>求排在 x 前面的是谁</li></ol><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pre, nxt模拟双向链表</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            nxt[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;  cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = pre[x], b = nxt[x];</span><br><span class="line">            pre[x] = nxt[x] = <span class="number">0</span>;</span><br><span class="line">            nxt[a] = b;</span><br><span class="line">            pre[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; pre[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-牛牛取石子"><a href="#D-牛牛取石子" class="headerlink" title="D - 牛牛取石子"></a><a href="https://ac.nowcoder.com/acm/contest/49888/D">D - 牛牛取石子</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取：</p><blockquote><p>第一堆取 1 个, 第二堆取 2 个<br>第一堆取 2 个, 第二堆取 1 个</p></blockquote><p>谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1e18: 打表找规律</p><p>模仿是博弈里面的一个重要的策略, 主要思想:<br>断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法</p><p>a, b两堆石子, 必败态是: min(a, b) % 3 == 0. 因为后手总是可以控制min(a, b)在一轮下来-3<br>B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1<br>B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:<br>A: 5 4<br>B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输<br>原因在于: 若min(a, b) % 3 != 0     A总是可以把min(a, b) % 3 == 0的局面给B</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> C = <span class="number">15</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">awin</span>(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(C + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">awin[<span class="number">1</span>][<span class="number">2</span>] = awin[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= C; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= C; ++ j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span>)   awin[i][j] |= !awin[i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">1</span>)   awin[i][j] |= !awin[i - <span class="number">2</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)  <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> r = a / <span class="number">3</span>;      <span class="comment">// ab互走r轮对称棋</span></span><br><span class="line">    b = b - r * <span class="number">3</span>;</span><br><span class="line">    a = a - r * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span>(a, b) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-牛牛的构造"><a href="#E-牛牛的构造" class="headerlink" title="E - 牛牛的构造"></a><a href="https://ac.nowcoder.com/acm/contest/49888/E">E - 牛牛的构造</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \leq i&lt;j \leq n$ &amp;&amp; $a_i - a_j = 2^x(x\in N)(1\le n \le 10^6, 1\le k \le 10^9)$</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>考虑降序的排列: 9 8 7 6 5 4 3 2 1</p><blockquote><p>f[x]: 降序排列时, x对xi-xj=2^k 的贡献<br>f[9]: 4<br>f[8]: 3<br>f[7]: 3<br>f[6]: 3<br>f[5]: 3<br>f[4]: 2<br>f[3]: 2<br>f[2]: 1<br>f[1]: 0</p></blockquote><p>先降序, 后升序<br>降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]<br>升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0<br>​</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="built_in">popcountll</span>(i - <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(f)</span><br><span class="line">    <span class="type">int</span> mxk = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(f), (<span class="type">int</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mxk &lt; k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dec, inc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= f[i]) &#123;</span><br><span class="line">            dec.<span class="built_in">pb</span>(i);</span><br><span class="line">            k -= f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            inc.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(inc));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : dec)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : inc)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-牛牛的考试"><a href="#F-牛牛的考试" class="headerlink" title="F -  牛牛的考试"></a><a href="https://ac.nowcoder.com/acm/contest/49888/F">F -  牛牛的考试</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？<br>若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟.</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间</p><blockquote><p>对于同一门课而言:<br>双开时间可以转成单开时间, 即双开可以反悔成单开.<br>但是单开不能转成双开, 否则说明同时用手机电脑学同一门课.</p></blockquote><p>所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dp;   <span class="comment">// dp[i][0] : 双开时间, dp[i][1] : 单开时间</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>, 2&gt; <span class="title">add</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125;</span></span><br><span class="line">    <span class="comment">// &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125;</span></span><br><span class="line">    <span class="comment">// &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>])    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">min</span>(a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] -= d, a[<span class="number">1</span>] += <span class="number">2</span> * d;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] + b[<span class="number">0</span>] + <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]), <span class="built_in">max</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]) - <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;;</span><br><span class="line">    <span class="comment">// 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的</span></span><br><span class="line">    <span class="comment">// return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u] = <span class="built_in">add</span>(dp[u], dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][<span class="number">1</span>] += a[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    g.<span class="built_in">resize</span>(n);    dp.<span class="built_in">resize</span>(n);   a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;   x--;</span><br><span class="line">        g[i].<span class="built_in">pb</span>(x); g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-牛牛写情书&quot;&gt;&lt;a href=&quot;#B-牛牛写情书&quot; class=&quot;headerlink&quot; title=&quot;B - 牛牛写情书&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/49888/B&quot;&gt;B - 牛牛写情书</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.19-12.25</title>
    <link href="http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/"/>
    <id>http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2023-01-21T01:42:30.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-19-周一-晴"><a href="#12-19-周一-晴" class="headerlink" title="12.19 周一  晴"></a>12.19 周一  晴</h2><p>今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我.</p><p>虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;,</p><h2 id="12-20-周二-晴"><a href="#12-20-周二-晴" class="headerlink" title="12.20 周二  晴"></a>12.20 周二  晴</h2><p>感染第一天: 流鼻涕</p><h2 id="12-21-周三-晴"><a href="#12-21-周三-晴" class="headerlink" title="12.21 周三  晴"></a>12.21 周三  晴</h2><p>待填</p><h2 id="12-22-周四-多云"><a href="#12-22-周四-多云" class="headerlink" title="12.22 周四  多云"></a>12.22 周四  多云</h2><h2 id="12-23-周五-阴"><a href="#12-23-周五-阴" class="headerlink" title="12.23 周五 阴"></a>12.23 周五 阴</h2><p>待填</p><h2 id="12-24-周六-晴"><a href="#12-24-周六-晴" class="headerlink" title="12.24 周六 晴"></a>12.24 周六 晴</h2><p>今天是考研第一天</p><p>晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了.</p><h2 id="12-25-周日-晴"><a href="#12-25-周日-晴" class="headerlink" title="12.25 周日 晴"></a>12.25 周日 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.29日晚22点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-19-周一-晴&quot;&gt;&lt;a href=&quot;#12-19-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.19 周一  晴&quot;&gt;&lt;/a&gt;12.19 周一  晴&lt;/h2&gt;&lt;p&gt;今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.12-12.18</title>
    <link href="http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/"/>
    <id>http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/</id>
    <published>2022-12-19T16:00:00.000Z</published>
    <updated>2023-01-21T01:43:26.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-12-周一-晴"><a href="#12-12-周一-晴" class="headerlink" title="12.12 周一  晴"></a>12.12 周一  晴</h2><p>早上刷题. </p><p>下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》, 同时刷题. 主要是《D. Range = √Sum》这题, 1800构造, 只能想出偶数的构造方法, 奇数情况还是过于抽象了. </p><p>晚上吃师生缘的煎饼果子, 看完了《剃须. 然后捡到高中生》. 个人认为这番其实还算治愈番, 但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩. 可能是这还只是我正式进军二次元后看的第二部番, 姑且还觉得不错, 挺期待剃须出第二部的. </p><p>晚上跟zzm及他同学联机深岩银河. </p><h2 id="12-13-周二-晴"><a href="#12-13-周二-晴" class="headerlink" title="12.13 周二  晴"></a>12.13 周二  晴</h2><p>日程基本同周一. </p><h2 id="12-14-周三-晴"><a href="#12-14-周三-晴" class="headerlink" title="12.14 周三  晴"></a>12.14 周三  晴</h2><p>日程基本同周一. 下番《辉夜大小姐想让我告白》全部三季. 晚餐尝试了步步高门口街道上的潼关肉夹馍, 10块量少但味道不错. </p><h2 id="12-15-周四-多云"><a href="#12-15-周四-多云" class="headerlink" title="12.15 周四  多云"></a>12.15 周四  多云</h2><p>今天9:45-11:45 是《高性能计算》的期末考试. 虽然线上考试并且开卷, 但我仍觉得很难. 老师也觉得很难, 所以又延长了10分钟到11:55. 我12点整把试卷拍照上传助教邮箱. 挺无语的, 本来就一限选, 还搞严格的签到、实验和线上考试. </p><p>晚上zwling发消息说南京站的物资到了, 惊喜的是外套居然还带ICPC标. 相比之下沈阳的廉价格子衫就是屑了. </p><h2 id="12-16-周五-阴"><a href="#12-16-周五-阴" class="headerlink" title="12.16 周五 阴"></a>12.16 周五 阴</h2><p>待填</p><h2 id="12-17-周六-晴"><a href="#12-17-周六-晴" class="headerlink" title="12.17 周六 晴"></a>12.17 周六 晴</h2><p>今天14:00-16:00是ICPC南京站的热身赛. 10点半不到我就吃了午餐, 午餐在师生缘吃的自助. 同样还是12点小睡了30分钟到1点起床. 我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合, 一起前往院楼. 看得出zwling似乎有些生病, 不过都拼到这一步了, 我相信大家都是想让本科的ICPC生涯有始有终的. </p><p>走到天马公寓门口时, 后面一位好心的小姐姐提醒了我书包在漏水. 听到她的提醒我先是愣了下, 随后立马把笔记本电脑拿了出来. 之前其实也发生过水壶漏水的事故, 并且电脑都没啥事. 但是这次漏水偏偏赶在热身赛赛前1小时不到, 并且还刚好是3人3机位. 一看到电脑朝下的那一边湿了一大片, 内心也凉了大半截. 不过好在有初中毕业游手机进水的经验, 这次还是学聪明了：虽然很想知道电脑是否还健在, 也很想知道明天的正式赛会不会受到影响, 我也还是忍住没按下开机键, 在路上全称用手拎着电脑边甩边让风吹, 到院楼放在门口晒了20分钟. 热身赛马上就要开始了, 我只能按下开机键, 已经做好了最坏的打算. 电脑也跟我开了个玩笑, 开机成功后自己又重启了, 不过好在这只是系统更新. 最后电脑开是能开, 但是左下角的屏幕就暗一片亮一片. </p><p>热身赛开始阶段我们跟着榜, 着力于过题数最多的B, 却发现只能想到6次方（n=20）的做法. 我的想法是每次直接找第一个1, 然后BFS到另外一个1, 将轨迹应用于全图. 这样每次至少减少1个1, 复杂度虽然不会超, 但是却无法保证轨迹总长度不超过50000, 所以也没敢上机写. 可是诡异的是很多支队伍都很快通过了. 前1小时我们都还是1题没过. 直到姜哥看到D题题面有对B题随机化解法的代码, 才发现这是往年南京站原题. 于是姜哥很快把D题签了, 然后把D题的代码直接复制到B, 至此B也过了. 最后的A题我和zwling想出了二分的假算法, 前期一直没找到钱越多买的书越多的反例, 因此也就因此WA. 姜哥及时提出了反例, 并且给出了正确的贪心做法, 只不过此时已经接近结束了. </p><p>虽说我们热身赛封榜前一道没过, 排在了300名左右. 在回宿舍的路上, 姜哥还说他隔壁宿舍有人羊了. 按照我一直奉为圭臬的人品守恒定律, 我已经看到了明天的结果：高数100将在南京站修成正果. 首先是队长zwling生病疑似阳性, 然后又是我电脑进水. 接下来又是姜哥附近与有人确诊. 这无疑给了我莫大的鼓舞. 回到园区后, zwling还是去门口核酸亭做了混检. </p><p>晚上打了atcoder Beginner Contest 282, 直接D题罚坐. rk2000+, 看来青名又要离我远去了. </p><h2 id="12-18-周日-晴"><a href="#12-18-周日-晴" class="headerlink" title="12.18 周日 晴"></a>12.18 周日 晴</h2><p>仍是凌晨1点睡, 只不过早上9:30起床, 10:00前进餐完毕, 只吃了肉松饼和上次CCSP发的零食, 睡了20来分钟. 10:00出发去院楼参加南京正式赛. </p><p>开题签到题I, 在我们迟疑的功夫, 已经过了快300人了. </p><p>第二题G贪心, 姜哥首先发现要贪心0前半段要取1, 后半段取-1, 随后我提出了二分分界线. 姜哥提出可以O(n)做, 但是写挂了, 于是我就上机开始二分了. 又到了经典二分分界线环节, 我还被这个分界线在最左边的情况卡了10分钟, 不愧是我…不过好在在姜哥提醒下, 很快就写完了. 幸运地一发A了. </p><p>第三题看着像计算几何, 姜哥一开始就说这题很简单, 只需要判断v型就行了, 我和zwling都是懵的. 随后姜哥画了几下就上机码了, 第一发没过. 随后过了10来分钟他想出了corner case, 交上去居然直接过了. 当然我们也只是开心了一下, 毕竟从此到结束, 我们都再也没能过一道题. </p><p>第四题大模拟二维前缀和, 我们还剩2小时的时间. 我想的是用将轨迹表示成一个01矩阵, 然后再用这个矩阵和最后袋鼠组成的矩形, 做类似求交算移入移出了多少. 姜哥表示应该确实就只是二维前缀和, 随后就开始码. 但是最后因为查不出哪里越界, 一直段错误. </p><p>结束后, 虽然zwling觉得可能还是打铁, 但我和姜哥都觉得铜牌概率蛮大. </p><p>5:30开始滚榜, 当看到《高数100》出现在铜牌区时, 我意识到本科的算法竞赛已经没有遗憾了. 我觉得这次铜牌不仅幸运女神站在我们这边, 更重要的是队伍的实力确实有所上升, 毕竟这次zwling生病了. 如果他没生病, 我估计我们能将A题调出来. 最后本科的所有XCPC至此都告一段落了, 希望zwling能在BUAA找到更强的队友, 继续在算法竞赛上取得更高的成就, 也希望姜哥顺利上岸, 在研究生阶段继续发挥他过人的思维优势. 最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家. </p><p>接下来就是修改《软件工程》课程大作业的报告, 并且收拾行李, 准备第二天9点的高铁了. 要好好放松下了, 首先得先把剩下的2集麻衣学姐看完hh. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.20日晚22点</p><p>BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐</p><p>我把《高数100》的队牌带回了宿舍, 跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起. 这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-12-周一-晴&quot;&gt;&lt;a href=&quot;#12-12-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.12 周一  晴&quot;&gt;&lt;/a&gt;12.12 周一  晴&lt;/h2&gt;&lt;p&gt;早上刷题. &lt;/p&gt;
&lt;p&gt;下午和zzm在综楼二楼教员休息室下番《冰菓》</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:06.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/44749">比赛链接</a></p><h2 id="Dijkstra-松弛的理解"><a href="#Dijkstra-松弛的理解" class="headerlink" title="Dijkstra 松弛的理解"></a>Dijkstra 松弛的理解</h2><p>“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比. 最初, 最短路径的成本被高估了, 就像延伸的弹簧一样. 当找到更短的路径时, 估计的成本会降低, 弹簧会放松. 最终, 找到了最短的路径（如果存在）, 并且弹簧已经松弛到其静止长度. </p><h2 id="D-点分治分点"><a href="#D-点分治分点" class="headerlink" title="D - 点分治分点"></a>D - 点分治分点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>G&lt;n, m&gt;, 且$n, m \leq 1e5$, 定义一条简单路径的 low 值为其路径上的边权的最小值, d(u, v) 为从 u 到 v 所有简单路径的最大 low 值. 对于给定的s, u 从 1 到 n 输出 d(s, u), 如果没有任何一条简单路径则输出 -1. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>点边数1e5 -&gt; Dijkstra变形套路</p><p>dist[i]: s-&gt;i的每条路径最短边中的最大值</p><p>松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">// s-&gt;i 每条路径最短边中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[s] = inf;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;inf, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dist[cv] &gt; cd) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : G[cv]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &lt; <span class="built_in">min</span>(dist[cv], w)) &#123;</span><br><span class="line">                dist[nv] = <span class="built_in">min</span>(dist[cv], w);</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &lt; -inf / <span class="number">2</span> || dist[i] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">            dist[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/44749&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Dijkstra-松弛的理解&quot;&gt;&lt;a href=&quot;#Dijkstra-松弛的理解&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 第八届“图灵杯”个人赛</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2023-01-20T07:03:54.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/11746">比赛链接</a></p><h2 id="贪吃的派蒙"><a href="#贪吃的派蒙" class="headerlink" title="贪吃的派蒙"></a><a href="https://ac.nowcoder.com/acm/contest/11746/G">贪吃的派蒙</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在每一次的排队中, 编号为i的角色领取上限为Ai, 这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内. 当一个角色领完本次的甜甜花酿鸡, 他/她就会回到队列的末尾, 直到所有甜甜花酿鸡都被吃完为止. 当轮到一个角色领取时, 如果所有的甜甜花酿鸡都被领完, 那么他/她就要帮大家刷盘子. </p><p>贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小, 那么他就把剩下的都吃完). 我们很容易找到派蒙的编号, Ax比其他所有的Ai都要大. 大家都想让派蒙最后留下来刷盘子, 请你写一个程序来判断这是否可能. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Seek-the-Joker-II"><a href="#Seek-the-Joker-II" class="headerlink" title="Seek the Joker II"></a><a href="https://ac.nowcoder.com/acm/contest/11746/E">Seek the Joker II</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 一堆k-1, 另一堆n-k, 先取到任意一堆的最后一个输</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11746&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;贪吃的派蒙&quot;&gt;&lt;a href=&quot;#贪吃的派蒙&quot; class=&quot;headerlink&quot; title=&quot;贪吃的派蒙&quot;&gt;&lt;/a&gt;&lt;a </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 10.31-11.6</title>
    <link href="http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/"/>
    <id>http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/</id>
    <published>2022-11-05T16:00:00.000Z</published>
    <updated>2023-01-14T11:50:43.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-3-周四-晴"><a href="#11-3-周四-晴" class="headerlink" title="11.3 周四 晴"></a>11.3 周四 晴</h2><p>今天一早起来就看到知乎推送《多地核酸开始自费》, 又了解到大舅那边前几天已经开始自费了, 收费是4元/次. 不禁联想到昨天还吐槽核酸检测人员的高收入. </p><p>早十有《高性能计算》, 依旧是平平无奇地上半节课签到, 课间从复邻舍401后门溜回宿舍. 不过今天罗HZ老师提到了签到的问题, 在课上指出了缺课达3次需要补卡. 我想起上上周自己因为没看课表, 直接漏掉了一次签到. 不料午饭后, 有同学在课程群里问有没有爬山组队. 这才知道所谓的补卡其实是跟LHZ爬岳麓山, 好感度++. 自己也得找个机会把缺的这次签到补回来. </p><p>下午依旧是赛前的日常刷题. </p><p>晚饭步步高挑香小面. 晚九点打算继续昨晚的师大天马宿舍之行. 虽然没有大门大开, 但是也只是扫个码就放行了. 漫步在师大宿舍园区, 我和ZZM都明显感觉到和湖大天马宿舍不同的地方. 简单来说就是中南南校区和这里都更加具有校园的氛围, 体现在绿化, 路旁的人行道, 路旁的宣传栏, 也体现在这里建筑的杂乱. </p><h2 id="11-4-周五-晴"><a href="#11-4-周五-晴" class="headerlink" title="11.4 周五 晴"></a>11.4 周五 晴</h2><p>8点30分第一个下床. 刷题. 干午饭. 学委此时也发了关于毕设导师的通知了, 毕设郑老师之前提过, 但是目前又没了消息. 我最担心的是找不到愿意挂名的导师. </p><p>下午第三节有《软件工程》, 课上做了些2022辽宁省赛的题目, 发现题目难度不大. 做了<a href="https://ac.nowcoder.com/acm/contest/43937/B">可莉的五子棋</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/M">画画</a>. <a href="https://ac.nowcoder.com/acm/contest/43937/I">图的分割</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/G">栈与公约数</a>暂时没想到做法. </p><p>晚上有例行的每周大组会, 我问了WSH, 发现大家都找了毕设的导师, 所以我也打算把当前进度汇报一下, 顺便问问毕设的事情. 于是跟老师和彭Z约了明天晚上讨论进度. </p><h2 id="11-5-周六-晴"><a href="#11-5-周六-晴" class="headerlink" title="11.5 周六 晴"></a>11.5 周六 晴</h2><p>今天14:00-16:00是ICPC沈阳站的热身赛. 所以10点半不到就吃了午餐, 休息小睡了20分钟后. 便在阜埠河公交站和zwl骑车去院楼105准备上机环境. </p><p>在比赛开始时, zwl的后置录像手机夹住了关机键, 手机直接关机了, 所以我们整场比赛都没法正常交题. 不过还是能看题面, A题签到, B题是输出 (随机生成)满足条件的a序列的期望. 公式是$\frac{(n!)^2}{n^n}$. 就是不知道<code>double</code>的精度能否满足要求. C题是类似石子合并的DP题. 但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$, 所以最后只能写一个假算法. 赛后问了SJ, 得知是四边形不等式决策单调性相关, 打扰了. </p><p>晚上的Atcoder只打了半小时. </p><h2 id="11-6-周日-晴"><a href="#11-6-周日-晴" class="headerlink" title="11.6 周日 晴"></a>11.6 周日 晴</h2><p>总结: 遗憾打铁<br>仍是凌晨1点睡, 8:30起床, 10:30前进餐完毕, 睡了10来分钟. 11:30到院楼参加沈阳正式赛. </p><p>开题签到题, 统计字符串中T和D的个数, WA了一发.<br>第二题找规律题, 姜哥首先发现r取越大越好, 但是只考虑a[i]作为左端点, 没加上右端点的情况, WA了一发</p><p>第三题构造题, 我首先用子矩阵数量公式判断出了无解情况. ZWL打表, 发现了长相特殊的合法情况, 所以尝试将二维压缩为一维. 问题转换成把一个数分解成若干个$\frac{i \times (i+1)}{2}$表示. 我提出从i从高到低贪心, 二分i的位置, 上机同时姜哥找反例. 姜哥发现没有反例并且提出可以线性, 但是我写到后面犯傻, 直接神志不清, 并不清楚线性的意思. 于是姜哥接过来完成算法. 第一发TLE, <code>endl</code>原因. 第二发WA, 爆<code>long long</code>. 最后过了</p><p>第四题大模拟暴搜, 题意没读懂, 其实就是炉石随从攻击的逻辑, 奈何没玩过. 调试1个半小时, 没能调对第二个样例. 以为是精度问题. 最后Rank290+无奈打铁. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;11-3-周四-晴&quot;&gt;&lt;a href=&quot;#11-3-周四-晴&quot; class=&quot;headerlink&quot; title=&quot;11.3 周四 晴&quot;&gt;&lt;/a&gt;11.3 周四 晴&lt;/h2&gt;&lt;p&gt;今天一早起来就看到知乎推送《多地核酸开始自费》, 又了解到大舅那边前几天已经开始自费</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 275 A-F</title>
    <link href="http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/"/>
    <id>http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/</id>
    <published>2022-11-03T16:00:00.000Z</published>
    <updated>2023-01-14T04:54:00.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个$r \times c (r, c\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数.</p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##.......</span><br><span class="line">##.......</span><br><span class="line">.........</span><br><span class="line">.......#.</span><br><span class="line">.....#...</span><br><span class="line">........#</span><br><span class="line">......#..</span><br><span class="line">.........</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子.</p><p>具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子.</p><p>因此, 答案是 2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标.</p><p>向量<code>[x, y]</code>顺时针旋转90°: <code>[y, -x]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rot</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = v;</span><br><span class="line">    v = &#123;y, -x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">9</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j) </span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">7</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ci = <span class="number">1</span>; ci &lt;= <span class="number">9</span>; ++ ci) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cj = <span class="number">1</span>; cj &lt;= <span class="number">9</span>; ++ cj) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ni = <span class="number">1</span>; ni &lt;= <span class="number">9</span>; ++ ni) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> nj = <span class="number">1</span>; nj &lt;= <span class="number">9</span>; ++ nj) </span><br><span class="line">                    <span class="keyword">if</span> (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[ni][nj] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                        array&lt;<span class="type">int</span>, 2&gt; v = &#123;ni - ci, nj - cj&#125;;</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i3 = ni + v[<span class="number">0</span>], j3 = nj + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i4 = i3 + v[<span class="number">0</span>], j4 = j3 + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7)   cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">check</span>(i3, j3) &amp;&amp; <span class="built_in">check</span>(i4, j4)</span><br><span class="line">                        &amp;&amp; g[i3][j3] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[i4][j4] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl;</span></span><br><span class="line">                            set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; s;</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ci, cj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ni, nj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i3, j3&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i4, j4&#125;);</span><br><span class="line">                            S.<span class="built_in">insert</span>(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>为非负整数 x 定义的函数 f(x) 满足以下条件：</p><ul><li><p>$f(0) = 1$</p></li><li><p>$f(k) = f(\lfloor \frac{k}{2}\rfloor) + f(\lfloor \frac{k}{3}\rfloor)$ 对于任何正整数 k</p></li></ul><p>然后找到 $f(N), N\in[0, 1^{18}]$.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>最多需要$log_2n \times log_3n$这么多个数的f值. 标准记搜</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.<span class="built_in">count</span>(u))    <span class="keyword">return</span> dp[u];</span><br><span class="line">    <span class="keyword">return</span> dp[u] = <span class="built_in">dfs</span>(u / <span class="number">2</span>) + <span class="built_in">dfs</span>(u / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; dp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个一维的棋盘上有 N + 1 个格子, 下标从 0 到 N , 玩家要从 0 这个点出发, 前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子, 每个骰面上都有不同的数字, 值域是 $[1, M]$ , 扔出每个面的概率都是 $\frac{1}{M}$ . 玩家需要根据要出来的骰面前进, 如果预计前进之后走出了棋盘, 就需要退回多走出的步数, 如果在终点停了下来, 游戏就胜利了, 不能再扔骰子. 问 K 回合后, 玩家胜利的概率. 将结果对 998244353 取模.</p><p>$0 \le M \le N \le 1000, M \in [1, 10], K \in [1, 1000]$ .</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令 dp[i][j] 为扔第 j 次骰子后, 玩家到达下标为 i 的格子的概率.</p><p>对于每一个 dp[i][j]  $dp[next_i][j + 1] = dp[i][j] \times \frac{1}{M}$. 注意如果走出了棋盘, 要特殊讨论停下来的下标.</p><p>已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dp[N][N];       <span class="comment">// 到达第i格, 共走了j步的所有情况之和</span></span><br><span class="line"><span class="comment">// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m_1 = <span class="built_in">qmi</span>(m , mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= m; ++ len) &#123;</span><br><span class="line">                <span class="type">int</span> ni = i + len;</span><br><span class="line">                <span class="keyword">if</span> (ni &gt; n) &#123;</span><br><span class="line">                    ni = n - (ni - n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// if (next_i &lt;= i) &#123;</span></span><br><span class="line">                <span class="comment">//     cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                dp[ni][j + <span class="number">1</span>] += (dp[i][j] * m_1) % mod;</span><br><span class="line">                dp[ni][j + <span class="number">1</span>] %= mod;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][j + <span class="number">1</span>] += dp[n][j];</span><br><span class="line">        dp[n][j + <span class="number">1</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 A , 定义一次操作的内容是, 删除 A 中一段连续的序列.</p><p>问对于 1, 2, …, M 中的每个数 s , 分别至少要操作多少次,  才能使得 A 中剩下的数和为 s , 如果不可能就输出 -1 .</p><p>$0 \le N \le M \le 3000,  1 \le a_i \le 3000$</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组分段式的DP, 用一个维度表示当前元素是否在分段中</p><p>dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中</p><p>如果a[i]不计入总和: <code>dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;);</code></p><p>如果a[i]计入总和: <code>dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;);</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];            <span class="comment">// 前i个数, 构成总和为j, 且第i个数是否在总和中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (j - a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;dp[n][j][<span class="number">0</span>], dp[n][j][<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)   ans = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的</p><p>C 模拟 + 向量旋转</p><p>D 记忆化搜索</p><p>E 概率DP</p><p>F DP + 数组划分 / 选取子段</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;一个$r \t</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_实现" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法_搜索" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 192 D-F</title>
    <link href="http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/"/>
    <id>http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/</id>
    <published>2022-11-02T16:00:00.000Z</published>
    <updated>2023-01-14T04:53:36.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定整数 $X, X \in [1, 10^{60}]$和 $M, M \in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. </p><p>求对于所有的 $a&gt;d,a \in \mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\le M$. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. </p><p>注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. </p><p>同时, <code>long long</code> 相乘可能会爆, 必须乘乘数<code>base</code>之前判断当前<code>val &gt; target / base </code>. 或者用 <code>__int128</code>AtCoder 支持 或龟速乘. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string x;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    <span class="type">signed</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : x)  mx = <span class="built_in">max</span>(mx, ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;                        <span class="comment">// 特判: 因为题目要求不同的数</span></span><br><span class="line">        <span class="keyword">if</span> (mx &lt;= m)    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> base) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; m / base) &#123;               <span class="comment">// 每次 + *base 之前 跟目标 /base 作比较 防止溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> b = x[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            val *= base;</span><br><span class="line">            val += b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (val &lt;= m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = mx, r = <span class="number">1e18</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))         l = mid;</span><br><span class="line">        <span class="keyword">else</span>                    r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; l - mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$G(N, M), N, M \leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\in\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 <code>-1</code>. </p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k;</span><br><span class="line">        G[a].<span class="built_in">pb</span>(&#123;b, t, k&#125;);</span><br><span class="line">        G[b].<span class="built_in">pb</span>(&#123;a, t, k&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;, vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;, greater&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x] = <span class="number">0</span>;    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, x&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, t, k] : G[cv]) &#123;</span><br><span class="line">            <span class="type">int</span> nd = (cd + k - <span class="number">1</span>) / k * k;</span><br><span class="line">            nd = nd + t;</span><br><span class="line">            <span class="comment">// cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (nd &lt; dist[nv]) &#123;</span><br><span class="line">                dist[nv] = nd;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;nd, nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (dist[y] &gt;= <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)  cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>                                    cout &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定数组a[N], $a[i] \leq 1e7$和$X \in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数</p><p>枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. </p><p><code>dp[k][i][j]</code> = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值</p><p>不拿第k个物品: <code>dp[k][i][j] = dp[k - 1][i][j];</code></p><p>拿第k个物品: <code>dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]);</code></p><p>总复杂度 $\mathcal{O}(n^4)$. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">int</span> a[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][N];        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> choose = <span class="number">1</span>; choose &lt;= n; ++ choose) &#123;</span><br><span class="line">        <span class="type">int</span> m = x % choose;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   w[i] = a[i] % choose;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">// dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(k, choose); ++ i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; choose; ++ j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i][j]) &#123;</span><br><span class="line">                        dp[k][i][j] = dp[k - <span class="number">1</span>][i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose]) &#123;</span><br><span class="line">                        dp[k][i][j] = <span class="built_in">max</span>(dp[k][i][j], dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose] + a[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose</span></span><br><span class="line">        <span class="keyword">if</span> (~dp[n][choose][m]) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (x - dp[n][choose][m]) / choose);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>D 考察乘法溢出, 各种边界讨论比较繁琐</p><p>E 最短路变形, 松弛边权做一下变化即可</p><p>F 背包+模数, 在外层套一层for模数<code>choose</code>, 状态表示加一个维度表示当前总和mod <code>choose</code>的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定整数 $X</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_二分" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/"/>
    <id>http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:15.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-国际象棋"><a href="#D-国际象棋" class="headerlink" title="D - 国际象棋"></a>D - 国际象棋</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\“四个方向上已经连了几个了.</p><p>注意不能分8个方向</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, t;</span><br><span class="line"><span class="type">int</span> h[N], g[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tt = <span class="number">1</span>; tt &lt;= t; ++ tt) &#123;</span><br><span class="line">        <span class="type">int</span> col, x = tt % <span class="number">2</span>;    cin &gt;&gt; col;</span><br><span class="line">        g[++ h[col]][col] = x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cx = h[col], cy = col;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//         for (int i = n; i &gt;= 1; -- i)   for (int j = 1; j &lt;= m; ++ j)   cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \n&quot;[j == m];</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; g[cx + <span class="number">1</span>][cy] == x)   ++ cx, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy] == x)   -- cx, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx][cy + <span class="number">1</span>] == x)   ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col; </span><br><span class="line">        <span class="keyword">while</span> (cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx][cy - <span class="number">1</span>] == x)   -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx + <span class="number">1</span>][cy + <span class="number">1</span>] == x)   ++ cx, ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy - <span class="number">1</span>] == x)   -- cx, -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx + <span class="number">1</span>][cy - <span class="number">1</span>] == x)   ++ cx, -- cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy + <span class="number">1</span>] == x)   -- cx, ++ cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; \\ &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-弹珠碰撞"><a href="#E-弹珠碰撞" class="headerlink" title="E - 弹珠碰撞"></a>E - 弹珠碰撞</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>长度为 n 的线段上, 有 m 颗弹珠在匀速以1单位/s 左右滚动. 弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. </p><p>两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动, 并交换两颗弹珠滚动的方向. 一颗弹珠可以反复发生碰撞, 如果在停滞中受到碰撞, 则停滞时间会累加. </p><p>如果一颗弹珠滚到了位置 0 或位置 n+1, 那么这颗弹珠就滚出了线段. 问最后一颗弹珠在什么时候滚出线段？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>a -&gt;  &lt;- b 左右两个弹珠相撞后</p><p>&lt;-a   b -&gt; </p><p>&lt;-b   a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的</p><p>算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行.</p><p>​    </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d, p;</span><br><span class="line">&#125; ball[N];</span><br><span class="line"><span class="type">int</span> pre1[N];        <span class="comment">// -&gt;</span></span><br><span class="line"><span class="type">int</span> suf0[N];        <span class="comment">// &lt;-</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].p;</span><br><span class="line">    <span class="built_in">sort</span>(ball + <span class="number">1</span>, ball + <span class="number">1</span> + m, [&amp;](<span class="keyword">auto</span> &amp;a, <span class="keyword">auto</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   pre1[i] = pre1[i - <span class="number">1</span>] + (ball[i].d == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; -- i)   suf0[i] = suf0[i + <span class="number">1</span>] + (ball[i].d == <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, p] = ball[i];</span><br><span class="line">        <span class="type">int</span> t = (d ? (n + <span class="number">1</span> - p) + suf0[i] : p + pre1[i]);</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-困难卷积"><a href="#F-困难卷积" class="headerlink" title="F - 困难卷积"></a>F - 困难卷积</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定整数序列 a[n], b[n], 求：<br>$$<br>\sum_{i=1}^n\sum_{j=1}^n\Big\lfloor\sqrt{|a_i-b_j|}\Big\rfloor<br>$$</p><p>其中 $\lfloor x\rfloor$表示不超过 x 的最大整数, 例如 $\lfloor 3.5\rfloor=3,\lfloor\sqrt 2\rfloor =1$. </p><p>$1≤n≤10^6, 0\leq a_i,b_i\leq 3\times 10^6, \sum a_i,\sum b_i\leq 10^7$. </p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>3e6 排除暴力. 注意到$\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnta, cntb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i], cnta[a[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; b[i], cntb[b[i]] ++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [va, ca] : cnta) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [vb, cb] : cntb) &#123;</span><br><span class="line">            ans += <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">abs</span>(va - vb))) * ca * cb;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-国际象棋&quot;&gt;&lt;a href=&quot;#D-国际象棋&quot; class=&quot;headerlink&quot; title=&quot;D - 国际象棋&quot;&gt;&lt;/a&gt;D - 国际象棋&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛34 A-H</title>
    <link href="http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/"/>
    <id>http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2023-01-16T12:00:43.760Z</updated>
    
    <content type="html"><![CDATA[<p>这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题).</p><h2 id="A-dd爱科学1-0-2-0"><a href="#A-dd爱科学1-0-2-0" class="headerlink" title="A - dd爱科学1.0+2.0"></a><a href="https://ac.nowcoder.com/acm/contest/11211/A">A - dd爱科学1.0</a><a href="https://ac.nowcoder.com/acm/contest/11211/C">+2.0</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>数组a[n](1≤n≤1000000, isupper(a[i]) == true). 求通过修改变成不下降序列的最小代价, 每次修改一个数x为y的代价为1(2.0版本为|x - y|).</p><blockquote><p>1.0 ACEBF -&gt; ACEEF 代价 = 1<br>2.0 AEEBC -&gt; AEEEE 代价 = 偏移量总和为|B-E|+|C-E|=3+2=5</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>dp[i][j]表示改至第i位为止, 最后一位为j的最小代价(或者理解成最后一位&lt;=j也行)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;         <span class="comment">// 当前字符为curr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; ++ k) &#123;      <span class="comment">// 从上一字符转移而来</span></span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][k] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到: min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了. 这样可以少O(26)的复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;</span><br><span class="line">    f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i)    f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> curr = str[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前字符改成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; ++ j) &#123;</span><br><span class="line">            <span class="comment">//从上一字符转移而来</span></span><br><span class="line">            <span class="comment">// for(int k = 1; k &lt;= j; ++ k)</span></span><br><span class="line">                <span class="comment">// f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j));</span></span><br><span class="line">            <span class="comment">// min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了</span></span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j] + <span class="built_in">abs</span>(curr - j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)    ans = <span class="built_in">min</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-dd爱探险"><a href="#B-dd爱探险" class="headerlink" title="B - dd爱探险"></a><a href="https://ac.nowcoder.com/acm/contest/11211/B">B - dd爱探险</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n(3≤n≤16)个空间站, 任意两个空间站间可以相互跳跃, 由空间站x跳跃到空间站y所需要的代价为P[x][y],注意不保证p[x][y]=p[y][x], dd可以任意选择出发的空间站, 并通过恰好n-1次跳跃把所有空间站跳完, 并且dd必须选择2次跳跃, 其中一次跳跃中进行重力加速, 另一次跳跃中进行反重力加速, 重力加速会导致当前跳跃代价变为0, 反重力加速会导致当前跳跃代价翻倍(乘2), 问跳完所有空间站所需要最小代价</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>状压DP. 经典TSP like<br>dp[1 &lt;&lt; N][N][2][2]: 走过了i中为1的点,且当前最后到达j, g, rg是否用了重力 / 反重力</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span> &lt;&lt; N][N][<span class="number">2</span>][<span class="number">2</span>];        <span class="comment">// 是否用了重力 / 反重力</span></span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; i][i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">0</span>; val &lt; (<span class="number">1</span> &lt;&lt; n); ++ val) &#123;         <span class="comment">// 1e5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> from = <span class="number">0</span>; from &lt; n; ++ from) &#123;         <span class="comment">// 10</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; n; ++ to) &#123;           <span class="comment">// 10</span></span><br><span class="line">                <span class="keyword">if</span> ((val &gt;&gt; to &amp; <span class="number">1</span>) &amp;&amp; (val &gt;&gt; from &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[val][to][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">0</span>][<span class="number">0</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">0</span>][<span class="number">1</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + <span class="number">0</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">1</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">1</span>][<span class="number">0</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">0</span>] + w[from][to] * <span class="number">2</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">0</span>] + w[from][to]&#125;);</span><br><span class="line">                    dp[val][to][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[val][to][<span class="number">1</span>][<span class="number">1</span>], dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">0</span>] + <span class="number">0</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">0</span>][<span class="number">1</span>] + w[from][to] * <span class="number">2</span>, dp[val ^ <span class="number">1</span> &lt;&lt; to][from][<span class="number">1</span>][<span class="number">1</span>] + w[from][to]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-dd爱矩阵"><a href="#D-dd爱矩阵" class="headerlink" title="D - dd爱矩阵"></a><a href="https://ac.nowcoder.com/acm/contest/11211/D">D - dd爱矩阵</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给一个n∗n的矩阵, 每行各选一个数字, 把选出来的n个数字相加, 一共有$n^{n}$ 种可行答案, 输出前n大</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>优先队列 + 动态前k大 + 数组合并</p><p>类似: <a href="https://www.luogu.com.cn/problem/P2085">P2085 最小函数值</a></p><p>先把问题简化一下, 如果两行, 每行 n个数, 怎么选<br>把两行分别降序 sort, 令第一行为数组 a, 第二行为数组 b<br>则可得到最大值为 a[0]+b[0], 并且得到 a[i]+b[j-1]&gt;a[i]+b[j]&gt;a[i]+b[j+1]<br>所以可以把 a[0]+b[i]全部推入优先队列当中, 并且标记对应的 i,每次取出 top, 再把 a[0]+b[i+1]推入优先队列当中,  n次操作即可得到前 n大<br>复杂度 O(nlogn)<br>回到这个题目, 由于是 n行, 可以每次处理两行, 并成一行新的,  n-1次操作把 n行并成一行, 复杂度 O(n^2 logn)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;a[<span class="number">0</span>] + b[i], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> top = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> sum = top.first, idx = top.second;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;sum - a[idx] + a[idx + <span class="number">1</span>], idx + <span class="number">1</span>&#125;);</span><br><span class="line">        t[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)     cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) cin &gt;&gt; b[j];</span><br><span class="line">        <span class="built_in">merge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-dd爱旋转"><a href="#E-dd爱旋转" class="headerlink" title="E - dd爱旋转"></a><a href="https://ac.nowcoder.com/acm/contest/11211/E">E - dd爱旋转</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>读入一个n∗n的矩阵, 对于一个矩阵有以下两种操作<br>1:顺时针旋180°</p><blockquote><p>[1 2] =&gt; [4 3]<br>[3 4]    [2 1]</p></blockquote><p>2:关于行镜像</p><blockquote><p>[1 2] =&gt; [3 4]<br>[3 4]    [1 2]</p></blockquote><p>给出q个操作, 输出操作完的矩阵</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>操作1: 相当于行镜像, 列镜像各做一次<br>操作2: 相当于行镜像做一次</p><p>只用看操作1和操作2的奇偶性就行了</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">op1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j] = vis[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j] =  <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">swap</span>(m[i][j], m[n + <span class="number">1</span> - i][n + <span class="number">1</span> - j]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">op2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++ i)</span><br><span class="line">        <span class="built_in">swap</span>(m[i], m[n + <span class="number">1</span> - i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            cin &gt;&gt; m[i][j];</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) ++ cnt1;</span><br><span class="line">        <span class="keyword">else</span>        ++ cnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt1 % <span class="number">2</span>)    <span class="built_in">op1</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt2 % <span class="number">2</span>)    <span class="built_in">op2</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            cout &lt;&lt;  m[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-dd爱框框"><a href="#F-dd爱框框" class="headerlink" title="F - dd爱框框"></a><a href="https://ac.nowcoder.com/acm/contest/11211/F">F - dd爱框框</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>读入n(1≤n≤10000000),x(1≤x≤10000),给出n个数a[1],a[2],……,求最小的区间[l,r], 使a[l]+a[l+1]+……+a[r]≥x, 若存在相同长度区间, 输出l最小的那个</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>二分区间长度 + 前缀和check + 二分内更新答案<br>OR 滑动窗口(不会)</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i + len &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span>(s[i + len] - s[i - <span class="number">1</span>] &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            lbound = i, rbound = i + len;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">    &#123;</span><br><span class="line">        ll t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))    r = mid;</span><br><span class="line">        <span class="keyword">else</span>    l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; lbound &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rbound &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-dd爱捣乱"><a href="#G-dd爱捣乱" class="headerlink" title="G - dd爱捣乱"></a><a href="https://ac.nowcoder.com/acm/contest/11211/G">G - dd爱捣乱</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一个完美串(islower == true)应该满足该串中任意长度≥2≥2的子串都不是回文串, 把一个字符从xx变成yy的代价是min(|x-y|,26-|x-y|),(|x-y|为ascii码差值), 问把一个串变成完美串的最小代价</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先讨论完美串满足条件, 如果是奇串, 则每一位前后两位不同, 即 a[i-1]≠a[i+1]<br>如果是偶串, 则相邻两位不同 a[i]≠a[i-1]<br>综上, 只要<strong>任意连续三位都满足两两不同</strong>, 就是一个完美串<br>那么一个很显然的想法, 枚举每一位的情况, 保证再枚举前两位情况, 保证不同的情况下更新答案<br>复杂度 O(n×26^3), 显然不可接受<br>所以进一步想, 每一位最多只会受前两位和后两位的影响, 所以最差情况下五个字母全部不同(abccd, 中间的c要+=2. 如果只有±1,0就不行了). 实际上相邻三个字符各自改变量最多只有五种情况: ±2,±1,0. )<br>所以对于每一位只要枚举改变量就行了,  dp[i][j][k]表示把第 i-1位的改变量是 j, 第 i位的改变量是 k的最小代价<br>dp[i][j][k]←dp[i-1][l][j]<br>最后枚举最后两位改变量 min(dp[n][i][j])就是答案<br>复杂度 O(n×5^3)</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">10</span>, offset = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">6</span>][<span class="number">6</span>];    <span class="comment">// 第i-1位的改变量为j, 第i位的改变量为k</span></span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   a[i] = s[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[<span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span> != (a[<span class="number">2</span>] + k + <span class="number">26</span>) % <span class="number">26</span>) &#123;</span><br><span class="line">                dp[<span class="number">2</span>][j + offset][k + offset] = <span class="built_in">min</span>(dp[<span class="number">2</span>][j + offset][k + offset], <span class="built_in">abs</span>(j) + <span class="built_in">abs</span>(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;    <span class="comment">// i-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;        <span class="comment">// i</span></span><br><span class="line">                <span class="keyword">if</span> ((a[i] + k + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span>) &#123; <span class="comment">// dp[i][j][k]</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">-2</span>; l &lt;= <span class="number">2</span>; ++ l) &#123;            <span class="comment">// i-2</span></span><br><span class="line">                        <span class="keyword">if</span> ( ((a[i - <span class="number">1</span>] + j + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">2</span>] + l + <span class="number">26</span>) % <span class="number">26</span>) </span><br><span class="line">                            &amp;&amp; ((a[i] + k + <span class="number">26</span>) % <span class="number">26</span> != (a[i - <span class="number">2</span>] + l + <span class="number">26</span>) % <span class="number">26</span>)) &#123;     <span class="comment">// dp[i - 1][l][j] </span></span><br><span class="line">                            dp[i][j + offset][k + offset] = <span class="built_in">min</span>(dp[i][j + offset][k + offset], dp[i - <span class="number">1</span>][l + offset][j + offset] + <span class="built_in">abs</span>(k));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-2</span>; j &lt;= <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">-2</span>; k &lt;= <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dp[n][j + offset][k + offset]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-dd爱整齐"><a href="#H-dd爱整齐" class="headerlink" title="H - dd爱整齐"></a><a href="https://ac.nowcoder.com/acm/contest/11211/H">H - dd爱整齐</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>当k=1时abababab, k=2时abbabbabb, k=3时abbbabbb这种类型的是优美序列, 现在给你一个数组a[n]和k((1≤k≤n≤1000000)), 每次你可以让数组中的数减1, 问你最少的操作次数使得n数组为k优美序列. 当然不一定就是abbabb, bbabba这个也是2的优美序列. 只要是优美序列的一段(子串)就行. 同时要保证a&gt;=b. </p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>看到循环结构 / 循环节, 要往模数上想<br>目标序列作为k优美序列的子串, 注意到当len(目标序列) &gt;= k时, 每k个数就会固定有一个a, k-1个b, 所以只需要确认a的位置就行. </p><p>把位置i对 k+1取余, 余数相等的位置的值必然相等. 因为给定了限制条件 a≥b, 所以通过简单贪心+前缀和计算把第i + Z*k位置上的数改变成a, 其他变成b的代价. 复杂度 O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;  </span><br><span class="line">    ++ k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">sum</span><span class="params">(k)</span>, <span class="title">cnt</span><span class="params">(k)</span>, <span class="title">mn</span><span class="params">(k, inf)</span></span>;</span><br><span class="line">    <span class="type">int</span> mna = <span class="number">1e18</span>, suma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];    mna = <span class="built_in">min</span>(mna, a[i]);   suma += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        sum[i % k] += a[i];</span><br><span class="line">        cnt[i % k] ++;</span><br><span class="line">        mn[i % k] = <span class="built_in">min</span>(mn[i % k], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;      <span class="comment">// 把第i个数变成a, 其他的数变成b</span></span><br><span class="line">        <span class="type">int</span> val = sum[i] - cnt[i] * mn[i] + (suma - sum[i]) - (n - cnt[i]) * mna;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题).&lt;/p&gt;
&lt;h2 id=&quot;A-dd爱科学1-0-2-0&quot;&gt;&lt;a href=&quot;#A-dd爱科学1-0-2-0&quot; class=&quot;headerlink&quot; title=&quot;A - dd爱科学1.</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
</feed>
