<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liucj&#39;s Harbour</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-01T15:26:32.645Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周记 - 2023 02.20-02.26</title>
    <link href="http://example.com/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2002.20-02.26/"/>
    <id>http://example.com/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2002.20-02.26/</id>
    <published>2023-02-21T16:00:00.000Z</published>
    <updated>2023-03-01T15:26:32.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-20-周一-晴"><a href="#02-20-周一-晴" class="headerlink" title="02.20 周一 晴"></a>02.20 周一 晴</h2><p>随便做了些codeforces SWERC ICPC的签到题(&lt;=R1500). R1300的题, 能直接双指针, 我还套了个二分上去. 是真的喜欢二分哈… </p><p>晚上跟一道R1800的交互题对线, 想了快1小时, 怼出来了, 猜数题, 归根结底又是逐位确定一个数. 不过要不是能看到错误样例, 估计要多花很多时间. </p><h2 id="02-21-周二-晴"><a href="#02-21-周二-晴" class="headerlink" title="02.21 周二 晴"></a>02.21 周二 晴</h2><p>今天上午无意间想起了12.18(南京站那天)的CSP认证. 想去看看难度如何, 于是就去CSP官网看了看, 刚好题目也放上去了. </p><p>首先当然是看看咱们的答辩T3大模拟难度如何, 没想到鼠标滚轮一下就滚到底了. 题面出人意料的短, 定睛一看题意也很简单, 大概意思就是对一个矩形进行花式遍历 + 套用公式. 可以说是有史以来最简单的T3了. </p><p>T2看了一眼, 感觉比T3难. 至少他涉及到了算法. 大概就是toposort + 自下向上的树形dp. 不得不说CSP的数据是真的弱, 代码有个逆天的BUG, 都能拿90分.  </p><p>T5 看了看, “区间连边”, 不是虚拟点就是线段树优化建图. 但是后者我掌握甚少, 打算明天系统学习一下, 顺便复习下线段树(我的数据结构水平连洛谷的线段树模板题2都敲不出来). </p><p>下午在yxc那学了会平衡树, 久光看了看视频, 就直接打扰了. yxc写的是旋转式的treap. 还没开始敲就知道自己搞不来. 所以我转而去学更加好写的split + merge的fhq 非旋式treap. 也算是对平衡树有了个初步认识. 不过以后就算遇到需要平衡树的题, 难题肯定是需要用到类似区间翻转之类的技术的, 我肯定也写不出来. 简单题我选择用pbds. </p><h2 id="02-22-周三-晴"><a href="#02-22-周三-晴" class="headerlink" title="02.22 周三 晴"></a>02.22 周三 晴</h2><p>今天一早在acwing上恰巧发现了昨天CSP T3”花式遍历”的简洁写法, 于是学习了下. </p><p>接下来便是痛苦的线段树优化建图的学习. 中午下午复习了线段树, 重温了懒标记. 补了一些线段树的基础题. 晚上对着maspy sensei的库学习具体RangeToRangeGraph的模板, 虽然maspy的模板也是基于zkw线段树的, 但是他并没有将线段树设成完全二叉树, 所以叶子节点不好区分. 学完之后拿来在codeforces 406D的模板题Legacy上试了试, 能过. </p><p>不过2022.12的CSP T5却样例都过不了. 纳闷了好久才发现样例的边权是带2的次幂的… 改过来之后, 再加上一个单汇多源最短路, 建个返图就行了. 最后骗了52分, 感觉还行. </p><h2 id="02-24-周四-多云"><a href="#02-24-周四-多云" class="headerlink" title="02.24 周四 多云"></a>02.24 周四 多云</h2><p>今晚打了小白月赛67, 体验是依托答辩. C题三角形切分那题题目也没说面积是否能为小数, 搞了一个多小时. D题是我自己sb了, 复制先前代码的时候忘记改符号了, 又得搞对拍. 然后用multiset又TLE. E题题意也是答辩. 看了半天样例才看懂, 最后5min才有思路, 其实就是倒着DP. 但是不完全对. 赛后5min才过. 不想鉴定hh. </p><h2 id="02-26-周日-晴"><a href="#02-26-周日-晴" class="headerlink" title="02.26 周日 晴"></a>02.26 周日 晴</h2><p>今天算是个值得纪念的日子, 因为就在今天, 我宣布<strong>LCJ正式进军钢琴界</strong>(虽然现在还莫得钱买真钢, 还是先拿家里的雅马哈小电子琴练着先). 下午花了一个下午, 尝试弹了弹拜厄的第11条: &lt;布谷鸟&gt;. 只能勉强把12小节谈下来, 不得不说是真的难. 首先难的便是识谱, 作为完全0基础选手, 只能一条线一条线地去数. 其次协调性也是大问题, 左右手经常打架, 是真的绝望… 不过听了下录音, 觉得还是有模有样的hhh. </p><p>晚上了解到妹妹之前玩的<Simply Piano> 这款APP, 手玩了下发现居然可以根据音频来评判弹奏是否正确. 可是会员贼贵, 一年得400了. 先试用一星期再说, 到时候再求助下万能的淘宝. </p><p>另外提一下今晚的ATC ABC 291. 发挥还行, 前期D题稍微卡了卡. 主要是看到”求方案数”, 我第一反应往组合计数上想了. 想了10min发现莫得思路. 于是看E, 发现E就是个类似差分约束的板子题. 直接toposort求最长路 + 判断是否为排列. 赛时30min的时候过掉了. 再反过来看D, 看到数据范围1e5, 这次很快转变思路, 想到了DP, 于是在第36min拿下. </p><p>本来没想着做出F的, 但是看了看好像又是那种比较能做的图论题. 类似删点最短路, 但又不完全像. 想着用线段树维护拓扑序区间内节点连边的最短路. 要维护区间最小值, 就要涉及到lazy_tag, 一涉及到lazy_tag, 我就寄. 毕竟总共就没做过几道线段树的题, 更别说lazy_tag了, 早知道之前下点功夫把maspy sensei的板子偷师下来, 放到自己的cp_library里面了. 怼了半天都没把样例怼出来. 最后zwl也觉得这种程度的图论题是应该做出来的, 哎真的难顶. 事后看了jiangly 发在B站的录像, 虽然也是起点终点求最短路, 但是他是枚举每一条边(u, v), 然后枚举(u, v)之间的点, 挨个去更新最小值. 我果然是思维僵尸hhh. </p><p>知足常乐咯, 表现分1300+, +30, 重新回到1100分. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-20-周一-晴&quot;&gt;&lt;a href=&quot;#02-20-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;02.20 周一 晴&quot;&gt;&lt;/a&gt;02.20 周一 晴&lt;/h2&gt;&lt;p&gt;随便做了些codeforces SWERC ICPC的签到题(&amp;lt;=R1</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2023 02.13-02.19</title>
    <link href="http://example.com/2023/02/19/%E5%91%A8%E8%AE%B0%20-%202023%2002.13-02.19/"/>
    <id>http://example.com/2023/02/19/%E5%91%A8%E8%AE%B0%20-%202023%2002.13-02.19/</id>
    <published>2023-02-18T16:00:00.000Z</published>
    <updated>2023-03-01T15:12:27.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-15-周三-阴-大风"><a href="#02-15-周三-阴-大风" class="headerlink" title="02.15 周三 阴~大风"></a>02.15 周三 阴~大风</h2><p>今天早上得早起, 去中三三院对面那家 明兴康复中心 做食道测压检查. 早上早饭也没吃, 就出发了. 大概9点左右, 在岗顶路口遇到了JJJ同学, 我靠是真的巧了, 这波只能说直接”逮到”(Doge). 通过VX得知他大概也是45月份左右回学校. </p><p>这次食道测压麻醉方式跟之前不太一样, 护士是先拿普鲁卡因滴进去我的鼻子, 再插管的. 但是难受还是会有点难受的, 主要是吞咽的时候会有些许恶心感. 由于这次检查还是给窦教授测数据, 所以也没收费, 只是收了普鲁卡因的钱. 我从三院拿了药还回中心之后, 就直接回家了. </p><h2 id="02-16-周四-多云-大风"><a href="#02-16-周四-多云-大风" class="headerlink" title="02.16 周四 多云~大风"></a>02.16 周四 多云~大风</h2><p>今天来看窦教授的专家门诊, 主要是希望窦教授能帮我补1针or2针. 结果遇到了另一位不会打嗝的病友, 她是来自Melbourne University的, 她在reddit上有rcpd病友群, 据说有几万人. 她这次来也是参考下国内这边的打针情况. 窦教授说会安排专门的麻醉室来打针, 不过比较难约上. 希望早点约上吧qwq</p><h2 id="02-19-周日-阴"><a href="#02-19-周日-阴" class="headerlink" title="02.19 周日 阴"></a>02.19 周日 阴</h2><p>今天晚上的ATC ABC是真的悲催. 表现分直接干到了400+, 灰名水平… 哎主要卡了C, 当时我就知道这盘大势已去. 没想到D题没有仔细思考就上来写, 到最后才发现做法是假的. 感觉其实就是一道codeforces div2 B题难度的gcd规律题. 是真的难受啊. 直接-52. 掉下1100了. 离青名1200再一次远去. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.15日晚19点30分 &amp;&amp; 02.19</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-15-周三-阴-大风&quot;&gt;&lt;a href=&quot;#02-15-周三-阴-大风&quot; class=&quot;headerlink&quot; title=&quot;02.15 周三 阴~大风&quot;&gt;&lt;/a&gt;02.15 周三 阴~大风&lt;/h2&gt;&lt;p&gt;今天早上得早起, 去中三三院对面那家 明兴康复中心 </summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>事记 - 2022计算机保研回忆录</title>
    <link href="http://example.com/2023/02/16/%E4%BA%8B%E8%AE%B0%20-%202022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    <id>http://example.com/2023/02/16/%E4%BA%8B%E8%AE%B0%20-%202022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/</id>
    <published>2023-02-15T16:00:00.000Z</published>
    <updated>2023-03-03T07:16:42.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事记-2022计算机保研回忆录"><a href="#事记-2022计算机保研回忆录" class="headerlink" title="事记 - 2022计算机保研回忆录"></a>事记 - 2022计算机保研回忆录</h1><blockquote><p>术语:<br>CS: 计算机科学<br>SE: 软件工程</p></blockquote><h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><ul><li><strong>本科院校</strong>: 湖南大学</li><li><strong>专业</strong>: 计算机科学与技术</li><li><strong>排名情况</strong>: 14/225(夏令营), 13/221(预推免). (这俩都是挑的最好的排名)</li><li><strong>外语水平</strong>: 四级629, 六级598. 自认为口语能过关.</li><li><strong>获奖及竞赛</strong>: 详见 <a href="https://lcj2021.github.io/about/">&lt;关于博主&gt;</a> 页面</li><li><strong>科研项目</strong>: 本校实验室实习一年半(产出CCF A类会议挂名一篇), 复旦大学大数据学院一学期的实习(无产出)经历</li><li><strong>最终去向</strong>: 复旦大学大数据学院</li></ul><h2 id="院校选择"><a href="#院校选择" class="headerlink" title="院校选择"></a>院校选择</h2><ul><li><strong>学校</strong>：北上广的高校(中山, 北航, 同济, 华东师, 华工 etc.) + 华五人(理想: 交&gt;复&gt;南&gt;浙&gt;科&gt;人)<br>  个人不太倾向研究所, 考虑到将来的选择, 可能更加注重title &amp;&amp; 身为广州人, 也更倾向于回家读书.</li><li><strong>硕/博</strong>：硕士博士都行, 但是优先硕士. 如果科研顺利可以转博.</li><li><strong>导师</strong>：人品 &gt; push程度 &gt; 学术能力<br>  人品rk first</li></ul><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><table><thead><tr><th>学院</th><th>入营</th><th>优营</th></tr></thead><tbody><tr><td>人大信院</td><td>❌</td><td>-</td></tr><tr><td>复旦大数据</td><td>✔️</td><td>候补</td></tr><tr><td>南大CS</td><td>候补</td><td>放弃</td></tr><tr><td>南大SE</td><td>候补</td><td>放弃</td></tr><tr><td>科大大数据</td><td>候补</td><td>放弃</td></tr><tr><td>上交电院</td><td>❌</td><td>-</td></tr><tr><td>同济SE</td><td>❌</td><td>-</td></tr><tr><td>计算所</td><td>✔️</td><td>放弃</td></tr><tr><td>天大智算</td><td>✔️</td><td>放弃</td></tr><tr><td>自动化所</td><td>❌</td><td>-</td></tr><tr><td>北航CS</td><td>✔️</td><td>✔️</td></tr><tr><td>华东师SE</td><td>✔️</td><td>✔️</td></tr><tr><td>中山CS</td><td>❌</td><td>-</td></tr><tr><td>华工CS</td><td>❌</td><td>-</td></tr><tr><td>哈深CS</td><td>❌</td><td>-</td></tr><tr><td>武大CS</td><td>❌</td><td>-</td></tr><tr><td>华科CS</td><td>❌</td><td>-</td></tr></tbody></table><blockquote><p>P.S.</p><p>中山大学: 由于个人操作疏忽, 在报名时, 忘记将最重要的盖了校章的资料上传了. 导致尽管有一群海王放弃, 开放第二波入营, 我也没能入营. 可以说是彻底无缘了.</p><p>南京大学CS &amp;&amp; SE: 并不是一批次入营, 而是在第二批入营的. 可是和华东师大的最终面试汇报冲突了, 权衡风险利弊(南大408大概率成为炮灰, 华东师范当时已经通过了笔试和导师面试)后还是选择了放弃.</p><p>科大大数据: 大概率是由于rk过低, 只能候补入营. 最后也没后补上.</p><p>清北的一些研究院也都投了, 显然白给hhh</p></blockquote><h3 id="华东师范大学-SE"><a href="#华东师范大学-SE" class="headerlink" title="华东师范大学 SE"></a>华东师范大学 SE</h3><p>ECNU的系统可以填报2个志愿, 所以我CS和SE都填了. 可是令我意外的是居然入了SE的夏令营, 听说ECNU有oq机制, 没想到居然放我入了SE. 具体考核的话, 分为机试 + 导师面试(包括看论文) + 个人汇报, 过程还是十分繁琐的, 这也算是筛除海王的一种方式吧. </p><h4 id="Stage1-机试"><a href="#Stage1-机试" class="headerlink" title="Stage1: 机试"></a>Stage1: 机试</h4><p>ECNU的机试是出了名的难. 这次我算是亲身体会到了. 总共3题. T1就按照题意模拟, 但我找不出BUG. T2感觉像是树形dp, 不过保守估计难度对应于codeforces 2000+分. T3是感觉像是删边最短路, 直接打扰, 不配看题. </p><p>还好是IOI赛制, 最后T1 WA了一个点85pt, T2瞎搞DP, 骗了30pt. T3爆零. 85+30+0=115pt. 有一说一T3直接暴力二进制枚举所有边, 可能还是可以骗些分的. 总体来说感觉还行. </p><h4 id="Stage2-导师单面"><a href="#Stage2-导师单面" class="headerlink" title="Stage2: 导师单面"></a>Stage2: 导师单面</h4><p>ECNU要求联系学院的一位老师, 联系好之后加了老师的QQ. 之后老师安排我阅读他的一篇<strong>长文</strong>. 我当时没注意到长文这一条件, 再加上当时在上苦逼的编译器小学期课, 天天在院楼苦逼地罚坐, 所以我临面试前一天赶忙看了看一篇短文, 大致是时空数据挖掘, 众包方向的A刊文章. </p><blockquote><p>P.S.</p><p>我还了解到我联系的这位老师和他所在的实验室都是热门, 他还跟我说学硕名额十分有限. 意思懂的都懂qwq</p></blockquote><p>面试首先要求我汇报文章的主要内容, 然后老师提问了我对于实时性要求更高的场景, 能不能提出在线的算法, 我想了想瞎扯了下, 老师似乎不是很满意. </p><p>其次便是算法考核. T1是问给定一个数组a, 要求把这个数组分成2组, 使得两组的总和尽可能接近. 这题还算比较简单, 就是一个简单的背包dp, 目标物品价值便是1/2的数组总和. 老师听了似乎不是很满意, 要求我给出证明, 我只得面试结束后给他发过去. T2看似是最小生成树的问题, 但是没想到怎么建图, 所以我就说二分答案. 老师似乎不太理解我的意思. 到这里面试便草草结束. </p><p>无论是机试的考核内容和难度, 还是单独面试的算法考核, 都不难看出ECNU SE 对于编程和算法的要求都是蛮高的. </p><h4 id="Stage3-最终汇报"><a href="#Stage3-最终汇报" class="headerlink" title="Stage3: 最终汇报"></a>Stage3: 最终汇报</h4><p>ECNU要求我们准备一个自我介绍的PPT, 然后在PPT内要放上Stage2所汇报的论文的内容. 汇报当天我在等候面试排队的时候, NJU CS的机试恰好开始了, NJU的小姐姐打电话来说要提前进场准备验证身份, 还说不参加要提前说. 没得办法, 只好先拖住了. 然鹅到NJU机试开始, 我都没能排队进入最终汇报, 只能打电话到NJU说放弃机试. 最终面试可以选择中英文汇报, 我由于时间仓促, 选择了中文. 到最后有个导师群面, 导师们用英文提问, 我只记得一个问题是介绍我在本校实验室所做的工作, 勉强支支吾吾答上来了. </p><p>最后夏令营闭幕式上会宣布优营成员, 还通过邮件发了优营证书, 属于是十分有心了. 我看优营还有SJTU的大佬, 属实打扰了. </p><h3 id="北京航空航天大学-CS"><a href="#北京航空航天大学-CS" class="headerlink" title="北京航空航天大学 CS"></a>北京航空航天大学 CS</h3><p>北航没有因为我过低的rank就把我筛掉, 估计是看在我那一丢丢算法竞赛经历的面子上才放我入营的. 知遇之恩, 由是感激.</p><p>北航考核方式是<strong>机试+面试</strong>. </p><h4 id="Stage1-机试-1"><a href="#Stage1-机试-1" class="headerlink" title="Stage1: 机试"></a>Stage1: 机试</h4><p>北航的机试一直都是以码农题著称, 我看了下往年的机试题, 感觉是难度还能接受的两道大模拟(低于CSP T3), 没想到今年的模拟这么逆天…</p><p>赛制是恶心的OI赛制. 可以用CSP的成绩来抵, 并且语言限定C++. 不过我CSP分数实在过低过于感人, 所以我还是来考机试了.</p><p>T1是字符串处理 + 结构体排序. 由于是线上机试, 所以拥有东道主优势(doge). 其实是自己的键盘快捷键ide自己比较熟悉啦. T1应该拿满60了, 因为我T2实在是没办法, 所以自己造了几组数据梭哈T1.</p><p>T2是关于编译原理的应用的巨大模拟之依托答辩, 实在难以模拟, 写不出来就输出样例想骗一下分. 不过这次机试好像并没有筛人, 但是机试很明显是算在了面试总评里面的. </p><p>赛后在腾讯会议看到了自己的高中同学, 西电acm知名选手et3_tsy. 我俩刚好在同一个房间, 祝福他能取得优异的成绩. 赛后我俩交流才发现T2连他这种巨佬都没干过, 区分度属实有点过于低了.</p><h4 id="Stage2-导师群面"><a href="#Stage2-导师群面" class="headerlink" title="Stage2: 导师群面"></a>Stage2: 导师群面</h4><p>面试是压力面, 内容包括<strong>政治+408+数学+英语</strong>, 面试问题汇总如下：</p><ul><li>如今正处百年未有之大变局, 我们身为青年应该作为</li><li>函数极限的定义, 用\epsilon-N语言来描述</li><li>同时抛两个硬币, 其中一个是正面, 问另一个是正面的概率</li><li>一个随机生成的01串, 口述一个算法能够统计其中的最长连续1的子串长度.</li><li>续上述问题, 长度为10000, 最长的连续1的子串长度期望大概是多少.</li><li>为什么要创建网络层</li><li>电话号码 IP相关? (记不清了)</li></ul><p>之前在知乎经验贴上看到北航的面试很硬核. やはりや, 北航的夏令营确实是一种压力面, 就是那种几个老师会一起怼你的那种, 丝毫不会放松进攻节奏. 问到T4时我直接脱口而出dp, dp[i]表示以第i个字符作为结尾的1子串最大长度, 从dp[i-1]到dp[i]分为00, 01, 10, 11四种转移. 复杂度O(n). しかし, 接下来的T5我直接就傻了. 概率期望类的题我一向不擅长, 我仔细想了想状态设计. 可能是我误解了老师的问题, 老师打断我说大概给出一个数字. 我就瞎蒙了个10+给他们. 到此为止, 可以看得出老师们对于我以上的回答都是挺满意的.</p><p>然鹅接下来的问题直接就拉低了我的分数. 一位老师直接开始问计网相关的问题… “哦豁~完蛋!” 要知道咱的计网可是hsr教的呀(保研成绩单上扫一眼, 计网分数显著低的同学肯定是咱78班的. doge).</p><p>最终在我等复旦候补的时候, 打电话问我确认意向, 得知录到了计算机学院的0835 软件工程, 感觉已经很不错了.</p><p>北航最终认可了我, 再加上我的队友zwling也最终去北航了, 因此北航在我心目中第好感度和地位直接排进前3.</p><h3 id="天大智算"><a href="#天大智算" class="headerlink" title="天大智算"></a>天大智算</h3><p>天大属于海王营. 首先参加机试, 机试难度 &lt; codeforces div4, 感觉很多人都能AK. 但是是OI赛制, 就很烦. 我提前大约20分钟完成. 但是没注意到最后一题的公式弄错了个地方, 估计那题爆零了qwq. 最后居然在Q群上说机试仅作为参考? 迷惑行为了属于是. 后续我也没参加了. </p><h3 id="计算所"><a href="#计算所" class="headerlink" title="计算所"></a>计算所</h3><p>计算所我报名的是”网络数据科学与技术重点实验室”, 其实是实在很难找到方向匹配的导师, 这个已经是找的相对匹配些的了. 入营邮件是群发的, 一看其他邮件的二级域名, pku, tongji, 实在是打扰了. 虽然最后也没想着参加机试, 但还是先回复了:”lcj+确认参加”. 结果最后还是没去参加机试. </p><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>夏令营拿到了北航CS和华师SE的offer可以作为保底, 同时争取下复旦的候补, 此时我已经身心俱疲, 于是开摆. 只报了南大的CS, 估计是被拉黑了, 没能入营(虽然我知道就算入营了也不可能卷过408大关, 拿到0812学硕).</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于: 02.15日晚19点30分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事记-2022计算机保研回忆录&quot;&gt;&lt;a href=&quot;#事记-2022计算机保研回忆录&quot; class=&quot;headerlink&quot; title=&quot;事记 - 2022计算机保研回忆录&quot;&gt;&lt;/a&gt;事记 - 2022计算机保研回忆录&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;术</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux - WSL2 下使用宿主机代理</title>
    <link href="http://example.com/2023/02/14/Linux%20-%20WSL2%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2023/02/14/Linux%20-%20WSL2%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/</id>
    <published>2023-02-13T16:00:00.000Z</published>
    <updated>2023-02-15T13:26:37.634Z</updated>
    
    <content type="html"><![CDATA[<p>WSL2科学上网</p><p>前言: 情人节当天搞了一晚上… 最后参考的这篇才成功 <a href="https://www.cnblogs.com/tuilk/p/16287472.html">https://www.cnblogs.com/tuilk/p/16287472.html</a>,</p><h2 id="1-Windows下打开代理"><a href="#1-Windows下打开代理" class="headerlink" title="1. Windows下打开代理"></a>1. Windows下打开代理</h2><h3 id="1-1-允许局域网"><a href="#1-1-允许局域网" class="headerlink" title="1.1 允许局域网"></a>1.1 允许局域网</h3><p>以<code>Clash</code>为例, 购买相关<code>配置</code>, 选择<code>主页</code>选项卡, 开启<code>允许局域网</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519095954875-534125057.png"></p><h3 id="1-2-开启防火墙"><a href="#1-2-开启防火墙" class="headerlink" title="1.2 开启防火墙"></a>1.2 开启防火墙</h3><p>打开<code>Windows Defender 防火墙</code>, 选择<code>允许应用或功能通过 Windows Defender 防火墙</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519100052696-2100542151.png"></p><p>点击<code>更改设置</code>, 找到<code>Clash for Windows</code>, 然后勾选<code>专用</code>和<code>公用</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519100127832-1936469422.png"></p><blockquote><p>如果找不到<code>Clash for Windows</code>, 点击下方的<code>允许其他应用</code>, 然后找到安装路径, 将<code>Clash for Windows.exe</code>文件加入进来.</p></blockquote><h2 id="2-配置WSL2-bashrc-长期配置"><a href="#2-配置WSL2-bashrc-长期配置" class="headerlink" title="2. 配置WSL2(.bashrc 长期配置)"></a>2. 配置WSL2(.bashrc 长期配置)</h2><p>写脚本, 放到脚本文件夹. 通过在.bashrc里配置alias调用脚本, 实现proxy的快速set和unset.</p><p>新建<code>proxy.sh</code>脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">hostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)</span><br><span class="line">wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">port=7890</span><br><span class="line"></span><br><span class="line">PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;</span><br><span class="line"></span><br><span class="line">set_proxy()&#123;</span><br><span class="line">  export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">  export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">  export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">  export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">  export ALL_PROXY=&quot;$&#123;PROXY_SOCKS5&#125;&quot;</span><br><span class="line">  export all_proxy=$&#123;PROXY_SOCKS5&#125;</span><br><span class="line"></span><br><span class="line">  git config --global http.https://github.com.proxy $&#123;PROXY_HTTP&#125;</span><br><span class="line">  git config --global https.https://github.com.proxy $&#123;PROXY_HTTP&#125;</span><br><span class="line"></span><br><span class="line">  echo &quot;Proxy has been opened.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset_proxy()&#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset HTTP_PROXY</span><br><span class="line">  unset https_proxy</span><br><span class="line">  unset HTTPS_PROXY</span><br><span class="line">  unset ALL_PROXY</span><br><span class="line">  unset all_proxy</span><br><span class="line">  git config --global --unset http.https://github.com.proxy</span><br><span class="line">  git config --global --unset https.https://github.com.proxy</span><br><span class="line"></span><br><span class="line">  echo &quot;Proxy has been closed.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_setting()&#123;</span><br><span class="line">  echo &quot;Host IP:&quot; $&#123;hostip&#125;</span><br><span class="line">  echo &quot;WSL IP:&quot; $&#123;wslip&#125;</span><br><span class="line">  echo &quot;Try to connect to Google...&quot;</span><br><span class="line">  resp=$(curl -I -s --connect-timeout 5 -m 5 -w &quot;%&#123;http_code&#125;&quot; -o /dev/null www.google.com)</span><br><span class="line">  if [ $&#123;resp&#125; = 200 ]; then</span><br><span class="line">    echo &quot;Proxy setup succeeded!&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;Proxy setup failed!&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;set&quot; ]</span><br><span class="line">then</span><br><span class="line">  set_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;unset&quot; ]</span><br><span class="line">then</span><br><span class="line">  unset_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;test&quot; ]</span><br><span class="line">then</span><br><span class="line">  test_setting</span><br><span class="line">else</span><br><span class="line">  echo &quot;Unsupported arguments.&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意: 其中第4行的<code>&lt;PORT&gt;</code>更换为自己的代理端口号.</p></blockquote><ul><li><code>source ./proxy.sh set</code>: 开启代理</li><li><code>source ./proxy.sh unset</code>: 关闭代理</li><li><code>source ./proxy.sh test</code>: 查看代理状态</li></ul><h3 id="2-1-任意路径下开启代理"><a href="#2-1-任意路径下开启代理" class="headerlink" title="2.1 任意路径下开启代理"></a>2.1 任意路径下开启代理</h3><p>可以在<code>~/.bashrc</code>中添加如下内容, 并将其中的路径修改为上述脚本的路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias proxy=&quot;source /path/to/proxy.sh&quot;</span><br></pre></td></tr></table></figure><p>然后输入如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>那么可以直接在任何路径下使用如下命令:</p><ul><li><code>proxy set</code>: 开启代理</li><li><code>proxy unset</code>: 关闭代理</li><li><code>proxy test</code>: 查看代理状态</li></ul><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>使用<code>curl</code>即可验证代理是否成功, 如果有返回值则说明代理成功.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WSL2科学上网&lt;/p&gt;
&lt;p&gt;前言: 情人节当天搞了一晚上… 最后参考的这篇才成功 &lt;a href=&quot;https://www.cnblogs.com/tuilk/p/16287472.html&quot;&gt;https://www.cnblogs.com/tuilk/p/162874</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Network" scheme="http://example.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2023 02.06-02.12</title>
    <link href="http://example.com/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/"/>
    <id>http://example.com/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/</id>
    <published>2023-02-13T16:00:00.000Z</published>
    <updated>2023-02-15T12:12:25.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-10-周五-多云-阴"><a href="#02-10-周五-多云-阴" class="headerlink" title="02.10 周五 多云~阴"></a>02.10 周五 多云~阴</h2><p>今天晚上参加了晚上7点的小白月赛66. 开局上来就被A搞了快10分钟. B更是因为没讨论 A &lt;= B的情况调到40分钟. D题一开始也是不会做, 不过好在发现了平方式的用意. 最后还剩半个多小时做E, 想了会发现是道完全图的构造题. 想着用set insert + erase + lower_bound 3e5次(2s时限)硬怼构造边权, 不过没写完. 赛后写完交了, TLE. やはり(yahari 果然)还是找出边权递增的顺序去赋值边权才行. </p><blockquote><p>后话: 其实set硬怼也行, 不过得用到 霓虹大神maspy的 <a href="https://maspypy.github.io/library/ds/fastset.hpp">fastset</a></p></blockquote><p>最后四题, 感觉我做E的时候还是太呆了. WF说要暂不返校要填表, 而且明天之前就要截止了. 我想着没啥理由, 然后就打了个嗝, 不过不是很畅通, 是那种嘶哑的, 心想之前考虑打 “加强针” (中间右边再补针). 不如趁这个机会打了得了, 所以就这么填了. </p><h2 id="02-11-周六-多云-阴"><a href="#02-11-周六-多云-阴" class="headerlink" title="02.11 周六 多云~阴"></a>02.11 周六 多云~阴</h2><p>早上补昨晚小白月赛66的F题, 发现好像是个挺简单的一眼二分 + 尝试性贪心(只用从后往前合并和从前往后合并两种, 枚举下就知道哪个更优了). </p><p>晚上打ABC 289. 前四题依然慢速, 做了20+分钟… 尤其是B题别人用题目性质 + 双指针很快写完, 我还用并查集硬怼模拟. C题二进制枚举看半天题. D题因为转为index 0 based党, 所以dp方式也改成了刷表法. しかし(shi ka shi 可是) vector开小了, RE了一发. E题想了一个小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. 以为是O(n^2)的, 其实是O(m^2)的, 都没看到边数m &lt;= 2000. 属于是瞎猫撞上死耗子了. </p><p>表现分1364, +29来到1138. 离青名只差62分了, がんばって (顽张って ga n ba te加油)!</p><h2 id="02-12-周日-多云-小雨"><a href="#02-12-周日-多云-小雨" class="headerlink" title="02.12 周日 多云~小雨"></a>02.12 周日 多云~小雨</h2><p>中午起床收到微信下午开组会. やはり还是得继续科研进度. 开会讨论后, 认为应该从下游任务的实际实验效果看看. 所以得用到分布式图计算的环境. 但是我之前除了gstore外就没用过其他框架了. 问了蔡学长, 得知服务器集群得校园网访问. 实在难顶. </p><p>下午4点 场的codeforces 852 div2. 难得不是阴间时间. 直接炸穿. A40+分钟才过. 哎情况没讨论好, 多写了if, 其实都要考虑的. B一开始看到了条件”数组元素绝对值之差为1”, 后面又忘了这个条件了. C吃完饭后回来才写完. </p><p>表现分只有不到1000分呢. 我直接好家伙, 上个青名都费劲, 我好像只配打div3和div4. 哎谁让我上次div4没把握好机会呢? 要是上次写慢些, 老老实实把树状数组写了, 再检查好二分边界, 也没那么多烦事了. 不过呢, 这点掉分只能说是小问题, 打还是会继续打的. 只是cf这种rated波动那么大的比赛, 不如直接彻底开摆得了. 这样得失心放轻些, 说不定还能表现得正常些. 下次div2我想直接从C或D开始干了, 效仿rainboy大神. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.15日晚19点30分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-10-周五-多云-阴&quot;&gt;&lt;a href=&quot;#02-10-周五-多云-阴&quot; class=&quot;headerlink&quot; title=&quot;02.10 周五 多云~阴&quot;&gt;&lt;/a&gt;02.10 周五 多云~阴&lt;/h2&gt;&lt;p&gt;今天晚上参加了晚上7点的小白月赛66. 开局上来就被</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 289 A-E</title>
    <link href="http://example.com/2023/02/11/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20289%20A-E/"/>
    <id>http://example.com/2023/02/11/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20289%20A-E/</id>
    <published>2023-02-10T16:00:00.000Z</published>
    <updated>2023-02-15T13:25:48.137Z</updated>
    
    <content type="html"><![CDATA[<p>+29! 表现分1364, 历史第二高, 感觉不错. </p><p>E题冥思苦想想了1个多小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. </p><h2 id="A-flip"><a href="#A-flip" class="headerlink" title="A. flip"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_a">A. flip</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将给定的01串s, 进行01翻转后输出</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>)   cout &lt;&lt; <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-V"><a href="#B-V" class="headerlink" title="B. V"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_b">B. V</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我是直接按照题意用并查集模拟了整个过程. 对于</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">    p[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x, x --;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">wcc</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">iota</span>(p, p + n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        <span class="built_in">merge</span>(x, x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        wcc[<span class="built_in">find</span>(i)].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(wcc[i]));</span><br><span class="line">        <span class="built_in">reverse</span>(<span class="built_in">all</span>(wcc[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)    S.<span class="built_in">insert</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = *S.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : wcc[<span class="built_in">find</span>(now)]) &#123;</span><br><span class="line">            cout &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            S.<span class="built_in">erase</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Coverage"><a href="#C-Coverage" class="headerlink" title="C. Coverage"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_c">C. Coverage</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>二进制枚举</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector <span class="title">S</span><span class="params">(m, vector&lt;<span class="type">int</span>&gt;(n))</span></span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> c;  cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;   x --;</span><br><span class="line">            S[i][x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">0</span>; val &lt; (<span class="number">1</span> &lt;&lt; m); ++ val) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">has</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; m; ++ b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt;&gt; b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (S[b][i]) &#123;</span><br><span class="line">                    has[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(has), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">            ++ ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Step-Up-Robot"><a href="#D-Step-Up-Robot" class="headerlink" title="D. Step Up Robot"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_d">D. Step Up Robot</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>dp[i]表示i点能否从0到达. 我用的刷表法, 每个i点更新n个新状态. </p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> m;  cin &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">is_trap</span><span class="params">(<span class="number">200&#x27;000</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">        is_trap[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">200&#x27;000</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_trap[i])     <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> inc : a) &#123;</span><br><span class="line">            dp[i + inc] |= dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(dp[x])</span><br><span class="line">    <span class="keyword">if</span> (dp[x]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Swap-Places"><a href="#E-Swap-Places" class="headerlink" title="E. Swap Places"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_e">E. Swap Places</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>新套路get. 难得赛时能想出这种没见过的东西. </p><p>两点绑定在一起进行 bfs. </p><p>queue 的元素为/[当前a所在节点, 当前b所在节点, 已经走过的步数/]</p><p>同时用dp[i][j]表示a到i, 且同时b到j的最小步数</p><p>每个状态只会入队出队一次, 复杂度O(n2)</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : c)   cin &gt;&gt; x;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u --, v --;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, inf)); <span class="comment">// </span></span><br><span class="line">    dp[<span class="number">0</span>][n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [ca, cb, cd] = q.<span class="built_in">front</span>();  q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (ca == n - <span class="number">1</span> &amp;&amp; cb == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cd &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> na : g[ca]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> nb : g[cb]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[na] == !c[nb] &amp;&amp; dp[na][nb] &gt; dp[ca][cb] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[na][nb] = dp[ca][cb] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;na, nb, dp[na][nb]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-flip-1"><a href="#A-flip-1" class="headerlink" title="A. flip"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_a">A. flip</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;+29! 表现分1364, 历史第二高, 感觉不错. &lt;/p&gt;
&lt;p&gt;E题冥思苦想想了1个多小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. &lt;/p&gt;
&lt;h2 id=&quot;A-flip&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_并查集" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="算法_图论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.30-02.05</title>
    <link href="http://example.com/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/"/>
    <id>http://example.com/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2023-02-15T12:12:46.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-03-周五-多云-小雨"><a href="#02-03-周五-多云-小雨" class="headerlink" title="02.03 周五 多云~小雨"></a>02.03 周五 多云~小雨</h2><p>今天主要参加了晚上10点半的div4 849. 开局虽然又被E (R1100)卡了下, 不过还是很快能搞定. F题一开始想不到好做法, 本来打算写树状数组, 但是没整理板子, 区间修改之类的又得重新写, 所以就投机取巧试了试用set维护还能修改的坐标. 一交, 诶居然能过. 然后就没理了. </p><p>G1和G2我一开始以为做了G2, G1也能一起交. 所以G1的罚时多了很多. G2我一开始想错了, 不过还是很快想到了二分. 并且很快写完了. 一看才400+人过. 暗自窃喜. 正式榜甚至进了首页, 表现分高达2050! zwling还觉得我能直接上蓝.  </p><p>没想到小丑竟是我自己…F和G2都FST了. 早知道F老老实实写区间修改 + 单点查询 树状数组了. G2是因为二分边界<code>l = 0</code>写成了<code>l = 1</code>. 我是真的讨厌这种下标从0开始, 从1开始的臭东西. 以后想坚定做下标0-base党了. 不过看到G2居然是R1900的题, 十分震惊. 感觉其他R1900的题比他难得不止一点半点. </p><h2 id="02-04-周六-小雨-中雨"><a href="#02-04-周六-小雨-中雨" class="headerlink" title="02.04 周六 小雨~中雨"></a>02.04 周六 小雨~中雨</h2><p>晚上有Atcoder Beginner Contest 288. 8点麻木地开打, 前两题签完到, C题经典手速慢的惊人, 一开始写toposort, 发现不对劲, 才改并查集. D题罚坐1个半小时, 一看全场就800+过, 是真的逆天. 属于那种大聪明之差分性质挖掘题. rk2000+, 直接完蛋, 不过最终-6. Atcoder yyds!</p><h2 id="02-05-周日-小雨"><a href="#02-05-周日-小雨" class="headerlink" title="02.05 周日 小雨"></a>02.05 周日 小雨</h2><p>晚上8点 tourist场的div2. 难得不是阴间时间, 但是考虑到tourist出题, 上次div1+div2合并场的A都给我干趴下了. 这次也不例外, A1 + A2直接给我整了半个小时. B题又是上下限约束题, 想了挺久才想出来. C题贪心, 但是本来1层循环4行的东西, 我写了一堆if 的答辩东西. 还WA了一发. 一看rk2000+. 好家伙我赛前看见register人数18000+, 现在只有7000+提交, 是真的逆天. 不过还好一分没丢没涨. </p><p>D结论瞎撞撞对了, 不过是真的难写. 其实主要是我的思路十分混乱, 其实只用把每个人视作多个 &lt;need char, give char&gt; 就行了. 先是恰好互补的人交换. 交换完剩下的一定只有3种人, 这3种人恰好能组成交换环. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.06日晚22点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-03-周五-多云-小雨&quot;&gt;&lt;a href=&quot;#02-03-周五-多云-小雨&quot; class=&quot;headerlink&quot; title=&quot;02.03 周五 多云~小雨&quot;&gt;&lt;/a&gt;02.03 周五 多云~小雨&lt;/h2&gt;&lt;p&gt;今天主要参加了晚上10点半的div4 849</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>笔记 - CP模板</title>
    <link href="http://example.com/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2023-02-14T14:22:24.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计数模板"><a href="#计数模板" class="headerlink" title="计数模板"></a>计数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> + (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> - (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> * (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> / (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *= (<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> /= (<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="type">int</span> v; os &gt;&gt; v; a = <span class="built_in">ModInt</span>(v); <span class="keyword">return</span> os;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b; <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>) u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;mod&gt;;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">fenwick</span>(<span class="type">int</span> n): <span class="built_in">n</span>(n) &#123;tr.<span class="built_in">resize</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (++ pos; pos &gt;= <span class="number">1</span>; pos -= <span class="built_in">lowbit</span>(pos)) &#123;</span><br><span class="line">            res += tr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (++ pos; pos &lt;= n; pos += <span class="built_in">lowbit</span>(pos)) &#123;</span><br><span class="line">            tr[pos] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串-双-哈希"><a href="#字符串-双-哈希" class="headerlink" title="字符串(双)哈希"></a>字符串(双)哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">hash_t</span> = array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod0 = <span class="number">1e9</span> + <span class="number">7</span>, mod1 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">hash_t</span> base = &#123;<span class="number">13331</span>, <span class="number">23333</span>&#125;;</span><br><span class="line"><span class="type">hash_t</span> pw[N];</span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> + (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] + b[<span class="number">0</span>]) % mod0, (a[<span class="number">1</span>] + b[<span class="number">1</span>]) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> - (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] - b[<span class="number">0</span>] + mod0) % mod0, (a[<span class="number">1</span>] - b[<span class="number">1</span>] + mod1) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> * (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] * b[<span class="number">0</span>] % mod0, a[<span class="number">1</span>] * b[<span class="number">1</span>] % mod1&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pw[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pre[i] = pre[i - <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">    suf[i] = suf[i + <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志:"></a>更新日志:</h2><p>2023.01.18: </p><p>加入计数模板 + 字符串双哈希模板</p><p>2023.02.06: </p><p>加入朴素fenwick模板</p><p>等cf上1500 / atcoder上青名, 就着手构建自己的library</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计数模板&quot;&gt;&lt;a href=&quot;#计数模板&quot; class=&quot;headerlink&quot; title=&quot;计数模板&quot;&gt;&lt;/a&gt;计数模板&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记_模板" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 848 (Div. 2) A-D</title>
    <link href="http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/"/>
    <id>http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/</id>
    <published>2023-02-01T16:00:00.000Z</published>
    <updated>2023-02-02T08:04:42.881Z</updated>
    
    <content type="html"><![CDATA[<p>比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难.</p><p>补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]=dp[n-1]+1. 从而求出dp[1]</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定由 1 和 -1 组成的数组，你必须选择两个相邻元素，然后翻转它们的符号。</p><p>求翻转后数组的最大和。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于相邻的2个数, 总共3种情况: </p><ol><li>(-1, -1)             总贡献 +4</li><li>(-1, 1) / (1, -1)    总贡献 0</li><li>只有(1, 1)           总贡献 -4</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(a), <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> add0 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; a[i] == <span class="number">-1</span> &amp;&amp; a[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; ans + <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; a[i] * a[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            add0 = <span class="literal">true</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add0)   cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; ans - <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定排列 p 和数组 a和正整数d. </p><p>定义a是不好数组, 如果对于所有a[1~m-1], 都有pos[a[i]] &lt; pos[a[i+1]] &lt;= pos[a[i]] + d</p><p>比如: p=[4,2,1,3,6,5] 和 d=2</p><blockquote><p>a=[2,3,6] is a not good array.<br>a=[2,6,5] is good because pos(a1)=2, pos(a2)=5, so the condition pos(a2)≤pos(a1)+d is not satisfied.<br>a=[1,6,3] is good because pos(a2)=5, pos(a3)=4, so the condition pos(a2)&lt;pos(a3) is not satisfied.</p></blockquote><p>请多次交换排列p中相邻的元素，使得a变成好数组</p><p>求最少交换次数。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>要破坏现有满足的2个条件, 只需要破坏其中一个条件就行. </p><p>枚举每个数, 分别计算破坏左边不等式和右边不等式的代价. 取个min就行</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span>, <span class="title">a</span><span class="params">(m)</span>, <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];    p[i] --;</span><br><span class="line">        pos[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x, x --;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> px = pos[x], py = pos[y];</span><br><span class="line">        <span class="keyword">if</span> (px + n - <span class="number">1</span> - py &gt;= d - (py - px) + <span class="number">1</span>)   ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(d - (py - px) + <span class="number">1</span>, (<span class="type">int</span>)<span class="number">0</span>));</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(py - px, (<span class="type">int</span>)<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Flexible-String"><a href="#C-Flexible-String" class="headerlink" title="C. Flexible String"></a><a href="https://codeforces.com/contest/1778/problem/C">C. Flexible String</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>现有字符串 a,b 。请选择修改 a 中至多 k 种 字符，对于 每一个 这样的字符，都可以将其改为另一个其他字符。</p><p>求修改后 a’ 的子串以及 b 的子串中，满足 a’[l..r] = b[l..r] 的数量的最大值。保证 a 中至多有 10 种字符。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>n(1e5), k(10). </p><p>暴力二进制枚举子集, 最高O(2^10 * 1e5), 2s能接受. </p><p>枚举每个子集, 对于a[i], 若是子集里的字母, 都替换成b[i]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1024 * 1e5 2s 应该能过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string a, b;    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    string unique_a = a;</span><br><span class="line">    <span class="built_in">uniq</span>(unique_a);</span><br><span class="line">    <span class="type">int</span> m = unique_a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(unique_a, m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= m) &#123;</span><br><span class="line">        cout &lt;&lt; n * (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">0</span>; val &lt; (<span class="number">1</span> &lt;&lt; m); ++ val) <span class="keyword">if</span> (<span class="built_in">popcountll</span>(val) == k) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">change</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; m; ++ b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt;&gt; b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                change[unique_a[b] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (change[a[i] - <span class="string">&#x27;a&#x27;</span>] || a[i] == b[i]) &#123;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr += len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len)    curr += len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, curr);</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Flexible-String-Revisit"><a href="#D-Flexible-String-Revisit" class="headerlink" title="D. Flexible String Revisit"></a><a href="https://codeforces.com/contest/1778/problem/D">D. Flexible String Revisit</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定两个二进制串 a, b. </p><p>每次随意翻转一个二进制位，求第一次使得 a=b 所需的期望次数。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设有 i 个二进制位不同的情况下，所需的次数是 dp[i] ，则有转移方程：</p><p><code>dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</code></p><p>其含义是，我们进行一次翻转后，有 i/n 的概率减少一个不同的位，这样就还需要 dp[i−1] 次；其他情况下将增加一个不同的位，则还需要 dp[i+1] 次。特别地， dp[0]=0， dp[n]=1+dp[n−1]</p><p>但是(しかし), 期望公式dp[i]依赖于dp[i-1]和dp[i+1]. 而我们的初始状态只有dp[0]=0. 因此需要通过解方程的方式才能得到答案</p><p>$$<br>dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n \ </p><p>dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n \ </p><p>dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n   \ </p><p>dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n) \<br>$$</p><p>dp[2] = dp[1] + … = k * dp[1] + b</p><p>用 dp[1] 看作已知，各个 dp[i] 表示为k * dp[1] + b. </p><p>一直到 dp[n] = 1 + dp[n - 1]</p><p>dp[n] - dp[n - 1] = k * dp[1] + b = 1, 这里的k和b都是已经通过递推算出来的, 所以dp[1]的值也就算出来了.</p><p>答案就是<code>dp[diff_cnt][0] * dp[1] + dp[diff_cnt][1]</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>-(array&lt;mint, <span class="number">2</span>&gt; a, array&lt;mint, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]-b[<span class="number">0</span>], a[<span class="number">1</span>]-b[<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>-(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]-b&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>*(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]*b, a[<span class="number">1</span>]*b&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>/(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]/b, a[<span class="number">1</span>]/b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;          cin &gt;&gt; n;</span><br><span class="line">    string a, b;    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)    diff += (a[i] != b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i]: 有i个不同之处的期望: dp[i][0] * dp[1] + dp[i][1]</span></span><br><span class="line">    vector&lt;array&lt;mint, 2&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);   </span><br><span class="line">    dp[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</span></span><br><span class="line">    <span class="comment">// dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n</span></span><br><span class="line">    <span class="comment">// dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n</span></span><br><span class="line">    <span class="comment">// dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        dp[i] = (dp[i<span class="number">-1</span>] - <span class="built_in">mint</span>(<span class="number">1</span>) - dp[i<span class="number">-2</span>] * <span class="built_in">mint</span>(i<span class="number">-1</span>) / <span class="built_in">mint</span>(n)) / (<span class="built_in">mint</span>(<span class="number">1</span>) - <span class="built_in">mint</span>(i<span class="number">-1</span>)/<span class="built_in">mint</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[n] = 1 + dp[n - 1]</span></span><br><span class="line">    <span class="comment">// dp[n] - dp[n - 1] = d[0] * dp[1][0] + d[1] = 1</span></span><br><span class="line">    <span class="comment">// k = dp[1][0] = (1 - d[1]) / d[0]</span></span><br><span class="line">    array&lt;mint, 2&gt; d = dp[n] - dp[n - <span class="number">1</span>];</span><br><span class="line">    mint k = (<span class="built_in">mint</span>(<span class="number">1</span>) - d[<span class="number">1</span>]) / d[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; dp[diff][<span class="number">0</span>] * k + dp[diff][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-Flip-Flop-Sum"><a href="#A-Flip-Flop-Sum" class="headerlink" title="A. Flip Flop Sum"></a><a href="https://codeforces.com/contest/1778/problem/A">A. Flip Flop Sum</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难.&lt;/p&gt;
&lt;p&gt;补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]=dp[n-1]+1. 从而求出dp[1]</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="算法_概率期望" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Educational Round 142 (Div. 2) A-D</title>
    <link href="http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/"/>
    <id>http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/</id>
    <published>2023-02-01T16:00:00.000Z</published>
    <updated>2023-02-06T13:55:56.070Z</updated>
    
    <content type="html"><![CDATA[<p>C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射.</p><p>6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶. </p><h2 id="B-Stand-up-Comedian"><a href="#B-Stand-up-Comedian" class="headerlink" title="B. Stand-up Comedian"></a><a href="https://codeforces.com/contest/1792/problem/B">B. Stand-up Comedian</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>Stand-up Comedian: 单口相声演员</p><p>有四种类型的笑话：</p><blockquote><p>第一种: 使AB的情绪都 +1</p><p>第二种: 使A的情绪 +1, B的情绪-1</p><p>第三种: 使A的情绪 -1, B的情绪+1</p><p>第四种会使AB的情绪都-1</p></blockquote><p>两人的情绪初始为0. 求在AB中某一人情绪降至0时可以讲的最大笑话数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>又犯了经典错误之 <code>b -= min(b, c);   c -= min(b, c);</code>. </p><p>第一种类型直接加上</p><p>所以 ans += a</p><p>第二种类型和第三种类型交替使用. </p><p>所以 ans += min(b, c)</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价. </p><p>所以 ans += min(a + 1, b + c + d)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="type">int</span> ans = a;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="type">int</span> dec = <span class="built_in">min</span>(b, c);</span><br><span class="line">        ans += dec * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// b -= min(b, c);</span></span><br><span class="line">        <span class="comment">// c -= min(b, c);</span></span><br><span class="line">        b -= dec;</span><br><span class="line">        c -= dec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a, b, c, d)</span><br><span class="line">    <span class="comment">// 此时 bc与d的地位等价</span></span><br><span class="line">    ans += <span class="built_in">min</span>(a + <span class="number">1</span>, b + c + d);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort"><a href="#C-Min-Max-Sort" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个排列p, 每次可以选两个数x和y, 将两者较小的移到开头, 较大的移到</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价结尾.. </p><p>问排成增序所需最小操作次数.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先可以确定操作次数上限是n/2, 即(n/2, n/2+1)…(1, n).</p><p>接下来再看怎么样能少操作几次.</p><p>例子: 1 6 3 4 2 5. (3, 4)一开始就挨在一起了, 并且是(3, 4)而不是(4, 3), 所以可以省略掉这一步, 直接考虑(2, 5). 发现(2, 5)并不分别位于(2, 3)的左右两侧. 所以这一步是必不可少的操作</p><p>如果情况是 1 2 3 4 6 5, 那么(3, 4)和(2, 5)都可以省略了. 只需要做一次(1, 6)操作就行.</p><p>结论就是 (n/2, n/2+1) 在最中间, 然后n/2-1, n/2+2分别位于(n/2, n/2+1)左右两侧, 如果某对逆序了, 或者没有位于两侧, 那么接下来的操作都不能省略.</p><p>用pos记下每个数的位置, l, r记录上一对数对的位置(注意n为奇数的情况, 此时中间只有一个数, 所以l = r) 然后从中间开始枚举, 依次判断数对的相对位置就行.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];   a[i] --;</span><br><span class="line">        pos[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: </span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="comment">// 5: 2</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="type">int</span> ans = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = pos[n / <span class="number">2</span>], r = pos[n / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n / <span class="number">2</span>; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = (n - <span class="number">2</span>) / <span class="number">2</span> - i, v2 = n - <span class="number">1</span> - v1;</span><br><span class="line">        <span class="built_in">LOG</span>(v1, v2)</span><br><span class="line">        <span class="type">int</span> p1 = pos[v1], p2 = pos[v2];</span><br><span class="line">        <span class="keyword">if</span> (p1 &gt; p2 || !(p1 &lt;= l &amp;&amp; p2 &gt;= r)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = p1, r = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= i;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Fixed-Prefix-Permutations"><a href="#D-Fixed-Prefix-Permutations" class="headerlink" title="D. Fixed Prefix Permutations"></a><a href="https://codeforces.com/contest/1792/problem/D">D. Fixed Prefix Permutations</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 n 个 1<del>m 的排列a[1</del>n].</p><p>定义一个排列的分值为: 最大的满足 p1=1,p2=2,….,pk=k 的 k .</p><p>定义两个排列 p,q 的乘积 p×q=r 为 r[j]=q[p[j]].</p><p>对于每个排列a[i], 求出它乘以所有这 n 个排列a[j]能得到的最大分值.</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价. </p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>学习(偷)了日本大神maspy的Trie板子.</p><p>固定的a[i], 记为p. a[j], 记为q. r[i] = q[p[i]] = i</p><p>q[p[i]] = i. 两边同时取q^-1, 也就是取pos_q. </p><p>p[i] = pos_q[i] = i. 也就是找p[i]和所有pos_q[i]最长的公共前缀. 只需要把所有的pos_q建一个Trie. 然后每次查询p[i]时, 在pos_q中找最长公共前缀的长度就行. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector <span class="title">p</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(m))</span></span>;</span><br><span class="line">    <span class="function">vector <span class="title">pos</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(m))</span></span>;</span><br><span class="line">    Trie&lt;<span class="number">10</span>&gt; tr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; p[i][j];     p[i][j] --;</span><br><span class="line">            pos[i][p[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tr.add&lt;vector&lt;<span class="type">int</span>&gt;&gt;(pos[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(pos[i])</span><br><span class="line">        <span class="type">int</span> cv = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">            cv = tr.TO[cv][p[i][j]];</span><br><span class="line">            <span class="built_in">LOG</span>(cv)</span><br><span class="line">            <span class="keyword">if</span> (cv == <span class="number">-1</span>)   <span class="keyword">break</span>;</span><br><span class="line">            ++ cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort-1"><a href="#C-Min-Max-Sort-1" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射.&lt;/p&gt;
&lt;p&gt;6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶. &lt;/p&gt;
&lt;h2 id=&quot;B-Stand-up-Co</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_字符串" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 287 A-F</title>
    <link href="http://example.com/2023/01/29/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20287%20A-F%20+%20Ex/"/>
    <id>http://example.com/2023/01/29/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20287%20A-F%20+%20Ex/</id>
    <published>2023-01-28T16:00:00.000Z</published>
    <updated>2023-02-15T13:25:43.317Z</updated>
    
    <content type="html"><![CDATA[<p>F是看似n^3, 实则n^2的树形dp, 用日语就是”二乗の木 DP”. 关键词: 树上子树dp + 连通块. </p><p>同时学到了: <strong>array&lt;int, 2&gt;比vector<int>(2)快很多</strong></p><h2 id="A-Majority"><a href="#A-Majority" class="headerlink" title="A. Majority"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_a">A. Majority</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        string s;   cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;For&quot;</span>) ++ c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; n / <span class="number">2</span>)  cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Postal-Card"><a href="#B-Postal-Card" class="headerlink" title="B. Postal Card"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_b">B. Postal Card</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>判断后缀串是否出现在set<string> 中</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        s[i] = s[i].<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;string&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        string x;   cin &gt;&gt; x;</span><br><span class="line">        S.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">        ans += S.<span class="built_in">count</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Path-Graph"><a href="#C-Path-Graph" class="headerlink" title="C. Path Graph?"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_c">C. Path Graph?</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>判断一张简单无向图是否为一条链. </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>max度数 &lt;= 2 + <strong>连通性判断</strong></p><p>赛时写的toposort</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u --, v --;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(v); g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">        ++ deg[u], ++ deg[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (deg[i] == <span class="number">1</span>) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cv = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        st[cv] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nv : g[cv]) <span class="keyword">if</span> (!st[nv]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (-- deg[nv] &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(nv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(st)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Match-or-Not"><a href="#D-Match-or-Not" class="headerlink" title="D. Match or Not"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_d">D. Match or Not</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定字符串s(n [1, 3e5])和t(n&gt;=m [1, 3e5]). 只由’?’和小写字母组成. </p><p>每次在s前面取i个, 后面取m-i个, 拼起来组成s’. 问s’能否跟t匹配?</p><p>PS: ‘?’可以替换成任意小写字母</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>前面取i个, 后面取m-i个. 想到前后缀. 统计前后缀跟t匹配的字符数量. 若前缀+后缀匹配数量 == m, 则成功</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s, t;    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;    t = <span class="string">&quot; &quot;</span> + t;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">suf</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[i])   ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;?&#x27;</span> || t[i] == <span class="string">&#x27;?&#x27;</span>) ok = <span class="number">1</span>;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= n - m + <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        <span class="type">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[i - n + m])   ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;?&#x27;</span> || t[i - n + m] == <span class="string">&#x27;?&#x27;</span>) ok = <span class="number">1</span>;</span><br><span class="line">        suf[i] = suf[i + <span class="number">1</span>] + ok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(pre)</span><br><span class="line">    <span class="built_in">LOG</span>(suf)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> sum = pre[i] + suf[i + n - m + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">LOG</span>(i, i + n - m + <span class="number">1</span>, sum)</span><br><span class="line">        <span class="keyword">if</span> (sum == m)   cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Karuta"><a href="#E-Karuta" class="headerlink" title="E. Karuta"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_e">E. Karuta</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给n个字符串, 问每个串和其他所有串的 LCP(最长公共前缀) 的最大值</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>先把所有串建 Trie. 然后对每一个s[i]查一遍, 走到计数器只有1的时候就停, 输出当前深度, 复杂度O(∑ |s[i]| )</p><p>赛时多写了个二分, 头脑发热了. </p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//son记录他的子节点  cnt记录编号为idx的节点 对应字符串数量  idx为节点唯一编号</span></span><br><span class="line"><span class="comment">//遍历trie树 的时候注意： 终点是curr ！！！ 而不是 idx,  idx不一定会被更新</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//curr表示当前节点 初始是 根节点 为空</span></span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果他的儿子 为空</span></span><br><span class="line">        <span class="keyword">if</span>(!son[curr][t]) son[curr][t] = ++idx;</span><br><span class="line">        curr = son[curr][t];</span><br><span class="line">        ++ cnt[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跑完在 字符串终点 ++cnt</span></span><br><span class="line">    <span class="comment">// 终点是curr ！！！ 而不是 idx,  idx不一定会被更新</span></span><br><span class="line">    <span class="comment">// ++ cnt[curr];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[curr][t])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        curr = son[curr][t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[curr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : s) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">insert</span>(x.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    <span class="built_in">LOG</span>(<span class="built_in">query</span>(<span class="string">&quot;bra&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> len = s[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">query</span>(s[i].<span class="built_in">substr</span>(<span class="number">0</span>, mid).<span class="built_in">data</span>()) &gt;= <span class="number">2</span>)    ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok)         l = mid;</span><br><span class="line">            <span class="keyword">else</span>            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Components"><a href="#F-Components" class="headerlink" title="F.     Components"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_f">F.     Components</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一棵树n([1, 5000]), 问有多少个点集的导出子图恰好有x = 0, 1, 2…n 个联通分量</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><a href="https://snuke.hatenablog.com/entry/2019/01/15/211812">日本大佬的blog</a></p><p>树形n^2 dp. 看似三层循环, 最坏会达到n^3, 其实应该从合并u和儿子v涉及到的边数考虑. </p><p>合并当前u的子树和孩子v的子树代价: sz[u] * sz[v], 看最终结果便是: u的子树内所有节点两两之间都考虑过转移了. 也就是一个n个点的”完全图”(实际可能有些点对间没有连边), 即n*(n-1)/2. </p><p>dp[i][j][0/1]: 以i为根节点的子树, 且i 0不选/1选, 形成的连通块个数. 共[u][0], [u][1], [v][0], [v][1] 4种情况</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a --, b --;</span><br><span class="line">        g[a].<span class="built_in">pb</span>(b); g[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i][j][0/1]: 以i为根的子树, 且选择了i, 形成j个连通块的方案数</span></span><br><span class="line">    <span class="function">vector <span class="title">dp</span><span class="params">(n, vector&lt;array&lt;mint, <span class="number">2</span>&gt;&gt;(n + <span class="number">1</span>, array&lt;mint, <span class="number">2</span>&gt;&#123;&#125;))</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sz</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) -&gt; void &#123;</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> dfs, <span class="type">int</span> u, <span class="type">int</span> p) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        dp[u][<span class="number">0</span>][<span class="number">0</span>] = dp[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) <span class="keyword">if</span> (v != p) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, v, u);</span><br><span class="line">            <span class="comment">// vector ndp(n + 1, vector&lt;mint&gt;(2));                  </span></span><br><span class="line">            <span class="function">vector <span class="title">ndp</span><span class="params">(n + <span class="number">1</span>, array&lt;mint, <span class="number">2</span>&gt;&#123;&#125;)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz[u]; ++ i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz[v]; ++ j) &#123;</span><br><span class="line">                    ndp[i + j][<span class="number">0</span>] += dp[u][i][<span class="number">0</span>] * dp[v][j][<span class="number">0</span>];     <span class="comment">// u不拿, v可以拿, 也可以不拿</span></span><br><span class="line">                    ndp[i + j][<span class="number">0</span>] += dp[u][i][<span class="number">0</span>] * dp[v][j][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    ndp[i + j][<span class="number">1</span>] += dp[u][i][<span class="number">1</span>] * dp[v][j][<span class="number">0</span>];     <span class="comment">// u  拿, v必须不拿, 连通块数量才可以不-1</span></span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= <span class="number">1</span>) &#123;                                   <span class="comment">// u  拿, v也拿, 那么u和v的2个连通块合并成1个了</span></span><br><span class="line">                        ndp[i + j - <span class="number">1</span>][<span class="number">1</span>] += dp[u][i][<span class="number">1</span>] * dp[v][j][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(dp[u], ndp);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; (dp[<span class="number">0</span>][i][<span class="number">0</span>] + dp[<span class="number">0</span>][i][<span class="number">1</span>]).<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ex-Directed-Graph-and-Query"><a href="#Ex-Directed-Graph-and-Query" class="headerlink" title="Ex. Directed Graph and Query"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_h">Ex. Directed Graph and Query</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定一张有向图g&lt;n, m&gt;(n [2, 2000]), 回答q组询问. </p><p>每组询问包括s和t, 问从s到t的路径的代价最小值. </p><p>一条路径的代价是其经过的点的编号的最大值. </p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>如果n在500以内, 可以Floyd插点更新. </p><p>n [2, 2000] 也可以用bitset优化的Floyd传递闭包求解.</p><p>d[i][j]表示i -&gt; j可以通过</p><p>最外层枚举插点k, 如果i能够到k, 那么k能够到的点, i也能到.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int k = 0; k &lt; n; ++ k) &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; ++ i) &#123;</span><br><span class="line">        if (d[i][k]) &#123;</span><br><span class="line">            d[i] |= d[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次插完一个新点k, 就遍历一下所有q, 是否能更新答案. </p><p>总复杂度O(n^3 / 64 + nq)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector <span class="title">d</span><span class="params">(n, bitset&lt;<span class="number">2000</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        a --;   b --;</span><br><span class="line">        d[a].<span class="built_in">set</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> qc;     cin &gt;&gt; qc;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">q</span>(qc);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(qc, inf)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; qc; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        s --; t --;</span><br><span class="line">        q[i] = &#123;s, t, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++ k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i][k]) &#123;</span><br><span class="line">                d[i] |= d[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [s, t, id] : q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; k || t &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (d[s][t]) &#123;</span><br><span class="line">                ans[id] = <span class="built_in">min</span>(ans[id], k + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; inf / <span class="number">2</span>)    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>                cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;F是看似n^3, 实则n^2的树形dp, 用日语就是”二乗の木 DP”. 关键词: 树上子树dp + 连通块. &lt;/p&gt;
&lt;p&gt;同时学到了: &lt;strong&gt;array&amp;lt;int, 2&amp;gt;比vector&lt;int&gt;(2)快很多&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_图论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_字符串" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.16-01.29 (2023春节)</title>
    <link href="http://example.com/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/"/>
    <id>http://example.com/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/</id>
    <published>2023-01-23T16:00:00.000Z</published>
    <updated>2023-02-15T12:14:48.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-17-周四-大年廿八-阴"><a href="#01-17-周四-大年廿八-阴" class="headerlink" title="01.17 周四 大年廿八 阴"></a>01.17 周四 大年廿八 阴</h2><p>下午出发前往大旺, 傍晚到达. 晚上与大伯奶奶到早茶店吃饭. </p><h2 id="01-18-周五-大年廿九-晴"><a href="#01-18-周五-大年廿九-晴" class="headerlink" title="01.18 周五 大年廿九 晴"></a>01.18 周五 大年廿九 晴</h2><p>早上5点半起床. 六点钟到水岸与堂哥奶奶碰面. 奶奶和我们坐一辆车, 6点10分左右启程, 中途服务区休息一次. 11点多到达村口. 全程睡过来. </p><h2 id="01-21-周六-除夕-雨"><a href="#01-21-周六-除夕-雨" class="headerlink" title="01.21 周六 除夕 雨"></a>01.21 周六 除夕 雨</h2><p>晚上8点有Atcoder Beginner Contest 286. 由于长辈聊天的原因, 我迟到了20分钟, 还好我有先见之明, 提前unrated participation了. 开局到D还是很顺利的. E一眼n=300, 鉴定为Floyd, 但是我对Floyd松弛时的更新没有深刻的理解, 导致赛后3分钟才调出E的错误. 何为”最短路松弛的理解”? 其实就是在能够松弛时, 要采取无条件赋值, 而不是取max. 这点在最短路计数上也是一样, 只不过当时是 += , 而不是赋值, 所以我忽视了这点. </p><p>本来老爸让我一定要在益罗塘山上睡一晚, 好在他在蹭网回去时改变了主意. 零点赏完烟花后入睡. </p><h2 id="01-22-周日-新年初一-晴"><a href="#01-22-周日-新年初一-晴" class="headerlink" title="01.22 周日 新年初一 晴"></a>01.22 周日 新年初一 晴</h2><p>晚上8点有Atcoder Regular Contest 154. 考虑到昨天晚上我因为种种原因晚了20分钟才下山参加比赛, 于是今晚也是unrated participation了. 开局A题直接不会, 贪心思路很容易, 就是让俩数尽可能差的大, 主要是长度为1e5的俩数相乘取模这一点没想好. 搞了一个钟头才摸出来. 什么龟速乘, 忽略高位的数都出来了… 我果然是一急啥蠢事都干了. B题一开始看以为又是大聪明题. 但是分析了10分钟发现是可做的, WA了2发也是在半小时内搞出来了一个O(n)的做法. AB总共WA了5发, rk 1200+, 感觉还行, 至少不会掉分(要是A模数运算再熟练些会更好). 而且B题放我以前肯定是无法发现题目性质的. 可喜可贺, 希望在新的一年里思维上能有更大的进步!</p><h2 id="01-23-周一-新年初二-雨"><a href="#01-23-周一-新年初二-雨" class="headerlink" title="01.23 周一 新年初二 雨"></a>01.23 周一 新年初二 雨</h2><p>今天要跟奶奶去拜访舅公舅婆. 从恭上村到何家, 大概有20+分钟的车程. 只能说很尬, 那么多亲戚就没几个认识的. 所以我选择和堂哥在屋外聊天. 午饭和舅公一桌, 面对一桌的酸菜, 腌菜, 我TM直接干白饭. </p><p>晚上刷了会题, 刷不动了. 继续看了&lt;尸体派对&gt;第二集. 看了2集之后, 可能是我刚进军二次元不就, 接触的作品太少, 感觉这种恐怖重口题材的挺好看的, 也挺想买steam上的尸体派对几部作品, 奈何太贵, 等骨折了入手一波. </p><p>晚上堂哥又摆出烧烤架, 我蹭了一块鸡柳 + 一条烤肠, 上一次烧烤还是在高中的某次年级出游. </p><h2 id="01-24-周二-新年初三-晴"><a href="#01-24-周二-新年初三-晴" class="headerlink" title="01.24 周二 新年初三 晴"></a>01.24 周二 新年初三 晴</h2><p>晚上依然睡不好觉, 早上七点半起床, 开始收拾行李, 准备下山. 大约九点半时到达恭上村村口吃腌面. 饭后随堂哥驱车前往拜访南良叔. 路上得知南良叔之前的旧屋拆迁了, 据说补偿还不错. 路上被中国电信的捉急信号和高德地图的误导耽误了20分钟, 于10点半到达拜访. 寒暄过后, 11点从党溪村返回大旺, 全程500公里. 4点左右到达大旺. 到达后依然是与大伯奶奶聚餐, 饱餐一顿后送奶奶回家后便准备驱车返回广州. </p><p>返程较短, 所以我尝试开回来. 开了1小时多些, 平均时速块80, 高速上最高开到了120. 估摸着也快有1年没碰方向盘了, 感觉还行. </p><h2 id="01-25-周三-新年初四-晴"><a href="#01-25-周三-新年初四-晴" class="headerlink" title="01.25 周三 新年初四 晴"></a>01.25 周三 新年初四 晴</h2><p>白天在家刷题. 傍晚LY vx问我去不去看电影, 原来他今天回到广州. 于是就打算看8点场的&lt;流浪地球2&gt;. </p><p>本来没打算电影有多大的惊喜, 看了看前面的部分, 感觉有些镜头挺尬的. 刚开始注意到频繁出现的摄像头, 也不知道有啥用意. 直到片尾的彩蛋说550A才是策划一系列危机的幕后黑手, 我才有点懂了. 感觉550A可能就是通过摄像头学习了很多, 在逐月计划, 太空电梯那会的某个阶段产生了意识, 但是处于一种潜伏状态. 另外就是我对于”相控阵”和550A的初衷也是挺好奇的. 不过我认为&lt;流浪地球2&gt;似乎没有&lt;星际穿越&gt;那么难懂. </p><h2 id="01-26-周四-新年初五-晴"><a href="#01-26-周四-新年初五-晴" class="headerlink" title="01.26 周四 新年初五 晴"></a>01.26 周四 新年初五 晴</h2><p>白天在家刷题. 下午购物. </p><p>晚上刷到UP主&lt;那些无名之辈&gt;的动态<a href="https://www.bilibili.com/video/BV12G4y1D7V7/">最看天赋的专业之一：C9院校，同宿舍4个数学男，毕业7年后的生活现状</a>, C9数学专业毕业生生活现状. 1个米国top10计算机读博年收入42w, 1个瑞士读博年收入30+w, 1个学而思老师转广州竞赛教练年收入20+w, 1个本校物理读博年收入5w, 毕业offer60+w. 第三个好巧不巧刚好是竞赛教练, 还是广州的. 看来当前教培改革已经对这行造成了很大的影响. 本来心里最理想的职业看来也走不通了. 我认为这辈子是真的没有遇到真正热爱的东西, 直到大三正式入坑OI(CP / ACM). 大四上学期的最后几个月, 可能是我这辈子最后一次为自己热衷的东西不计代价地追寻付出了. 万幸的是上天眷顾, 我找到了优秀的队友, 也选对了赛站, 在我的XCPC最后一舞中收获了牌子. </p><p>之前一直在抱怨高中</p><h2 id="01-27-周五-新年初六-多云"><a href="#01-27-周五-新年初六-多云" class="headerlink" title="01.27 周五 新年初六 多云"></a>01.27 周五 新年初六 多云</h2><p>白天在家刷题. 下午购物</p><p>晚上有codeforces div3, 常规阴间时间. 本来还在想要不要打, 一看zwling已经报名了, 我也就报名了. 可以说是打得挺烂了. E题非得硬去分析二进制数位的性质, 结果还是得搞对拍. 整题搞了一个多小时, zwling说打表就行, 只花了10+min就搞定了. 妈的又是打表, 上次vp小白月赛的n(1e18)的模仿棋博弈也是没看出要打表. 不过由于cf号目前分段比较低, 所以rk1700+也+55. </p><h2 id="01-28-周六-新年初七-晴"><a href="#01-28-周六-新年初七-晴" class="headerlink" title="01.28 周六 新年初七 晴"></a>01.28 周六 新年初七 晴</h2><p>白天不想学习, 但是又找不到想玩的. </p><p>晚上有Atcoder Beginner Contest 287. 8点麻木地开打, 前两题签完到, C直接给我干趴下了. 判断一张图是不是一条<br>链, 我寻思着不是只用判断: “度1点数==2 &amp;&amp; 度2点==n-2 &amp;&amp; 边数==点数-1 “就行了嘛. 直接WA3发, 不过也不是第一次翻车了, 不就是经典codeforces经典卡div2 B嘛. 跳过C先做D, 一开始头脑发热又想不到, 不过好在冷静下来做出来了. 回过头看C, 我TM直接toposort总可以了吧, 于是就过了. 一看rk2000+, 如果不做出E翻盘, 那我的AT1200分青名计划就又要延期了. 看了E的题意, 涉及到前缀, “最大”长度, 我直接想到前缀数据结构Trie + 二分长度. 但是Trie的题也就acwing的模板题做过, 所以花了点时间先学, 把统计词频的代码改成了统计前缀词频, 就过了E. 结果rk1300+, 感觉还行, +21 to 1115. 此时还剩下30+分钟, F我想的是树上背包, 但是自知功力还未到. 所以直接开摆. </p><p>本来想早睡的, 但是睡前玩了会&lt;深岩银河&gt;, 又玩到12点半. </p><h2 id="01-28-周日-新年初八-晴"><a href="#01-28-周日-新年初八-晴" class="headerlink" title="01.28 周日 新年初八 晴"></a>01.28 周日 新年初八 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.24(2022春节初三)日晚22点 + 01.29</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-17-周四-大年廿八-阴&quot;&gt;&lt;a href=&quot;#01-17-周四-大年廿八-阴&quot; class=&quot;headerlink&quot; title=&quot;01.17 周四 大年廿八 阴&quot;&gt;&lt;/a&gt;01.17 周四 大年廿八 阴&lt;/h2&gt;&lt;p&gt;下午出发前往大旺, 傍晚到达. 晚上</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 286 A-F</title>
    <link href="http://example.com/2023/01/22/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20286%20A-F/"/>
    <id>http://example.com/2023/01/22/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20286%20A-F/</id>
    <published>2023-01-21T16:00:00.000Z</published>
    <updated>2023-02-15T13:25:52.027Z</updated>
    
    <content type="html"><![CDATA[<p>F还没调出来, 看到maspy大佬用自己的板子熟练得一, 余数vector和除数vector一传, 直接调用自己写的crt函数就出答案了. 感觉等我思维练得差不多了也可以开始系统地学习这种”工程式”cp了</p><h2 id="A-Range-Swap"><a href="#A-Range-Swap" class="headerlink" title="A. Range Swap"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_a">A. Range Swap</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="B-Cat"><a href="#B-Cat" class="headerlink" title="B. Cat"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_b">B. Cat</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-Rotate-and-Palindrome"><a href="#C-Rotate-and-Palindrome" class="headerlink" title="C. Rotate and Palindrome"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_c">C. Rotate and Palindrome</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串s(长度n: [1, 5000]). 问通过任意次以下操作使其变成回文串的最小代价. </p><blockquote><p>操作1: s = rotate(s.begin(), s.begin() + 1, s.end()) 即循环左移一位. 代价为a</p><p>操作2: 将任意的s[i]修改为c. 代价为b</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>n([1, 5000]): 暴力枚举左移位数 + 修改次数</p><p>左移可以用deque. 利用了pop_front(), push_back()和顺序容器随机访存的特性. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    string s;       cin &gt;&gt; s;</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; dq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) dq.<span class="built_in">pb</span>(s[i]);</span><br><span class="line">    <span class="type">int</span> best = n * b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> c_cost = (i) * a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; ++ j) &#123;</span><br><span class="line">            c_cost += b * (dq[j] != dq[n - j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        best = <span class="built_in">min</span>(best, c_cost);</span><br><span class="line">        <span class="built_in">LOG</span>(dq, (i) * a, c_cost)</span><br><span class="line">        <span class="keyword">auto</span> s0 = dq.<span class="built_in">front</span>();   dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        dq.<span class="built_in">pb</span>(s0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(best)</span><br><span class="line">    cout &lt;&lt; best &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Money-in-Hand"><a href="#D-Money-in-Hand" class="headerlink" title="D. Money in Hand"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_d">D. Money in Hand</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>手头上有n([1, 50])种货币, 第i种: 价值a([1, 100])元, 且拥有b([1, 50])张, 问能否用这些货币刚好凑出x([1, 10000])元</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>暴力分组背包dp即可. O(n * x * b)</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">5</span>, M = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> dp[N][M];</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= x; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c * a[i] &lt;= j &amp;&amp; c &lt;= b[i]; ++ c) &#123;</span><br><span class="line">                dp[i][j] |= dp[i - <span class="number">1</span>][j - c * a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(dp[n][x])</span><br><span class="line">    <span class="keyword">if</span> (dp[n][x])   cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Souvenir"><a href="#E-Souvenir" class="headerlink" title="E. Souvenir"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_e">E. Souvenir</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>有n([1, 300])个旅游目标城市, 给定这n个城市之间航班的邻接矩阵, 以及每个城市能购买的纪念品价值a[n]. 现在要求最优化以下目标: </p><blockquote><p>首要: 转机次数最小化</p><p>次要: 转机次数一定时, 最大化路过城市所能购买的纪念品价值</p></blockquote><p>给出q个询问. 每次询问S, T. 分别回答首要目标和次要目标. 若从S无法到达T, 输出”Impossible”</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>n([1, 300]) 一眼Floyd. </p><p>类似于<strong>最短路计数</strong>, 在最短路相同时(dist[i][j] == dist[i][k] + dist[k][j]), 不做最短路更新, 但是要做纪念品价值更新. </p><p><strong>在最短路能更新时, 所有更新均为无条件赋值!!!</strong>. 即不能取max之类的</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp1[N][N], dp2[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp1, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   dp1[i][i] = <span class="number">0</span>, dp2[i][i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="type">char</span> c;     cin &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">                dp1[i][j] = <span class="number">1</span>;</span><br><span class="line">                dp2[i][j] = a[i] + a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp1[i][j] &gt; dp1[i][k] + dp1[k][j]) &#123;</span><br><span class="line">                    <span class="comment">// 强制更新dp 不能取max</span></span><br><span class="line">                    dp1[i][j] = dp1[i][k] + dp1[k][j];</span><br><span class="line">                    dp2[i][j] = dp2[i][k] + dp2[k][j] - a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp1[i][j] == dp1[i][k] + dp1[k][j]) &#123;</span><br><span class="line">                    dp2[i][j] = <span class="built_in">max</span>(dp2[i][j], dp2[i][k] + dp2[k][j] - a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (dp1[l][r] &lt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">            cout &lt;&lt; dp1[l][r] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; dp2[l][r] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Guess-The-Number-2"><a href="#F-Guess-The-Number-2" class="headerlink" title="F. Guess The Number 2"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_f">F. Guess The Number 2</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>交互题</p><p>你需要猜出电脑给定的一个正整数n([1, 1e9]). 只能通过以下方式算出n: </p><blockquote><p>你给出一个排列a[m] (m: [1~110]). </p><p>电脑会根据a[m]返回一个数组b. b[i] = a[ a[ a[i] ] ] … (共a[i]n次)</p></blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><strong>置换环 / functional graph</strong> + <strong>中国剩余定理ChineseRemainTheory</strong></p><p>思路其实想了大概10分钟就出了, 因为b和a的关系其实就是在functional graph走了n步所到达的点. functional graph 置换环这类题之前vp 797 div3 做过一道<a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a>. </p><p>所以套路肯定是循环节长度, lcm. 这里变通一下就变成了知道循环节长度和其对应的模数. </p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;F还没调出来, 看到maspy大佬用自己的板子熟练得一, 余数vector和除数vector一传, 直接调用自己写的crt函数就出答案了. 感觉等我思维练得差不多了也可以开始系统地学习这种”工程式”cp了&lt;/p&gt;
&lt;h2 id=&quot;A-Range-Swap&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_组合数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.09-01.15</title>
    <link href="http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/"/>
    <id>http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-02-15T12:15:32.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-09-周一-小雨"><a href="#01-09-周一-小雨" class="headerlink" title="01.09 周一  小雨"></a>01.09 周一  小雨</h2><p>早上十点开始vp Educational Codeforces Round 141. 嗯, 只做了2题, 第二题经典构造矩阵, 做了一个多小时. 其实C题我也不会, 是一道关于最佳可能排名的贪心题. 贪心还是得多练, 正解是二分. D题dp, muggle用的记忆化搜索, 看了他的代码感觉记搜确实得熟练起来. </p><p>晚上八点20开始vp 小白月赛65. 表现依然糟糕, 只会3题. 并且这次的B题是考察字符串匹配, 其实暴力n^2就行. 我非得试着用双指针. 这也暴露出我对字符串匹配的理解误区. 要是真能双指针直接瞎搞, 那还要啥KMP呢? D题这种1e18的一眼结论题, 但是没想过打表, 比赛经验太差. 正解是”模仿棋”. E构造, F贪心 + 树形dp. </p><h2 id="01-10-周二-小雨"><a href="#01-10-周二-小雨" class="headerlink" title="01.10 周二  小雨"></a>01.10 周二  小雨</h2><p>早上补了昨晚的DEF. </p><p>下午晚上补了我第一场牛客比赛(小白月赛34)的所有题. 基本以dp为主, 然后还有一道经典 矩阵每行取数, 求前k大的题. 堆 + 合并行贪心. </p><h2 id="01-11-周三-中雨"><a href="#01-11-周三-中雨" class="headerlink" title="01.11 周三  中雨"></a>01.11 周三  中雨</h2><p>早上10点开始vp 843(div2). 可以算是形势逆转的一局, 虽然一开始经典卡B, 但是对拍调完C之后, 还是想出了B. 赛后发现C有1600分. </p><h2 id="01-12-周四-小雨"><a href="#01-12-周四-小雨" class="headerlink" title="01.12 周四  小雨"></a>01.12 周四  小雨</h2><p>考虑到18号要回大埔过年, 早上先花了点时间下番&lt;更衣人偶坠入爱河&gt;, 但是没有外挂弹幕, 告辞, 晚点再来. 9点40开始vp 839(div3). 表现垃圾. 只会3道. D是拆绝对值 + 约束答案范围. </p><p>中午看到2022南京终于上了cf gym. 看到了&lt;高数100&gt;, 看到了自己和队友们的名字. 在第一页尾部, 相信很快就会被vp的大佬们压下去.  </p><p>下午2点郑老师发来vx说给我发些奖励, 问我银行卡之类的信息. </p><h2 id="01-13-周五-阴"><a href="#01-13-周五-阴" class="headerlink" title="01.13 周五  阴"></a>01.13 周五  阴</h2><p>下午1点突然想看看2022南京的正解, 于是想到zwling之前说的dianhsu写的插件. 用这个插件可以在别人的submission中查看gym的代码. 之后我下了dls的A和D的代码, 然而题目都记不清了. </p><p>下午3点开组会, 和顾学长一起获得了三等奖金, 发了言. 和组里的大部分同学都不熟, 所以挺紧张的. </p><p>组会上我得知很多学长学姐都在2022年做出了A类工作. 心情十分复杂, 想搞科研, 但是心里有放不下CP. 可能是心愿还没有达成吧. 至于这个心愿, 我也不知道具体是个什么样的目标. </p><h2 id="01-14-周六-阴"><a href="#01-14-周六-阴" class="headerlink" title="01.14 周六  阴"></a>01.14 周六  阴</h2><p>vp 844(div1+2)</p><h2 id="01-15-周日-阴"><a href="#01-15-周日-阴" class="headerlink" title="01.15 周日  阴"></a>01.15 周日  阴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.21(2022除夕)日午12点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-09-周一-小雨&quot;&gt;&lt;a href=&quot;#01-09-周一-小雨&quot; class=&quot;headerlink&quot; title=&quot;01.09 周一  小雨&quot;&gt;&lt;/a&gt;01.09 周一  小雨&lt;/h2&gt;&lt;p&gt;早上十点开始vp Educational Codeforces </summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 89 A-D</title>
    <link href="http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/"/>
    <id>http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-01-21T03:16:42.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-Practical-Skill-Test"><a href="#D-Practical-Skill-Test" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Practical-Skill-Test-1"><a href="#D-Practical-Skill-Test-1" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个h * w的矩阵a, 里面不重不漏地填充着[1, h * w]的数字. 现在给定一个正整数d ([1, h * w]), 并且给出q组询问: </p><blockquote><p>l, r</p><p>问: a[x1][y1] == l —&gt; a[x2][y2] == l + d —&gt; … —&gt; a[xn][yn] == r</p><p>这段路所走过的曼哈顿距离是多少</p></blockquote><blockquote><p>曼哈顿距离: (x1, y1)与(x2, y2)的曼哈顿距离是|x1 - x2| + |y1 - y2|</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="倍增-我的思路"><a href="#倍增-我的思路" class="headerlink" title="倍增 (我的思路)"></a>倍增 (我的思路)</h4><p>既然无法记录从每个点(a值==i)出发到[i+1, n]的所有距离, 那么就可以考虑倍增</p><p>to[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走到的点</p><p>dist[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走过的路程</p><p>边界: to超出h * w的部分要特判0</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">to</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u + d &lt;= h * w; ++ u) &#123;</span><br><span class="line">        to[u][<span class="number">0</span>] = u + d;</span><br><span class="line">        dist[u][<span class="number">0</span>] = a2cor[u + d] - a2cor[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt; <span class="number">20</span>; ++ b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= h * w; ++ u) &#123;</span><br><span class="line">            to[u][b] = to[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">            dist[u][b] = dist[u][b - <span class="number">1</span>] + dist[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> binary_jump = [&amp;](<span class="type">int</span> S, <span class="type">int</span> T) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">19</span>; b &gt;= <span class="number">0</span>; -- b) <span class="keyword">if</span> (to[S][b] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to[S][b] &lt;= T) &#123;</span><br><span class="line">                ans += dist[S][b];</span><br><span class="line">                S = to[S][b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(S == T);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">binary_jump</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前缀和-官方题解"><a href="#前缀和-官方题解" class="headerlink" title="前缀和 (官方题解)"></a>前缀和 (官方题解)</h4><p>pre[i] 表示a[i - kd] —&gt; a[i - (k-1)d] —&gt; a[i - d] —&gt; a[i] 的路程之和</p><p>pre[i] = pre[i - d] + dist(i - d, i)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(h * w + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= h * w; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">4</span>] + (a2cor[i] - a2cor[i - <span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; pre[r] - pre[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-Practical-Skill-Test&quot;&gt;&lt;a href=&quot;#D-Practical-Skill-Test&quot; class=&quot;headerlink&quot; title=&quot;D - Practical Skill Test&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://a</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_倍增" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 284 A-F</title>
    <link href="http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/"/>
    <id>http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/</id>
    <published>2023-01-16T16:00:00.000Z</published>
    <updated>2023-02-15T13:25:59.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Generalized-ABC"><a href="#A-Generalized-ABC" class="headerlink" title="A. Generalized ABC"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_a">A. Generalized ABC</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)   cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Multi-Test-Cases"><a href="#B-Multi-Test-Cases" class="headerlink" title="B. Multi Test Cases"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_b">B. Multi Test Cases</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        ans += (x &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Count-Connected-Components"><a href="#C-Count-Connected-Components" class="headerlink" title="C. Count Connected Components"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_c">C. Count Connected Components</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    p.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">iota</span>(<span class="built_in">all</span>(p), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u = <span class="built_in">find</span>(u), v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v)     <span class="keyword">continue</span>;</span><br><span class="line">        p[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> wcc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(wcc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        wcc += (<span class="built_in">find</span>(i) == i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wcc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Happy-New-Year-2023"><a href="#D-Happy-New-Year-2023" class="headerlink" title="D. Happy New Year 2023"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_d">D. Happy New Year 2023</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个正整数n (n &lt;= 4e18), 找出两个质数p, q. 满足n = p * p * q</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>看到(n &lt;= 4e18) + 乘三次 —&gt; $(1e18)^{1/3} \to \ O(1e6)$</p><p>n = p * p * q </p><p>显然有min(p, q) &lt;= n^(1/3)</p><p>设x为p, q中最小的数, y为最大的数</p><p>检查x * x * y 和 x * y * y</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> is_p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_p, <span class="number">1</span>, <span class="keyword">sizeof</span> is_p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_p[i]) &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">            is_p[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> p = primes[i];</span><br><span class="line">        <span class="type">int</span> p2 = p * p;</span><br><span class="line">        <span class="keyword">if</span> (n % p2 == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n / p2 &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % p)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> val = n / p;</span><br><span class="line">        <span class="comment">// p * q * q</span></span><br><span class="line">        <span class="type">int</span> rt = <span class="built_in">sqrtl</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (rt * rt == val) &#123;</span><br><span class="line">            cout &lt;&lt; rt &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Count-Simple-Paths"><a href="#E-Count-Simple-Paths" class="headerlink" title="E. Count Simple Paths"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_e">E. Count Simple Paths</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定G(n &lt;= 1e5, m),  统计从1出发的简单路径数目. 其中每个节点度数&lt;8. </p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>简单路径数目: dfs + st[n]回溯 / bit_dp [1 &lt;&lt; n][n]</p><p>类似: <a href="https://atcoder.jp/contests/abc054/tasks/abc054_c">C - One-stroke Path</a></p><p>节点数量过大 + 有节点度数保证 == dfs. </p><p>cnt达到题目上限时, 在dfs过程中直接exit(0). </p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    ++ cnt;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= <span class="number">1000000</span>) &#123;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[v])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    st[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    g.<span class="built_in">resize</span>(n);</span><br><span class="line">    st.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;  u --, v --;</span><br><span class="line">        g[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        g[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(cnt);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-ABCBAC"><a href="#F-ABCBAC" class="headerlink" title="F. ABCBAC"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_f">F. ABCBAC</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串s[2 * n](n &lt;= 1e6), 设s1[i] = s[1, i] + s[n - (i) + 1, n], s2[i] = reverse(all(s[i + 1, n - i]))</p><p>问是否存在i, 满足s1 == s2</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>string hash: 第一次使用double hash</p><p>本质考察: <strong>哈希拼接(base进制数理解) + 翻转哈希(后缀哈希)</strong></p><p><strong>哈希拼接</strong>: 前缀i + 后缀n-i 拼接. 就比如俩十进制数12, 34567 要拼接起来, 要先把12 * 100000再和后者相加, 才能变成1234567. </p><p>这里的哈希同理, 只不过换成了base进制数, 所以前者(前缀s[1, i])的哈希值先 * pw[n - i] (后缀的长度次幂), 再与后缀的哈希相加. </p><p><strong>哈希截取</strong>: 从1234567中截取”34567”的哈希值, 要将前缀哈希1234567 - 12 * 100000. 即pre[r] - pre[l - 1] * base[r - l + 1]. </p><p><strong>翻转哈希</strong>: s[l, r]的翻转哈希: suf[l] - suf[r + 1] * pw[r - l + 1]即可</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">hash_t</span> = array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod0 = <span class="number">1e9</span> + <span class="number">7</span>, mod1 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">hash_t</span> base = &#123;<span class="number">13331</span>, <span class="number">23333</span>&#125;;</span><br><span class="line"><span class="type">hash_t</span> pw[N];</span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> + (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] + b[<span class="number">0</span>]) % mod0, (a[<span class="number">1</span>] + b[<span class="number">1</span>]) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> - (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] - b[<span class="number">0</span>] + mod0) % mod0, (a[<span class="number">1</span>] - b[<span class="number">1</span>] + mod1) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> * (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] * b[<span class="number">0</span>] % mod0, a[<span class="number">1</span>] * b[<span class="number">1</span>] % mod1&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> pre[N], suf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;   s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    pw[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">        pw[i] = pw[i - <span class="number">1</span>] * base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        suf[i] = suf[i + <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(n, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s前i + s后2* n - i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="comment">// s前i + s后2* n - i 哈希拼接</span></span><br><span class="line">        <span class="comment">// [1, i] [i + 1, i + n] [i + n + 1, 2 * n]</span></span><br><span class="line">        <span class="type">hash_t</span> h1 = pre[i] * pw[n - i] + (pre[<span class="number">2</span> * n] - pre[i + n + <span class="number">1</span> - <span class="number">1</span>] * pw[n - i]) ;</span><br><span class="line">        <span class="comment">// [i + 1, i + n] 翻转后的哈希</span></span><br><span class="line">        <span class="type">hash_t</span> h2 = suf[i + <span class="number">1</span>] - suf[(i + n) + <span class="number">1</span>] * pw[n];</span><br><span class="line">        <span class="keyword">if</span> (h1 == h2) &#123;</span><br><span class="line">            string ans = s.<span class="built_in">substr</span>(<span class="number">1</span> + i, n);</span><br><span class="line">            <span class="built_in">reverse</span>(<span class="built_in">all</span>(ans));</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;A-Generalized-ABC&quot;&gt;&lt;a href=&quot;#A-Generalized-ABC&quot; class=&quot;headerlink&quot; title=&quot;A. Generalized ABC&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://atcoder.jp/contes</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_并查集" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_图论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="算法_哈希" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 285 A-F</title>
    <link href="http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/"/>
    <id>http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/</id>
    <published>2023-01-16T16:00:00.000Z</published>
    <updated>2023-02-15T13:25:56.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Edge-Checker-2"><a href="#A-Edge-Checker-2" class="headerlink" title="A. Edge Checker 2"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_a">A. Edge Checker 2</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b / a == <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Longest-Uncommon-Prefixs"><a href="#B-Longest-Uncommon-Prefixs" class="headerlink" title="B. Longest Uncommon Prefixs"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_b">B. Longest Uncommon Prefixs</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;   s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; i + l &lt;= n; ++ l) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] == s[l + i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, l);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">LOG</span>(ans)</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-abc285-brutmhyhiizp"><a href="#C-abc285-brutmhyhiizp" class="headerlink" title="C. abc285_brutmhyhiizp"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_c">C. abc285_brutmhyhiizp</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>将26进制数(A-Z)转成10进制数(0-9)<br>BRUTMHYHIIZP —&gt; 10000000000000000</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;  cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        ans = ans * <span class="number">26</span> + (s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Change-Usernames"><a href="#D-Change-Usernames" class="headerlink" title="D. Change Usernames"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_d">D. Change Usernames</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>n个改名需求&lt;s[i], t[i]&gt;, 问是否能通过合理安排这n次改名的顺序, 使得改名没有冲突. </p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a b</span><br><span class="line">b c</span><br><span class="line">c a</span><br><span class="line">ans: No</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b</span><br><span class="line">b c</span><br><span class="line">ans: Yes</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>其实就是map&lt;string, int&gt;哈希 + 判环. toposort就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; id;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">to</span><span class="params">(<span class="number">2</span> * n + <span class="number">10</span>)</span>, <span class="title">ind</span><span class="params">(<span class="number">2</span> * n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        string s, t;    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="type">int</span> si, ti;</span><br><span class="line">        <span class="keyword">if</span> (!id.<span class="built_in">count</span>(s))   id[s] = ++ idx;</span><br><span class="line">        <span class="keyword">if</span> (!id.<span class="built_in">count</span>(t))   id[t] = ++ idx;</span><br><span class="line">        si = id[s];</span><br><span class="line">        ti = id[t];</span><br><span class="line">        to[si] = ti;</span><br><span class="line">        ++ ind[ti];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(<span class="number">2</span> * n + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>)    q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cv = q.<span class="built_in">front</span>();    q.<span class="built_in">pop</span>();</span><br><span class="line">        st[cv] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!to[cv])    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> nv = to[cv];</span><br><span class="line">        <span class="keyword">if</span> (-- ind[nv] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) ok = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Work-or-Rest"><a href="#E-Work-or-Rest" class="headerlink" title="E. Work or Rest"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_e">E. Work or Rest</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>一共有n(&lt;=5000)天, 每天可以是工作日 or 休息日 现在需要安排这n天, 使得工作效率之和最大化. 第i天(工作日)的工作效率定义为: </p><p>设这一天离最近的休息日距离d(把这n天视为一个环, 即第1天和第n天首尾相连), 第i天的工作效率为a[d]. 其中a[n]是给定的序列</p><p>如XOOOX (O代表工作日, X代表休息日)中: </p><blockquote><p>O[1] = a[min(1, 3)]</p><p>O[2] = a[min(2, 2)]</p><p>O[3] = a[min(3, 1)]</p></blockquote><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先要将n天的安排和a[n]独立开, 毕竟我第i天是工作日不代表这天的效率就是a的某个数, 具体要看n天的安排.</p><p>又因为n天是一个环, 所以可以设第一天是工作日. </p><p>影响效率之和的因素只有休息日天数和间隔. 设某两天休息日的间隔为d, 则这两天间的工作日效率之和为: </p><blockquote><p>d=1: a1</p><p>d=2: 2*a1</p><p>d=3: 2*a1 + a2</p></blockquote><p>记b[d]为间隔d天的效率贡献</p><p>n&lt;=5000. 可以n^2 DP</p><h4 id="间隔数dp"><a href="#间隔数dp" class="headerlink" title="间隔数dp"></a>间隔数dp</h4><p>dp[i][j] 表示安排完了前i天, 且当前已经连续j天是工作日</p><p>dp[i][j] = dp[i][j - 1]</p><p>dp[i][0] = dp[i][j] + b[j]</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line">    a[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   b[i] = b[i - <span class="number">1</span>] + a[(i + <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Why 必须初始化 负数? </span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i][<span class="number">0</span>], dp[i - <span class="number">1</span>][j] + b[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = dp[n + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包dp"><a href="#完全背包dp" class="headerlink" title="完全背包dp"></a>完全背包dp</h4><p>把间隔数i + 1(连续i天工作日 + 1天休息日)视作物品i的体积, d[i]视作物品i的价值. 背包容量为n</p><blockquote><p>w[i] = w[i - 1] + a[i + 1 &gt;&gt; 1];</p><p>v[i] = i + 1;</p></blockquote><p>dp[n][n]即为所求</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)       cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        w[i] = w[i - <span class="number">1</span>] + a[i + <span class="number">1</span> &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        v[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; ++ i) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int c = 0; c * v[i] &lt;= n; ++ c) &#123;</span></span><br><span class="line">    <span class="comment">//         for (int j = c * v[i]; j &lt;= n; ++ j) &#123;</span></span><br><span class="line">    <span class="comment">//             dp[i][j] = max(dp[i][j], dp[i - 1][j - c * v[i]] + w[i] * c);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="comment">// for (int j = n; j &gt;= 0; -- j) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i])</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// OXXXXXX OXXXXXX</span></span><br><span class="line">    <span class="built_in">LOG</span>(dp[n][n])</span><br><span class="line">    cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Substring-of-Sorted-String"><a href="#F-Substring-of-Sorted-String" class="headerlink" title="F. Substring of Sorted String"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_f">F. Substring of Sorted String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>小写字符串s[n], q个询问<br>2种询问方式: </p><blockquote><p>1 x c: s[x] = c</p><p>2 l r: 设t[n]=sort(all(s)), 判断s[l, r]是否为t的子串</p></blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><blockquote><p>s = acbd     t = abcd</p><p>q = 2 1 4    NO</p></blockquote><blockquote><p>s = abbd     t = abbd</p><p>q = 2 1 3    YES</p></blockquote><blockquote><p>s = abcdc     t = abccd</p><p>q = 2 2 4    NO</p></blockquote><p>tag[i]记录s[i - 1] -&gt; s[i] 是否为非递减</p><p>seg[c].range(l, r) 记录字母c在[l, r]内出现次数</p><p>s[l, r]为t的子串, 需要满足以下两个条件: </p><ol><li>s[l + 1, r]内的字符都是递增的. 即tag.range_sum(l + 1, r) == 0</li><li>s[l + 1, r - 1]内的字符出现频数 == t对应字符出现频数. 如样例3</li></ol><p>tag: 单点修改, 区间求和 —&gt; fenwick_tree</p><p>seg: 求s[l, r]内某字符的出现频数, 支持修改 —&gt; fenwick_tree</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick_tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tr;</span><br><span class="line">    <span class="built_in">fenwick_tree</span>(<span class="type">int</span> n) &#123;<span class="keyword">this</span>-&gt;n = n; tr.<span class="built_in">resize</span>(n + <span class="number">5</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span>   </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">range</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;       cin &gt;&gt; n;</span><br><span class="line">    string s;    cin &gt;&gt; s;      s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="type">int</span> q;       cin &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;fenwick_tree&gt;  <span class="title">seg</span><span class="params">(<span class="number">26</span>, fenwick_tree(n + <span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="function">fenwick_tree <span class="title">tag</span><span class="params">(n + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        seg[s[i] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) tag.<span class="built_in">add</span>(i, s[i - <span class="number">1</span>] &gt; s[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> op;   cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;  <span class="type">char</span> c;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">            cnt[s[x] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            seg[s[x] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">add</span>(x, <span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// s[x - 1] s[x] s[x + 1]</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                tag.<span class="built_in">add</span>(x, -(tag.<span class="built_in">range</span>(x, x)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; n) &#123;</span><br><span class="line">                tag.<span class="built_in">add</span>(x + <span class="number">1</span>, -(tag.<span class="built_in">range</span>(x + <span class="number">1</span>, x + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s[x] = c;</span><br><span class="line">            cnt[s[x] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            seg[s[x] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">add</span>(x, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                tag.<span class="built_in">add</span>(x, s[x - <span class="number">1</span>] &gt; s[x]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; n) &#123;</span><br><span class="line">                tag.<span class="built_in">add</span>(x + <span class="number">1</span>, s[x] &gt; s[x + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="type">int</span> ok = <span class="literal">true</span>;</span><br><span class="line">            ok &amp;= (tag.<span class="built_in">range</span>(l + <span class="number">1</span>, r) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = s[l] + <span class="number">1</span> - <span class="string">&#x27;a&#x27;</span>; i &lt;= s[r] - <span class="number">1</span> - <span class="string">&#x27;a&#x27;</span>; ++ i) &#123;</span><br><span class="line">                ok &amp;= (seg[i].<span class="built_in">range</span>(l, r) == cnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">LOG</span>(ok)</span><br><span class="line">            <span class="keyword">if</span> (ok)     cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span>        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;A-Edge-Checker-2&quot;&gt;&lt;a href=&quot;#A-Edge-Checker-2&quot; class=&quot;headerlink&quot; title=&quot;A. Edge Checker 2&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://atcoder.jp/contests/</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D</title>
    <link href="http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/"/>
    <id>http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/</id>
    <published>2023-01-16T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:50.353Z</updated>
    
    <content type="html"><![CDATA[<p>比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.</p><p>补题: D因式分解 + 枚举因子 + 压缩状态</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分别计算俩点向四个方向的墙面相连的距离, 求最小值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w, d, h;    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class="line">    <span class="type">int</span> a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> dist1 = <span class="built_in">min</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist2 = <span class="built_in">min</span>(b, g);</span><br><span class="line">    <span class="type">int</span> dist3 = w - <span class="built_in">max</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist4 = d - <span class="built_in">max</span>(b, g);</span><br><span class="line">    <span class="type">int</span> ans1 = <span class="number">2</span> * dist1 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans2 = <span class="number">2</span> * dist2 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans3 = <span class="number">2</span> * dist3 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans4 = <span class="number">2</span> * dist4 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;ans1, ans2, ans3, ans4&#125;);</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Going-to-the-Cinema"><a href="#B-Going-to-the-Cinema" class="headerlink" title="B. Going to the Cinema"></a><a href="https://codeforces.com/contest/1782/problem/B">B. Going to the Cinema</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一: </p><ol><li>自己去,但除自己外去的人数 &lt; ai</li><li>自己不去,但除自己外去的人数&gt;= ai</li></ol><p>问有多少种选择去的人的集合的方案,使得没有人伤心.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>设去的人的集合A={p1,⋯,pa},不去的人的集合B={q1,⋯,qb},则A⋃B={1,⋯,n},a+b=n.​</p><ol><li>对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \geq \max_{1 \leq i\leq a} a_{p_i}$.​    </li><li>对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当<br>$a &lt; \min_{1\leq j\leq b} a_{q_j}$.</li></ol><p>枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1]</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + n + <span class="number">1</span>);</span><br><span class="line">    a[n + <span class="number">1</span>] = inf; a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; a[i] &amp;&amp; i &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++ ans;</span><br><span class="line">            <span class="built_in">LOG</span>(i, a[i], a[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Equal-Frequencies"><a href="#C-Equal-Frequencies" class="headerlink" title="C. Equal Frequencies"></a><a href="https://codeforces.com/contest/1782/problem/C">C. Equal Frequencies</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>称一个字符串是好的,如果每种字符出现的次数都相等. </p><p>n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t.</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n / seg</p><p>首先将字母按照cnt[26] (字母出现频数) 降序排序, 要<strong>尽最大可能利用现有的多的字母</strong></p><p>以下代码用来找到最小的代及cost其对应的ac</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">    <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">        mn_cost = now;          best_ac = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要统计<strong>cnt不足ac的部分</strong>就行了, 不足的部分肯定是需要其他redundant的来补充的. </p><p>aim[26]表示t中每个字母的目标次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">    aim[ord[i]] = best_ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来只需要看s[i]的cnt: </p><ol><li>cnt &gt;  aim[s[i]], 在26个字母中找cnt还不足aim的进行替换</li><li>cnt &lt;= aim[s[i]], 跳过</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)   cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ord</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(<span class="built_in">all</span>(ord), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(ord), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt[a] &gt; cnt[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// d: n的因子, 作为每个字母的出现次数</span></span><br><span class="line">    <span class="type">int</span> mn_cost = n, best_ac = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">        <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">            mn_cost = now;          best_ac = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> best_seg = n / best_ac;</span><br><span class="line">    <span class="built_in">LOG</span>(mn_cost, best_ac, best_seg)</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">aim</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">        aim[ord[i]] = best_ac;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(aim)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aim[ch - <span class="string">&#x27;a&#x27;</span>] &gt;= cnt[ch - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; <span class="number">26</span>; ++ to) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aim[to] &gt; cnt[to]) &#123;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">                ch = (<span class="type">char</span>)to + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Many-Perfect-Squares"><a href="#D-Many-Perfect-Squares" class="headerlink" title="D. Many Perfect Squares"></a><a href="https://codeforces.com/contest/1782/problem/D">D. Many Perfect Squares</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>非递减数组a<a href="1%E2%89%A4n%E2%89%A450">n</a>. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数. </p><p>例如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 13 22 90</span><br></pre></td></tr></table></figure><p>选择 x = 3</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4,9,16,25,93</span><br></pre></td></tr></table></figure><p>4,9,16,25,93<br>最多有4个完全平方数</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x. </p><p>先sort(all(a))</p><p>设有 $i &lt; j, a_i + x = va^2 ,a_j + x = vb^2$ </p><p>对完全平方数做差有$vb^2 - va^2 = (vb-va)(vb+va) = a_j + x - (a_i + x) = a_j - a_i$</p><p>令 diff = aj - ai</p><p>则 (vb - va)(vb + va) = diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d = diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x = va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x. </p><p>用dp[x] |= 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意. </p><p>最后统计一下每个x的二进制1个数就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> diff = a[j] - a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> div = <span class="number">1</span>; div * div &lt;= diff; ++ div) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff % div != <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> diva = div, divb = diff / div;</span><br><span class="line">                <span class="keyword">if</span> (diva % <span class="number">2</span> != divb % <span class="number">2</span>)     <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 12 = 2 * 6       va = 2, vb = 4    </span></span><br><span class="line">                <span class="comment">// x = va * va - a[i]</span></span><br><span class="line">                <span class="type">int</span> va = (divb - diva) / <span class="number">2</span>, vb = (diva + divb) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> x = va * va - a[i];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>)                      <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">LOG</span>(a[i], a[j], diff, va, vb)</span><br><span class="line">                dp[x] |= (<span class="number">1ll</span> &lt;&lt; i) | (<span class="number">1ll</span> &lt;&lt; j);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;        <span class="comment">// 只有1个数a, 肯定能找到x, 使得a+x是平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, val] : dp) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)<span class="built_in">popcountll</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.&lt;/p&gt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_实现" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="算法_数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 134 A-F</title>
    <link href="http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/"/>
    <id>http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/</id>
    <published>2023-01-14T16:00:00.000Z</published>
    <updated>2023-01-20T07:14:17.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="R2532橙题-F-Permutation-Oddness"><a href="#R2532橙题-F-Permutation-Oddness" class="headerlink" title="R2532橙题 F - Permutation Oddness"></a>R2532橙题 <a href="https://atcoder.jp/contests/abc134/tasks/abc134_f">F - Permutation Oddness</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>设 P = (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;=50)的排列. 定义Oddness:= $\sum |p_i - i|$. 求满足定义Oddness = k 的不同排列P的数量</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解.</p><p>这里以<a href="https://img.atcoder.jp/abc134/editorial.pdf">官方题解</a>为基础, 加以翻译并解释. </p><blockquote><p>若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K</p></blockquote><p>dp[i][j][k][l]=表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. </p><p>因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j=k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. </p><p>状态转移方程写作：<br>dp[i][j][k] = (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j]</p><p>当考虑第i个数与盒子的时候, 分5种情况: </p><blockquote><p>数i和盒子i直接配对, 未配对的依然是j个</p><p>但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j];</p></blockquote><blockquote><p>数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</p><p>未配对的数-1, 盒子数-1, 所以未配对的-1个. </p><p>当前状态j, 所以上一状态j+1</p><p>有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1);</p></blockquote><blockquote><p>数i和盒子i都不配对, 未配对的是j+1个</p><p>有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j &gt;= 1)     dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j];</p></blockquote><p>注意, 可能情况个数要从上一状态出发考虑</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mint dp[N][N][N * N];    </span><br><span class="line"><span class="comment">// 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对</span></span><br><span class="line"><span class="comment">// 且 当前的奇异值为k的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * j; k &lt;= n * n; ++ k) &#123;</span><br><span class="line">                <span class="comment">// 数i和盒子i直接配对, 未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j];</span><br><span class="line">                <span class="comment">// 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</span></span><br><span class="line">                <span class="comment">// 未配对的数-1, 盒子数-1, 所以未配对的-1个. </span></span><br><span class="line">                <span class="comment">// 当前状态j, 所以上一状态j+1</span></span><br><span class="line">                <span class="comment">// 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= i) dp[i][j][k] += dp[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">2</span> * j] * (j + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 数i和盒子i都不配对, 未配对的是j+1个</span></span><br><span class="line">                <span class="comment">// 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span>)     dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">2</span> * j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;R2532橙题-F-Permutation-Oddness&quot;&gt;&lt;a href=&quot;#R2532橙题-F-Permutation-Oddness&quot; class=&quot;headerlink&quot; title=&quot;R2532橙题 F - Permutation Oddness&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 797 (Div. 3) A-G</title>
    <link href="http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/"/>
    <id>http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/</id>
    <published>2023-01-13T16:00:00.000Z</published>
    <updated>2023-01-14T04:51:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. </p><p>补题: </p><h2 id="A-Print-a-Pedestal-Codeforces-logo"><a href="#A-Print-a-Pedestal-Codeforces-logo" class="headerlink" title="A. Print a Pedestal (Codeforces logo?)"></a><a href="https://codeforces.com/contest/1690/problem/A">A. Print a Pedestal (Codeforces logo?)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> d = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Array-Decrements"><a href="#B-Array-Decrements" class="headerlink" title="B. Array Decrements)"></a><a href="https://codeforces.com/contest/1690/problem/B">B. Array Decrements)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; d0, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> cd = b[i] - a[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            d0.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d.size == 1</span></span><br><span class="line">    <span class="keyword">if</span> (*d0.<span class="built_in">begin</span>() &lt; *d.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Restoring-the-Duration-of-Tasks"><a href="#C-Restoring-the-Duration-of-Tasks" class="headerlink" title="C. Restoring the Duration of Tasks"></a><a href="https://codeforces.com/contest/1690/problem/C">C. Restoring the Duration of Tasks</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d = f - s<br>否则当前任务到来时间s &lt; 上个任务完成时间 d = f - f[i - 1]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span> ,<span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : f)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span>, f[<span class="number">0</span>] - s[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; f[i - <span class="number">1</span>])    ans.<span class="built_in">pb</span>(f[i] - s[i]);</span><br><span class="line">        <span class="keyword">else</span>                    ans.<span class="built_in">pb</span>(f[i] - f[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Black-and-White-Stripe"><a href="#D-Black-and-White-Stripe" class="headerlink" title="D. Black and White Stripe"></a><a href="https://codeforces.com/contest/1690/problem/D">D. Black and White Stripe</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;   cin &gt;&gt; s;   s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = l + k - <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span> - (pre[r] - pre[l - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Price-Maximization"><a href="#E-Price-Maximization" class="headerlink" title="E. Price Maximization"></a><a href="https://codeforces.com/contest/1690/problem/E">E. Price Maximization</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以<br>的和k, 求和最大是多少</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分. </p><p>把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;=k - x, 所以lower_bound一下k - x</p><p>也可以把a排序, 然后首尾双指针搞搞</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ans += x / k;</span><br><span class="line">        x %= k;</span><br><span class="line">        <span class="keyword">if</span> (x)  S.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (S.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> itx = S.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 先取值, 再删除? </span></span><br><span class="line">        <span class="type">int</span> x = *itx;</span><br><span class="line">        S.<span class="built_in">erase</span>(itx);</span><br><span class="line">        <span class="keyword">auto</span> ity = S.<span class="built_in">lower_bound</span>(k - x);</span><br><span class="line">        <span class="keyword">if</span> (ity != S.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> y = *ity;</span><br><span class="line">            ans ++;</span><br><span class="line">            S.<span class="built_in">erase</span>(ity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Shifting-String"><a href="#F-Shifting-String" class="headerlink" title="F. Shifting String"></a><a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \sqrt{n})$</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;      cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        x --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (st[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = i;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line">        <span class="keyword">for</span> (; st[now] == <span class="number">-1</span>; now = p[now]) &#123;</span><br><span class="line">            loop.<span class="built_in">pb</span>(now);</span><br><span class="line">            st[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(loop)</span><br><span class="line">        deque&lt;<span class="type">char</span>&gt; dq0, dq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : loop) dq0.<span class="built_in">pb</span>(s[p]);</span><br><span class="line">        dq.<span class="built_in">assign</span>(<span class="built_in">all</span>(dq0));</span><br><span class="line">        <span class="type">int</span> cl = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (;cl &lt; loop.<span class="built_in">size</span>(); ++ cl) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = dq.<span class="built_in">back</span>(); dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            dq.<span class="built_in">push_front</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (dq == dq0) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len.<span class="built_in">pb</span>(cl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : len) &#123;</span><br><span class="line">        ans = <span class="built_in">lcm</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Count-the-Trains"><a href="#G-Count-the-Trains" class="headerlink" title="G. Count the Trains"></a><a href="https://codeforces.com/contest/1690/problem/G">G. Count the Trains</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少</p><p>例如[10, 13, 5, 2, 6] =&gt; [10, 10, 5, 2, 2] 一共有3种不同的数</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>维护每段火车的车头位置和整节车的速度. </p><p>在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车</p><p>如果速度x &gt;= 左边的火车段的速度, 就直接把it合并到左边(erase掉it)</p><p>如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)).</p><p>insert和erase的次数不会超过O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> i, <span class="type">int</span> x) &#123;</span><br><span class="line">        mp[i] = x;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(i);       <span class="comment">// 根据键key查找</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5    ---&gt; 9 10 | 5</span></span><br><span class="line">        <span class="keyword">if</span> (it != mp.<span class="built_in">begin</span>() &amp;&amp; <span class="built_in">prev</span>(it)-&gt;second &lt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5 | 3 | 1  ---&gt; 9 | 2 5 3 | 1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">next</span>(it) != mp.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it)-&gt;second &gt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(<span class="built_in">next</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k, d;   cin &gt;&gt; k &gt;&gt; d;      k --;</span><br><span class="line">        a[k] -= d;</span><br><span class="line">        <span class="built_in">add</span>(k, a[k]);</span><br><span class="line">        cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. &lt;/p&gt;
</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_组合数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_双指针" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
