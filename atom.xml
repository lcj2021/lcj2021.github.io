<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liucj&#39;s Harbour</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-15T12:12:25.636Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周记 - 2023 02.06-02.12</title>
    <link href="http://example.com/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/"/>
    <id>http://example.com/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/</id>
    <published>2023-02-13T16:00:00.000Z</published>
    <updated>2023-02-15T12:12:25.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-10-周五-多云-阴"><a href="#02-10-周五-多云-阴" class="headerlink" title="02.10 周五 多云~阴"></a>02.10 周五 多云~阴</h2><p>今天晚上参加了晚上7点的小白月赛66. 开局上来就被A搞了快10分钟. B更是因为没讨论 A &lt;= B的情况调到40分钟. D题一开始也是不会做, 不过好在发现了平方式的用意. 最后还剩半个多小时做E, 想了会发现是道完全图的构造题. 想着用set insert + erase + lower_bound 3e5次(2s时限)硬怼构造边权, 不过没写完. 赛后写完交了, TLE. やはり(yahari 果然)还是找出边权递增的顺序去赋值边权才行. </p><blockquote><p>后话: 其实set硬怼也行, 不过得用到 霓虹大神maspy的 <a href="https://maspypy.github.io/library/ds/fastset.hpp">fastset</a></p></blockquote><p>最后四题, 感觉我做E的时候还是太呆了. WF说要暂不返校要填表, 而且明天之前就要截止了. 我想着没啥理由, 然后就打了个嗝, 不过不是很畅通, 是那种嘶哑的, 心想之前考虑打 “加强针” (中间右边再补针). 不如趁这个机会打了得了, 所以就这么填了. </p><h2 id="02-11-周六-多云-阴"><a href="#02-11-周六-多云-阴" class="headerlink" title="02.11 周六 多云~阴"></a>02.11 周六 多云~阴</h2><p>早上补昨晚小白月赛66的F题, 发现好像是个挺简单的一眼二分 + 尝试性贪心(只用从后往前合并和从前往后合并两种, 枚举下就知道哪个更优了). </p><p>晚上打ABC 289. 前四题依然慢速, 做了20+分钟… 尤其是B题别人用题目性质 + 双指针很快写完, 我还用并查集硬怼模拟. C题二进制枚举看半天题. D题因为转为index 0 based党, 所以dp方式也改成了刷表法. しかし(shi ka shi 可是) vector开小了, RE了一发. E题想了一个小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. 以为是O(n^2)的, 其实是O(m^2)的, 都没看到边数m &lt;= 2000. 属于是瞎猫撞上死耗子了. </p><p>表现分1364, +29来到1138. 离青名只差62分了, がんばって (顽张って ga n ba te加油)!</p><h2 id="02-12-周日-多云-小雨"><a href="#02-12-周日-多云-小雨" class="headerlink" title="02.12 周日 多云~小雨"></a>02.12 周日 多云~小雨</h2><p>中午起床收到微信下午开组会. やはり还是得继续科研进度. 开会讨论后, 认为应该从下游任务的实际实验效果看看. 所以得用到分布式图计算的环境. 但是我之前除了gstore外就没用过其他框架了. 问了蔡学长, 得知服务器集群得校园网访问. 实在难顶. </p><p>下午4点 场的codeforces 852 div2. 难得不是阴间时间. 直接炸穿. A40+分钟才过. 哎情况没讨论好, 多写了if, 其实都要考虑的. B一开始看到了条件”数组元素绝对值之差为1”, 后面又忘了这个条件了. C吃完饭后回来才写完. </p><p>表现分只有不到1000分呢. 我直接好家伙, 上个青名都费劲, 我好像只配打div3和div4. 哎谁让我上次div4没把握好机会呢? 要是上次写慢些, 老老实实把树状数组写了, 再检查好二分边界, 也没那么多烦事了. 不过呢, 这点掉分只能说是小问题, 打还是会继续打的. 只是cf这种rated波动那么大的比赛, 不如直接彻底开摆得了. 这样得失心放轻些, 说不定还能表现得正常些. 下次div2我想直接从C或D开始干了, 效仿rainboy大神. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.15日晚19点30分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-10-周五-多云-阴&quot;&gt;&lt;a href=&quot;#02-10-周五-多云-阴&quot; class=&quot;headerlink&quot; title=&quot;02.10 周五 多云~阴&quot;&gt;&lt;/a&gt;02.10 周五 多云~阴&lt;/h2&gt;&lt;p&gt;今天晚上参加了晚上7点的小白月赛66. 开局上来就被</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.30-02.05</title>
    <link href="http://example.com/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/"/>
    <id>http://example.com/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2023-02-15T12:12:46.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-03-周五-多云-小雨"><a href="#02-03-周五-多云-小雨" class="headerlink" title="02.03 周五 多云~小雨"></a>02.03 周五 多云~小雨</h2><p>今天主要参加了晚上10点半的div4 849. 开局虽然又被E (R1100)卡了下, 不过还是很快能搞定. F题一开始想不到好做法, 本来打算写树状数组, 但是没整理板子, 区间修改之类的又得重新写, 所以就投机取巧试了试用set维护还能修改的坐标. 一交, 诶居然能过. 然后就没理了. </p><p>G1和G2我一开始以为做了G2, G1也能一起交. 所以G1的罚时多了很多. G2我一开始想错了, 不过还是很快想到了二分. 并且很快写完了. 一看才400+人过. 暗自窃喜. 正式榜甚至进了首页, 表现分高达2050! zwling还觉得我能直接上蓝.  </p><p>没想到小丑竟是我自己…F和G2都FST了. 早知道F老老实实写区间修改 + 单点查询 树状数组了. G2是因为二分边界<code>l = 0</code>写成了<code>l = 1</code>. 我是真的讨厌这种下标从0开始, 从1开始的臭东西. 以后想坚定做下标0-base党了. 不过看到G2居然是R1900的题, 十分震惊. 感觉其他R1900的题比他难得不止一点半点. </p><h2 id="02-04-周六-小雨-中雨"><a href="#02-04-周六-小雨-中雨" class="headerlink" title="02.04 周六 小雨~中雨"></a>02.04 周六 小雨~中雨</h2><p>晚上有Atcoder Beginner Contest 288. 8点麻木地开打, 前两题签完到, C题经典手速慢的惊人, 一开始写toposort, 发现不对劲, 才改并查集. D题罚坐1个半小时, 一看全场就800+过, 是真的逆天. 属于那种大聪明之差分性质挖掘题. rk2000+, 直接完蛋, 不过最终-6. Atcoder yyds!</p><h2 id="02-05-周日-小雨"><a href="#02-05-周日-小雨" class="headerlink" title="02.05 周日 小雨"></a>02.05 周日 小雨</h2><p>晚上8点 tourist场的div2. 难得不是阴间时间, 但是考虑到tourist出题, 上次div1+div2合并场的A都给我干趴下了. 这次也不例外, A1 + A2直接给我整了半个小时. B题又是上下限约束题, 想了挺久才想出来. C题贪心, 但是本来1层循环4行的东西, 我写了一堆if 的答辩东西. 还WA了一发. 一看rk2000+. 好家伙我赛前看见register人数18000+, 现在只有7000+提交, 是真的逆天. 不过还好一分没丢没涨. </p><p>D结论瞎撞撞对了, 不过是真的难写. 其实主要是我的思路十分混乱, 其实只用把每个人视作多个 &lt;need char, give char&gt; 就行了. 先是恰好互补的人交换. 交换完剩下的一定只有3种人, 这3种人恰好能组成交换环. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.06日晚22点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;02-03-周五-多云-小雨&quot;&gt;&lt;a href=&quot;#02-03-周五-多云-小雨&quot; class=&quot;headerlink&quot; title=&quot;02.03 周五 多云~小雨&quot;&gt;&lt;/a&gt;02.03 周五 多云~小雨&lt;/h2&gt;&lt;p&gt;今天主要参加了晚上10点半的div4 849</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>笔记 - CP模板</title>
    <link href="http://example.com/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-02-05T16:00:00.000Z</published>
    <updated>2023-02-14T14:22:24.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计数模板"><a href="#计数模板" class="headerlink" title="计数模板"></a>计数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> + (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> - (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> * (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> / (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *= (<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> /= (<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="type">int</span> v; os &gt;&gt; v; a = <span class="built_in">ModInt</span>(v); <span class="keyword">return</span> os;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b; <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>) u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;mod&gt;;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">fenwick</span>(<span class="type">int</span> n): <span class="built_in">n</span>(n) &#123;tr.<span class="built_in">resize</span>(n);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (++ pos; pos &gt;= <span class="number">1</span>; pos -= <span class="built_in">lowbit</span>(pos)) &#123;</span><br><span class="line">            res += tr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (++ pos; pos &lt;= n; pos += <span class="built_in">lowbit</span>(pos)) &#123;</span><br><span class="line">            tr[pos] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串-双-哈希"><a href="#字符串-双-哈希" class="headerlink" title="字符串(双)哈希"></a>字符串(双)哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">hash_t</span> = array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod0 = <span class="number">1e9</span> + <span class="number">7</span>, mod1 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="type">hash_t</span> base = &#123;<span class="number">13331</span>, <span class="number">23333</span>&#125;;</span><br><span class="line"><span class="type">hash_t</span> pw[N];</span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> + (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] + b[<span class="number">0</span>]) % mod0, (a[<span class="number">1</span>] + b[<span class="number">1</span>]) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> - (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="type">hash_t</span> res = &#123;(a[<span class="number">0</span>] - b[<span class="number">0</span>] + mod0) % mod0, (a[<span class="number">1</span>] - b[<span class="number">1</span>] + mod1) % mod1&#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">hash_t</span> <span class="keyword">operator</span> * (<span class="type">hash_t</span> a, <span class="type">hash_t</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] * b[<span class="number">0</span>] % mod0, a[<span class="number">1</span>] * b[<span class="number">1</span>] % mod1&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pw[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; ++ i) &#123;</span><br><span class="line">    pre[i] = pre[i - <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">    suf[i] = suf[i + <span class="number">1</span>] * base + <span class="type">hash_t</span>&#123;s[i], s[i]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志:"></a>更新日志:</h2><p>2023.01.18: </p><p>加入计数模板 + 字符串双哈希模板</p><p>2023.02.06: </p><p>加入朴素fenwick模板</p><p>等cf上1500 / atcoder上青名, 就着手构建自己的library</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计数模板&quot;&gt;&lt;a href=&quot;#计数模板&quot; class=&quot;headerlink&quot; title=&quot;计数模板&quot;&gt;&lt;/a&gt;计数模板&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记_模板" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 848 (Div. 2) A-D</title>
    <link href="http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/"/>
    <id>http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/</id>
    <published>2023-02-01T16:00:00.000Z</published>
    <updated>2023-02-02T08:04:42.881Z</updated>
    
    <content type="html"><![CDATA[<p>比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难.</p><p>补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]=dp[n-1]+1. 从而求出dp[1]</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定由 1 和 -1 组成的数组，你必须选择两个相邻元素，然后翻转它们的符号。</p><p>求翻转后数组的最大和。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于相邻的2个数, 总共3种情况: </p><ol><li>(-1, -1)             总贡献 +4</li><li>(-1, 1) / (1, -1)    总贡献 0</li><li>只有(1, 1)           总贡献 -4</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(a), <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> add0 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; a[i] == <span class="number">-1</span> &amp;&amp; a[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; ans + <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; a[i] * a[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            add0 = <span class="literal">true</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add0)   cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>        cout &lt;&lt; ans - <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定排列 p 和数组 a和正整数d. </p><p>定义a是不好数组, 如果对于所有a[1~m-1], 都有pos[a[i]] &lt; pos[a[i+1]] &lt;= pos[a[i]] + d</p><p>比如: p=[4,2,1,3,6,5] 和 d=2</p><blockquote><p>a=[2,3,6] is a not good array.<br>a=[2,6,5] is good because pos(a1)=2, pos(a2)=5, so the condition pos(a2)≤pos(a1)+d is not satisfied.<br>a=[1,6,3] is good because pos(a2)=5, pos(a3)=4, so the condition pos(a2)&lt;pos(a3) is not satisfied.</p></blockquote><p>请多次交换排列p中相邻的元素，使得a变成好数组</p><p>求最少交换次数。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>要破坏现有满足的2个条件, 只需要破坏其中一个条件就行. </p><p>枚举每个数, 分别计算破坏左边不等式和右边不等式的代价. 取个min就行</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, d;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span>, <span class="title">a</span><span class="params">(m)</span>, <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];    p[i] --;</span><br><span class="line">        pos[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x, x --;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> px = pos[x], py = pos[y];</span><br><span class="line">        <span class="keyword">if</span> (px + n - <span class="number">1</span> - py &gt;= d - (py - px) + <span class="number">1</span>)   ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(d - (py - px) + <span class="number">1</span>, (<span class="type">int</span>)<span class="number">0</span>));</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(py - px, (<span class="type">int</span>)<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Flexible-String"><a href="#C-Flexible-String" class="headerlink" title="C. Flexible String"></a><a href="https://codeforces.com/contest/1778/problem/C">C. Flexible String</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>现有字符串 a,b 。请选择修改 a 中至多 k 种 字符，对于 每一个 这样的字符，都可以将其改为另一个其他字符。</p><p>求修改后 a’ 的子串以及 b 的子串中，满足 a’[l..r] = b[l..r] 的数量的最大值。保证 a 中至多有 10 种字符。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>n(1e5), k(10). </p><p>暴力二进制枚举子集, 最高O(2^10 * 1e5), 2s能接受. </p><p>枚举每个子集, 对于a[i], 若是子集里的字母, 都替换成b[i]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1024 * 1e5 2s 应该能过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string a, b;    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    string unique_a = a;</span><br><span class="line">    <span class="built_in">uniq</span>(unique_a);</span><br><span class="line">    <span class="type">int</span> m = unique_a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">LOG</span>(unique_a, m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= m) &#123;</span><br><span class="line">        cout &lt;&lt; n * (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">0</span>; val &lt; (<span class="number">1</span> &lt;&lt; m); ++ val) <span class="keyword">if</span> (<span class="built_in">popcountll</span>(val) == k) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">change</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; m; ++ b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt;&gt; b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                change[unique_a[b] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (change[a[i] - <span class="string">&#x27;a&#x27;</span>] || a[i] == b[i]) &#123;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr += len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len)    curr += len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, curr);</span><br><span class="line">    &#125; <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Flexible-String-Revisit"><a href="#D-Flexible-String-Revisit" class="headerlink" title="D. Flexible String Revisit"></a><a href="https://codeforces.com/contest/1778/problem/D">D. Flexible String Revisit</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定两个二进制串 a, b. </p><p>每次随意翻转一个二进制位，求第一次使得 a=b 所需的期望次数。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设有 i 个二进制位不同的情况下，所需的次数是 dp[i] ，则有转移方程：</p><p><code>dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</code></p><p>其含义是，我们进行一次翻转后，有 i/n 的概率减少一个不同的位，这样就还需要 dp[i−1] 次；其他情况下将增加一个不同的位，则还需要 dp[i+1] 次。特别地， dp[0]=0， dp[n]=1+dp[n−1]</p><p>但是(しかし), 期望公式dp[i]依赖于dp[i-1]和dp[i+1]. 而我们的初始状态只有dp[0]=0. 因此需要通过解方程的方式才能得到答案</p><p>$$<br>dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n \ </p><p>dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n \ </p><p>dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n   \ </p><p>dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n) \<br>$$</p><p>dp[2] = dp[1] + … = k * dp[1] + b</p><p>用 dp[1] 看作已知，各个 dp[i] 表示为k * dp[1] + b. </p><p>一直到 dp[n] = 1 + dp[n - 1]</p><p>dp[n] - dp[n - 1] = k * dp[1] + b = 1, 这里的k和b都是已经通过递推算出来的, 所以dp[1]的值也就算出来了.</p><p>答案就是<code>dp[diff_cnt][0] * dp[1] + dp[diff_cnt][1]</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>-(array&lt;mint, <span class="number">2</span>&gt; a, array&lt;mint, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]-b[<span class="number">0</span>], a[<span class="number">1</span>]-b[<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>-(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]-b&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>*(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]*b, a[<span class="number">1</span>]*b&#125;;</span><br><span class="line">&#125;</span><br><span class="line">array&lt;mint, 2&gt; <span class="keyword">operator</span>/(array&lt;mint, <span class="number">2</span>&gt; a, mint b) &#123;</span><br><span class="line"><span class="keyword">return</span> array&lt;mint, <span class="number">2</span>&gt; &#123;a[<span class="number">0</span>]/b, a[<span class="number">1</span>]/b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;          cin &gt;&gt; n;</span><br><span class="line">    string a, b;    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)    diff += (a[i] != b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i]: 有i个不同之处的期望: dp[i][0] * dp[1] + dp[i][1]</span></span><br><span class="line">    vector&lt;array&lt;mint, 2&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);   </span><br><span class="line">    dp[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</span></span><br><span class="line">    <span class="comment">// dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n</span></span><br><span class="line">    <span class="comment">// dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n</span></span><br><span class="line">    <span class="comment">// dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        dp[i] = (dp[i<span class="number">-1</span>] - <span class="built_in">mint</span>(<span class="number">1</span>) - dp[i<span class="number">-2</span>] * <span class="built_in">mint</span>(i<span class="number">-1</span>) / <span class="built_in">mint</span>(n)) / (<span class="built_in">mint</span>(<span class="number">1</span>) - <span class="built_in">mint</span>(i<span class="number">-1</span>)/<span class="built_in">mint</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[n] = 1 + dp[n - 1]</span></span><br><span class="line">    <span class="comment">// dp[n] - dp[n - 1] = d[0] * dp[1][0] + d[1] = 1</span></span><br><span class="line">    <span class="comment">// k = dp[1][0] = (1 - d[1]) / d[0]</span></span><br><span class="line">    array&lt;mint, 2&gt; d = dp[n] - dp[n - <span class="number">1</span>];</span><br><span class="line">    mint k = (<span class="built_in">mint</span>(<span class="number">1</span>) - d[<span class="number">1</span>]) / d[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; dp[diff][<span class="number">0</span>] * k + dp[diff][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-Flip-Flop-Sum"><a href="#A-Flip-Flop-Sum" class="headerlink" title="A. Flip Flop Sum"></a><a href="https://codeforces.com/contest/1778/problem/A">A. Flip Flop Sum</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难.&lt;/p&gt;
&lt;p&gt;补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]=dp[n-1]+1. 从而求出dp[1]</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
    <category term="算法_概率期望" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Educational Round 142 (Div. 2) A-D</title>
    <link href="http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/"/>
    <id>http://example.com/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/</id>
    <published>2023-02-01T16:00:00.000Z</published>
    <updated>2023-02-06T13:55:56.070Z</updated>
    
    <content type="html"><![CDATA[<p>C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射.</p><p>6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶. </p><h2 id="B-Stand-up-Comedian"><a href="#B-Stand-up-Comedian" class="headerlink" title="B. Stand-up Comedian"></a><a href="https://codeforces.com/contest/1792/problem/B">B. Stand-up Comedian</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>Stand-up Comedian: 单口相声演员</p><p>有四种类型的笑话：</p><blockquote><p>第一种: 使AB的情绪都 +1</p><p>第二种: 使A的情绪 +1, B的情绪-1</p><p>第三种: 使A的情绪 -1, B的情绪+1</p><p>第四种会使AB的情绪都-1</p></blockquote><p>两人的情绪初始为0. 求在AB中某一人情绪降至0时可以讲的最大笑话数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>又犯了经典错误之 <code>b -= min(b, c);   c -= min(b, c);</code>. </p><p>第一种类型直接加上</p><p>所以 ans += a</p><p>第二种类型和第三种类型交替使用. </p><p>所以 ans += min(b, c)</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价. </p><p>所以 ans += min(a + 1, b + c + d)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="type">int</span> ans = a;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="type">int</span> dec = <span class="built_in">min</span>(b, c);</span><br><span class="line">        ans += dec * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// b -= min(b, c);</span></span><br><span class="line">        <span class="comment">// c -= min(b, c);</span></span><br><span class="line">        b -= dec;</span><br><span class="line">        c -= dec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a, b, c, d)</span><br><span class="line">    <span class="comment">// 此时 bc与d的地位等价</span></span><br><span class="line">    ans += <span class="built_in">min</span>(a + <span class="number">1</span>, b + c + d);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort"><a href="#C-Min-Max-Sort" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个排列p, 每次可以选两个数x和y, 将两者较小的移到开头, 较大的移到</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价结尾.. </p><p>问排成增序所需最小操作次数.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先可以确定操作次数上限是n/2, 即(n/2, n/2+1)…(1, n).</p><p>接下来再看怎么样能少操作几次.</p><p>例子: 1 6 3 4 2 5. (3, 4)一开始就挨在一起了, 并且是(3, 4)而不是(4, 3), 所以可以省略掉这一步, 直接考虑(2, 5). 发现(2, 5)并不分别位于(2, 3)的左右两侧. 所以这一步是必不可少的操作</p><p>如果情况是 1 2 3 4 6 5, 那么(3, 4)和(2, 5)都可以省略了. 只需要做一次(1, 6)操作就行.</p><p>结论就是 (n/2, n/2+1) 在最中间, 然后n/2-1, n/2+2分别位于(n/2, n/2+1)左右两侧, 如果某对逆序了, 或者没有位于两侧, 那么接下来的操作都不能省略.</p><p>用pos记下每个数的位置, l, r记录上一对数对的位置(注意n为奇数的情况, 此时中间只有一个数, 所以l = r) 然后从中间开始枚举, 依次判断数对的相对位置就行.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];   a[i] --;</span><br><span class="line">        pos[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: </span></span><br><span class="line">    <span class="comment">// 0 1 2 3</span></span><br><span class="line">    <span class="comment">// 5: 2</span></span><br><span class="line">    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="type">int</span> ans = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = pos[n / <span class="number">2</span>], r = pos[n / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n / <span class="number">2</span>; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> v1 = (n - <span class="number">2</span>) / <span class="number">2</span> - i, v2 = n - <span class="number">1</span> - v1;</span><br><span class="line">        <span class="built_in">LOG</span>(v1, v2)</span><br><span class="line">        <span class="type">int</span> p1 = pos[v1], p2 = pos[v2];</span><br><span class="line">        <span class="keyword">if</span> (p1 &gt; p2 || !(p1 &lt;= l &amp;&amp; p2 &gt;= r)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = p1, r = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= i;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Fixed-Prefix-Permutations"><a href="#D-Fixed-Prefix-Permutations" class="headerlink" title="D. Fixed Prefix Permutations"></a><a href="https://codeforces.com/contest/1792/problem/D">D. Fixed Prefix Permutations</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 n 个 1<del>m 的排列a[1</del>n].</p><p>定义一个排列的分值为: 最大的满足 p1=1,p2=2,….,pk=k 的 k .</p><p>定义两个排列 p,q 的乘积 p×q=r 为 r[j]=q[p[j]].</p><p>对于每个排列a[i], 求出它乘以所有这 n 个排列a[j]能得到的最大分值.</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价. </p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>学习(偷)了日本大神maspy的Trie板子.</p><p>固定的a[i], 记为p. a[j], 记为q. r[i] = q[p[i]] = i</p><p>q[p[i]] = i. 两边同时取q^-1, 也就是取pos_q. </p><p>p[i] = pos_q[i] = i. 也就是找p[i]和所有pos_q[i]最长的公共前缀. 只需要把所有的pos_q建一个Trie. 然后每次查询p[i]时, 在pos_q中找最长公共前缀的长度就行. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector <span class="title">p</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(m))</span></span>;</span><br><span class="line">    <span class="function">vector <span class="title">pos</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(m))</span></span>;</span><br><span class="line">    Trie&lt;<span class="number">10</span>&gt; tr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; p[i][j];     p[i][j] --;</span><br><span class="line">            pos[i][p[i][j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tr.add&lt;vector&lt;<span class="type">int</span>&gt;&gt;(pos[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(pos[i])</span><br><span class="line">        <span class="type">int</span> cv = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">            cv = tr.TO[cv][p[i][j]];</span><br><span class="line">            <span class="built_in">LOG</span>(cv)</span><br><span class="line">            <span class="keyword">if</span> (cv == <span class="number">-1</span>)   <span class="keyword">break</span>;</span><br><span class="line">            ++ cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort-1"><a href="#C-Min-Max-Sort-1" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射.&lt;/p&gt;
&lt;p&gt;6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶. &lt;/p&gt;
&lt;h2 id=&quot;B-Stand-up-Co</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_字符串" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.16-01.29 (2023春节)</title>
    <link href="http://example.com/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/"/>
    <id>http://example.com/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/</id>
    <published>2023-01-23T16:00:00.000Z</published>
    <updated>2023-02-15T12:14:48.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-17-周四-大年廿八-阴"><a href="#01-17-周四-大年廿八-阴" class="headerlink" title="01.17 周四 大年廿八 阴"></a>01.17 周四 大年廿八 阴</h2><p>下午出发前往大旺, 傍晚到达. 晚上与大伯奶奶到早茶店吃饭. </p><h2 id="01-18-周五-大年廿九-晴"><a href="#01-18-周五-大年廿九-晴" class="headerlink" title="01.18 周五 大年廿九 晴"></a>01.18 周五 大年廿九 晴</h2><p>早上5点半起床. 六点钟到水岸与堂哥奶奶碰面. 奶奶和我们坐一辆车, 6点10分左右启程, 中途服务区休息一次. 11点多到达村口. 全程睡过来. </p><h2 id="01-21-周六-除夕-雨"><a href="#01-21-周六-除夕-雨" class="headerlink" title="01.21 周六 除夕 雨"></a>01.21 周六 除夕 雨</h2><p>晚上8点有Atcoder Beginner Contest 286. 由于长辈聊天的原因, 我迟到了20分钟, 还好我有先见之明, 提前unrated participation了. 开局到D还是很顺利的. E一眼n=300, 鉴定为Floyd, 但是我对Floyd松弛时的更新没有深刻的理解, 导致赛后3分钟才调出E的错误. 何为”最短路松弛的理解”? 其实就是在能够松弛时, 要采取无条件赋值, 而不是取max. 这点在最短路计数上也是一样, 只不过当时是 += , 而不是赋值, 所以我忽视了这点. </p><p>本来老爸让我一定要在益罗塘山上睡一晚, 好在他在蹭网回去时改变了主意. 零点赏完烟花后入睡. </p><h2 id="01-22-周日-新年初一-晴"><a href="#01-22-周日-新年初一-晴" class="headerlink" title="01.22 周日 新年初一 晴"></a>01.22 周日 新年初一 晴</h2><p>晚上8点有Atcoder Regular Contest 154. 考虑到昨天晚上我因为种种原因晚了20分钟才下山参加比赛, 于是今晚也是unrated participation了. 开局A题直接不会, 贪心思路很容易, 就是让俩数尽可能差的大, 主要是长度为1e5的俩数相乘取模这一点没想好. 搞了一个钟头才摸出来. 什么龟速乘, 忽略高位的数都出来了… 我果然是一急啥蠢事都干了. B题一开始看以为又是大聪明题. 但是分析了10分钟发现是可做的, WA了2发也是在半小时内搞出来了一个O(n)的做法. AB总共WA了5发, rk 1200+, 感觉还行, 至少不会掉分(要是A模数运算再熟练些会更好). 而且B题放我以前肯定是无法发现题目性质的. 可喜可贺, 希望在新的一年里思维上能有更大的进步!</p><h2 id="01-23-周一-新年初二-雨"><a href="#01-23-周一-新年初二-雨" class="headerlink" title="01.23 周一 新年初二 雨"></a>01.23 周一 新年初二 雨</h2><p>今天要跟奶奶去拜访舅公舅婆. 从恭上村到何家, 大概有20+分钟的车程. 只能说很尬, 那么多亲戚就没几个认识的. 所以我选择和堂哥在屋外聊天. 午饭和舅公一桌, 面对一桌的酸菜, 腌菜, 我TM直接干白饭. </p><p>晚上刷了会题, 刷不动了. 继续看了&lt;尸体派对&gt;第二集. 看了2集之后, 可能是我刚进军二次元不就, 接触的作品太少, 感觉这种恐怖重口题材的挺好看的, 也挺想买steam上的尸体派对几部作品, 奈何太贵, 等骨折了入手一波. </p><p>晚上堂哥又摆出烧烤架, 我蹭了一块鸡柳 + 一条烤肠, 上一次烧烤还是在高中的某次年级出游. </p><h2 id="01-24-周二-新年初三-晴"><a href="#01-24-周二-新年初三-晴" class="headerlink" title="01.24 周二 新年初三 晴"></a>01.24 周二 新年初三 晴</h2><p>晚上依然睡不好觉, 早上七点半起床, 开始收拾行李, 准备下山. 大约九点半时到达恭上村村口吃腌面. 饭后随堂哥驱车前往拜访南良叔. 路上得知南良叔之前的旧屋拆迁了, 据说补偿还不错. 路上被中国电信的捉急信号和高德地图的误导耽误了20分钟, 于10点半到达拜访. 寒暄过后, 11点从党溪村返回大旺, 全程500公里. 4点左右到达大旺. 到达后依然是与大伯奶奶聚餐, 饱餐一顿后送奶奶回家后便准备驱车返回广州. </p><p>返程较短, 所以我尝试开回来. 开了1小时多些, 平均时速块80, 高速上最高开到了120. 估摸着也快有1年没碰方向盘了, 感觉还行. </p><h2 id="01-25-周三-新年初四-晴"><a href="#01-25-周三-新年初四-晴" class="headerlink" title="01.25 周三 新年初四 晴"></a>01.25 周三 新年初四 晴</h2><p>白天在家刷题. 傍晚LY vx问我去不去看电影, 原来他今天回到广州. 于是就打算看8点场的&lt;流浪地球2&gt;. </p><p>本来没打算电影有多大的惊喜, 看了看前面的部分, 感觉有些镜头挺尬的. 刚开始注意到频繁出现的摄像头, 也不知道有啥用意. 直到片尾的彩蛋说550A才是策划一系列危机的幕后黑手, 我才有点懂了. 感觉550A可能就是通过摄像头学习了很多, 在逐月计划, 太空电梯那会的某个阶段产生了意识, 但是处于一种潜伏状态. 另外就是我对于”相控阵”和550A的初衷也是挺好奇的. 不过我认为&lt;流浪地球2&gt;似乎没有&lt;星际穿越&gt;那么难懂. </p><h2 id="01-26-周四-新年初五-晴"><a href="#01-26-周四-新年初五-晴" class="headerlink" title="01.26 周四 新年初五 晴"></a>01.26 周四 新年初五 晴</h2><p>白天在家刷题. 下午购物. </p><p>晚上刷到UP主&lt;那些无名之辈&gt;的动态<a href="https://www.bilibili.com/video/BV12G4y1D7V7/">最看天赋的专业之一：C9院校，同宿舍4个数学男，毕业7年后的生活现状</a>, C9数学专业毕业生生活现状. 1个米国top10计算机读博年收入42w, 1个瑞士读博年收入30+w, 1个学而思老师转广州竞赛教练年收入20+w, 1个本校物理读博年收入5w, 毕业offer60+w. 第三个好巧不巧刚好是竞赛教练, 还是广州的. 看来当前教培改革已经对这行造成了很大的影响. 本来心里最理想的职业看来也走不通了. 我认为这辈子是真的没有遇到真正热爱的东西, 直到大三正式入坑OI(CP / ACM). 大四上学期的最后几个月, 可能是我这辈子最后一次为自己热衷的东西不计代价地追寻付出了. 万幸的是上天眷顾, 我找到了优秀的队友, 也选对了赛站, 在我的XCPC最后一舞中收获了牌子. </p><p>之前一直在抱怨高中</p><h2 id="01-27-周五-新年初六-多云"><a href="#01-27-周五-新年初六-多云" class="headerlink" title="01.27 周五 新年初六 多云"></a>01.27 周五 新年初六 多云</h2><p>白天在家刷题. 下午购物</p><p>晚上有codeforces div3, 常规阴间时间. 本来还在想要不要打, 一看zwling已经报名了, 我也就报名了. 可以说是打得挺烂了. E题非得硬去分析二进制数位的性质, 结果还是得搞对拍. 整题搞了一个多小时, zwling说打表就行, 只花了10+min就搞定了. 妈的又是打表, 上次vp小白月赛的n(1e18)的模仿棋博弈也是没看出要打表. 不过由于cf号目前分段比较低, 所以rk1700+也+55. </p><h2 id="01-28-周六-新年初七-晴"><a href="#01-28-周六-新年初七-晴" class="headerlink" title="01.28 周六 新年初七 晴"></a>01.28 周六 新年初七 晴</h2><p>白天不想学习, 但是又找不到想玩的. </p><p>晚上有Atcoder Beginner Contest 287. 8点麻木地开打, 前两题签完到, C直接给我干趴下了. 判断一张图是不是一条<br>链, 我寻思着不是只用判断: “度1点数==2 &amp;&amp; 度2点==n-2 &amp;&amp; 边数==点数-1 “就行了嘛. 直接WA3发, 不过也不是第一次翻车了, 不就是经典codeforces经典卡div2 B嘛. 跳过C先做D, 一开始头脑发热又想不到, 不过好在冷静下来做出来了. 回过头看C, 我TM直接toposort总可以了吧, 于是就过了. 一看rk2000+, 如果不做出E翻盘, 那我的AT1200分青名计划就又要延期了. 看了E的题意, 涉及到前缀, “最大”长度, 我直接想到前缀数据结构Trie + 二分长度. 但是Trie的题也就acwing的模板题做过, 所以花了点时间先学, 把统计词频的代码改成了统计前缀词频, 就过了E. 结果rk1300+, 感觉还行, +21 to 1115. 此时还剩下30+分钟, F我想的是树上背包, 但是自知功力还未到. 所以直接开摆. </p><p>本来想早睡的, 但是睡前玩了会&lt;深岩银河&gt;, 又玩到12点半. </p><h2 id="01-28-周日-新年初八-晴"><a href="#01-28-周日-新年初八-晴" class="headerlink" title="01.28 周日 新年初八 晴"></a>01.28 周日 新年初八 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.24(2022春节初三)日晚22点 + 01.29</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-17-周四-大年廿八-阴&quot;&gt;&lt;a href=&quot;#01-17-周四-大年廿八-阴&quot; class=&quot;headerlink&quot; title=&quot;01.17 周四 大年廿八 阴&quot;&gt;&lt;/a&gt;01.17 周四 大年廿八 阴&lt;/h2&gt;&lt;p&gt;下午出发前往大旺, 傍晚到达. 晚上</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2023 01.09-01.15</title>
    <link href="http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/"/>
    <id>http://example.com/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-02-15T12:15:32.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-09-周一-小雨"><a href="#01-09-周一-小雨" class="headerlink" title="01.09 周一  小雨"></a>01.09 周一  小雨</h2><p>早上十点开始vp Educational Codeforces Round 141. 嗯, 只做了2题, 第二题经典构造矩阵, 做了一个多小时. 其实C题我也不会, 是一道关于最佳可能排名的贪心题. 贪心还是得多练, 正解是二分. D题dp, muggle用的记忆化搜索, 看了他的代码感觉记搜确实得熟练起来. </p><p>晚上八点20开始vp 小白月赛65. 表现依然糟糕, 只会3题. 并且这次的B题是考察字符串匹配, 其实暴力n^2就行. 我非得试着用双指针. 这也暴露出我对字符串匹配的理解误区. 要是真能双指针直接瞎搞, 那还要啥KMP呢? D题这种1e18的一眼结论题, 但是没想过打表, 比赛经验太差. 正解是”模仿棋”. E构造, F贪心 + 树形dp. </p><h2 id="01-10-周二-小雨"><a href="#01-10-周二-小雨" class="headerlink" title="01.10 周二  小雨"></a>01.10 周二  小雨</h2><p>早上补了昨晚的DEF. </p><p>下午晚上补了我第一场牛客比赛(小白月赛34)的所有题. 基本以dp为主, 然后还有一道经典 矩阵每行取数, 求前k大的题. 堆 + 合并行贪心. </p><h2 id="01-11-周三-中雨"><a href="#01-11-周三-中雨" class="headerlink" title="01.11 周三  中雨"></a>01.11 周三  中雨</h2><p>早上10点开始vp 843(div2). 可以算是形势逆转的一局, 虽然一开始经典卡B, 但是对拍调完C之后, 还是想出了B. 赛后发现C有1600分. </p><h2 id="01-12-周四-小雨"><a href="#01-12-周四-小雨" class="headerlink" title="01.12 周四  小雨"></a>01.12 周四  小雨</h2><p>考虑到18号要回大埔过年, 早上先花了点时间下番&lt;更衣人偶坠入爱河&gt;, 但是没有外挂弹幕, 告辞, 晚点再来. 9点40开始vp 839(div3). 表现垃圾. 只会3道. D是拆绝对值 + 约束答案范围. </p><p>中午看到2022南京终于上了cf gym. 看到了&lt;高数100&gt;, 看到了自己和队友们的名字. 在第一页尾部, 相信很快就会被vp的大佬们压下去.  </p><p>下午2点郑老师发来vx说给我发些奖励, 问我银行卡之类的信息. </p><h2 id="01-13-周五-阴"><a href="#01-13-周五-阴" class="headerlink" title="01.13 周五  阴"></a>01.13 周五  阴</h2><p>下午1点突然想看看2022南京的正解, 于是想到zwling之前说的dianhsu写的插件. 用这个插件可以在别人的submission中查看gym的代码. 之后我下了dls的A和D的代码, 然而题目都记不清了. </p><p>下午3点开组会, 和顾学长一起获得了三等奖金, 发了言. 和组里的大部分同学都不熟, 所以挺紧张的. </p><p>组会上我得知很多学长学姐都在2022年做出了A类工作. 心情十分复杂, 想搞科研, 但是心里有放不下CP. 可能是心愿还没有达成吧. 至于这个心愿, 我也不知道具体是个什么样的目标. </p><h2 id="01-14-周六-阴"><a href="#01-14-周六-阴" class="headerlink" title="01.14 周六  阴"></a>01.14 周六  阴</h2><p>vp 844(div1+2)</p><h2 id="01-15-周日-阴"><a href="#01-15-周日-阴" class="headerlink" title="01.15 周日  阴"></a>01.15 周日  阴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.21(2022除夕)日午12点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-09-周一-小雨&quot;&gt;&lt;a href=&quot;#01-09-周一-小雨&quot; class=&quot;headerlink&quot; title=&quot;01.09 周一  小雨&quot;&gt;&lt;/a&gt;01.09 周一  小雨&lt;/h2&gt;&lt;p&gt;早上十点开始vp Educational Codeforces </summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 89 A-D</title>
    <link href="http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/"/>
    <id>http://example.com/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-01-21T03:16:42.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-Practical-Skill-Test"><a href="#D-Practical-Skill-Test" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Practical-Skill-Test-1"><a href="#D-Practical-Skill-Test-1" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个h * w的矩阵a, 里面不重不漏地填充着[1, h * w]的数字. 现在给定一个正整数d ([1, h * w]), 并且给出q组询问: </p><blockquote><p>l, r</p><p>问: a[x1][y1] == l —&gt; a[x2][y2] == l + d —&gt; … —&gt; a[xn][yn] == r</p><p>这段路所走过的曼哈顿距离是多少</p></blockquote><blockquote><p>曼哈顿距离: (x1, y1)与(x2, y2)的曼哈顿距离是|x1 - x2| + |y1 - y2|</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="倍增-我的思路"><a href="#倍增-我的思路" class="headerlink" title="倍增 (我的思路)"></a>倍增 (我的思路)</h4><p>既然无法记录从每个点(a值==i)出发到[i+1, n]的所有距离, 那么就可以考虑倍增</p><p>to[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走到的点</p><p>dist[i][j]: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走过的路程</p><p>边界: to超出h * w的部分要特判0</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">to</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(h * w + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u + d &lt;= h * w; ++ u) &#123;</span><br><span class="line">        to[u][<span class="number">0</span>] = u + d;</span><br><span class="line">        dist[u][<span class="number">0</span>] = a2cor[u + d] - a2cor[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt; <span class="number">20</span>; ++ b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= h * w; ++ u) &#123;</span><br><span class="line">            to[u][b] = to[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">            dist[u][b] = dist[u][b - <span class="number">1</span>] + dist[to[u][b - <span class="number">1</span>]][b - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> binary_jump = [&amp;](<span class="type">int</span> S, <span class="type">int</span> T) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">19</span>; b &gt;= <span class="number">0</span>; -- b) <span class="keyword">if</span> (to[S][b] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to[S][b] &lt;= T) &#123;</span><br><span class="line">                ans += dist[S][b];</span><br><span class="line">                S = to[S][b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(S == T);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">binary_jump</span>(l, r) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前缀和-官方题解"><a href="#前缀和-官方题解" class="headerlink" title="前缀和 (官方题解)"></a>前缀和 (官方题解)</h4><p>pre[i] 表示a[i - kd] —&gt; a[i - (k-1)d] —&gt; a[i - d] —&gt; a[i] 的路程之和</p><p>pre[i] = pre[i - d] + dist(i - d, i)</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span> - (array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(h + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w + <span class="number">1</span>));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">a2cor</span>(h * w + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; ++ j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            a2cor[a[i][j]] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(h * w + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt;= h * w; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">4</span>] + (a2cor[i] - a2cor[i - <span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;  cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; pre[r] - pre[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-Practical-Skill-Test&quot;&gt;&lt;a href=&quot;#D-Practical-Skill-Test&quot; class=&quot;headerlink&quot; title=&quot;D - Practical Skill Test&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://a</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数据结构" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法_倍增" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D</title>
    <link href="http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/"/>
    <id>http://example.com/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/</id>
    <published>2023-01-16T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:50.353Z</updated>
    
    <content type="html"><![CDATA[<p>比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.</p><p>补题: D因式分解 + 枚举因子 + 压缩状态</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分别计算俩点向四个方向的墙面相连的距离, 求最小值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w, d, h;    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h;</span><br><span class="line">    <span class="type">int</span> a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> dist1 = <span class="built_in">min</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist2 = <span class="built_in">min</span>(b, g);</span><br><span class="line">    <span class="type">int</span> dist3 = w - <span class="built_in">max</span>(a, f);</span><br><span class="line">    <span class="type">int</span> dist4 = d - <span class="built_in">max</span>(b, g);</span><br><span class="line">    <span class="type">int</span> ans1 = <span class="number">2</span> * dist1 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans2 = <span class="number">2</span> * dist2 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans3 = <span class="number">2</span> * dist3 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans4 = <span class="number">2</span> * dist4 + <span class="built_in">abs</span>(a - f) + <span class="built_in">abs</span>(b - g) + h;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;ans1, ans2, ans3, ans4&#125;);</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Going-to-the-Cinema"><a href="#B-Going-to-the-Cinema" class="headerlink" title="B. Going to the Cinema"></a><a href="https://codeforces.com/contest/1782/problem/B">B. Going to the Cinema</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一: </p><ol><li>自己去,但除自己外去的人数 &lt; ai</li><li>自己不去,但除自己外去的人数&gt;= ai</li></ol><p>问有多少种选择去的人的集合的方案,使得没有人伤心.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>设去的人的集合A={p1,⋯,pa},不去的人的集合B={q1,⋯,qb},则A⋃B={1,⋯,n},a+b=n.​</p><ol><li>对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \geq \max_{1 \leq i\leq a} a_{p_i}$.​    </li><li>对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当<br>$a &lt; \min_{1\leq j\leq b} a_{q_j}$.</li></ol><p>枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1]</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + n + <span class="number">1</span>);</span><br><span class="line">    a[n + <span class="number">1</span>] = inf; a[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(a)</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; a[i] &amp;&amp; i &lt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++ ans;</span><br><span class="line">            <span class="built_in">LOG</span>(i, a[i], a[i + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Equal-Frequencies"><a href="#C-Equal-Frequencies" class="headerlink" title="C. Equal Frequencies"></a><a href="https://codeforces.com/contest/1782/problem/C">C. Equal Frequencies</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>称一个字符串是好的,如果每种字符出现的次数都相等. </p><p>n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t.</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n / seg</p><p>首先将字母按照cnt[26] (字母出现频数) 降序排序, 要<strong>尽最大可能利用现有的多的字母</strong></p><p>以下代码用来找到最小的代及cost其对应的ac</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">    <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">        mn_cost = now;          best_ac = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要统计<strong>cnt不足ac的部分</strong>就行了, 不足的部分肯定是需要其他redundant的来补充的. </p><p>aim[26]表示t中每个字母的目标次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">    aim[ord[i]] = best_ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来只需要看s[i]的cnt: </p><ol><li>cnt &gt;  aim[s[i]], 在26个字母中找cnt还不足aim的进行替换</li><li>cnt &lt;= aim[s[i]], 跳过</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s)   cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ord</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(<span class="built_in">all</span>(ord), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(ord), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt[a] &gt; cnt[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// d: n的因子, 作为每个字母的出现次数</span></span><br><span class="line">    <span class="type">int</span> mn_cost = n, best_ac = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= n; ++ d) <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, seg = n / d;</span><br><span class="line">        <span class="keyword">if</span> (seg &gt; <span class="number">26</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; mn_cost) &#123;</span><br><span class="line">            mn_cost = now;          best_ac = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> best_seg = n / best_ac;</span><br><span class="line">    <span class="built_in">LOG</span>(mn_cost, best_ac, best_seg)</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">aim</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; best_seg; ++ i) &#123;</span><br><span class="line">        aim[ord[i]] = best_ac;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(aim)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aim[ch - <span class="string">&#x27;a&#x27;</span>] &gt;= cnt[ch - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> to = <span class="number">0</span>; to &lt; <span class="number">26</span>; ++ to) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aim[to] &gt; cnt[to]) &#123;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">                ch = (<span class="type">char</span>)to + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Many-Perfect-Squares"><a href="#D-Many-Perfect-Squares" class="headerlink" title="D. Many Perfect Squares"></a><a href="https://codeforces.com/contest/1782/problem/D">D. Many Perfect Squares</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>非递减数组a<a href="1%E2%89%A4n%E2%89%A450">n</a>. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数. </p><p>例如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 13 22 90</span><br></pre></td></tr></table></figure><p>选择 x = 3</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4,9,16,25,93</span><br></pre></td></tr></table></figure><p>4,9,16,25,93<br>最多有4个完全平方数</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x. </p><p>先sort(all(a))</p><p>设有 $i &lt; j, a_i + x = va^2 ,a_j + x = vb^2$ </p><p>对完全平方数做差有$vb^2 - va^2 = (vb-va)(vb+va) = a_j + x - (a_i + x) = a_j - a_i$</p><p>令 diff = aj - ai</p><p>则 (vb - va)(vb + va) = diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d = diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x = va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x. </p><p>用dp[x] |= 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意. </p><p>最后统计一下每个x的二进制1个数就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> diff = a[j] - a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> div = <span class="number">1</span>; div * div &lt;= diff; ++ div) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff % div != <span class="number">0</span>)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> diva = div, divb = diff / div;</span><br><span class="line">                <span class="keyword">if</span> (diva % <span class="number">2</span> != divb % <span class="number">2</span>)     <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 12 = 2 * 6       va = 2, vb = 4    </span></span><br><span class="line">                <span class="comment">// x = va * va - a[i]</span></span><br><span class="line">                <span class="type">int</span> va = (divb - diva) / <span class="number">2</span>, vb = (diva + divb) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> x = va * va - a[i];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>)                      <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">LOG</span>(a[i], a[j], diff, va, vb)</span><br><span class="line">                dp[x] |= (<span class="number">1ll</span> &lt;&lt; i) | (<span class="number">1ll</span> &lt;&lt; j);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;        <span class="comment">// 只有1个数a, 肯定能找到x, 使得a+x是平方数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, val] : dp) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)<span class="built_in">popcountll</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.&lt;/p&gt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_实现" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%AE%9E%E7%8E%B0/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_暴力" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9A%B4%E5%8A%9B/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="算法_数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 134 A-F</title>
    <link href="http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/"/>
    <id>http://example.com/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/</id>
    <published>2023-01-14T16:00:00.000Z</published>
    <updated>2023-01-20T07:14:17.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="R2532橙题-F-Permutation-Oddness"><a href="#R2532橙题-F-Permutation-Oddness" class="headerlink" title="R2532橙题 F - Permutation Oddness"></a>R2532橙题 <a href="https://atcoder.jp/contests/abc134/tasks/abc134_f">F - Permutation Oddness</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>设 P = (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;=50)的排列. 定义Oddness:= $\sum |p_i - i|$. 求满足定义Oddness = k 的不同排列P的数量</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解.</p><p>这里以<a href="https://img.atcoder.jp/abc134/editorial.pdf">官方题解</a>为基础, 加以翻译并解释. </p><blockquote><p>若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K</p></blockquote><p>dp[i][j][k][l]=表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. </p><p>因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j=k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. </p><p>状态转移方程写作：<br>dp[i][j][k] = (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j]</p><p>当考虑第i个数与盒子的时候, 分5种情况: </p><blockquote><p>数i和盒子i直接配对, 未配对的依然是j个</p><p>但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j];</p></blockquote><blockquote><p>数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] += dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</p><p>未配对的数-1, 盒子数-1, 所以未配对的-1个. </p><p>当前状态j, 所以上一状态j+1</p><p>有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j + 1 &lt;= i) dp[i][j][k] += dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1);</p></blockquote><blockquote><p>数i和盒子i都不配对, 未配对的是j+1个</p><p>有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j &gt;= 1)     dp[i][j][k] += dp[i - 1][j - 1][k - 2 * j];</p></blockquote><p>注意, 可能情况个数要从上一状态出发考虑</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mint dp[N][N][N * N];    </span><br><span class="line"><span class="comment">// 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对</span></span><br><span class="line"><span class="comment">// 且 当前的奇异值为k的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * j; k &lt;= n * n; ++ k) &#123;</span><br><span class="line">                <span class="comment">// 数i和盒子i直接配对, 未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j];</span><br><span class="line">                <span class="comment">// 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</span></span><br><span class="line">                <span class="comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - <span class="number">2</span> * j] * j;</span><br><span class="line">                <span class="comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</span></span><br><span class="line">                <span class="comment">// 未配对的数-1, 盒子数-1, 所以未配对的-1个. </span></span><br><span class="line">                <span class="comment">// 当前状态j, 所以上一状态j+1</span></span><br><span class="line">                <span class="comment">// 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= i) dp[i][j][k] += dp[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">2</span> * j] * (j + <span class="number">1</span>) * (j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 数i和盒子i都不配对, 未配对的是j+1个</span></span><br><span class="line">                <span class="comment">// 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span>)     dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">2</span> * j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][<span class="number">0</span>][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;R2532橙题-F-Permutation-Oddness&quot;&gt;&lt;a href=&quot;#R2532橙题-F-Permutation-Oddness&quot; class=&quot;headerlink&quot; title=&quot;R2532橙题 F - Permutation Oddness&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 797 (Div. 3) A-G</title>
    <link href="http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/"/>
    <id>http://example.com/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/</id>
    <published>2023-01-13T16:00:00.000Z</published>
    <updated>2023-01-14T04:51:41.517Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. </p><p>补题: </p><h2 id="A-Print-a-Pedestal-Codeforces-logo"><a href="#A-Print-a-Pedestal-Codeforces-logo" class="headerlink" title="A. Print a Pedestal (Codeforces logo?)"></a><a href="https://codeforces.com/contest/1690/problem/A">A. Print a Pedestal (Codeforces logo?)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> d = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; d + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Array-Decrements"><a href="#B-Array-Decrements" class="headerlink" title="B. Array Decrements)"></a><a href="https://codeforces.com/contest/1690/problem/B">B. Array Decrements)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : b)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; d0, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> cd = b[i] - a[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            d0.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d.<span class="built_in">insert</span>(cd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d.size == 1</span></span><br><span class="line">    <span class="keyword">if</span> (*d0.<span class="built_in">begin</span>() &lt; *d.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Restoring-the-Duration-of-Tasks"><a href="#C-Restoring-the-Duration-of-Tasks" class="headerlink" title="C. Restoring the Duration of Tasks"></a><a href="https://codeforces.com/contest/1690/problem/C">C. Restoring the Duration of Tasks</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d = f - s<br>否则当前任务到来时间s &lt; 上个任务完成时间 d = f - f[i - 1]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span> ,<span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : f)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span>, f[<span class="number">0</span>] - s[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; f[i - <span class="number">1</span>])    ans.<span class="built_in">pb</span>(f[i] - s[i]);</span><br><span class="line">        <span class="keyword">else</span>                    ans.<span class="built_in">pb</span>(f[i] - f[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Black-and-White-Stripe"><a href="#D-Black-and-White-Stripe" class="headerlink" title="D. Black and White Stripe"></a><a href="https://codeforces.com/contest/1690/problem/D">D. Black and White Stripe</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    string s;   cin &gt;&gt; s;   s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = l + k - <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, r - l + <span class="number">1</span> - (pre[r] - pre[l - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Price-Maximization"><a href="#E-Price-Maximization" class="headerlink" title="E. Price Maximization"></a><a href="https://codeforces.com/contest/1690/problem/E">E. Price Maximization</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以<br>的和k, 求和最大是多少</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分. </p><p>把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;=k - x, 所以lower_bound一下k - x</p><p>也可以把a排序, 然后首尾双指针搞搞</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ans += x / k;</span><br><span class="line">        x %= k;</span><br><span class="line">        <span class="keyword">if</span> (x)  S.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (S.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> itx = S.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 先取值, 再删除? </span></span><br><span class="line">        <span class="type">int</span> x = *itx;</span><br><span class="line">        S.<span class="built_in">erase</span>(itx);</span><br><span class="line">        <span class="keyword">auto</span> ity = S.<span class="built_in">lower_bound</span>(k - x);</span><br><span class="line">        <span class="keyword">if</span> (ity != S.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> y = *ity;</span><br><span class="line">            ans ++;</span><br><span class="line">            S.<span class="built_in">erase</span>(ity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Shifting-String"><a href="#F-Shifting-String" class="headerlink" title="F. Shifting String"></a><a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \sqrt{n})$</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;      cin &gt;&gt; n;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        x --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (st[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> now = i;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; loop;</span><br><span class="line">        <span class="keyword">for</span> (; st[now] == <span class="number">-1</span>; now = p[now]) &#123;</span><br><span class="line">            loop.<span class="built_in">pb</span>(now);</span><br><span class="line">            st[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(loop)</span><br><span class="line">        deque&lt;<span class="type">char</span>&gt; dq0, dq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : loop) dq0.<span class="built_in">pb</span>(s[p]);</span><br><span class="line">        dq.<span class="built_in">assign</span>(<span class="built_in">all</span>(dq0));</span><br><span class="line">        <span class="type">int</span> cl = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (;cl &lt; loop.<span class="built_in">size</span>(); ++ cl) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = dq.<span class="built_in">back</span>(); dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            dq.<span class="built_in">push_front</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (dq == dq0) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len.<span class="built_in">pb</span>(cl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : len) &#123;</span><br><span class="line">        ans = <span class="built_in">lcm</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Count-the-Trains"><a href="#G-Count-the-Trains" class="headerlink" title="G. Count the Trains"></a><a href="https://codeforces.com/contest/1690/problem/G">G. Count the Trains</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少</p><p>例如[10, 13, 5, 2, 6] =&gt; [10, 10, 5, 2, 2] 一共有3种不同的数</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>维护每段火车的车头位置和整节车的速度. </p><p>在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车</p><p>如果速度x &gt;= 左边的火车段的速度, 就直接把it合并到左边(erase掉it)</p><p>如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)).</p><p>insert和erase的次数不会超过O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> i, <span class="type">int</span> x) &#123;</span><br><span class="line">        mp[i] = x;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(i);       <span class="comment">// 根据键key查找</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5    ---&gt; 9 10 | 5</span></span><br><span class="line">        <span class="keyword">if</span> (it != mp.<span class="built_in">begin</span>() &amp;&amp; <span class="built_in">prev</span>(it)-&gt;second &lt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9 | 5 | 3 | 1  ---&gt; 9 | 2 5 3 | 1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">next</span>(it) != mp.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it)-&gt;second &gt;= x) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(<span class="built_in">next</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k, d;   cin &gt;&gt; k &gt;&gt; d;      k --;</span><br><span class="line">        a[k] -= d;</span><br><span class="line">        <span class="built_in">add</span>(k, a[k]);</span><br><span class="line">        cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上. &lt;/p&gt;
</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_组合数学" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_双指针" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>年记 - 2022</title>
    <link href="http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/"/>
    <id>http://example.com/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/</id>
    <published>2023-01-12T16:00:00.000Z</published>
    <updated>2023-01-13T08:13:08.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-年终总结"><a href="#2022-年终总结" class="headerlink" title="2022 年终总结"></a>2022 年终总结</h1><p>刘城君</p><hr><h1 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h1><p>开始图划分的任务: 基于标签传播思想, 优化目标主要是复制因子RF. </p><p>随机初始化种子节点的tag, 多轮多源BFS的方式进行tag, 选取邻居最多的tag进行标记. </p><p>1度点优化. 1度点对RF没有影响</p><p>tag合并(按照tag规模/tag结点重合度). 但由于块数与节点数的数量关系限制, 效果不佳.</p><p>每个一次assign多个tag(一次性覆盖)</p><p>由于传播方式存在问题, 因此负载均衡很差. </p><hr><h1 id="9月-11月"><a href="#9月-11月" class="headerlink" title="9月 - 11月"></a>9月 - 11月</h1><p>期间阅读了HEP, NE等论文, 了解到Local search的策略, 以及分区boundary节点度数分布对RF的影响. 同时再次阅读了NE的源码. </p><p>为了优化负载均衡, 尝试在初始阶段就用BFS确定分区大致分布, 此阶段可以保障tag平衡. 第二阶段加入tag约束, 进行剩余节点的tag assignment. </p><p>效果较5月版本有明显进步, 数据集Lj上的表现(-p 8)为: RF=1.66-1.71 Balance = 1.05. 已经优于除NE外的其他算法. 但距离NE的1.33, 1.00仍有较大差距</p><hr><h1 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h1><p>分析RF和Tag的分区交界处节点的度数分布, 发现RF 2/3度点数量基本没有. </p><p>尝试将初始块变得更加紧密: 选k-core作为初始块. 效果一般</p><p>11月版本中第二阶段传播顺序诡异, 并且存在传播失败的可能. </p><p>尝试由当前的按照节点id顺序被动传播改成按照&lt;节点|tag|, 负载均衡, 节点度数&gt;的优先级进行BFS主动传播. 效果不如11月版本</p><hr><h1 id="1月-现在"><a href="#1月-现在" class="headerlink" title="1月 - 现在"></a>1月 - 现在</h1><p>修改第一阶段BFS的策略, 加入启发式策略: 优先扩展与Core紧密的节点. </p><p>基于NE的代码进行实现, 并且尝试两种版本: </p><blockquote><p>优先扩展与Core紧密的节点: RF: 1.7+, Balance: 1.00</p><p>优先扩展与Core+Boundary紧密的节点: 本质上就是NE, RF效果与NE十分接近</p></blockquote><p>在修改NE代码过程中, 意识到初始分区只分配p-1块, 最后1块分配p, 从而取消第二阶段的传播. 效果可能会优于当前版本</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>idea储备不足: 阅读更多相关论文</p><p>争取在RF / 实际任务效果上取得进展</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-年终总结&quot;&gt;&lt;a href=&quot;#2022-年终总结&quot; class=&quot;headerlink&quot; title=&quot;2022 年终总结&quot;&gt;&lt;/a&gt;2022 年终总结&lt;/h1&gt;&lt;p&gt;刘城君&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;5月&quot;&gt;&lt;a href=&quot;#5月&quot; cla</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 839 (Div. 3) A-G</title>
    <link href="http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/"/>
    <id>http://example.com/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-02-02T08:01:05.678Z</updated>
    
    <content type="html"><![CDATA[<p>上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. </p><p>补题: D题要从题目限制的不等式去推出x的范围. F题发掘性质: 可染色的块一定是递减的. </p><h2 id="C-Different-Differences"><a href="#C-Different-Differences" class="headerlink" title="C. Different Differences"></a><a href="https://codeforces.com/contest/1772/problem/C">C. Different Differences</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Absolute-Sorting"><a href="#D-Absolute-Sorting" class="headerlink" title="D. Absolute Sorting"></a><a href="https://codeforces.com/contest/1772/problem/D">D. Absolute Sorting</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>a[n], 询问是否存在一个数x, a[i] &lt;- |a[i] - x|, 形成非单调递减序列, 如果不存在输出-1</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>假设找到了一个x满足题意. 那么就有|a[i] - x| &lt;= |a[i+1] - x|. </p><p>两边平方: $(a[i] - x)^2 \leq (a[i+1] - x)^2$<br>因式分解: $(a[i] - a[i+1])(a[i] + a[i+1] - 2x) \leq 0$</p><p>接下来逐个判断a[i] - a[i+1], 分类讨论: </p><blockquote><p>a[i] - a[i+1] &gt; 0: a[i] + a[i+1] - 2x &lt;= 0<br>a[i] - a[i+1] &lt; 0: a[i] + a[i+1] - 2x &gt;= 0</p></blockquote><p>即可得到x的范围</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> mx = (<span class="type">int</span>)<span class="number">2e9</span>, mn = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// (x - y)(x + y - 2x) &lt;= 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], y = a[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;    <span class="comment">// (x + y - 2x) &lt; 0</span></span><br><span class="line">            mn = <span class="built_in">max</span>(mn, x + y + <span class="number">1</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; y) &#123;   <span class="comment">// (x + y - 2x) &gt; 0</span></span><br><span class="line">            mx = <span class="built_in">min</span>(mx, x + y &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;      <span class="comment">// x没有要求</span></span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mn &lt;= mx) &#123;</span><br><span class="line">        cout &lt;&lt; mn &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Permutation-Game"><a href="#E-Permutation-Game" class="headerlink" title="E. Permutation Game"></a><a href="https://codeforces.com/contest/1772/problem/E">E. Permutation Game</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>题意, 在一个序列p中, AB两人轮流操作, 每次的操作选择</p><ol><li>将p中的某个数变为可调换位置的(涂色)</li><li>重新排列, 但只能调动可变换位置的</li><li>跳过回合</li></ol><p>如果最后形成上升序列甲赢, 递减序列乙赢, 否则平局</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><p>A要涂色的: p[3], p[4]<br>B要涂色的: p[3], p[4], p[1], p[2]</p><p>AB俩人都要涂色的: p[3], p[4]<br>只属于A自己要涂色的: 没有<br>只属于B自己要涂色的: p[1], p[2]</p><p>如果A把只有自己要涂色的(a)+公共涂色的都涂完了(c), B还剩下没涂, A就赢了<br>如果B把只有自己要涂色的(b)+公共涂色的都涂完了(c), A还剩下没涂, B就赢了</p><p>但是要注意A是先手, 所以就算AB同时涂完(b+c==a), 也算A赢. 其他都是平局, 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : p) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        x --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == i) &#123;</span><br><span class="line">            ++ b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[i] == n - i - <span class="number">1</span>) &#123;</span><br><span class="line">            ++ a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++ c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(a, b, c)</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b + c) &#123;    <span class="comment">// b先翻完. 如果相等的话, 后手染色完, 下一轮到先手, 先手就直接排序了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Second&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= a + c) &#123;   <span class="comment">// a先翻完, 由于a先手, 同时ab翻完也不行</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tie&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Copy-of-a-Copy-of-a-Copy"><a href="#F-Copy-of-a-Copy-of-a-Copy" class="headerlink" title="F. Copy of a Copy of a Copy"></a><a href="https://codeforces.com/contest/1772/problem/F">F. Copy of a Copy of a Copy</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个n行m列的01矩阵 (3≤n,m≤30). 其中0表示白色, 1表示黑色. 每次你可以选择以下操作的中的一个:</p><ol><li>选择一个不是边界的点 (i,j)(i≠1,i≠n,j≠1,j≠m), 并且他的上下左右的4个点, 其颜色都与之相反, 则把这个点变成相反的颜色. </li><li>创建一个当前矩阵的拷贝. </li></ol><p>执行了 k(k≤100)次拷贝操作. 现在给出制作的所有 k 个拷贝. 此外, 还有初始的矩阵.  然而, 所有k+1个矩阵的顺序被打乱了. 因为找出初始版本, 并且输出经过了哪些操作. </p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>一旦对某个单元格涂色, 就再也不能重新涂色了. 这是因为不能对它的邻居也重新涂色, 因为它们中的每一个都有至少一个相同颜色的邻居——这个单元格本身</p><p>这给了我们副本的顺序. 只需按照当前可以进行的重新涂色操作数量的降序对它们进行排序即可. 如果数字相同, 则副本必须相等, 因此它们的顺序无关紧要. </p><p>排序后, 考虑一对相邻图片的所有不同单元格. 不可能有两个不同的单元格彼此相邻. 因此, 任何操作都不能干扰另一个操作. 所以制作副本的时候, 随便顺序操作就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    ++ k;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&gt; <span class="built_in">a</span>(k + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(m)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= k; ++ id) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">                cin &gt;&gt; a[id][i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">cnt</span>(k + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">1</span>; id &lt;= k; ++ id) &#123;</span><br><span class="line">        cnt[id][<span class="number">1</span>] = id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">auto</span> cc = a[id][i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; ++ dir) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> nc = a[id][i + dx[dir]][j + dy[dir]];</span><br><span class="line">                    diff += (cc != nc);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[id][<span class="number">0</span>] += (diff == <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// LOG(cnt)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">begin</span>(cnt) + <span class="number">1</span>, <span class="built_in">end</span>(cnt), greater&lt;array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt;());</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> g0 = a[cnt[i - <span class="number">1</span>][<span class="number">1</span>]], g1 = a[cnt[i][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; m; ++ l) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g0[j][l] != g1[j][l]) &#123;</span><br><span class="line">                    ans.<span class="built_in">pb</span>(&#123;j, l&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pb</span>(&#123;<span class="number">-1</span>, cnt[i][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : ans) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Gaining-Rating"><a href="#G-Gaining-Rating" class="headerlink" title="G. Gaining Rating"></a><a href="https://codeforces.com/contest/1772/problem/G">G. Gaining Rating</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>你在一个网站上下棋 , 初始你的等级为$x(x \le 10^{12})$ , 你想要升级到 y$(x &lt; y \le 10^{12})$你有$n(n \le 2 * 10^5)$个对手, 第i个队友的等级为 a[i]$(a[i] \le 10^{12})$ . 你需要与这些对手对战, 如果你的等级大于等于对手的等级, 你将获胜, 并且等级加1. 否则等级减1. </p><p>注意, 对手的等级不会发生变化. </p><p>为了防止你一直打最低等级的对手的, 网站有一个规定. 如果你要与对手 i 对战, 则应该没有其他对手 j, 使得你与 i 的比赛次数多于与 j 的比赛次数. 问你需要打多少局, 才能升到等级y, 如果不能输出-1. </p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>要想rating++, 肯定是先跟a[i]小于自己x的人先打, rating打上去了, 再找之前打不过的复仇, 从他们身上赚rating. 所以要先按照a升序排序. </p><p>先判断最开始一轮, rating能不能有所长进, 如果不能, 那就不行</p><p>算完第一轮的长进change之后, 开始逐个找之前打不过的人a[i]. 自己需要加win_t轮change, 最后第win_t + 1轮到达a[i]面前时, 我已经有了x + win_t * change + i的rating. 即 $x + win_t * change + i \geq a[i]$. 取个ceil就可以算出复仇a[i]的轮数了</p><p>但是有可能在打败a[i]之前, 就已经达到了y的目标, 所以要算出suc_t = ceil(y - x - i, change). 如果win_t &gt;= suc_t, 就要进入最后一轮, 直到x&gt;=y. </p><p>直到最后全部a都能击败后, 直接随便挑对手就行了. 即ans += y - x(当前的rating)</p><p>注意上述的x, change和ans都是会实时更新的</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y;  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>; <span class="comment">// b: 是否可以击败i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;   <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    <span class="type">int</span> change = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= a[i])  ++ x, ++ change, ++ ans, b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>            -- x, -- change, ++ ans, b[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= y)     &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (change &lt;= <span class="number">0</span>)    &#123;cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">auto</span> ceil = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="keyword">if</span> (b[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// x + win_t * change + i &gt;= a[i]</span></span><br><span class="line">        <span class="comment">// (a[i] - x - i) / change &lt;= win_t</span></span><br><span class="line">        <span class="type">int</span> <span class="type">win_t</span> = <span class="built_in">ceil</span>(a[i] - x - i, change);</span><br><span class="line">        <span class="comment">// x + suc_t * change + i &gt;= y</span></span><br><span class="line">        <span class="comment">// (y - x - i) / change &lt;= suc_t</span></span><br><span class="line">        <span class="type">int</span> <span class="type">suc_t</span> = <span class="built_in">ceil</span>(y - x - i, change);</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">win_t</span> &gt;= <span class="type">suc_t</span>) &#123;</span><br><span class="line">            ans += <span class="type">suc_t</span> * n;</span><br><span class="line">            x += <span class="type">suc_t</span> * change;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= a[j])  ++ x, ++ ans;</span><br><span class="line">                <span class="keyword">else</span>            -- x, ++ ans;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="keyword">return</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="type">win_t</span> * n;</span><br><span class="line">        x += <span class="type">win_t</span> * change;</span><br><span class="line">        b[i] = <span class="number">1</span>;</span><br><span class="line">        change += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(ans)</span><br><span class="line">    cout &lt;&lt; ans + y - x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢. &lt;/p&gt;
&lt;p&gt;补题:</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 685 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-14T04:52:30.069Z</updated>
    
    <content type="html"><![CDATA[<p>做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了</p><h2 id="C-String-Equality"><a href="#C-String-Equality" class="headerlink" title="C. String Equality"></a><a href="https://codeforces.com/contest/1451/problem/C">C. String Equality</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给两个字符串a和b, 问a能不能通过无限次操作到b.</p><p>第一种操作, 相邻交换字符: </p><p>第二种操作, 选取区间长度为k的子串,而且子串中的字母都 &lt;’z’, 每一个字母都加一（比如S0=’a’ 操作后,S0=’b’) </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D-Circle-Game"><a href="#D-Circle-Game" class="headerlink" title="D. Circle Game"></a><a href="https://codeforces.com/contest/1451/problem/D">D. Circle Game</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一个d和R,A和B轮流操作, 从(0,0)开始移动, 可以选择 x+=d 或者 y+=d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候, 那个人就输了</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-Bitwise-Queries-Hard-Version"><a href="#E-Bitwise-Queries-Hard-Version" class="headerlink" title="E. Bitwise Queries (Hard Version)"></a><a href="https://codeforces.com/contest/1451/problem/E2">E. Bitwise Queries (Hard Version)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 n 的数组(n 是 2 的幂) , 有 3 种操作, AND OR XOR, 可以获得数组两个元素的 AND OR XOR 值, 仅限 n+1 次操作求原数组</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先考虑以 $a_1$ 为基准求出 $a_1 \oplus a_k$, 这样只要求出 $a_1$ 就可以求出整个数组, 这一步需要 $n-1$ 次操作. </p><p>因为只有 $n$ 个元素, 元素的范围是 $[0,n-1]$, 所以可以进行分类讨论：</p><p>1.所有元素并不是互不相同. 也就是说有重复的元素, 这样只要找到相同的元素, 对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值）, 又因为知道了所有元素和 $a_1$ 的 XOR, 所以可以直接算出整个数组. 考虑如何找到相同的元素, 可以开个桶记录每个元素出现的次数. 取最大的出现次数（这种情况下至少两次）, 然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素, 任意取两个询问 AND 就可以了. 不过这里有个要注意的, 如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素, 取 $1$ 询问即可. </p><p>2.所有元素互不相同. 也就是是 $[0,n-1]$ 的全排列. 考虑 XOR 的性质, 相同就是 $0$, 也就是说可以选择 $1$ 这个数, 只有最后一位是 $1$, 其他都是 $0$, 也就是说如果 $a_1\oplus a_k=1$, $a_1$ 和 $a_k$ 只有最后一位不一样, 可以通过 AND 操作求出前 $\log n-1$ 位. 同理如果 $a_1\oplus a_k=\frac n2$, $a_1$ 和 $a_k$ 只有第一位不一样, 可以通过 AND 操作求出后 $\log n-1$ 位. 把两个结果组合一下（直接或起来）就可以得到 $a_1$. 其实不一定要选择 $1$ 和 $\frac n2$, 只要保证这两个数二进制下每位都至少有个数是 $0$ 就行. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AND</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;AND &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">XOR</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;XOR &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res;    cin &gt;&gt; res;     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xr</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  cnt[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        xr[i] = <span class="built_in">XOR</span>(<span class="number">1</span>, i);</span><br><span class="line">        cnt[xr[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a1, mx_show_xr = <span class="built_in">max_element</span>(<span class="built_in">all</span>(cnt)) - cnt.<span class="built_in">begin</span>(); <span class="comment">// mx_show_xr: 出现最多的xr值</span></span><br><span class="line">    <span class="keyword">if</span> (cnt[mx_show_xr] &gt; <span class="number">1</span>) &#123;        <span class="comment">// n个数中有重复的</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dulplicate_pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123; </span><br><span class="line">            <span class="comment">// if (cnt[xr[i]] == cnt[mx_show_xr]) &#123;         // X!!! cnt一致的xr值可能有多个!!!</span></span><br><span class="line">            <span class="keyword">if</span> (xr[i] == mx_show_xr) &#123;</span><br><span class="line">                dulplicate_pos.<span class="built_in">pb</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(dulplicate_pos)</span><br><span class="line">        <span class="comment">// assert(dulplicate_pos.size() &gt; 1);</span></span><br><span class="line">        <span class="type">int</span> a_dulplicate;</span><br><span class="line">        <span class="keyword">if</span> (dulplicate_pos.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(<span class="number">1</span>, dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a_dulplicate = <span class="built_in">AND</span>(dulplicate_pos.<span class="built_in">front</span>(), dulplicate_pos.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        a1 = a_dulplicate ^ mx_show_xr;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// n个数无重复, 就是[0, n-1]的全排列 </span></span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), <span class="number">1</span>) - xr.<span class="built_in">begin</span>();         <span class="comment">// a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同</span></span><br><span class="line">        <span class="type">int</span> py = <span class="built_in">find</span>(<span class="built_in">all</span>(xr), n / <span class="number">2</span>) - xr.<span class="built_in">begin</span>();</span><br><span class="line">        a1 = <span class="built_in">AND</span>(<span class="number">1</span>, px) | <span class="built_in">AND</span>(<span class="number">1</span>, py);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了&lt;/p&gt;
&lt;h2 id=&quot;C-String-Equality&quot;&gt;&lt;a href=&quot;#C-String-Equality&quot; class=&quot;headerlink&quot; title=&quot;C. String Equ</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>题解 - Codeforces Round 843 (Div. 2) A-E</title>
    <link href="http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/"/>
    <id>http://example.com/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-01-21T04:28:02.707Z</updated>
    
    <content type="html"><![CDATA[<p>次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.</p><p>补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题</p><h2 id="A-Gardener-and-the-Capybaras"><a href="#A-Gardener-and-the-Capybaras" class="headerlink" title="A. Gardener and the Capybaras"></a><a href="https://codeforces.com/contest/1775/problem/A2">A. Gardener and the Capybaras</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将仅包含a和b的字符串s分成三部分s=s1+s2+s3, 使得s2是这三个部分的一个最值（最大值或最小值, 按字典序比较）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;=s3</p><p>s2为min: 直接拿一个a就行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;   cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">substr</span>(i + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aaaabaaab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>  &lt;&lt; s.<span class="built_in">substr</span>(i, n - i - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a><a href="https://codeforces.com/contest/1775/problem/B">B. Gardener and the Array</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>记 f(a) 是 a 数组中, 所有数的按位或. </p><p>现有 n 个数 c1,c2…cn组成的数组, 询问是否有两个不同的子数组 a 和 b , 使得 f(a)=f(b)</p><p>数据保证所有数的二进制中 1 的数量之和不超过$10^5$</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci | cj | ck) = f(cj | ck). 如下样例:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2 4</span><br><span class="line">2 2 3</span><br><span class="line">4 3 4 </span><br></pre></td></tr></table></figure><p>ci: 2 3</p><p>cj: 1 2 4</p><p>ck: 3 4</p><p>所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(n);</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; cnt(200000 + 10, 0);</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> k;  cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">            <span class="type">int</span> x;  cin &gt;&gt; x;</span><br><span class="line">            c[i].<span class="built_in">pb</span>(x);</span><br><span class="line">            cnt[x] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort(all(c[i]));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;v = c[i];</span><br><span class="line">        <span class="type">bool</span> suc = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">            suc &amp;= (cnt[x] &gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suc) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Interesting-Sequence"><a href="#C-Interesting-Sequence" class="headerlink" title="C. Interesting Sequence"></a><a href="https://codeforces.com/contest/1775/problem/C">C. Interesting Sequence</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于n, 求最小的m, 使得 n&amp;(n+1)&amp;…&amp;m = x</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>获取x的二进制长度: floor(log2(x)) + 1</strong></p><p>每一二进制位上, 只可能从无0变成有0<br>所以x只可能是n的二进制子集<br>某一二进制位经历从1变成0, 全部低位肯定全部经历过全0<br>所以: x只能保留n高位1的子集<br>他的高一位也要经历翻转<br>所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行<br>注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行</p><p>n: 0000110111100000101 101101011001110100111011001000000000000000000<br>x: 0000110111100000101 000000000000000000000000000000000000000000000<br>ans: -1 (公共前缀最后一位是1)</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000000000000000000000000000000000000000000000<br>ans: 000011011110000011</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000010000000000000000000000000000000000000000<br>ans: -1 (mask &amp; x != x)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) &#123;        <span class="comment">// &amp; 只会变小</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> bit = <span class="built_in">floor</span>(<span class="built_in">log2</span>(n)) + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; (<span class="number">1ll</span> &lt;&lt; bit) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">62</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b &gt;= <span class="number">0</span>; -- b) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; b &amp; <span class="number">1</span>) == (n &gt;&gt; b &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            mask |= (<span class="type">int</span>)(x &gt;&gt; b &amp; <span class="number">1</span>) &lt;&lt; b;</span><br><span class="line">            last = (x &gt;&gt; b &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((n &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; (x &gt;&gt; b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;  </span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="number">1</span> || (mask &amp; x) != x) &#123;            <span class="comment">// 1011 -&gt; 1010</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后1个1的位置</span></span><br><span class="line">    b += <span class="number">1</span>;</span><br><span class="line">    mask |= <span class="number">1ll</span> &lt;&lt; (b);</span><br><span class="line">    cout &lt;&lt; mask &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上对拍数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span>  </span>&#123;<span class="keyword">return</span> <span class="built_in">mrand</span>() % x + <span class="number">1</span>; &#125;   <span class="comment">// [1, x]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    vector pw&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rnd</span>(<span class="number">1000</span>), b = pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>] + pw[<span class="built_in">rnd</span>(pw.<span class="built_in">size</span>()) - <span class="number">1</span>];</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Friendly-Spiders"><a href="#D-Friendly-Spiders" class="headerlink" title="D. Friendly Spiders"></a><a href="https://codeforces.com/contest/1775/problem/D">D. Friendly Spiders</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边. 请找到 s 和 t 的最短路径. $1\le n, a_i\le 3\times 10^5$</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>边权01 -&gt; 01bfs</p><p>建图问题:</p><ul><li>每一次遇到一个数时, 即使它只有一条边, 我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图</li><li>图的边数很多, 没有办法快速求解</li></ul><p>从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n</p><p>最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \sqrt{n})$. bfs复杂度$O(n + n \sqrt{n})$</p><p>坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建.</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v2id</span>(<span class="number">300000</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v2id[x].<span class="built_in">pb</span>(++ idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; <span class="built_in">g</span>(<span class="number">600000</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_p</span><span class="params">(<span class="number">300000</span> + <span class="number">10</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">300000</span>; ++ i) &#123;</span><br><span class="line">        <span class="comment">// if (st[i])      continue;</span></span><br><span class="line">        <span class="keyword">if</span> (!is_p[i])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 2, 4, 6, 8, 10...之间连边 打电话式建图n^2</span></span><br><span class="line">        <span class="comment">// 交换机式建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= <span class="number">300000</span>; j += i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j != i)     is_p[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v2id[j].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> uid : v2id[j]) &#123;</span><br><span class="line">                    g[uid].<span class="built_in">pb</span>(&#123;i + <span class="number">300000</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                    g[i + <span class="number">300000</span>].<span class="built_in">pb</span>(&#123;uid, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dq;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, inf)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(<span class="number">600000</span> + <span class="number">10</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;                        dq.<span class="built_in">pb</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (dq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = dq.<span class="built_in">front</span>();     dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cv == t) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : g[cv]) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(cv, nv, w)</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &gt; dist[cv] + w) &#123;</span><br><span class="line">                dist[nv] = dist[cv] + w;</span><br><span class="line">                pre[nv] = cv;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">                    dq.<span class="built_in">pb</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.<span class="built_in">push_front</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(dist[t])</span><br><span class="line">    <span class="keyword">if</span> (dist[t] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> now = t;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">while</span> (now != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt;= <span class="number">300000</span>) &#123;</span><br><span class="line">            path.<span class="built_in">pb</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        now = pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(path));</span><br><span class="line">    <span class="built_in">LOG</span>(path)</span><br><span class="line">    cout &lt;&lt; path.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> u : path) cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-The-Human-Equation"><a href="#E-The-Human-Equation" class="headerlink" title="E. The Human Equation"></a><a href="https://codeforces.com/contest/1775/problem/E">E. The Human Equation</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给一个序列a[n] (n&lt;=2e5), 要通过下面的两种操作, 最终全部变成0, 最少需要操作几次</p><blockquote><p>操作1: 选a的一个子序列, 然后子序列奇数位+1, 偶数位-1<br>操作2: 选a的一个子序列, 然后子序列奇数位-1, 偶数位+1</p></blockquote><p>如[1,4,2,8,5,7,3,6,9] -&gt; [4,2,5,6]用操作1<br>-&gt; [1,5,1,8,6,7,3,5,9]</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>pre[n]: a[n]的前缀和数组</p><p>a[i] + 1, a[j] - 1 相当于pre[i ~ j - 1] + 1<br>a[3] + 1, a[4] - 1 相当于pre[3] + 1<br>a[3] + 1, a[5] - 1 相当于pre[3 ~ 4] + 1</p><p>最终状态: pre全部为0</p><p>所以一次操作, 可以把pre上任何位置上的数+1 / -1</p><p>只需要记录前缀和中的mn和mx, 答案分类讨论下就行</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cs = <span class="number">0</span>, mx = <span class="number">-2e9</span>, mn = <span class="number">2e9</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cs += a[i];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, cs);</span><br><span class="line">        mn = <span class="built_in">min</span>(mn, cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx &lt; <span class="number">0</span>)         ans = <span class="built_in">abs</span>(mn);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mn &gt; <span class="number">0</span>)    ans = <span class="built_in">abs</span>(mx);</span><br><span class="line">    <span class="keyword">else</span>                ans = mx - mn;</span><br><span class="line">    <span class="built_in">LOG</span>(ans, mn, mx)</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.&lt;/p&gt;
&lt;p&gt;补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_数论" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA/"/>
    
    <category term="算法_贪心" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_位运算" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛65 A-F</title>
    <link href="http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/"/>
    <id>http://example.com/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/</id>
    <published>2023-01-08T16:00:00.000Z</published>
    <updated>2023-01-14T11:49:48.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-牛牛写情书"><a href="#B-牛牛写情书" class="headerlink" title="B - 牛牛写情书"></a><a href="https://ac.nowcoder.com/acm/contest/49888/B">B - 牛牛写情书</a></h2><h3 id="题意-分析"><a href="#题意-分析" class="headerlink" title="题意 + 分析"></a>题意 + 分析</h3><p>判断模式串T是否是给定串S的子串.<br>瞎写双指针      X<br>KMP / 双哈希            V<br>5e3: 直接substr暴力$n^2$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string os, k;    cin &gt;&gt; os &gt;&gt; k;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(os[i])) &#123;</span><br><span class="line">            s.<span class="built_in">pb</span>(os[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(s)</span><br><span class="line">    n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + m - <span class="number">1</span> &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">substr</span>(i, m) == k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-牛牛排队伍"><a href="#C-牛牛排队伍" class="headerlink" title="C - 牛牛排队伍"></a><a href="https://ac.nowcoder.com/acm/contest/49888/C">C - 牛牛排队伍</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面. 老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c =&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？</p><p>一共会有 k 次操作, 每次会执行下面的一种：</p><ol><li>把 x 叫走</li><li>求排在 x 前面的是谁</li></ol><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pre, nxt模拟双向链表</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            nxt[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k --) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;  cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = pre[x], b = nxt[x];</span><br><span class="line">            pre[x] = nxt[x] = <span class="number">0</span>;</span><br><span class="line">            nxt[a] = b;</span><br><span class="line">            pre[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; pre[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-牛牛取石子"><a href="#D-牛牛取石子" class="headerlink" title="D - 牛牛取石子"></a><a href="https://ac.nowcoder.com/acm/contest/49888/D">D - 牛牛取石子</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取：</p><blockquote><p>第一堆取 1 个, 第二堆取 2 个<br>第一堆取 2 个, 第二堆取 1 个</p></blockquote><p>谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1e18: 打表找规律</p><p>模仿是博弈里面的一个重要的策略, 主要思想:<br>断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法</p><p>a, b两堆石子, 必败态是: min(a, b) % 3 == 0. 因为后手总是可以控制min(a, b)在一轮下来-3<br>B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1<br>B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:<br>A: 5 4<br>B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输<br>原因在于: 若min(a, b) % 3 != 0     A总是可以把min(a, b) % 3 == 0的局面给B</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> C = <span class="number">15</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">awin</span>(C + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(C + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">awin[<span class="number">1</span>][<span class="number">2</span>] = awin[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= C; ++ i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= C; ++ j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span>)   awin[i][j] |= !awin[i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; j &gt;= <span class="number">1</span>)   awin[i][j] |= !awin[i - <span class="number">2</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)  <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> r = a / <span class="number">3</span>;      <span class="comment">// ab互走r轮对称棋</span></span><br><span class="line">    b = b - r * <span class="number">3</span>;</span><br><span class="line">    a = a - r * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">min</span>(a, b) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E-牛牛的构造"><a href="#E-牛牛的构造" class="headerlink" title="E - 牛牛的构造"></a><a href="https://ac.nowcoder.com/acm/contest/49888/E">E - 牛牛的构造</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \leq i&lt;j \leq n$ &amp;&amp; $a_i - a_j = 2^x(x\in N)(1\le n \le 10^6, 1\le k \le 10^9)$</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>考虑降序的排列: 9 8 7 6 5 4 3 2 1</p><blockquote><p>f[x]: 降序排列时, x对xi-xj=2^k 的贡献<br>f[9]: 4<br>f[8]: 3<br>f[7]: 3<br>f[6]: 3<br>f[5]: 3<br>f[4]: 2<br>f[3]: 2<br>f[2]: 1<br>f[1]: 0</p></blockquote><p>先降序, 后升序<br>降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]<br>升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0<br>​</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="built_in">popcountll</span>(i - <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(f)</span><br><span class="line">    <span class="type">int</span> mxk = <span class="built_in">accumulate</span>(<span class="built_in">all</span>(f), (<span class="type">int</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mxk &lt; k) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dec, inc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= f[i]) &#123;</span><br><span class="line">            dec.<span class="built_in">pb</span>(i);</span><br><span class="line">            k -= f[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            inc.<span class="built_in">pb</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(inc));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : dec)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : inc)  cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-牛牛的考试"><a href="#F-牛牛的考试" class="headerlink" title="F -  牛牛的考试"></a><a href="https://ac.nowcoder.com/acm/contest/49888/F">F -  牛牛的考试</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？<br>若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟.</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间</p><blockquote><p>对于同一门课而言:<br>双开时间可以转成单开时间, 即双开可以反悔成单开.<br>但是单开不能转成双开, 否则说明同时用手机电脑学同一门课.</p></blockquote><p>所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; dp;   <span class="comment">// dp[i][0] : 双开时间, dp[i][1] : 单开时间</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function">array&lt;<span class="type">int</span>, 2&gt; <span class="title">add</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; a, array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125;</span></span><br><span class="line">    <span class="comment">// &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125;</span></span><br><span class="line">    <span class="comment">// &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>])    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">min</span>(a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>] &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    a[<span class="number">0</span>] -= d, a[<span class="number">1</span>] += <span class="number">2</span> * d;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] + b[<span class="number">0</span>] + <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]), <span class="built_in">max</span>(a[<span class="number">1</span>], b[<span class="number">1</span>]) - <span class="built_in">min</span>(a[<span class="number">1</span>], b[<span class="number">1</span>])&#125;;</span><br><span class="line">    <span class="comment">// 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的</span></span><br><span class="line">    <span class="comment">// return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u] = <span class="built_in">add</span>(dp[u], dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][<span class="number">1</span>] += a[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin &gt;&gt; n;</span><br><span class="line">    g.<span class="built_in">resize</span>(n);    dp.<span class="built_in">resize</span>(n);   a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin &gt;&gt; x;   x--;</span><br><span class="line">        g[i].<span class="built_in">pb</span>(x); g[x].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-牛牛写情书&quot;&gt;&lt;a href=&quot;#B-牛牛写情书&quot; class=&quot;headerlink&quot; title=&quot;B - 牛牛写情书&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/49888/B&quot;&gt;B - 牛牛写情书</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_DP" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP/"/>
    
    <category term="算法_构造" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0/"/>
    
    <category term="算法_博弈" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.19-12.25</title>
    <link href="http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/"/>
    <id>http://example.com/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2023-01-21T01:42:30.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-19-周一-晴"><a href="#12-19-周一-晴" class="headerlink" title="12.19 周一  晴"></a>12.19 周一  晴</h2><p>今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我.</p><p>虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;,</p><h2 id="12-20-周二-晴"><a href="#12-20-周二-晴" class="headerlink" title="12.20 周二  晴"></a>12.20 周二  晴</h2><p>感染第一天: 流鼻涕</p><h2 id="12-21-周三-晴"><a href="#12-21-周三-晴" class="headerlink" title="12.21 周三  晴"></a>12.21 周三  晴</h2><p>待填</p><h2 id="12-22-周四-多云"><a href="#12-22-周四-多云" class="headerlink" title="12.22 周四  多云"></a>12.22 周四  多云</h2><h2 id="12-23-周五-阴"><a href="#12-23-周五-阴" class="headerlink" title="12.23 周五 阴"></a>12.23 周五 阴</h2><p>待填</p><h2 id="12-24-周六-晴"><a href="#12-24-周六-晴" class="headerlink" title="12.24 周六 晴"></a>12.24 周六 晴</h2><p>今天是考研第一天</p><p>晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了.</p><h2 id="12-25-周日-晴"><a href="#12-25-周日-晴" class="headerlink" title="12.25 周日 晴"></a>12.25 周日 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.29日晚22点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-19-周一-晴&quot;&gt;&lt;a href=&quot;#12-19-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.19 周一  晴&quot;&gt;&lt;/a&gt;12.19 周一  晴&lt;/h2&gt;&lt;p&gt;今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>周记 - 2022 12.12-12.18</title>
    <link href="http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/"/>
    <id>http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/</id>
    <published>2022-12-19T16:00:00.000Z</published>
    <updated>2023-01-21T01:43:26.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-12-周一-晴"><a href="#12-12-周一-晴" class="headerlink" title="12.12 周一  晴"></a>12.12 周一  晴</h2><p>早上刷题. </p><p>下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》, 同时刷题. 主要是《D. Range = √Sum》这题, 1800构造, 只能想出偶数的构造方法, 奇数情况还是过于抽象了. </p><p>晚上吃师生缘的煎饼果子, 看完了《剃须. 然后捡到高中生》. 个人认为这番其实还算治愈番, 但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩. 可能是这还只是我正式进军二次元后看的第二部番, 姑且还觉得不错, 挺期待剃须出第二部的. </p><p>晚上跟zzm及他同学联机深岩银河. </p><h2 id="12-13-周二-晴"><a href="#12-13-周二-晴" class="headerlink" title="12.13 周二  晴"></a>12.13 周二  晴</h2><p>日程基本同周一. </p><h2 id="12-14-周三-晴"><a href="#12-14-周三-晴" class="headerlink" title="12.14 周三  晴"></a>12.14 周三  晴</h2><p>日程基本同周一. 下番《辉夜大小姐想让我告白》全部三季. 晚餐尝试了步步高门口街道上的潼关肉夹馍, 10块量少但味道不错. </p><h2 id="12-15-周四-多云"><a href="#12-15-周四-多云" class="headerlink" title="12.15 周四  多云"></a>12.15 周四  多云</h2><p>今天9:45-11:45 是《高性能计算》的期末考试. 虽然线上考试并且开卷, 但我仍觉得很难. 老师也觉得很难, 所以又延长了10分钟到11:55. 我12点整把试卷拍照上传助教邮箱. 挺无语的, 本来就一限选, 还搞严格的签到、实验和线上考试. </p><p>晚上zwling发消息说南京站的物资到了, 惊喜的是外套居然还带ICPC标. 相比之下沈阳的廉价格子衫就是屑了. </p><h2 id="12-16-周五-阴"><a href="#12-16-周五-阴" class="headerlink" title="12.16 周五 阴"></a>12.16 周五 阴</h2><p>待填</p><h2 id="12-17-周六-晴"><a href="#12-17-周六-晴" class="headerlink" title="12.17 周六 晴"></a>12.17 周六 晴</h2><p>今天14:00-16:00是ICPC南京站的热身赛. 10点半不到我就吃了午餐, 午餐在师生缘吃的自助. 同样还是12点小睡了30分钟到1点起床. 我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合, 一起前往院楼. 看得出zwling似乎有些生病, 不过都拼到这一步了, 我相信大家都是想让本科的ICPC生涯有始有终的. </p><p>走到天马公寓门口时, 后面一位好心的小姐姐提醒了我书包在漏水. 听到她的提醒我先是愣了下, 随后立马把笔记本电脑拿了出来. 之前其实也发生过水壶漏水的事故, 并且电脑都没啥事. 但是这次漏水偏偏赶在热身赛赛前1小时不到, 并且还刚好是3人3机位. 一看到电脑朝下的那一边湿了一大片, 内心也凉了大半截. 不过好在有初中毕业游手机进水的经验, 这次还是学聪明了：虽然很想知道电脑是否还健在, 也很想知道明天的正式赛会不会受到影响, 我也还是忍住没按下开机键, 在路上全称用手拎着电脑边甩边让风吹, 到院楼放在门口晒了20分钟. 热身赛马上就要开始了, 我只能按下开机键, 已经做好了最坏的打算. 电脑也跟我开了个玩笑, 开机成功后自己又重启了, 不过好在这只是系统更新. 最后电脑开是能开, 但是左下角的屏幕就暗一片亮一片. </p><p>热身赛开始阶段我们跟着榜, 着力于过题数最多的B, 却发现只能想到6次方（n=20）的做法. 我的想法是每次直接找第一个1, 然后BFS到另外一个1, 将轨迹应用于全图. 这样每次至少减少1个1, 复杂度虽然不会超, 但是却无法保证轨迹总长度不超过50000, 所以也没敢上机写. 可是诡异的是很多支队伍都很快通过了. 前1小时我们都还是1题没过. 直到姜哥看到D题题面有对B题随机化解法的代码, 才发现这是往年南京站原题. 于是姜哥很快把D题签了, 然后把D题的代码直接复制到B, 至此B也过了. 最后的A题我和zwling想出了二分的假算法, 前期一直没找到钱越多买的书越多的反例, 因此也就因此WA. 姜哥及时提出了反例, 并且给出了正确的贪心做法, 只不过此时已经接近结束了. </p><p>虽说我们热身赛封榜前一道没过, 排在了300名左右. 在回宿舍的路上, 姜哥还说他隔壁宿舍有人羊了. 按照我一直奉为圭臬的人品守恒定律, 我已经看到了明天的结果：高数100将在南京站修成正果. 首先是队长zwling生病疑似阳性, 然后又是我电脑进水. 接下来又是姜哥附近与有人确诊. 这无疑给了我莫大的鼓舞. 回到园区后, zwling还是去门口核酸亭做了混检. </p><p>晚上打了atcoder Beginner Contest 282, 直接D题罚坐. rk2000+, 看来青名又要离我远去了. </p><h2 id="12-18-周日-晴"><a href="#12-18-周日-晴" class="headerlink" title="12.18 周日 晴"></a>12.18 周日 晴</h2><p>仍是凌晨1点睡, 只不过早上9:30起床, 10:00前进餐完毕, 只吃了肉松饼和上次CCSP发的零食, 睡了20来分钟. 10:00出发去院楼参加南京正式赛. </p><p>开题签到题I, 在我们迟疑的功夫, 已经过了快300人了. </p><p>第二题G贪心, 姜哥首先发现要贪心0前半段要取1, 后半段取-1, 随后我提出了二分分界线. 姜哥提出可以O(n)做, 但是写挂了, 于是我就上机开始二分了. 又到了经典二分分界线环节, 我还被这个分界线在最左边的情况卡了10分钟, 不愧是我…不过好在在姜哥提醒下, 很快就写完了. 幸运地一发A了. </p><p>第三题看着像计算几何, 姜哥一开始就说这题很简单, 只需要判断v型就行了, 我和zwling都是懵的. 随后姜哥画了几下就上机码了, 第一发没过. 随后过了10来分钟他想出了corner case, 交上去居然直接过了. 当然我们也只是开心了一下, 毕竟从此到结束, 我们都再也没能过一道题. </p><p>第四题大模拟二维前缀和, 我们还剩2小时的时间. 我想的是用将轨迹表示成一个01矩阵, 然后再用这个矩阵和最后袋鼠组成的矩形, 做类似求交算移入移出了多少. 姜哥表示应该确实就只是二维前缀和, 随后就开始码. 但是最后因为查不出哪里越界, 一直段错误. </p><p>结束后, 虽然zwling觉得可能还是打铁, 但我和姜哥都觉得铜牌概率蛮大. </p><p>5:30开始滚榜, 当看到《高数100》出现在铜牌区时, 我意识到本科的算法竞赛已经没有遗憾了. 我觉得这次铜牌不仅幸运女神站在我们这边, 更重要的是队伍的实力确实有所上升, 毕竟这次zwling生病了. 如果他没生病, 我估计我们能将A题调出来. 最后本科的所有XCPC至此都告一段落了, 希望zwling能在BUAA找到更强的队友, 继续在算法竞赛上取得更高的成就, 也希望姜哥顺利上岸, 在研究生阶段继续发挥他过人的思维优势. 最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家. </p><p>接下来就是修改《软件工程》课程大作业的报告, 并且收拾行李, 准备第二天9点的高铁了. 要好好放松下了, 首先得先把剩下的2集麻衣学姐看完hh. </p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.20日晚22点</p><p>BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐</p><p>我把《高数100》的队牌带回了宿舍, 跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起. 这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-12-周一-晴&quot;&gt;&lt;a href=&quot;#12-12-周一-晴&quot; class=&quot;headerlink&quot; title=&quot;12.12 周一  晴&quot;&gt;&lt;/a&gt;12.12 周一  晴&lt;/h2&gt;&lt;p&gt;早上刷题. &lt;/p&gt;
&lt;p&gt;下午和zzm在综楼二楼教员休息室下番《冰菓》</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - 第八届“图灵杯”个人赛</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2023-01-20T07:03:54.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/11746">比赛链接</a></p><h2 id="贪吃的派蒙"><a href="#贪吃的派蒙" class="headerlink" title="贪吃的派蒙"></a><a href="https://ac.nowcoder.com/acm/contest/11746/G">贪吃的派蒙</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在每一次的排队中, 编号为i的角色领取上限为Ai, 这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内. 当一个角色领完本次的甜甜花酿鸡, 他/她就会回到队列的末尾, 直到所有甜甜花酿鸡都被吃完为止. 当轮到一个角色领取时, 如果所有的甜甜花酿鸡都被领完, 那么他/她就要帮大家刷盘子. </p><p>贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小, 那么他就把剩下的都吃完). 我们很容易找到派蒙的编号, Ax比其他所有的Ai都要大. 大家都想让派蒙最后留下来刷盘子, 请你写一个程序来判断这是否可能. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Seek-the-Joker-II"><a href="#Seek-the-Joker-II" class="headerlink" title="Seek the Joker II"></a><a href="https://ac.nowcoder.com/acm/contest/11746/E">Seek the Joker II</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 一堆k-1, 另一堆n-k, 先取到任意一堆的最后一个输</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11746&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;贪吃的派蒙&quot;&gt;&lt;a href=&quot;#贪吃的派蒙&quot; class=&quot;headerlink&quot; title=&quot;贪吃的派蒙&quot;&gt;&lt;/a&gt;&lt;a </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2023-01-20T07:04:06.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/44749">比赛链接</a></p><h2 id="Dijkstra-松弛的理解"><a href="#Dijkstra-松弛的理解" class="headerlink" title="Dijkstra 松弛的理解"></a>Dijkstra 松弛的理解</h2><p>“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比. 最初, 最短路径的成本被高估了, 就像延伸的弹簧一样. 当找到更短的路径时, 估计的成本会降低, 弹簧会放松. 最终, 找到了最短的路径（如果存在）, 并且弹簧已经松弛到其静止长度. </p><h2 id="D-点分治分点"><a href="#D-点分治分点" class="headerlink" title="D - 点分治分点"></a>D - 点分治分点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>G&lt;n, m&gt;, 且$n, m \leq 1e5$, 定义一条简单路径的 low 值为其路径上的边权的最小值, d(u, v) 为从 u 到 v 所有简单路径的最大 low 值. 对于给定的s, u 从 1 到 n 输出 d(s, u), 如果没有任何一条简单路径则输出 -1. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>点边数1e5 -&gt; Dijkstra变形套路</p><p>dist[i]: s-&gt;i的每条路径最短边中的最大值</p><p>松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">// s-&gt;i 每条路径最短边中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[s] = inf;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;inf, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dist[cv] &gt; cd) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : G[cv]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &lt; <span class="built_in">min</span>(dist[cv], w)) &#123;</span><br><span class="line">                dist[nv] = <span class="built_in">min</span>(dist[cv], w);</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &lt; -inf / <span class="number">2</span> || dist[i] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">            dist[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/44749&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Dijkstra-松弛的理解&quot;&gt;&lt;a href=&quot;#Dijkstra-松弛的理解&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
</feed>
