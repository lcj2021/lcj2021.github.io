<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liucj&#39;s Harbour</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-20T14:13:36.316Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周记 - 2022 12.12-12.18</title>
    <link href="http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/"/>
    <id>http://example.com/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18/</id>
    <published>2022-12-19T16:00:00.000Z</published>
    <updated>2022-12-20T14:13:36.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-12-周四-晴"><a href="#12-12-周四-晴" class="headerlink" title="12.12 周四  晴"></a>12.12 周四  晴</h2><p>待填</p><h2 id="12-13-周四-晴"><a href="#12-13-周四-晴" class="headerlink" title="12.13 周四  晴"></a>12.13 周四  晴</h2><p>待填</p><h2 id="12-14-周四-晴"><a href="#12-14-周四-晴" class="headerlink" title="12.14 周四  晴"></a>12.14 周四  晴</h2><p>待填</p><h2 id="12-15-周四-多云"><a href="#12-15-周四-多云" class="headerlink" title="12.15 周四  多云"></a>12.15 周四  多云</h2><p>今天9:45-11:45 是《高性能计算》的期末考试。虽然线上考试并且开卷，但我仍觉得很难。老师也觉得很难，所以又延长了10分钟到11:55。我12点整把试卷拍照上传助教邮箱。挺无语的，本来就一限选，还搞严格的签到、实验和线上考试。</p><p>晚上zwling发消息说南京站的物资到了，惊喜的是外套居然还带ICPC标。相比之下沈阳的廉价格子衫就是屑了。</p><h2 id="12-16-周五-阴"><a href="#12-16-周五-阴" class="headerlink" title="12.16 周五 阴"></a>12.16 周五 阴</h2><p>待填</p><h2 id="12-17-周六-晴"><a href="#12-17-周六-晴" class="headerlink" title="12.17 周六 晴"></a>12.17 周六 晴</h2><p>今天14:00-16:00是ICPC南京站的热身赛。10点半不到我就吃了午餐，午餐在师生缘吃的自助。同样还是12点小睡了30分钟到1点起床。我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合，一起前往院楼。看得出zwling似乎有些生病，不过都拼到这一步了，我相信大家都是想让本科的ICPC生涯有始有终的。</p><p>走到天马公寓门口时，后面一位好心的小姐姐提醒了我书包在漏水。听到她的提醒我先是愣了下，随后立马把笔记本电脑拿了出来。之前其实也发生过水壶漏水的事故，并且电脑都没啥事。但是这次漏水偏偏赶在热身赛赛前1小时不到，并且还刚好是3人3机位。一看到电脑朝下的那一边湿了一大片，内心也凉了大半截。不过好在有初中毕业游手机进水的经验，这次还是学聪明了：虽然很想知道电脑是否还健在，也很想知道明天的正式赛会不会受到影响，我也还是忍住没按下开机键，在路上全称用手拎着电脑边甩边让风吹，到院楼放在门口晒了20分钟。热身赛马上就要开始了，我只能按下开机键，已经做好了最坏的打算。电脑也跟我开了个玩笑，开机成功后自己又重启了，不过好在这只是系统更新。最后电脑开是能开，但是左下角的屏幕就暗一片亮一片。</p><p>热身赛开始阶段我们跟着榜，着力于过题数最多的B，却发现只能想到6次方（n=20）的做法。我的想法是每次直接找第一个1，然后BFS到另外一个1，将轨迹应用于全图。这样每次至少减少1个1，复杂度虽然不会超，但是却无法保证轨迹总长度不超过50000，所以也没敢上机写。可是诡异的是很多支队伍都很快通过了。前1小时我们都还是1题没过。直到姜哥看到D题题面有对B题随机化解法的代码，才发现这是往年南京站原题。于是姜哥很快把D题签了，然后把D题的代码直接复制到B，至此B也过了。最后的A题我和zwling想出了二分的假算法，前期一直没找到钱越多买的书越多的反例，因此也就因此WA。姜哥及时提出了反例，并且给出了正确的贪心做法，只不过此时已经接近结束了。</p><p>虽说我们热身赛封榜前一道没过，排在了300名左右。在回宿舍的路上，姜哥还说他隔壁宿舍有人羊了。按照我一直奉为圭臬的人品守恒定律，我已经看到了明天的结果：高数100将在南京站修成正果。首先是队长zwling生病疑似阳性，然后又是我电脑进水。接下来又是姜哥附近与有人确诊。这无疑给了我莫大的鼓舞。回到园区后，zwling还是去门口核酸亭做了混检。</p><p>晚上打了atcoder Beginner Contest 282，直接D题罚坐。rk2000+，看来青名又要离我远去了。</p><h2 id="12-18-周日-晴"><a href="#12-18-周日-晴" class="headerlink" title="12.18 周日 晴"></a>12.18 周日 晴</h2><p>仍是凌晨1点睡，只不过早上9:30起床，10:00前进餐完毕，只吃了肉松饼和上次CCSP发的零食，睡了20来分钟。10:00出发去院楼参加南京正式赛。</p><p>开题签到题I，在我们迟疑的功夫，已经过了快300人了。</p><p>第二题G贪心，姜哥首先发现要贪心0前半段要取1，后半段取-1，随后我提出了二分分界线。姜哥提出可以O(n)做，但是写挂了，于是我就上机开始二分了。又到了经典二分分界线环节，我还被这个分界线在最左边的情况卡了10分钟，不愧是我……不过好在在姜哥提醒下，很快就写完了。幸运地一发A了。</p><p>第三题看着像计算几何，姜哥一开始就说这题很简单，只需要判断v型就行了，我和zwling都是懵的。随后姜哥画了几下就上机码了，第一发没过。随后过了10来分钟他想出了corner case，交上去居然直接过了。当然我们也只是开心了一下，毕竟从此到结束，我们都再也没能过一道题。</p><p>第四题大模拟二维前缀和，我们还剩2小时的时间。我想的是用将轨迹表示成一个01矩阵，然后再用这个矩阵和最后袋鼠组成的矩形，做类似求交算移入移出了多少。姜哥表示应该确实就只是二维前缀和，随后就开始码。但是最后因为查不出哪里越界，一直段错误。</p><p>结束后，虽然zwling觉得可能还是打铁，但我和姜哥都觉得铜牌概率蛮大。</p><p>5:30开始滚榜，当看到《高数100》出现在铜牌区时，我意识到本科的算法竞赛已经没有遗憾了。我觉得这次铜牌不仅幸运女神站在我们这边，更重要的是队伍的实力确实有所上升，毕竟这次zwling生病了。如果他没生病，我估计我们能将A题调出来。最后本科的所有XCPC至此都告一段落了，希望zwling能在BUAA找到更强的队友，继续在算法竞赛上取得更高的成就，也希望姜哥顺利上岸，在研究生阶段继续发挥他过人的思维优势。最后也感谢我的舍友ZZM为了给我做志愿者特意推迟2周时间回家。</p><p>接下来就是修改《软件工程》课程大作业的报告，并且收拾行李，准备第二天9点的高铁了。要好好放松下了，首先得先把剩下的2集麻衣学姐看完hh。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.20日晚22点</p><p>BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐</p><p>我把《高数100》的队牌带回了宿舍，跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起。这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;12-12-周四-晴&quot;&gt;&lt;a href=&quot;#12-12-周四-晴&quot; class=&quot;headerlink&quot; title=&quot;12.12 周四  晴&quot;&gt;&lt;/a&gt;12.12 周四  晴&lt;/h2&gt;&lt;p&gt;待填&lt;/p&gt;
&lt;h2 id=&quot;12-13-周四-晴&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - 第八届“图灵杯”个人赛</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2022-11-11T01:32:37.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/11746">比赛链接</a></p><h2 id="贪吃的派蒙"><a href="#贪吃的派蒙" class="headerlink" title="贪吃的派蒙"></a><a href="https://ac.nowcoder.com/acm/contest/11746/G">贪吃的派蒙</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在每一次的排队中，编号为i的角色领取上限为Ai，这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内。当一个角色领完本次的甜甜花酿鸡，他/她就会回到队列的末尾，直到所有甜甜花酿鸡都被吃完为止。当轮到一个角色领取时，如果所有的甜甜花酿鸡都被领完，那么他/她就要帮大家刷盘子。</p><p>贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小，那么他就把剩下的都吃完)。我们很容易找到派蒙的编号，Ax比其他所有的Ai都要大。大家都想让派蒙最后留下来刷盘子，请你写一个程序来判断这是否可能。 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Seek-the-Joker-II"><a href="#Seek-the-Joker-II" class="headerlink" title="Seek the Joker II"></a><a href="https://ac.nowcoder.com/acm/contest/11746/E">Seek the Joker II</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子，一堆k-1，另一堆n-k，先取到任意一堆的最后一个输</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/11746&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;贪吃的派蒙&quot;&gt;&lt;a href=&quot;#贪吃的派蒙&quot; class=&quot;headerlink&quot; title=&quot;贪吃的派蒙&quot;&gt;&lt;/a&gt;&lt;a </summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/"/>
    <id>http://example.com/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/</id>
    <published>2022-11-06T16:00:00.000Z</published>
    <updated>2022-11-07T16:03:22.710Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/44749">比赛链接</a></p><h2 id="Dijkstra-松弛的理解"><a href="#Dijkstra-松弛的理解" class="headerlink" title="Dijkstra 松弛的理解"></a>Dijkstra 松弛的理解</h2><p>“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比。最初，最短路径的成本被高估了，就像延伸的弹簧一样。当找到更短的路径时，估计的成本会降低，弹簧会放松。最终，找到了最短的路径（如果存在），并且弹簧已经松弛到其静止长度。</p><h2 id="D-点分治分点"><a href="#D-点分治分点" class="headerlink" title="D - 点分治分点"></a>D - 点分治分点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>G&lt;n, m&gt;, 且$n, m \leq 1e5$，定义一条简单路径的 low 值为其路径上的边权的最小值，d(u, v) 为从 u 到 v 所有简单路径的最大 low 值。对于给定的s，u 从 1 到 n 输出 d(s, u)，如果没有任何一条简单路径则输出 -1。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>点边数1e5 -&gt; Dijkstra变形套路</p><p>dist[i]: s-&gt;i的每条路径最短边中的最大值</p><p>松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv]. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">// s-&gt;i 每条路径最短边中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        G[u].<span class="built_in">pb</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[s] = inf;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;inf, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dist[cv] &gt; cd) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, w] : G[cv]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[nv] &lt; <span class="built_in">min</span>(dist[cv], w)) &#123;</span><br><span class="line">                dist[nv] = <span class="built_in">min</span>(dist[cv], w);</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[nv], nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] &lt; -inf / <span class="number">2</span> || dist[i] &gt; inf / <span class="number">2</span>) &#123;</span><br><span class="line">            dist[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/44749&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Dijkstra-松弛的理解&quot;&gt;&lt;a href=&quot;#Dijkstra-松弛的理解&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>周记 - 2022 10.31-11.6</title>
    <link href="http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/"/>
    <id>http://example.com/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.6/</id>
    <published>2022-11-05T16:00:00.000Z</published>
    <updated>2022-12-20T12:49:11.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-3-周四-晴"><a href="#11-3-周四-晴" class="headerlink" title="11.3 周四 晴"></a>11.3 周四 晴</h2><p>今天一早起来就看到知乎推送《多地核酸开始自费》，又了解到大舅那边前几天已经开始自费了，收费是4元/次。不禁联想到昨天还吐槽核酸检测人员的高收入。</p><p>早十有《高性能计算》，依旧是平平无奇地上半节课签到，课间从复邻舍401后门溜回宿舍。不过今天罗HZ老师提到了签到的问题，在课上指出了缺课达3次需要补卡。我想起上上周自己因为没看课表，直接漏掉了一次签到。不料午饭后，有同学在课程群里问有没有爬山组队。这才知道所谓的补卡其实是跟LHZ爬岳麓山，好感度++。自己也得找个机会把缺的这次签到补回来。</p><p>下午依旧是赛前的日常刷题。</p><p>晚饭步步高挑香小面。晚九点打算继续昨晚的师大天马宿舍之行。虽然没有大门大开，但是也只是扫个码就放行了。漫步在师大宿舍园区，我和ZZM都明显感觉到和湖大天马宿舍不同的地方。简单来说就是中南南校区和这里都更加具有校园的氛围，体现在绿化，路旁的人行道，路旁的宣传栏，也体现在这里建筑的杂乱。</p><h2 id="11-4-周五-晴"><a href="#11-4-周五-晴" class="headerlink" title="11.4 周五 晴"></a>11.4 周五 晴</h2><p>8点30分第一个下床。刷题。干午饭。学委此时也发了关于毕设导师的通知了，毕设郑老师之前提过，但是目前又没了消息。我最担心的是找不到愿意挂名的导师。</p><p>下午第三节有《软件工程》，课上做了些2022辽宁省赛的题目，发现题目难度不大。做了<a href="https://ac.nowcoder.com/acm/contest/43937/B">可莉的五子棋</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/M">画画</a>。<a href="https://ac.nowcoder.com/acm/contest/43937/I">图的分割</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/G">栈与公约数</a>暂时没想到做法。</p><p>晚上有例行的每周大组会，我问了WSH，发现大家都找了毕设的导师，所以我也打算把当前进度汇报一下，顺便问问毕设的事情。于是跟老师和彭Z约了明天晚上讨论进度。</p><h2 id="11-5-周六-晴"><a href="#11-5-周六-晴" class="headerlink" title="11.5 周六 晴"></a>11.5 周六 晴</h2><p>今天14:00-16:00是ICPC沈阳站的热身赛。所以10点半不到就吃了午餐，休息小睡了20分钟后。便在阜埠河公交站和zwl骑车去院楼105准备上机环境。</p><p>在比赛开始时，zwl的后置录像手机夹住了关机键，手机直接关机了，所以我们整场比赛都没法正常交题。不过还是能看题面，A题签到，B题是输出 (随机生成)满足条件的a序列的期望。公式是$\frac{(n!)^2}{n^n}$。就是不知道<code>double</code>的精度能否满足要求。C题是类似石子合并的DP题。但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$，所以最后只能写一个假算法。赛后问了SJ，得知是四边形不等式决策单调性相关，打扰了。</p><p>晚上的Atcoder只打了半小时。</p><h2 id="11-6-周日-晴"><a href="#11-6-周日-晴" class="headerlink" title="11.6 周日 晴"></a>11.6 周日 晴</h2><p>总结: 遗憾打铁<br>仍是凌晨1点睡，8:30起床，10:30前进餐完毕，睡了10来分钟。11:30到院楼参加沈阳正式赛。</p><p>开题签到题，统计字符串中T和D的个数，WA了一发。<br>第二题找规律题，姜哥首先发现r取越大越好，但是只考虑a[i]作为左端点，没加上右端点的情况，WA了一发</p><p>第三题构造题，我首先用子矩阵数量公式判断出了无解情况。ZWL打表，发现了长相特殊的合法情况，所以尝试将二维压缩为一维。问题转换成把一个数分解成若干个$\frac{i \times (i+1)}{2}$表示。我提出从i从高到低贪心，二分i的位置，上机同时姜哥找反例。姜哥发现没有反例并且提出可以线性，但是我写到后面犯傻，直接神志不清，并不清楚线性的意思。于是姜哥接过来完成算法。第一发TLE，<code>endl</code>原因。第二发WA，爆<code>long long</code>。最后过了</p><p>第四题大模拟暴搜，题意没读懂，其实就是炉石随从攻击的逻辑，奈何没玩过。调试1个半小时，没能调对第二个样例。以为是精度问题。最后Rank290+无奈打铁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;11-3-周四-晴&quot;&gt;&lt;a href=&quot;#11-3-周四-晴&quot; class=&quot;headerlink&quot; title=&quot;11.3 周四 晴&quot;&gt;&lt;/a&gt;11.3 周四 晴&lt;/h2&gt;&lt;p&gt;今天一早起来就看到知乎推送《多地核酸开始自费》，又了解到大舅那边前几天已经开始自费了</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 275 A-F</title>
    <link href="http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/"/>
    <id>http://example.com/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/</id>
    <published>2022-11-03T16:00:00.000Z</published>
    <updated>2022-11-04T05:26:55.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个$r \times c (r, c\in [1, 9])$二维平面S. 元素S[i][j]是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数. </p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##.......</span><br><span class="line">##.......</span><br><span class="line">.........</span><br><span class="line">.......#.</span><br><span class="line">.....#...</span><br><span class="line">........#</span><br><span class="line">......#..</span><br><span class="line">.........</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子. </p><p>具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子. </p><p>因此，答案是 2. </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标. </p><p>向量<code>[x, y]</code>顺时针旋转90°: <code>[y, -x]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rot</span><span class="params">(array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = v;</span><br><span class="line">    v = &#123;y, -x&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">9</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++ j) </span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; g[<span class="number">5</span>][<span class="number">7</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    set&lt;set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ci = <span class="number">1</span>; ci &lt;= <span class="number">9</span>; ++ ci) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cj = <span class="number">1</span>; cj &lt;= <span class="number">9</span>; ++ cj) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ni = <span class="number">1</span>; ni &lt;= <span class="number">9</span>; ++ ni) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> nj = <span class="number">1</span>; nj &lt;= <span class="number">9</span>; ++ nj) </span><br><span class="line">                    <span class="keyword">if</span> (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[ni][nj] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                        array&lt;<span class="type">int</span>, 2&gt; v = &#123;ni - ci, nj - cj&#125;;</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i3 = ni + v[<span class="number">0</span>], j3 = nj + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="built_in">rot</span>(v);</span><br><span class="line">                        <span class="type">int</span> i4 = i3 + v[<span class="number">0</span>], j4 = j3 + v[<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7)   cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">check</span>(i3, j3) &amp;&amp; <span class="built_in">check</span>(i4, j4)</span><br><span class="line">                        &amp;&amp; g[i3][j3] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[i4][j4] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                            <span class="comment">// cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl;</span></span><br><span class="line">                            set&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; s;</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ci, cj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;ni, nj&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i3, j3&#125;);</span><br><span class="line">                            s.<span class="built_in">insert</span>(&#123;i4, j4&#125;);</span><br><span class="line">                            S.<span class="built_in">insert</span>(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>为非负整数 x 定义的函数 f(x) 满足以下条件：</p><ul><li><p>$f(0) = 1$</p></li><li><p>$f(k) = f(\lfloor \frac{k}{2}\rfloor) + f(\lfloor \frac{k}{3}\rfloor)$ 对于任何正整数 k</p></li></ul><p>然后找到 $f(N), N\in[0, 1^{18}]$. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>最多需要$log_2n \times log_3n$这么多个数的f值. 标准记搜</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.<span class="built_in">count</span>(u))    <span class="keyword">return</span> dp[u];</span><br><span class="line">    <span class="keyword">return</span> dp[u] = <span class="built_in">dfs</span>(u / <span class="number">2</span>) + <span class="built_in">dfs</span>(u / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; dp.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个一维的棋盘上有 N + 1 个格子，下标从 0 到 N ，玩家要从 0 这个点出发，前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子，每个骰面上都有不同的数字，值域是 $[1, M]$ ，扔出每个面的概率都是 $\frac{1}{M}$ . 玩家需要根据要出来的骰面前进，如果预计前进之后走出了棋盘，就需要退回多走出的步数，如果在终点停了下来，游戏就胜利了，不能再扔骰子. 问 K 回合后，玩家胜利的概率. 将结果对 998244353 取模. </p><p>$0 \le M \le N \le 1000, M \in [1, 10], K \in [1, 1000]$ . </p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令 dp[i][j] 为扔第 j 次骰子后，玩家到达下标为 i 的格子的概率. </p><p>对于每一个 dp[i][j]  $dp[next_i][j + 1] = dp[i][j] \times \frac{1}{M}$. 注意如果走出了棋盘，要特殊讨论停下来的下标. </p><p>已经到达终点n的状态[n][j]不用再向[next_i][j + 1]转移了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span> + <span class="number">10</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dp[N][N];       <span class="comment">// 到达第i格, 共走了j步的所有情况之和</span></span><br><span class="line"><span class="comment">// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % mod;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m_1 = <span class="built_in">qmi</span>(m , mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= m; ++ len) &#123;</span><br><span class="line">                <span class="type">int</span> ni = i + len;</span><br><span class="line">                <span class="keyword">if</span> (ni &gt; n) &#123;</span><br><span class="line">                    ni = n - (ni - n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// if (next_i &lt;= i) &#123;</span></span><br><span class="line">                <span class="comment">//     cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                dp[ni][j + <span class="number">1</span>] += (dp[i][j] * m_1) % mod;</span><br><span class="line">                dp[ni][j + <span class="number">1</span>] %= mod;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][j + <span class="number">1</span>] += dp[n][j];</span><br><span class="line">        dp[n][j + <span class="number">1</span>] %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 A ，定义一次操作的内容是，删除 A 中一段连续的序列. </p><p>问对于 1, 2, …, M 中的每个数 s ，分别至少要操作多少次， 才能使得 A 中剩下的数和为 s ，如果不可能就输出 -1 . </p><p>$0 \le N \le M \le 3000， 1 \le a_i \le 3000$</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组分段式的DP, 用一个维度表示当前元素是否在分段中</p><p>dp[N][N][2]: 前i个数, 构成总和为j, 且第i个数是否在总和中</p><p>如果a[i]不计入总和: <code>dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;);</code></p><p>如果a[i]计入总和: <code>dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;);</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];            <span class="comment">// 前i个数, 构成总和为j, 且第i个数是否在总和中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (j - a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;dp[i][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - a[i]][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">min</span>(&#123;dp[n][j][<span class="number">0</span>], dp[n][j][<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)   ans = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的</p><p>C 模拟 + 向量旋转</p><p>D 记忆化搜索</p><p>E 概率DP</p><p>F DP + 数组划分 / 选取子段</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;一个$r \t</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_模拟" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="算法_记忆化搜索" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
    <category term="算法_DP_概率" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%A6%82%E7%8E%87/"/>
    
    <category term="算法_DP_数组划分" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 192 D-F</title>
    <link href="http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/"/>
    <id>http://example.com/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/</id>
    <published>2022-11-02T16:00:00.000Z</published>
    <updated>2022-11-04T15:49:37.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定整数 $X, X \in [1, 10^{60}]$和 $M, M \in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. </p><p>求对于所有的 $a&gt;d,a \in \mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\le M$. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) =1$ 只需特判. </p><p>注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. </p><p>同时, <code>long long</code> 相乘可能会爆, 必须乘乘数<code>base</code>之前判断当前<code>val &gt; target / base </code>. 或者用 <code>__int128</code>AtCoder 支持 或龟速乘. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string x;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; m;</span><br><span class="line">    <span class="type">signed</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : x)  mx = <span class="built_in">max</span>(mx, ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;                        <span class="comment">// 特判: 因为题目要求不同的数</span></span><br><span class="line">        <span class="keyword">if</span> (mx &lt;= m)    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> base) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; m / base) &#123;               <span class="comment">// 每次 + *base 之前 跟目标 /base 作比较 防止溢出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> b = x[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            val *= base;</span><br><span class="line">            val += b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (val &lt;= m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = mx, r = <span class="number">1e18</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))         l = mid;</span><br><span class="line">        <span class="keyword">else</span>                    r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; l - mx &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$G(N, M), N, M \leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\in\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 <code>-1</code>. </p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; G[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k;</span><br><span class="line">        G[a].<span class="built_in">pb</span>(&#123;b, t, k&#125;);</span><br><span class="line">        G[b].<span class="built_in">pb</span>(&#123;a, t, k&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;, vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;, greater&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x] = <span class="number">0</span>;    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, x&#125;);</span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cd, cv] = pq.<span class="built_in">top</span>();   pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cd &gt; dist[cv])  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [nv, t, k] : G[cv]) &#123;</span><br><span class="line">            <span class="type">int</span> nd = (cd + k - <span class="number">1</span>) / k * k;</span><br><span class="line">            nd = nd + t;</span><br><span class="line">            <span class="comment">// cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (nd &lt; dist[nv]) &#123;</span><br><span class="line">                dist[nv] = nd;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;nd, nv&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (dist[y] &gt;= <span class="number">0x3f3f3f3f3f3f3f3f</span> / <span class="number">2</span>)  cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>                                    cout &lt;&lt; dist[y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定数组a[N], $a[i] \leq 1e7$和$X \in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k = X$, 求出满足的最小整数mn的值. </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数</p><p>枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. </p><p><code>dp[k][i][j]</code> = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值</p><p>不拿第k个物品: <code>dp[k][i][j] = dp[k - 1][i][j];</code></p><p>拿第k个物品: <code>dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]);</code></p><p>总复杂度 $\mathcal{O}(n^4)$. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">int</span> a[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][N];        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> choose = <span class="number">1</span>; choose &lt;= n; ++ choose) &#123;</span><br><span class="line">        <span class="type">int</span> m = x % choose;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   w[i] = a[i] % choose;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="comment">// dp[k][i][j] = 前k个数, 选了i个数，它们的和必须是%choose=j，满足要求的和的最大值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(k, choose); ++ i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; choose; ++ j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i][j]) &#123;</span><br><span class="line">                        dp[k][i][j] = dp[k - <span class="number">1</span>][i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (~dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose]) &#123;</span><br><span class="line">                        dp[k][i][j] = <span class="built_in">max</span>(dp[k][i][j], dp[k - <span class="number">1</span>][i - <span class="number">1</span>][(j - w[k] + choose) % choose] + a[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose</span></span><br><span class="line">        <span class="keyword">if</span> (~dp[n][choose][m]) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, (x - dp[n][choose][m]) / choose);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>D 考察乘法溢出, 各种边界讨论比较繁琐</p><p>E 最短路变形, 松弛边权做一下变化即可</p><p>F 背包+模数, 在外层套一层for模数<code>choose</code>, 状态表示加一个维度表示当前总和mod <code>choose</code>的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D&quot;&gt;&lt;a href=&quot;#D&quot; class=&quot;headerlink&quot; title=&quot;D&quot;&gt;&lt;/a&gt;D&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定整数 $X</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_二分" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86/"/>
    
    <category term="算法_最短路" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="算法_DP_背包" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-DP-%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/"/>
    <id>http://example.com/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/</id>
    <published>2022-10-31T16:00:00.000Z</published>
    <updated>2022-11-03T10:56:26.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="D-国际象棋"><a href="#D-国际象棋" class="headerlink" title="D - 国际象棋"></a>D - 国际象棋</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>每次加入棋子, 就判断这个位置上”-“, “|”, “/“. “\“四个方向上已经连了几个了.</p><p>注意不能分8个方向</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, t;</span><br><span class="line"><span class="type">int</span> h[N], g[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> tt = <span class="number">1</span>; tt &lt;= t; ++ tt) &#123;</span><br><span class="line">        <span class="type">int</span> col, x = tt % <span class="number">2</span>;    cin &gt;&gt; col;</span><br><span class="line">        g[++ h[col]][col] = x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cx = h[col], cy = col;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//         for (int i = n; i &gt;= 1; -- i)   for (int j = 1; j &lt;= m; ++ j)   cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \n&quot;[j == m];</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; g[cx + <span class="number">1</span>][cy] == x)   ++ cx, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy] == x)   -- cx, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx][cy + <span class="number">1</span>] == x)   ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col; </span><br><span class="line">        <span class="keyword">while</span> (cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx][cy - <span class="number">1</span>] == x)   -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy + <span class="number">1</span> &lt;= m &amp;&amp; g[cx + <span class="number">1</span>][cy + <span class="number">1</span>] == x)   ++ cx, ++ cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy - <span class="number">1</span>] == x)   -- cx, -- cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cx + <span class="number">1</span> &lt;= n &amp;&amp; cy - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx + <span class="number">1</span>][cy - <span class="number">1</span>] == x)   ++ cx, -- cy, ++ cnt;</span><br><span class="line">        cx = h[col], cy = col;</span><br><span class="line">        <span class="keyword">while</span> (cx - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; cy + <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; g[cx - <span class="number">1</span>][cy + <span class="number">1</span>] == x)   -- cx, ++ cy, ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= k)       <span class="keyword">return</span> tt;</span><br><span class="line"><span class="comment">//         cerr &lt;&lt; &quot; \\ &quot; &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-弹珠碰撞"><a href="#E-弹珠碰撞" class="headerlink" title="E - 弹珠碰撞"></a>E - 弹珠碰撞</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>长度为 n 的线段上，有 m 颗弹珠在匀速以1单位/s 左右滚动。弹珠ball有d, p两个参数. d(0/1)表示左/右方向, p表示初始位置. </p><p>两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动，并交换两颗弹珠滚动的方向。一颗弹珠可以反复发生碰撞，如果在停滞中受到碰撞，则停滞时间会累加。</p><p>如果一颗弹珠滚到了位置 0 或位置 n+1，那么这颗弹珠就滚出了线段。问最后一颗弹珠在什么时候滚出线段？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>a -&gt;  &lt;- b 左右两个弹珠相撞后</p><p>&lt;-a   b -&gt; </p><p>&lt;-b   a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的</p><p>算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行.</p><p>​    </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d, p;</span><br><span class="line">&#125; ball[N];</span><br><span class="line"><span class="type">int</span> pre1[N];        <span class="comment">// -&gt;</span></span><br><span class="line"><span class="type">int</span> suf0[N];        <span class="comment">// &lt;-</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].p;</span><br><span class="line">    <span class="built_in">sort</span>(ball + <span class="number">1</span>, ball + <span class="number">1</span> + m, [&amp;](<span class="keyword">auto</span> &amp;a, <span class="keyword">auto</span> &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)   pre1[i] = pre1[i - <span class="number">1</span>] + (ball[i].d == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; -- i)   suf0[i] = suf0[i + <span class="number">1</span>] + (ball[i].d == <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, p] = ball[i];</span><br><span class="line">        <span class="type">int</span> t = (d ? (n + <span class="number">1</span> - p) + suf0[i] : p + pre1[i]);</span><br><span class="line">        <span class="comment">// cerr &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">max</span>(t, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-困难卷积"><a href="#F-困难卷积" class="headerlink" title="F - 困难卷积"></a>F - 困难卷积</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定整数序列 a[n], b[n]，求：<br>$$<br>\sum_{i=1}^n\sum_{j=1}^n\Big\lfloor\sqrt{|a_i-b_j|}\Big\rfloor<br>$$</p><p>其中 $\lfloor x\rfloor$表示不超过 x 的最大整数，例如 $\lfloor 3.5\rfloor=3,\lfloor\sqrt 2\rfloor =1$。</p><p>$1≤n≤10^6，0\leq a_i,b_i\leq 3\times 10^6，\sum a_i,\sum b_i\leq 10^7$。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>3e6 排除暴力. 注意到$\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnta, cntb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i], cnta[a[i]] ++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; b[i], cntb[b[i]] ++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [va, ca] : cnta) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [vb, cb] : cntb) &#123;</span><br><span class="line">            ans += <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">abs</span>(va - vb))) * ca * cb;</span><br><span class="line">        &#125;</span><br><span class="line">    cerr &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;D-国际象棋&quot;&gt;&lt;a href=&quot;#D-国际象棋&quot; class=&quot;headerlink&quot; title=&quot;D - 国际象棋&quot;&gt;&lt;/a&gt;D - 国际象棋&lt;/h2&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    <category term="题解" scheme="http://example.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="算法_思维" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95-%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/31/hello-world/"/>
    <id>http://example.com/2022/10/31/hello-world/</id>
    <published>2022-10-31T11:31:34.473Z</published>
    <updated>2022-10-31T11:29:53.845Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 下使用 Clash 代理</title>
    <link href="http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2022/02/02/Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/</id>
    <published>2022-02-01T16:00:00.000Z</published>
    <updated>2022-10-31T16:21:23.581Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu科学上网</p><ol><li> 在 <a href="https://link.zhihu.com/?target=https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a> 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash。</li><li> 添加执行权限（sudo chmod + x clash），将 clash 放到 /usr/bin/ 目录下（sudo cp clash /usr/bin/）。</li><li> 在终端中运行 clash，会在 ~/.config/clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件。用商家提供的替换这两个文件，重新运行 clash。</li><li>设置系统代理：<br> <img src="/images/2022-02-02-clash-on-Ubuntu_1.png" alt="1"></li></ol><blockquote><ol><li>用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响。</li><li>将clash进程加入开机自启动</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ubuntu科学上网&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 在 &lt;a href=&quot;https://link.zhihu.com/?target=https://github.com/Dreamacro/clash/releases&quot;&gt;https://github.com/Dreama</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Network" scheme="http://example.com/tags/Network/"/>
    
  </entry>
  
</feed>
