<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/30/AAAI2025%20Rebuttal/"/>
    <url>/2024/11/30/AAAI2025%20Rebuttal/</url>
    
    <content type="html"><![CDATA[<p>Summary<br>This paper studies the problem of learning a routing function for the hybrid retrieval setup where an ensemble of dense (more accurate but expensive) and sparse retrieval (less accurate but cheap) methods are used. It proposes a low-cost learned routing network PIN (Priority-biased interaction network) which takes in the scores of the sparse retrieval method and some learned priority bias as input and predicts whether the sparse retrieval method’s output should be further reranked&#x2F;augmented with dense retriever’s output.</p><p>Strengths<br>The paper offers a low-cost routing network that is competent with the more expensive methods on the explored benchmarks</p><p>Weakness<br>The paper is difficult to read with many details not put in their relevant places or unclear by reading the paper. For e.g. -<br>a) Figure 2’s caption is just “Overview of our framework”, ideally this figure’s caption should clearly explain the figure and the method along with what the red&#x2F;black lines mean, similarly for other figures in the paper;<br>b) In section 3.2 the DCNv2 equation is defined without saying what x0 represents;<br>c) For the priority bias only this statement is mentioned: “Specifically, we use a learnable priority bias approach for the top 100 signals” which to me isn’t clear what exactly is the formulation of this priority bias - is it a learnable scalar for each of the positions?<br>d) there are no training details</p><p>There is limited novelty in the proposed method or any new technical insight offered.<br>The design choices of the method are not well motivated, for e.g. why the chosen network is a DCNv2 architecture why not any MLP block, or what happens if you just put an MLP block?</p><p>W1<br>a) 红线代表着Sparse检索器得到的passage的数据流，黑线代表原始问题的数据流，蓝线代表Dense检索器得到passage的数据流，紫线代表Hybrid Retriever返回的数据流。我们会在figure2的caption中详细介绍这些线条含义，包括所选query用例的分析。<br>b) 在 DCNv2 的公式里，x0 为原始输入的 sparse 信号，在每轮迭代过程中，都要运用到这个原始输入。<br>c) 是的。这个scalar是可学习的。并且这是基于Sparse检索器分数的bias，其尺度处于一个相当可控的数值范围之内，所以学习效果良好。<br>d) 我们在Appendix B中的Setup Details中提到了我们的训练方法，后续我们还会进一步补充更多训练细节，和工作的可扩展性。</p><p>W2<br>我们提出了一种general framework。在此框架中，我们提出了新的、ROI驱动的问题，旨在优化overall 开销。我们从端到端的视角来考虑问题，这有别于传统的、仅注重查询难度预测准确度的问题。并且我们创新地以uplift的视角建模问题，使得模型具有超越纯Hybrid Retrieval的潜力。</p><p>下表展示的是squad数据集， 我们把train中的query按照三个retriever能否回答，分成了以下8类。</p><table><thead><tr><th>class</th><th>DR hit?</th><th>HR hit?</th><th>SR hit?</th><th>proportion</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1.55%</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0.09%</td></tr><tr><td>2</td><td>1</td><td>0</td><td>0</td><td>1.02%</td></tr><tr><td>3</td><td>1</td><td>1</td><td>0</td><td>4.62%</td></tr><tr><td>4</td><td>0</td><td>1</td><td>1</td><td>16.81%</td></tr><tr><td>5</td><td>1</td><td>0</td><td>1</td><td>0.18%</td></tr><tr><td>6</td><td>1</td><td>1</td><td>1</td><td>55.92%</td></tr><tr><td>7</td><td>0</td><td>0</td><td>0</td><td>19.79%</td></tr></tbody></table><p>我们将SR hit为0的都当作正样本。<br>注意到我们并没有排除class7，这是考虑到这些查询在词项mismatch上的表现会反映到Sparse signal中，这能反映查询的困难性。<br>这样label还有个好处就是：能在一定程度上学习那些HR不能回答，而SR却能回答的问题（class 0和5，共占比1.73%）。事实上当我们的budget在一定范围内时，我们的混合检索模型甚至能超过HR的recall。<br>在SQuAD-test上，仅需HR 92%的成本即可达到84.19%的召回率，超过了纯HR的检索质量（84.15%）。</p><p>W3<br>受限于篇幅，我们并未展示我们模型设计动机，我们会在final version中补充。<br>最初，我们尝试了以 LightGBM 为代表的浅层模型，并手动进行低阶特征交叉（如top1信号和最后一个信号的乘积）。在这个过程中，我们选取并发现这些特征交叉呈现出了较高的特征重要度，其预测结果相较于原始的 Sparse 信号也更为出色。基于此，我们着重对几种常见的、能自动挖掘交叉特征的 CTR 模型的效果展开了实验，例如 FiBiNet、AFN 等。</p><p>我们选择了其中效果最好的DCNv2作为router的backbone，作用于我们的框架。<br>同时，我们也曾尝试针对这些信号使用 CNN1d 等深度模型，然而它们的效果均不如 DCNv2 理想。</p><p>除此之外，在对 LightGBM 的特征重要度进行分析时，我们发现某些信号（比如重要度排名最高的 3 个信号和最低的 3 个信号）通常具有比其他信号高得多的重要度。鉴于此，我们尝试去 “学习” 这种所谓的重要度，于是考虑引入了 priority - bias。</p><p>在Section 4.4 Ablation Study的Table6中，w&#x2F;o position bias&amp; interaction layer就代表了MLP block。</p><p>1a) The red, blue and purple line represent data flow of passages from the SR, DR and HR, the black line is that of the original question. These will be detailed in the caption of Figure 2, including analysis of selected query cases in final version.<br>1b) In the formula of DCNv2, x0 is the original input sparse signal, which is used in each iteration process.<br>1c) Yes. They are learnable scalars for each of the positions.<br>1d) We mentioned training method in the Setup Details in Appendix B. We will further supplement more training details and the scalability in final version.<br>2 ) We propose an ROI-driven questions aiming to optimize the overall cost. Considering the problem from an end-to-end perspective, different from the traditional ones focusing only on the query difficulty prediction accuracy. Moreover, we innovatively model the problem from the view of uplift, enabling the model to have the potential to surpass pure HR.<br>The following table shows the SQuAD dataset. We divide train queries into 4 classes based on retrievability by SR and HR.</p><table><thead><tr><th>class</th><th>HR hit?</th><th>SR hit?</th><th>proportion</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1.73%</td></tr><tr><td>1</td><td>1</td><td>0</td><td>4.71%</td></tr><tr><td>2</td><td>1</td><td>1</td><td>72.73%</td></tr><tr><td>3</td><td>0</td><td>0</td><td>20.81%</td></tr></tbody></table><p>We regard all those with 0 SR hit as positive samples.<br>An advantage is that it can learn the problems that HR cannot answer but SR can (class 0).<br>On test set, a recall rate of 84.19% can be achieved with only 92% of the cost of HR, exceeding the retrieval quality of pure HR (84.15%).</p><p>3 ) Constrained by the length, we did not present the design motivation, and we will supplement it in the final version.<br>Initially, we try shallow models like LightGBM and manually do low-order feature cross (products of the tops and tails). During this, we select and find that these cross features exhibit high feature importance, and the prediction results with crossing are also better. Based on this, we mainly experiment on the effects of CTR models that can automatically mine cross-features, such as FiBiNet, AFN, etc.<br>We select DCNv2 (the most effective among them) as the backbone of the router for our framework.<br>Meanwhile, we try using deep models such as CNN1d for these signals but they are less effective than DCNv2.<br>In addition, we find that certain signals (e.g. the top and bottom ones) usually have higher importance than other signals in LightGBM. So we attempt to learn this by introducing priority-bias.<br>In Table 6 of Section 4.4 Ablation Study, “w&#x2F;o position bias &amp; interaction layer” represents the bare MLP block.</p><p>Review:<br>This paper presents the Priority-biased Interaction Network (PIN), integrated into a cost-efficient hybrid retrieval framework. The approach relies solely on numerical retrieval feedback signals for inference, achieving prediction accuracy comparable to BERT-based models while operating with only 1% of the parameters and 1‰ of the computational cost. The proposed Priority-Biased Interaction Network efficiently predicts which queries need hybrid retrieval, significantly reducing computational costs while maintaining high recall rates.</p><p>Pros: Lightweight Design: The PIN model can run on a single-threaded CPU, unlike typical transformer-based models that require extensive GPU resources.</p><p>Cons: The baselines used in the paper, such as BERT-QPP and DPR, are around three years old and may not reflect recent advancements in retrieval techniques.</p><p>W<br>由衷感谢您的认可。在此需要说明的是，Dense 模型的优劣并非我们此次比较的目标，原因在于 DPR 是可以被任意 dense 模型所替换的。我们所提出的是基于 Sparse 信号的路由器（router）以及一个通用框架。<br>无论是当前 SOTA 的 BGE - m3，还是 openAI - text - embedding - 3 等都可以用来作为dense模块。<br>我们实际上是选出了sparse难以回答的query給dense模块，因此一个更好的dense模块会提高整体的召回效果，而对我们的查询路由决策影响有限。</p><p>据我们了解，在 QPP 领域中，除了基于 LLM 的方法之外，BERT - QPP 已经是较为新颖且被广泛应用的工作了。那些更新的利用 LLM 进行决策的工作，成本要高得多。二者完全不是一个量级，仅仅是 LLM 的决策时间就已经超过了我们模型的端到端运行时间。</p><p>Thank you for your valuable suggestions. We will supplement the relevant work of Sparse, Dense Retrieval models and more QPP methods in the final version<br>It should be noted here that the quality of the Dense model is not the target of our comparison this time, because DPR can be replaced by any dense model. What we proposed is a router based on Sparse signals and a general framework.</p><p>Whether it is the state-of-the-art BGE-m3 or openAI’s text-embedding-3, etc., they can all be used as dense modules.</p><p>We actually select the queries that are difficult for the sparse model to answer and give them to the dense module. Therefore, a better dense module will improve the overall recall effect, but has limited impact on our query routing decision.</p><p>As far as we know, in the QPP field, apart from the LLM-based methods, BERT-QPP is already relatively novel and widely-used work. Those newer works that use LLM for decision-making are much more costly. They are not in the same order of magnitude at all. Just the decision-making time of the LLM already exceeds the end-to-end running time of our model.</p><p>论文中提到的通用框架是什么？</p><p>如何评估改进后的dense模块的效果？</p><p>稀疏模型和密集模型各自的优势是什么？</p><p>Review:<br>Overview:</p><p>This paper proposes the Priority-biased Interaction Network (PIN), a lightweight framework aimed at improving the efficiency of hybrid retrieval systems used in tasks like Open-Domain Question Answering (ODQA) and Retrieval-Augmented Generation (RAG). The primary goal of the framework is to reduce computational costs while maintaining the recall rates of more resource-intensive hybrid retrieval methods, which combine both sparse and dense retrieval. The paper introduces a Query Performance Prediction (QPP) method that relies on numerical retrieval feedback rather than the more complex, computation-heavy BERT-based models. Experiments across seven question-answering datasets demonstrate that the proposed framework achieves comparable recall to full hybrid retrieval, while reducing costs by over 13%.</p><p>Pros:</p><p>The paper is well-structured and easy to follow, making the proposed framework and methodology clear and accessible.<br>The Priority-biased Interaction Network (PIN) presents an innovative approach to reducing computational costs in hybrid retrieval without sacrificing performance, an important contribution to resource-efficient retrieval systems.<br>The framework demonstrates substantial efficiency gains, using only 1% of the parameters and 1‰ of the computational cost of BERT-based models, while maintaining comparable accuracy.<br>The extensive experimental evaluation across diverse datasets provides a thorough demonstration of the framework’s effectiveness in real-world scenarios.<br>Cons:</p><p>1.The related work on sparse retrievers omits key references such as SPLADE, which is an important method in sparse lexical and expansion retrieval models:<br>[a] Formal, Thibault, et al. “SPLADE: Sparse lexical and expansion model for first-stage ranking.” SIGIR, 2021.<br>[b] Formal, Thibault, et al. “SPLADE v2: Sparse lexical and expansion model for information retrieval.” arXiv, 2021.<br>% Similarly, the dense retrieval-related section does not cover some of the latest developments in decoder-only models like e5-mistral and its high-scoring variations in the BEIR benchmark:<br>[c] Wang, Liang, et al. “Improving text embeddings with large language models.” arXiv, 2023.<br>[d] Meng, Rui, et al. “Sfrembedding-mistral: enhance text retrieval with transfer learning.” Salesforce AI Research Blog, 2024.<br>[e] Lee, Chankyu, et al. “NV-Embed: Improved Techniques for Training LLMs as Generalist Embedding Models.” arXiv, 2024.</p><p>2.The training process for the Priority-biased Interaction Network (PIN) is not clearly explained. More specifically, how is the ground truth for the PIN output curated?</p><p>In Figure 3, it is unclear whether the input signal for Sparse Retrieval (SigSR) is sorted before being fed as input. If not, the use of a position bias could result in different values based on the order of the input, which might introduce inconsistencies.</p><p>The integration of Figure 3 (PIN) into the broader framework (Figure 2) is unclear. Is the Priority-biased Interaction Network part of the QPP process? Further clarification is needed in Section 3.</p><p>Justification:</p><p>While the overall idea of a cost-efficient hybrid retrieval framework is novel and promising, there are concerns about missing recent works in both sparse and dense retrieval literature. Additionally, further clarity is needed regarding the training process of the Priority-biased Interaction Network. Addressing these issues would make the paper more robust and complete.<br>% 虽然成本高效的混合检索框架的总体想法是新颖的和有前途的，但人们担心稀疏和密集检索文献中缺少最近的工作。此外，需要进一步明确优先偏向交互网络的训练过程。解决这些问题将使论文更加健全和完整。</p><p>W1-2</p><p>感谢理解。<br>我们先前引用了SPLADE，但在后期由于篇幅原因未引入这些工作。我们将会在final version补充他们。</p><p>但是值得注意的是，只要sparse模型的信号在一定尺度内且排好序，我们的模型是通用的。</p><p>我们将会在final version中引用他们，并讨论他们与我们工作的关系。<br>Dense模型并不影响我们PIN网络的输入——sparse信号，也因此造成的影响有限。<br>当然更好的Dense模型会有更好的HR检索效果。</p><p>W3<br>我们会在final version中介绍更多关于训练的细节，尤其是label标注以及数据分布。<br>下表展示的是squad数据集， 我们把train中的query按照三个retriever能否回答，分成了以下8类。</p><table><thead><tr><th>class</th><th>DR hit?</th><th>HR hit?</th><th>SR hit?</th><th>proportion</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1.55%</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0.09%</td></tr><tr><td>2</td><td>1</td><td>0</td><td>0</td><td>1.02%</td></tr><tr><td>3</td><td>1</td><td>1</td><td>0</td><td>4.62%</td></tr><tr><td>4</td><td>0</td><td>1</td><td>1</td><td>16.81%</td></tr><tr><td>5</td><td>1</td><td>0</td><td>1</td><td>0.18%</td></tr><tr><td>6</td><td>1</td><td>1</td><td>1</td><td>55.92%</td></tr><tr><td>7</td><td>0</td><td>0</td><td>0</td><td>19.79%</td></tr></tbody></table><p>Dense Retriever 的能回答的问题是class 2, 3, 5, 6的并集，召回率为61.75%。<br>Sparse Retriever则是class 0, 4, 5, 6，召回率为74.47%；Hybrid Retriever是class 1, 3, 4, 6，召回率为77.45%。<br>我们将SR hit为0的都当作正样本，即class 1, 2, 3, 7。<br>注意到我们并没有排除class7，这是考虑到这些查询在词项mismatch上的表现会反映到Sparse signal中，这能反映查询的困难性。<br>这实际上是Uplift模型的简化版。<br>这样label还有个好处就是：能在一定程度上学习那些HR不能回答，而SR却能回答的问题（class 0和5，共占比1.73%）。事实上当我们的budget在一定范围内时，我们的混合检索模型甚至能超过HR的recall。<br>在SQuAD-test上，仅需HR 92%的成本即可达到84.19%的召回率，超过了纯HR的检索质量（84.15%）。</p><p>W4<br>检索模型的工作是返回top-k个最相关的 passage，top-k是根据分数排序的，因此分数是有序的。</p><p>W5<br>PIN确实就是在 QPP process 起作用。我们会在section3以及figure2的caption中进行补充。</p><p>1 )<br>We previously cited SPLADE, but finally did not cite it due to space limitations in the later stage. We will supplement them in the final version.<br>However, it is worth noting that as long as the signals of the sparse model are within a certain scale and sorted, they can also be applied to our model.<br>2 )<br>We will cite them in the final version and discuss their relationship with our work.<br>The Dense model does not affect the input of our PIN network-the sparse signal, and thus has limited impact.<br>Certainly, a better Dense model will lead to a better HR retrieval effect and thus better end-to-end retrieval effect.</p><p>3 ) We model the problem from the perspective of uplift, so the annotation of the ground truth label is similar.<br>The following table shows the SQuAD dataset. We divide train queries into 4 classes based on retrievability by SR and HR.</p><table><thead><tr><th>class</th><th>HR hit?</th><th>SR hit?</th><th>proportion</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1.73%</td></tr><tr><td>1</td><td>1</td><td>0</td><td>4.71%</td></tr><tr><td>2</td><td>1</td><td>1</td><td>72.73%</td></tr><tr><td>3</td><td>0</td><td>0</td><td>20.81%</td></tr></tbody></table><p>We regard all those with 0 SR hit as positive samples.<br>In our context, the consumption voucher is an HR boost (most of the time, an HR boost can make retrieval better), and the customer is a query. We need to give the consumption voucher to those customers worthy of investment, that is, class 1. Note that we did not exclude class 3. This is because the performance of these queries in term mismatch will be reflected in the Sparse signal, which can reflect the difficulty of the query.<br>An advantage is that it can learn the problems that HR cannot answer but SR can (class 0).<br>On test set, a recall rate of 84.19% can be achieved with only 92% of the cost of HR, exceeding the retrieval quality of pure HR (84.15%).</p><p>We will introduce more details about the training in the final version, especially the label annotation and data distribution.</p><p>4 ) Yes, it is sorted. The task of the retrieval model is to return the top-k most relevant passages which is sorted according to the scores.</p><p>5 ) PIN indeed functions in the QPP process. We will make supplements in section 3 and the caption of figure 2.</p><p>Response to Justification:<br>Thank you for your Justification. We will supplement the relevant work of Sparse and Dense Retrieval models in the final version. We mentioned the training method in the Setup Details in Appendix B, and we will also supplement more detailed modeling and training processes.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 混合检索框架探索（二阶段）</title>
    <link href="/2024/11/14/%E8%AE%B0%E5%BD%95%20-%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%89/"/>
    <url>/2024/11/14/%E8%AE%B0%E5%BD%95%20-%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h2><p>All In　ICDE 論文！<br>頑張るよ！</p><h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><p>Introduction</p><p>传统ANNS算法存在着召回瓶颈，无法达到高召回率。即便是著名的HNSW索引，也难以在大型高维度数据集中达到高召回率。此外，一味地增加索引参数不仅难以达到高召回率（图的稀疏性），更会极大延长构建索引的时间空间开销。更进一步地，在查询与数据库分布一致性未知的情况下，ANNS索引将会遭受更严重的性能损失。</p><p>kNNS exact search则需要极大的成本，0.5M条query在10M x 768dim的数据库中进行kNNS，即便是在96 thread下也需要超过10个小时。<br>随着GPU上的NNS搜索技术的引入，这一过程被极大地加速。但即便是放到GPU上运行，也需要超过10分钟。</p><p>由此可见，在传统ANNS算法和 kNNS exact search 中，存在着相当大的隔阂。<br>因此我们提出了一个异构机器上的混合检索系统，来弥补这个隔阂。<br>考虑到同分布情况下，大部分查询都是简单查询。这些查询在ANNS图索引只需要很少的NDC，就可以达到较高的召回率。而kNNS则近乎一视同仁——无论简单困难都能慢工出细活，达到极高召回率。<br>一种直觉上的想法是尽量发挥ANNS和kNNS各自的优势，即把这些所谓的简单查询分配给ANNS，剩下的困难查询交给GPU。</p><p>具体来说，我们的贡献可以总结如下：</p><ul><li>我们研究了一种全新的问题：异构机器下的混合最近邻检索。我们提出了一种混合检索系统，通过合理地将查询进行路由，将“简单”查询分配给CPU上的HNSW近似索引，剩下的分配给GPU进行暴力搜索。</li><li>我们提出了一种路由模型，来提供快速而精确的查询路由推理。我们针对HNSW索引的检索特点，挖掘了获取成本低，且表现力强的因子来丰富模型。</li><li>我们在5个数据集上进行了大量丰富的实验来验证我们模型的端到端表现。数据集的量级高达10M～100M，维度覆盖96～1024，模态包含文本、图片以及文搜图、图搜文跨模态检索。结果表明我们的混合模型充分利用了CPU和GPU的优势，提供了高QPS高Recall表现。</li></ul><p>Preliminaries</p><p>Experiments</p><p>相关工作：</p><p>ANNS与kNNS。<br>现有的ANNS索引可以分成以下几类：<br>1）划分类，如基于LS Hashing的各种索引，利用哈希函数将向量划分到不同的桶中，使得相似向量有较大概率落入同一桶。最新的工作利用深度学习来进行 Hash。Inverted Files倒排索引类则通常利用聚类，通过索引指向各个聚类，检索时先定位可能的聚类再在聚类内查找相似向量。基于树的划分方法是对数据空间进行划分，以树形结构存储向量，通过比较维度信息来缩小搜索范围。较为出名的有K-D Tree和Ball Tree。<br>2）图搜索类：利用图搜索技术来加速检索。DiskANN可以将索引存储在磁盘上，适用于大规模数据，在磁盘和内存间进行数据交互来完成检索。NSG通过构建特殊的图结构，减少搜索路径长度，有效找到近邻向量。最具代表性的是HNSW，通过构建具有分层结构的图来建立“高速公路”，在图中进行高效搜索。<br>3）量化类：</p><p>在高维度NNS检索背景下，由于curse of dimensionality，ANNS的各种pruning技术将不可避免地造成recall的损失。要想保持高召回率检索，一种方案是提高ANNS index的参数。但是这显然会造成极大的indexing时空开销，例如以M&#x3D;128，efConstruct&#x3D;1000的参数使用HNSW对deep100m进行index，在96线程下花费5小时建立的索引高达31G，最终仍需检索全部向量的28.65%才能达到99.94%的召回率。<br>另一种方案便是使用brute force检索，虽然没有indexing成本，但每进行一条向量的检索就需要进行<code>9.6T</code>次浮点数加法和乘法。<br>值得注意的是，在L2距离和maximum inner product度量下，这一步骤可以转换为矩阵乘法运算，which is GPU所擅长的。</p><p>kNN-join。与我们的工作类似，都是利用异构机器的计算资源来进行高效的NNS。但是一大区别是，他们工作讨论的都是low to moderate dimensionality KNN searches (2–6 dimensions), where ANNS也能取得近似kNNS的召回效果，然而我们讨论的是成百上千维的NNS问题。<br>自从以BERT、CLIP、Vision Transformer等为代表的深度学习模型流行以来，NNS逐渐转向了更高维度的应用，如BERT的768维、BGE-m3的1024维。<br>而这一类工作都是建立在所建立“index”不会带来recall损失的前提下的，并且召回邻居数通常只有几十。<br>在本文中我们所讨论的工作是在高维度dim、高近邻数k以及base向量很多的困难召回场景。</p><p>Out-of-Distribution。在常规的NNS问题中，我们都假定query向量的分布与base向量的分布是一致的。<br>然而，在例如文搜图等跨模态检索场景下，这样的假设是不成立的。<br>跨模态NNS旨在使用一个模态（例如文本）的数据向量作为查询，以检索另一模态（例如图像或视频）中最相似的项。然而，不同模态之间的向量存在固有的分布差异，跨模态查询变成了对数据库中数据的分布偏移（OOD）查询。OOD查询在空间上偏离基础数据，且OOD查询的k个最近邻在高维空间中彼此距离较远。这一属性破坏了现有ANNS索引的假设，因此更加扩大了ANNS和kNNS之间的隔阂。<br>现有的工作提出了利用已知的OOD查询来指导ANNS索引的构建，很大程度上缓解了OOD上召回率的损失。但是这种针对OOD查询专门建index的方法，需要在ANNS侧投入更多的索引构建时间空间投入。</p><p>MTL实盘效果验证：不及原生单分类模型的效果</p><p>新策略：</p><p>HNSW的最大的特点是它确认搜索入口点的方式。<br>起初从结点稀疏的顶层进入，逐层下降来得到基层的入口点。<br>这个逐层下降的过程NDC在44～333之间，平均NDC仅有100+。<br>但是这短短的100+次比较，却十分具有区分度。<br>在“逐层下降 zoom in”的过程中收集特征，效果与在“基层搜索”过程中收集的特征相当。<br>但是收集成本显著更低，ROI更高。</p><p>以往的工作（SIGMOD20早停）采集“基层搜索”的特征——当前时间节点，队列top结点与query的距离。<br>我们提出可以用成本更低的方式，即采集“zoom in”阶段的特征。<br>并且我们额外加入了3个图索引所特有的搜索特征：1）搜索“回退”次数；2）“逐层下降”阶段的NDC；3）搜索更新最优距离的次数</p><p>还有个好处是可以把“逐层下降”得到的结果——入口点，以极低的成本和二阶段的正式搜索对接。<br>如果是采集“基层搜索”过程的特征，有两个缺点：<br>1）采集特征需要执行更高的NDC，这会拖累决策推理速度。<br>2）“基层搜索”的中间结果为队列、搜索过的点集合，与二阶段正式搜索对接成本高于“zoom in”的对接。后者仅需对接搜索入口点即可。</p><p>实验结果表明，我们的决策效果显著优于仅用查询作为特征的方法。<br>我们首次在OOD数据集上进行了验证，证明了因子和特征对于ood查询也是有辨识度的，更进一步地证明了我们因子选择的重要性。</p><h2 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h2><p>avg score：只考虑总recall &gt; 80%部分的召回点，取平均</p><p>0.5%budget打点</p><p>full_feat &#x3D; qonly + dist_feat + update_feat</p><p>cross_topk &#x3D; 将qonly所有维度中方差最大的topk个维度拿出来，做二阶交叉，得到新的<code>topk * (topk - 1) / 2</code></p><p>MTL_fusion &#x3D; 同时预测 原有的二分类得分 + log2的NDC（SIGMOD20早停论文中已经被证实有效）。两者相乘作为最终得分。但是目前是两个模型分别训练。<br>欠点：存在一定偏差性 + 推理成本翻倍。<br>难点：MTL版本的LightGBM只支持统一目标，比如3个分类head &#x2F; 3个回归head。而我们的任务是二分类 + 回归</p><p>MTL Sort模块：接在召回模块之后。通常用<strong>同一个模型</strong>来做multi-task-learning，共享bottom、特征提取部分，分出多个head，做多个目标的预测。最终这多个目标的得分根据一定的公式得到最终得分，用来排序</p><table><thead><tr><th>method</th><th>full_feat</th><th>qonly</th><th>MTL_fusion</th><th>cross_25</th></tr></thead><tbody><tr><td>thr_600</td><td>924.79</td><td>916.63</td><td>916.65</td><td>916.42</td></tr><tr><td>thr_680</td><td></td><td>920.89</td><td>921.80</td><td></td></tr><tr><td>thr_690</td><td></td><td>920.88</td><td>924.68</td><td></td></tr><tr><td>thr_700</td><td>927.82</td><td>920.73</td><td>927.40（？）</td><td>920.75</td></tr><tr><td>thr_710</td><td></td><td>920.57</td><td>930.02（？）</td><td></td></tr><tr><td>thr_720</td><td></td><td>921.24</td><td>930.62</td><td></td></tr><tr><td>thr_730</td><td></td><td>921.03</td><td>929.55</td><td></td></tr><tr><td>thr_800</td><td>923.73</td><td>918.59</td><td>920.57</td><td>918.43</td></tr></tbody></table><blockquote><p>P.S. 目前只是打点得分，并没有进行端到端 QPS-recall测试</p></blockquote><p>获取 dist_feat + update_feat 成本过高<br>用ANNS，根据query找到train中的近似样本，用近似样本的特征来近似。</p><p>预测效果不如qonly</p><h2 id="11-03"><a href="#11-03" class="headerlink" title="11.03"></a>11.03</h2><p>用户量级，用户个体一旦fail，体验感灾难性。</p><p>加到6个数据集</p><p>skyline算法<br>一对一的 multi-vector search</p><p>采样一部分query，将他们图搜特征的中位数 &#x2F; 平均数作为在线特征</p><h3 id="11-02-优化端到端表现"><a href="#11-02-优化端到端表现" class="headerlink" title="11.02 优化端到端表现"></a>11.02 优化端到端表现</h3><p>将第一阶段，NDC从 0 -&gt; check_stamp 的中间结果保存。<br>lightgbm推理后，直接从中间结果继续搜索。</p><p>如果 内存交换时间 &lt; 0 -&gt; check_stamp的搜索时间，就会有提升效果</p><p>DEBUG：没有把正确的qid传给 stage 2的搜索过程。</p><p>出现问题：在CPU瓶颈（HNSW的完成时间 &gt; GPU）的阶段<br>结论：&#x3D;&#x3D;CPU瓶颈越早出现，效果越好！&#x3D;&#x3D;<br>解决方案：</p><ol><li>将HNSW的线程数调小（？）</li><li>将建图参数调大</li></ol><h3 id="11-01-特征选择-端到端实现"><a href="#11-01-特征选择-端到端实现" class="headerlink" title="11.01  特征选择 + 端到端实现"></a>11.01  特征选择 + 端到端实现</h3><p>feat_dist：用绝对距离<code>check_candidates[i].first</code>优于相对距离<code>check_candidates[i].first / dist_start</code></p><h3 id="10-30-下午讨论结果"><a href="#10-30-下午讨论结果" class="headerlink" title="10.30 下午讨论结果"></a>10.30 下午讨论结果</h3><p>contribution</p><ol><li>异构计算资源 CPU GPU。新的问题，给定有限的GPU和CPU计算资源，如何route达到高召回、</li><li>learning方法图索引难度。<br> &#x3D;&#x3D;能否在OOD数据集上生效？&#x3D;&#x3D;</li><li>图特有的特征：回溯次数、更新次数</li><li>大量实验，数据集丰富：<ol><li>规模从1m到100m</li><li>文本、图片以及跨模态</li><li>不同的距离度量：L2以及InnerProduct</li><li>维度从96到1024</li></ol></li></ol><p>参数：</p><ol><li>check_stamp</li><li>分配阈值</li><li>计算资源，索引参数、数据分布</li><li>训练样本数量</li></ol><h3 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h3><p>feat_query: dim维<br>feat_dist: 100维<br>feat_update: 3维</p><p>当前统计法：以feat_dist为例，计算的是100个feat_importance的平均值</p><h3 id="数据集更新"><a href="#数据集更新" class="headerlink" title="数据集更新"></a>数据集更新</h3><h4 id="deep100m-96d"><a href="#deep100m-96d" class="headerlink" title="deep100m 96d"></a>deep100m 96d</h4><p>fvecs格式下，base.norm大小为37G。A6000显存48G，能塞得下✅</p><h4 id="datacomp-CLIP-768d"><a href="#datacomp-CLIP-768d" class="headerlink" title="datacomp-CLIP 768d"></a>datacomp-CLIP 768d</h4><p>新增数据集 <a href="https://hf-mirror.com/datasets/nielsr/datacomp-small-with-embeddings">datacomp-small-with-embeddings</a>。<br>基于clip模型，共10M行，每一行对应一张图片 &amp; 其对应描述 和 text_embedding &amp; image_embedding。</p><p>跨模态检索：文搜图<br>以10M条image_embedding作为base向量建HNSW，用10k条text_embedding检索。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">index_path: /data/guohaoran/HNNS/index/datacomp-image.M_48.efc_1000.hnsw<br>num_test: 10000<br>Build Time: 2.1e-07<br>Search 836 / 10000<br>[Query][HNSW] Params: M: 48, efSearch: 1000<br>[Query][HNSW] Using GT from file: /data/guohaoran/HNNS/query/datacomp//query.norm.gt.ivecs.cpu.1000<br>[Query][HNSW] Search time: 3.24526<br>[Query][HNSW] Recall@1000: 0.727616<br></code></pre></td></tr></table></figure><p>结论：发生OOD现象。将M增大至128，recall@1000更是降低到69%。</p><p>是否需要保留OOD数据集？</p><p>CPUFlat [[记录 - 信息检索探索（二阶段）#^ad2371]]</p><h4 id="imagenet-768d（移除？❌）"><a href="#imagenet-768d（移除？❌）" class="headerlink" title="imagenet 768d（移除？❌）"></a>imagenet 768d（移除？❌）</h4><p>imagenet在GPUFlat [[记录 - 信息检索探索（二阶段）#^4a7874]]和HNSW高参数下存在少量向量极难被检索。</p><p><del>GPUFlat在recall@1000下无法与CPU保持一致。</del><br>以上现象普遍存在。</p><h3 id="GPUFlat（kselect-1024）"><a href="#GPUFlat（kselect-1024）" class="headerlink" title="GPUFlat（kselect&#x3D;1024）"></a>GPUFlat（kselect&#x3D;1024）</h3><p>datacomp-image 10M 768d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td></td><td></td><td></td><td></td></tr><tr><td>1000</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>gist 1M 960d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td>0.997</td><td></td><td>0.995</td><td></td></tr><tr><td>10</td><td>0.9991</td><td></td><td>0.9994</td><td></td></tr><tr><td>100</td><td>0.99988</td><td></td><td>0.99985</td><td></td></tr><tr><td>1000</td><td>0.999967</td><td></td><td>0.999964</td><td>0.175949</td></tr></tbody></table><p>imagenet 10M 768d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td>0.9911</td><td></td><td>0.9958</td><td></td></tr><tr><td>10</td><td>0.99671</td><td></td><td>0.99675</td><td></td></tr><tr><td>100</td><td>0.999452</td><td></td><td>0.999351</td><td></td></tr><tr><td>1000</td><td>0.999727</td><td>137.739</td><td>0.999464</td><td>11.1365</td></tr></tbody></table><p>wikipedia 10M 1024d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td></td><td></td><td></td><td></td></tr><tr><td>1000</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>deep100m 96d<br>train 1M 无法全量，显存只够查询0.25M。</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td></td><td></td><td></td><td></td></tr><tr><td>100</td><td></td><td></td><td></td><td></td></tr><tr><td>1000（1024 select）</td><td></td><td></td><td></td><td></td></tr><tr><td>1000（2048 select）</td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="10-27"><a href="#10-27" class="headerlink" title="10.27"></a>10.27</h2><h3 id="考え（かんがえ）"><a href="#考え（かんがえ）" class="headerlink" title="考え（かんがえ）"></a>考え（かんがえ）</h3><ul><li>多线程建图，图性能损失</li><li>GPU矩阵乘法的精度 vs CPU</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>医疗、金融风控 ANNS。<ul><li>在医学影像分析中，可以通过对大量已标注的影像数据进行学习，当出现新的影像时，能够找到与该影像特征相似的样本，从而辅助医生进行诊断决策。</li><li>在金融风控领域，也可以通过对大量客户数据的学习，找到与新客户特征相似的已有客户，从而评估新客户的风险水平。</li></ul></li><li>大规模GPU召回</li><li>XML（Extreme Multi-label Learning，极限多标签学习）<ul><li>任务处理的是具有大量标签的分类问题</li><li>每个样本可能与多个标签相关联</li><li>标签的总数可能达到成千上万</li><li>推理时，参考样本 # base越多，近邻数k越大，效果一般越好</li></ul></li></ul><h3 id="GPUFLat-分析与精简"><a href="#GPUFLat-分析与精简" class="headerlink" title="GPUFLat 分析与精简"></a>GPUFLat 分析与精简</h3><p>Q：GPUFlat与CPUFlat的结果为何存在出入？<br>A：CPUFlat的计算方式为 <code>for d in dim</code> 循环累加。误差来源于double + float之间的累加；<br>GPUFlat的计算方式为矩阵乘法，乘法次数和加法次数与CPU相比未知。</p><p>Q：以谁为准（作为GroundTruth）？<br>A：CPUFlat。</p><p>10.22 抽丝剥茧环节基本结束</p><h3 id="GroundTruth搜索数据"><a href="#GroundTruth搜索数据" class="headerlink" title="GroundTruth搜索数据"></a>GroundTruth搜索数据</h3><p>^ad2371</p><p>gist1m</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br><span class="hljs-keyword">time:</span> 1886.34s<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br><span class="hljs-keyword">time:</span> 4.8691s<br>cores: 96<br></code></pre></td></tr></table></figure><p>imagenet</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 19441.9s<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 2200.28s<br>cores: 96<br></code></pre></td></tr></table></figure><p>wikipedia</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 36911.1<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 3036.28<br>cores: 96<br></code></pre></td></tr></table></figure><p>datacomp-image 10M 768d<br>query: datacomp-text</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 37383.7<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 694.926<br>cores: 96<br></code></pre></td></tr></table></figure><p>query: datacomp-image</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: <br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 2692.25<br>cores: 96<br></code></pre></td></tr></table></figure><p>datacomp-text 10M 768d<br>query: datacomp-image</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 37758.5<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 2046.11<br>cores: 96<br></code></pre></td></tr></table></figure><p>query: datacomp-text</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: <br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: <br>cores: 96<br></code></pre></td></tr></table></figure><p>datacomp-combined 10M 1536 d<br>query: datacomp-combined</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: <br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 3864.86<br>cores: 96<br></code></pre></td></tr></table></figure><p>deep100m 96d</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 118717<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: 3265.83<br>cores: 96<br></code></pre></td></tr></table></figure><p>SPACEV 100d</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: learn <br># vectors: 500K <br>recall_k: 1000<br>time: 136484<br>cores: 96<br><br>data_split: query <br># vectors: 10K <br>recall_k: 1000<br>time: <br>cores: 96<br></code></pre></td></tr></table></figure><h3 id="建图数据"><a href="#建图数据" class="headerlink" title="建图数据"></a>建图数据</h3><p><a href="https://github.com/erikbern/ann-benchmarks/blob/main/ann_benchmarks/algorithms/hnswlib/config.yml">ANN Benchmark</a></p><p><code>efconstruct == efsearch</code></p><p>gist1m 960d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th><th>size</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>96</td><td>256.912</td><td>118M</td></tr><tr><td>48</td><td>1000</td><td>96</td><td>303.864</td><td>131M</td></tr><tr><td>64</td><td>1000</td><td>96</td><td>306.888</td><td>137M</td></tr><tr><td>96</td><td>1000</td><td>96</td><td>317.833</td><td>142M</td></tr><tr><td>128</td><td>1000</td><td>96</td><td>309.673</td><td>143M</td></tr><tr><td>256</td><td>1000</td><td>96</td><td>330.769</td><td>143M</td></tr></tbody></table><p>imagenet 10M 768d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th><th>size</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>96</td><td>1270.36</td><td>1.3G</td></tr><tr><td>48</td><td>1000</td><td>96</td><td>1335.19</td><td>1.4G</td></tr><tr><td>64</td><td>1000</td><td>96</td><td>1376.5</td><td>1.4G</td></tr><tr><td>96</td><td>1000</td><td>96</td><td></td><td>1.4G</td></tr><tr><td>128</td><td>1000</td><td>96</td><td>1428.77</td><td>1.4G</td></tr></tbody></table><p>wikipedia 10M  1024d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th></tr></thead><tbody><tr><td>16</td><td>1000</td><td>96</td><td>2767</td></tr><tr><td>32</td><td>1000</td><td>96</td><td>4431.62</td></tr><tr><td>48</td><td>1000</td><td>96</td><td>5492.39</td></tr><tr><td>64</td><td>1000</td><td>96</td><td>6153.54</td></tr><tr><td>96</td><td>1000</td><td>96</td><td>6781.29</td></tr><tr><td>128</td><td>1000</td><td>96</td><td>7084.53</td></tr><tr><td></td><td></td><td></td><td>7456.89</td></tr></tbody></table><p>datacomp-image 10M  768d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>96</td><td>1887.43</td></tr><tr><td>48</td><td>1000</td><td>96</td><td>2090.48</td></tr><tr><td>64</td><td>1000</td><td>96</td><td></td></tr><tr><td>96</td><td>1000</td><td>96</td><td></td></tr><tr><td>128</td><td>1000</td><td>96</td><td></td></tr></tbody></table><p>deep100m 96d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>96</td><td>14019.8</td></tr><tr><td>48</td><td>1000</td><td>96</td><td></td></tr><tr><td>64</td><td>1000</td><td>96</td><td></td></tr><tr><td>96</td><td>1000</td><td>96</td><td></td></tr><tr><td>128</td><td>1000</td><td>96</td><td>17933</td></tr></tbody></table><p>spacev100m 100d</p><table><thead><tr><th>M</th><th>ef_construct</th><th># thread</th><th>time</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>96</td><td>30943</td></tr><tr><td>48</td><td>1000</td><td>96</td><td></td></tr><tr><td>64</td><td>1000</td><td>96</td><td></td></tr><tr><td>96</td><td>1000</td><td>96</td><td></td></tr><tr><td>128</td><td>1000</td><td>96</td><td></td></tr></tbody></table><h3 id="GPUFLat-数据（depreciated）"><a href="#GPUFLat-数据（depreciated）" class="headerlink" title="GPUFLat 数据（depreciated）"></a>GPUFLat 数据（depreciated）</h3><p>^4a7874</p><p>gist 1M 960d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td>0.999960</td><td>54.3132&#x2F;54.4417&#x2F;54.7458</td><td>1</td><td>0.156648&#x2F;0.150908&#x2F;0.15616</td></tr><tr><td>10</td><td>0.998689</td><td>54.8549&#x2F;55.1605&#x2F;54.6921</td><td>0.999200</td><td>0.158231&#x2F;0.160197&#x2F;0.155859</td></tr><tr><td>100</td><td>0.999845</td><td>56.5907&#x2F;56.2320&#x2F;56.2018</td><td>0.999810</td><td>0.208489&#x2F;0.15984&#x2F;0.161549</td></tr><tr><td>1000</td><td>0.999961</td><td>64.6821&#x2F;65.2319&#x2F;65.3669</td><td>0.999963</td><td>0.176541&#x2F;0.175003&#x2F;0.172843</td></tr></tbody></table><p>imagenet 10M 768d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td>0.931518</td><td>453.385&#x2F;451.547&#x2F;451.811</td><td>0.955000</td><td>8.8142&#x2F;8.79696&#x2F;8.79121</td></tr><tr><td>10</td><td>0.994679</td><td>454.876&#x2F;454.66&#x2F;452.106</td><td>0.996050</td><td>8.95321&#x2F;8.83573&#x2F;8.8199</td></tr><tr><td>100</td><td>0.999175</td><td>476.927&#x2F;460.545&#x2F;460.727</td><td>0.999115</td><td>9.16091&#x2F;9.15087&#x2F;9.0416</td></tr><tr><td>1000</td><td>0.999701</td><td>599.089&#x2F;570.655&#x2F;565.609</td><td>0.999423</td><td>11.2577&#x2F;11.8291&#x2F;11.1889</td></tr></tbody></table><p>wikipedia 10M 1024d</p><table><thead><tr><th>k</th><th>train recall@k</th><th>train time (s)</th><th>query recall@k</th><th>query time (s)</th></tr></thead><tbody><tr><td>1</td><td>0.999816</td><td>601.338&#x2F;600.813&#x2F;600.462</td><td>0.999600</td><td>11.8147&#x2F;11.8079&#x2F;11.707</td></tr><tr><td>10</td><td>0.999957</td><td>603.516&#x2F;602.828&#x2F;603.36</td><td>0.999950</td><td>11.7984&#x2F;11.7992&#x2F;11.7448</td></tr><tr><td>100</td><td>0.999990</td><td>613.853&#x2F;612.5&#x2F;612.988</td><td>0.999986</td><td>12.0125&#x2F;11.9544&#x2F;11.9426</td></tr><tr><td>1000</td><td>0.999993</td><td>732.101&#x2F;731.671&#x2F;728.928</td><td>0.999993</td><td>14.3147&#x2F;14.2636&#x2F;14.2045</td></tr></tbody></table><h3 id="图搜数据"><a href="#图搜数据" class="headerlink" title="图搜数据"></a>图搜数据</h3><p>gist 1M  960d  0.5M Train</p><table><thead><tr><th>M</th><th>ef_search</th><th># NDC</th><th>query R@1</th><th>query R@10</th><th>query R@100</th><th>query R@1000</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>23807.5</td><td>0.997672</td><td>0.997861</td><td>0.995402</td><td>0.977185</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>48</td><td>1000</td><td>27675.7</td><td>0.99845</td><td>0.99865</td><td>0.997169</td><td>0.985006</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>1000</td><td>29905.8</td><td>0.998728</td><td>0.998925</td><td>0.997761</td><td>0.987761</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>96</td><td>1000</td><td>32199.4</td><td>0.998962</td><td>0.999099</td><td>0.998116</td><td>0.989472</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>128</td><td>1000</td><td>33102.2</td><td>0.99903</td><td>0.999157</td><td>0.99824</td><td>0.990018</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>68231.4</td><td>0.99966</td><td>0.999788</td><td>0.999726</td><td>0.99899</td></tr><tr><td>256</td><td>1000</td><td>33830.3</td><td>0.999098</td><td>0.99921</td><td>0.998363</td><td>0.990482</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>&#x3D;&#x3D;3000&#x3D;&#x3D;</td><td>69427.9</td><td>0.999688</td><td>0.999811</td><td>0.999763</td><td>0.999098</td></tr></tbody></table><p>imagenet 10M  768d  0.5M Train</p><table><thead><tr><th>M</th><th>ef_search</th><th># NDC</th><th>query R@1</th><th>query R@10</th><th>query R@100</th><th>query R@1000</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>13514.7</td><td>0.998534</td><td>0.99879</td><td>0.998761</td><td>0.994057</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>48</td><td>1000</td><td>14973.7</td><td>0.998722</td><td>0.998971</td><td>0.998992</td><td>0.995304</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>1000</td><td>15668.7</td><td>0.998806</td><td>0.999037</td><td>0.99905</td><td>0.995674</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>37390.7</td><td>0.999192</td><td>0.999315</td><td>0.999372</td><td>0.999151</td></tr><tr><td>96</td><td>1000</td><td>16123.2</td><td>0.998958</td><td>0.999187</td><td>0.999436</td><td>0.996225</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>&#x3D;&#x3D;3000&#x3D;&#x3D;</td><td>38504.8</td><td>0.999334</td><td>0.999445</td><td>0.99973</td><td>0.999542</td></tr><tr><td>128</td><td>1000</td><td>16238.4</td><td>0.998892</td><td>0.999129</td><td>0.999145</td><td>0.995935</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>38793.1</td><td>0.999298</td><td>0.999419</td><td>0.999473</td><td>0.99925</td></tr></tbody></table><p>wikipedia 10M  1024d  0.5M Train</p><table><thead><tr><th>M</th><th>ef_search</th><th># NDC</th><th>query R@1</th><th>query R@10</th><th>query R@100</th><th>query R@1000</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>35857.2</td><td>0.9974</td><td>0.997157</td><td>0.992503</td><td>0.95115</td></tr><tr><td></td><td>2000</td><td>64470.6</td><td>0.99893</td><td>0.998886</td><td>0.997506</td><td>0.982482</td></tr><tr><td></td><td>3000</td><td>90485.5</td><td>0.99938</td><td>0.999363</td><td>0.99872</td><td>0.990995</td></tr><tr><td>48</td><td>1000</td><td>45798</td><td>0.998554</td><td>0.998562</td><td>0.9959</td><td>0.967415</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>1000</td><td>52376.8</td><td>0.99886</td><td>0.998976</td><td>0.997115</td><td>0.974716</td></tr><tr><td></td><td>2000</td><td>93114.2</td><td>0.999588</td><td>0.999635</td><td>0.999193</td><td>0.992416</td></tr><tr><td></td><td>3000</td><td>129674</td><td>0.999772</td><td>0.999789</td><td>0.999614</td><td>0.996506</td></tr><tr><td>96</td><td>1000</td><td>60255.4</td><td>0.999186</td><td>0.999252</td><td>0.99797</td><td>0.980642</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>147959</td><td>0.999838</td><td>0.999835</td><td>0.99973</td><td>0.997501</td></tr><tr><td>128</td><td>1000</td><td>64441.1</td><td>0.999224</td><td>0.999333</td><td>0.998219</td><td>0.982658</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>157619</td><td>0.99983</td><td>0.999844</td><td>0.999759</td><td>0.997807</td></tr><tr><td>256</td><td>1000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>167695</td><td>0.999868</td><td>0.999865</td><td>0.999781</td><td>0.998002</td></tr></tbody></table><p>deep100m  96d  1M Train</p><table><thead><tr><th>M</th><th>ef_search</th><th># NDC</th><th>query R@1</th><th>query R@10</th><th>query R@100</th><th>query R@1000</th></tr></thead><tbody><tr><td>32</td><td>1000</td><td>30764.6</td><td>0.9989</td><td>0.99878</td><td>0.996928</td><td>0.978704</td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td>75789</td><td>0.9991</td><td>0.99911</td><td>0.998942</td><td>0.997054</td></tr><tr><td>48</td><td>1000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>64</td><td>1000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>96</td><td>1000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>128</td><td>1000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3000</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>10000</td><td>286450</td><td>0.999435</td><td>0.999385</td><td>0.99937</td><td>0.999405</td></tr></tbody></table><h3 id="欠点（けってん-ketten）があります"><a href="#欠点（けってん-ketten）があります" class="headerlink" title="欠点（けってん　ketten）があります"></a>欠点（けってん　ketten）があります</h3><p>label的规则。目前是把不能做到100%Recall的Q当成正样本。</p><p>可是在Recall@1000这种极端情况下，正样本的比例会达到50%以上。<br>在只有50% GPU Budget下，难以召回大部份正样本。</p><p>设置一个阈值thr，将<code>召回数量 &lt; thr</code>的样本label为1，反之为0</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>将查询Q集合分为两部份：$Q_C$和$Q_G$，前者由CPU HNSW多线程搜索，后者由GPUFlat基于矩阵乘法搜索。<br>默认$Q_C$和$Q_G$为1:1。</p><p>$Q_G$的QPS固定，问题在于如何分配最少的CPU资源（线程数），使得$Q_C$的QPS能接近$Q_G$。<br>这样$Q_C$和$Q_G$完成的总用时最少。<br>同时在此问题上下文中，我们还需要考虑$Q_C$的召回率。</p><p>motivation：将 NDC大的 &#x2F; 无法达到高召回率阈值thr的 Q交给GPU，其余简单查询交给CPU。</p><p>利用HNNS-Core进行分配。</p><h3 id="实验结果（非端到端-R-1000）"><a href="#实验结果（非端到端-R-1000）" class="headerlink" title="实验结果（非端到端 R@1000）"></a>实验结果（非端到端 R@1000）</h3><p>gist 1M 960d 1k Test</p><table><thead><tr><th>thr</th><th># NDC all</th><th># below thr</th><th># $Q_C$</th><th># $Q_G$</th><th># NDC CPU</th><th># NDC GPU</th><th># CPU miss</th><th>AUC (R vs Budget)</th><th>R@1000</th></tr></thead><tbody><tr><td>999</td><td>71922.43</td><td>138</td><td>503</td><td>497</td><td>64237.26</td><td>79700.38</td><td>0 &#x2F; 138</td><td>0.8872</td><td></td></tr><tr><td>1000</td><td>71922.43</td><td>282</td><td>494</td><td>506</td><td>64079.93</td><td>79578.95</td><td>25 &#x2F; 282</td><td>0.7829</td><td></td></tr></tbody></table><p>imagenet 10M 768d 10k Test</p><table><thead><tr><th>thr</th><th># NDC all</th><th># below thr</th><th># $Q_C$</th><th># $Q_G$</th><th># NDC CPU</th><th># NDC GPU</th><th># CPU miss</th><th>AUC (R vs Budget)</th><th>R@HNSW</th><th>R@CPU</th><th>R@GPU</th><th>R@HNNS</th></tr></thead><tbody><tr><td>999</td><td>43268.65</td><td>376</td><td>4825</td><td>5175</td><td>36059.25</td><td>49990.46</td><td>2 &#x2F; 376</td><td>0.9468</td><td>0.999542</td><td>0.999995</td><td>&#x3D;&#x3D;0.9989340&#x3D;&#x3D;</td><td>0.9994461</td></tr><tr><td>1000</td><td>43268.65</td><td>913</td><td>4658</td><td>5342</td><td>35651.92</td><td>49910.12</td><td>14 &#x2F; 913</td><td>0.8926</td><td>0.999542</td><td>0.999997</td><td>&#x3D;&#x3D;0.9980967&#x3D;&#x3D;</td><td>0.9994467</td></tr></tbody></table><p>wikipedia 10M 1024d 10k Test</p><table><thead><tr><th>thr</th><th># NDC all</th><th># below thr</th><th># $Q_C$</th><th># $Q_G$</th><th># NDC CPU</th><th># NDC GPU</th><th># CPU miss</th><th>AUC (R vs Budget)</th><th>R@1000</th></tr></thead><tbody><tr><td>999</td><td>156330.61</td><td>3374</td><td>5028</td><td>4972</td><td>123977.30</td><td>189048.31</td><td>236 &#x2F; 3374</td><td>0.7796</td><td></td></tr><tr><td>1000</td><td>156330.61</td><td>5188</td><td>5095</td><td>4905</td><td>124399.18</td><td>189498.93</td><td>1134 &#x2F; 5188</td><td>0.6864</td><td></td></tr></tbody></table><p>结论：R@HNNS 介于 R@GPU和R@HNSW 之间，其中<code>R@GPU &lt; R@HNSW</code>！</p><p>最大难点：无法解决R@GPU的精度问题</p><p>解决方案：</p><ol><li>以GPUFlat作为GT</li><li>爆改GPUFlat，</li></ol><p>Q：为何既能同时提高CPU侧的R@1000，又能降低CPU侧的NDC呢？<br>A：两者基本成正相关。</p><p><img src="https://img.picgo.net/2024/10/26/imagebc2030de1939ce89.png" alt="image"></p><h2 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h2><h3 id="Closing-the-gap-between-ANNS-and-kNNS-混合ANNS索引"><a href="#Closing-the-gap-between-ANNS-and-kNNS-混合ANNS索引" class="headerlink" title="Closing the gap between ANNS and kNNS - 混合ANNS索引"></a>Closing the gap between ANNS and kNNS - 混合ANNS索引</h3><p>ANNS速度快，但很难召回100%的answer。<br>通常情况：5~30ms &#x2F; query</p><p>比如图索引连通性不够，参数再大也没法达到100%；<br>IVF得搜很多簇，相当于暴搜时间慢</p><p>如今互联网企业已经尝试使用GPU集群进行召回：美团、字节跳动。<br>通常情况：A6000单卡，batch_size&#x3D;1，每个查询需要60ms。<br>优点是没有召回率损失，但成本高。</p><p>能否结合GPU kNNS + CPU ANNS的优势，实现高召回率 + 高QPS？</p><p>应用场景：</p><ol><li>医疗、金融风控 ANNS</li><li>大规模GPU召回</li></ol><p>cost effective</p><p>GPU kNNS视角：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs erlang">能否将一些简单查询分配给CPU ANNS？<br><br>这些简单查询即使是用ANNS，也能接近<span class="hljs-number">100</span><span class="hljs-comment">%召回，并且速度比GPU kNNS更快。</span><br><br>这样既能保持极高召回率，还能减轻GPU负担，提高总体qps<br><br>预测特征：只有<span class="hljs-keyword">query</span>向量本身，预测精度难以保证。<br></code></pre></td></tr></table></figure><p>CPU ANNS视角：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs erlang">能否将一些困难查询分配给GPU kNNS？<br><br>这些困难查询就能保证<span class="hljs-number">100</span><span class="hljs-comment">%召回。</span><br><br>从而破解纯ANNS无法达到极高召回的难题。<br><br>预测特征：<span class="hljs-keyword">query</span>向量本身 + 当前候选的距离。（还可以加入更多特征，比如Bert的cluster id特征）<br></code></pre></td></tr></table></figure><h3 id="背景-10-20-updated"><a href="#背景-10-20-updated" class="headerlink" title="背景 10.20 updated"></a>背景 10.20 updated</h3><p>链接：<a href="https://zhuanlan.zhihu.com/p/438753577">Faiss on GPU&#x2F;CPU</a><br><img src="https://pic2.zhimg.com/v2-1b01cc54b3a5fe5dd34045cd71b11239_b.jpg" alt="ANNS覆盖"></p><p>可以看到GPU上的Faiss没能覆盖Faiss中的全部的算法，这是因为HNSW等算法对GPU是天然不亲和的。GPU在传统深度学习和数据挖掘中扮演计算密集型的算术优化器的角色，在一个NN网络中（如ResNet、VGG等），超过95%的计算量都来自于各种方式的<strong>矩阵计算</strong>（卷积、全连接等），所以GPU才能在这些领域大放异彩。</p><p>然而和高性能计算相对应的，则是GPU孱弱的的程序控制和跳转能力，对于HNSW等算法，我们几乎无时无刻都需要在一套精巧的算法中判断和跳转（是否在当前layer进行搜索、对于当前的candidates是否完成遍历、是否进行启发式搜索等），所以自然难以在GPU上最大程度的发挥GPU的能力。</p><p>GPU作为老师，CPU是学生，一起完成作业。</p><p>高召回率背景：</p><p>CPU学生做得慢且不完全准确，但是人&#x2F;cores可以有很多。每人每秒钟可以做20～100个作业。</p><p>GPU老师任何查询都能 做得快且完全准确。每秒钟最多可以做接近1000个作业，与batch_size有关。</p><p>CPU学生计划将困难作业分给GPU老师做，困难作业指的是：</p><ul><li>学生做得慢（比较次数多）</li><li>做得差（召回率低）</li></ul><p>但是首先学生要从老师的“标准答案”（以上两个label训练）中“学习”如何区分困难查询</p><p>预期目标：学生做他们擅长的 得分率高且做得快的作业；老师做学生不擅长做的。</p><p>两者负载均衡，且整体得分率高</p><h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><p>新加入：</p><p>搜索回退次数<br>下限更新次数<br>队列pop次数</p><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>gist1m</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br>data_split: query <br># vectors: 10K <br>recall_k: 100<br>time: <br>cores: 128<br><br><br>data_split: learn <br># vectors: 500K <br>recall_k: 100<br>time: <br>cores: 128<br><br></code></pre></td></tr></table></figure><p>imagenet ground_truth</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: query<br># vectors: 10K <br>recall_k: 100<br>time: 2888.13<br>cores: 128<br><br><br>data_split: learn <br># vectors: 500K <br>recall_k: 100<br>time: 31990.1s<br>cores: 128<br><br></code></pre></td></tr></table></figure><p>wikipedia ground_truth</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">data_split: query <br># vectors: 10K <br>recall_k: 100<br>time: <br>cores: 128<br><br><br>data_split: learn <br># vectors: 500K <br>recall_k: 100<br>time: 29783.1s<br>cores: 128<br><br></code></pre></td></tr></table></figure><h3 id="CPU算法选择"><a href="#CPU算法选择" class="headerlink" title="CPU算法选择"></a>CPU算法选择</h3><ul><li><input checked="" disabled="" type="checkbox"> HNSW</li><li><input disabled="" type="checkbox"> Vamana</li><li><input disabled="" type="checkbox"> NSG</li></ul><h3 id="GPU暴搜"><a href="#GPU暴搜" class="headerlink" title="GPU暴搜"></a>GPU暴搜</h3><p>toy版本：github上<a href="https://github.com/vincentfpgarcia/kNN-CUDA">kNN-CUDA</a>修改版，召回率100%，但速度很慢</p><p>faiss版本：<strong>极其难以修改</strong>，召回率99.999%，但在10M x 1024的数据集上 QPS近1000。<br>昨晚刚刚分离出可运行版本。目前最大的困难</p><h2 id="10-13"><a href="#10-13" class="headerlink" title="10.13"></a>10.13</h2><h3 id="数据集调查"><a href="#数据集调查" class="headerlink" title="数据集调查"></a>数据集调查</h3><table><thead><tr><th>dataset</th><th># embeds</th><th># dimension</th><th>encoder model</th></tr></thead><tbody><tr><td>imagenet</td><td>13M</td><td>768</td><td>Vision Transformer</td></tr><tr><td>GIST1M</td><td>1M</td><td>960</td><td></td></tr><tr><td>wikipedia</td><td>42.5M</td><td>1024</td><td>BGE-m3</td></tr></tbody></table><h3 id="Findings"><a href="#Findings" class="headerlink" title="Findings"></a>Findings</h3><p>仅在DistilBert级别以上的Bert能超过lightgbm</p><p>GIST1M上的实验结果。<br>实验参数：<code>M=16, efSearch=500, check_stamp=1000, num_tokens=8192</code><br>建图参数较小，无法达到很高的recall</p><table><thead><tr><th>baseline</th><th>RMSE</th><th>MAE</th><th>inference time</th></tr></thead><tbody><tr><td>lightgbm</td><td>0.1214</td><td>0.0915</td><td><strong>0.0134</strong></td></tr><tr><td>DistilBert</td><td><strong>0.1004</strong></td><td><strong>0.0738</strong></td><td>0.6950</td></tr><tr><td>TinyBert</td><td>0.1186</td><td>0.0906</td><td>0.5460</td></tr><tr><td>num_tokens&#x3D;8192的效果优于4096，应该存在某个最优的cluster&#x2F;token参数</td><td></td><td></td><td></td></tr></tbody></table><p>建图参数越大，能达到的召回率上限越高，Bert预测的准确度应该会跟lightgbm拉开差距</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>只发现在GIST这样960维的高维数据集上，存在优势</p><p>实际端到端加速效果还未知</p><p>我们这种方法不局限于图索引，IVF方法同样适用。</p><p>本质是提出了一种新的难度预测&#x2F;早停范式，与数据集维度解耦，而只与当前搜索的中间结果的所在位置有关。</p><p>预测工具不局限于Bert，只要是能做token序列分类的模型理论上都能用。比如LSTM。</p><p><code>M=64, efConstruct=1000</code></p><table><thead><tr><th>efSearch</th><th>recall@100</th><th>time</th><th>comparison</th></tr></thead><tbody><tr><td>4000</td><td>0.998057</td><td>421.299</td><td>53291.7</td></tr><tr><td>2500</td><td>0.998042</td><td>299.477</td><td>36215.7</td></tr><tr><td>2250</td><td>0.997934</td><td>421.864</td><td>33222.5</td></tr><tr><td>2000</td><td>0.997928</td><td>247.026</td><td>30177.1</td></tr><tr><td>1500</td><td>0.997798</td><td>201.132</td><td>23869.5</td></tr><tr><td><code>M=128, efConstruct=1000</code></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>efSearch</th><th>recall@100</th><th>time</th><th>comparison</th></tr></thead><tbody><tr><td>5000</td><td>0.998575</td><td>523.454</td><td>66928.3</td></tr><tr><td>3000</td><td>0.998474</td><td>333.312</td><td>43923.9</td></tr><tr><td>2000</td><td>0.99845</td><td>256.377</td><td>31527</td></tr><tr><td>1000</td><td>0.998113</td><td></td><td>17885.2</td></tr><tr><td><code>M=256, efConstruct=1000</code></td><td></td><td></td><td></td></tr><tr><td>Build Time: 10889.2</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>efSearch</th><th>recall@100</th><th>time</th><th>comparison</th></tr></thead><tbody><tr><td>7500</td><td>0.998472</td><td>694.225</td><td>94251.6</td></tr><tr><td>3000</td><td>0.998452</td><td>337.471</td><td>44230.1</td></tr></tbody></table><h3 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a>聚类问题</h3><p>所选聚类方法KMeans</p><p>imagenet数据集使用的是InnerProduct，不能直接用L2做KMeans。</p><p>Naive KMeans只能用L2做聚类，导致得到的Bert训练token数据质量较差（未跟检索Metric IP对齐）<br>但是如果把KMeans逻辑中的L2距离直接换成IP，则产生的聚类将会非常skewed：会有非常大的cluster。</p><p>调研发现一种专门针对IP、cosine metric的KMeans算法：Spherical KMeans。</p><p>希望能同时解决Bert For IVF</p><p>OpenAI-text-embedding 3072维，是否开源？要不要钱？</p><h3 id="实际效果（stamp-1000）"><a href="#实际效果（stamp-1000）" class="headerlink" title="实际效果（stamp 1000）"></a>实际效果（stamp 1000）</h3><p>lgb</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> time of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">04120230674743652</span><br><span class="hljs-attribute">The</span> mse of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">039302242508574975</span><br><span class="hljs-attribute">The</span> rmse of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">19824793191500126</span><br><span class="hljs-attribute">The</span> mae of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">26930854327860576</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">efSearch:</span> <span class="hljs-number">5000</span><br><span class="hljs-attr">efConstruct:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">M:</span> <span class="hljs-number">128</span><br><span class="hljs-attr">check_stamp:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">num_clusters:</span> <span class="hljs-number">8192</span><br><span class="hljs-string">comparison_pred[0]:</span> <span class="hljs-number">2250</span><br><span class="hljs-attr">Build Time:</span> <span class="hljs-number">2.01e-07</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">Query search time:</span> <span class="hljs-number">1.89001</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-string">Recall@100:</span> <span class="hljs-number">0.994818</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">num_early_stop:</span> <span class="hljs-number">0</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">avg comparison:</span> <span class="hljs-number">7621.27</span><br></code></pre></td></tr></table></figure><p>bert</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Inference</span> time: <span class="hljs-number">6</span>.<span class="hljs-number">979</span> <br><span class="hljs-attribute">The</span> mse of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">043406706</span> <br><span class="hljs-attribute">The</span> rmse of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">2083427615813856</span> <br><span class="hljs-attribute">The</span> mae of prediction is <span class="hljs-number">0</span>.<span class="hljs-number">15999442</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">efSearch:</span> <span class="hljs-number">5000</span><br><span class="hljs-attr">efConstruct:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">M:</span> <span class="hljs-number">128</span><br><span class="hljs-attr">check_stamp:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">num_clusters:</span> <span class="hljs-number">8192</span><br><span class="hljs-string">comparison_pred[0]:</span> <span class="hljs-number">1750</span><br><span class="hljs-attr">Build Time:</span> <span class="hljs-number">2.11e-07</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">Query search time:</span> <span class="hljs-number">2.29762</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-string">Recall@100:</span> <span class="hljs-number">0.994266</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">num_early_stop:</span> <span class="hljs-number">0</span><br>[<span class="hljs-string">Early</span> <span class="hljs-string">stop</span>] <span class="hljs-attr">avg comparison:</span> <span class="hljs-number">9160.68</span><br></code></pre></td></tr></table></figure><h2 id="09-29"><a href="#09-29" class="headerlink" title="09.29"></a>09.29</h2><p>HNSW 记录</p><p>efSearch: 1500<br>M: 128<br>efConstruction: 1500<br>num_clusters: 4096<br>check_stamp: 5000<br>Build Time: 350.897<br>Query TIme: 91.2687<br>Recall@100: 0.999234<br>num_early_stop: 0<br>avg comparison: 30552</p><p>efSearch: 2000<br>M: 128<br>efConstruction: 2000<br>num_clusters: 4096<br>check_stamp: 5000<br>Build Time: 451.171<br>Query TIme: 105.395<br>Recall@100: 0.99921<br>num_early_stop: 0<br>avg comparison: 38310.4</p><h3 id="如何获取训练数据？"><a href="#如何获取训练数据？" class="headerlink" title="如何获取训练数据？"></a>如何获取训练数据？</h3><p>1）随机生成。不服从原向量空间的分布。<br>2）某些数据集会提供 learn vector</p><h3 id="如何用Bert做回归任务？"><a href="#如何用Bert做回归任务？" class="headerlink" title="如何用Bert做回归任务？"></a>如何用Bert做回归任务？</h3><p>以二分类任务的形式，让Bert学习一个token序列的得分。</p><p>训练数据如何构造？<br>样本点在图搜的某个时间戳（例如 comparison&#x3D;1000 ），拿出队列中的结点对应的 cluster id（长度100）。cluster id序列 作为这个样本的特征，将来作为Bert的tokens直接输入。</p><p>如果当前的recall已经为100%，那么它的label&#x3D;0。否则label为1</p><p>接下来，每隔500次comparison进行一次recall计算，如果当前搜索结果的recall到达了100%，就把当前的comparison作为这条样本的最终比较次数。</p><p>把所有样本的比较次数汇总，做分位数统计存入Table。</p><p>根据得分对token序列的打分对应的分位数，从Table中查找对应的比较次数，作为最终预测结果。</p><p>混合训练数据：</p><p>把不同搜索参数下的样本做混合，作为同一个模型的训练数据。<br>比如efSearch&#x3D;500和efSearch&#x3D;1000的样本进行混合。</p><h3 id="Bert推理速度调研"><a href="#Bert推理速度调研" class="headerlink" title="Bert推理速度调研"></a>Bert推理速度调研</h3><p>单卡2080ti</p><p>使用PIN工作的数据集：平均每个序列约80个tokens，共10570个序列。</p><p>cross-encoder推理速度</p><table><thead><tr><th>Bert变种</th><th>推理速度</th><th>AUC</th></tr></thead><tbody><tr><td>bert-base-uncased</td><td>40.032</td><td>0.8364</td></tr><tr><td>distilbert-base-uncased</td><td>21.731</td><td>0.8360</td></tr><tr><td>tinybert-4l</td><td>7.637</td><td>0.8357</td></tr><tr><td>tinybert-l2-v2</td><td>6.548</td><td>0.8353</td></tr><tr><td>影响因素：</td><td></td><td></td></tr><tr><td>1）显卡级别。“相比上一代 V100 芯片，A100 在 BERT 模型的训练上性能提升 6 倍，BERT 推断时性能提升 7 倍。”—— <a href="https://segmentfault.com/a/1190000044372654">https://segmentfault.com/a/1190000044372654</a></td><td></td><td></td></tr><tr><td>A100与2080ti的性能差距未知，A100上实际的推理速度不可推算。</td><td></td><td></td></tr></tbody></table><p>2）特征token序列的长度，可选50，100。序列越长推理越慢</p><p>3）以上实验包含了tokenize的时间开销，早停实际推理时，拿到的特征已经是token，不需要计算tokenizer的时间。</p><p>规律性：某个时间戳，队列中结点对应的token。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br>qid: 198, recall: 1, deduped:6 <br>595 595 595 595 595 595 5321 595 5321 595 595 595 5321 5321 595 595 595 595 595 5321 5321 595 595 5321 5321 595 595 3219 595 595 595 5321 595 595 5321 5321 595 5321 595 595 595 5321 5323 3219 5321 5321 5321 595 795 5321 595 595 595 595 595 595 595 595 595 595 535 595 5321 5321 595 595 595 3219 5321 5321 5321 5321 5321 5321 5321 595 5321 5321 595 595 5321<br><br>qid: 199, recall: 0.8,deduped: 59<br>1656 2303 421 705 682 421 2619 848 1760 6938 3340 3121 848 7882 3877 4393 377 3877 5471 54 3161 3682 848 4144 271I5 421 782 3340 5984 5102 5471 771 6518 2596 5417 421 1613 165 7919 6938 750 3161 2401 3479 363 627 3127 3554 7835 6302 6518 8037 2726 8054 5465 1656 2438 4570 8054 1912 1656 750 1656 491 7867 6938 2856 7463 2303 2427 892 3877 6518 7550 2596 5984 3682 750 1656 3554 5690 6548 4421 3728 8054 7592 5984 750 115 6443 7414 7609 3877 6146 5471 6882 7550 2137 8854 7414<br></code></pre></td></tr></table></figure><h3 id="09-26"><a href="#09-26" class="headerlink" title="09.26"></a>09.26</h3><p>实锤：Bert去掉 tokenizer 后，推理速度接近翻倍</p><h3 id="09-27"><a href="#09-27" class="headerlink" title="09.27"></a>09.27</h3><p>完成 CrossEncoder 的初步实验：去掉自带的tokenizer，直接将输入当作token做推理。</p><p>数据集情况：SIFT1M，# Train 100k，观察窗口&#x3D;2000 Comparison。</p><p>完成 SIGMOD2020 早停的复现，lightgbm 预测效果不如 Bert</p><p>性能预测依据：<br>1）distance、query based：SIGMOD2020<br>2）vertex based：Bert早停</p><p>下午142机器宕机，后续实验无法继续推进</p><h3 id="09-28"><a href="#09-28" class="headerlink" title="09.28"></a>09.28</h3><p>准备SIFT10M、GIST1M数据集，包括base_gt、train_gt的计算。</p><p>在SIFT10M、GIST1M上建图，参数遵从SIGMOD2020 <code>M=16, efConstruct=500</code>.</p><p>142机器仍全天宕机</p><h3 id="09-29-1"><a href="#09-29-1" class="headerlink" title="09.29"></a>09.29</h3><p>给定召回率目标，将比较次数最小化</p><p>应用场景：客户的口味需求。</p><p>在搜索场景下，A类客户容易满足，仅需很低的召回率；B类客户口味较刁，需要很高的召回率。</p><p>根据召回率需求，用几套不同的模型。一次检索完后，客户根据满意度进行反馈是否需要继续检索。模型利用搜索的特征进行预测，达到最小的比较次数。</p><p>场景：B类用户提出的需求，对应99%的召回率。最小比较次数为 11450 次</p><p>baseline：</p><p>1）每隔500次返回一次结果，但是次数太多（23次）客户会烦。比较次数肯定会小，为11500次，仅溢出50次比较</p><p>2）根据口味最刁的用户，即最高召回率需求的用户，进行调参。这样会导致成本很高。</p><p>方法：用模型预测，可能返回2次结果就能达到B类用户的需求。但是比较次数可能会溢出较多，成本较高。</p><h2 id="09-22"><a href="#09-22" class="headerlink" title="09.22"></a>09.22</h2><h3 id="Q2Q2P-检索"><a href="#Q2Q2P-检索" class="headerlink" title="Q2Q2P 检索"></a>Q2Q2P 检索</h3><p>借鉴推荐系统中的 U2U2I 召回。</p><p>传统召回：U2I，User塔、Item塔。根据uid拿到user embedding，从Item中做ANNS</p><p>U2U2I 召回：利用 User 喜爱的 Item 建图。得到 user embedding 以及user之间的相似度（根据喜好 图）。推理时，从当前用户最相似的 User 中获取Item倒排。</p><p>做法：生成一部份伪查询 Q’，使得这些伪查询能覆盖大部分的 Document。</p><p>好处：不需要document塔。只需要专注于Q2Q相似度，Q2Q查询之间语态应该更接近，更容易学。并且检索速度应该会更快，因为|Q’| 会设计得比较小，比直接搜D得搜索量要小。</p><p>引入到Passage Retrieval面临的问题：<br>1）推理时，给定的Q无法直接拿到它的 embedding（U2U2I可以）。需要 text -&gt; embedding的步骤。很难做成端到端的模型，把GNN的知识喂给query塔<br>2）GNN数量级问题：U2U2I使用GNN训练 User 之间的相似度。但是Item&#x2F;document 的数量级都在M级别以上。</p><h3 id="基于Bert-的图索引早停"><a href="#基于Bert-的图索引早停" class="headerlink" title="基于Bert 的图索引早停"></a>基于Bert 的图索引早停</h3><p>chengjun</p><p>推理速度问题：TinyBert、DistilBert可以解决。精度会有所损失。</p><p>和杨铭讨论结果：可能需要换个故事，换个任务。<br>通常思路：用ANNS增强PLM，但是此任务属于PLM增强ANNS</p><h3 id="Multi-Vector调研"><a href="#Multi-Vector调研" class="headerlink" title="Multi-Vector调研"></a>Multi-Vector调研</h3><p>现有方法：设计了检索范式，其中用到了LSH</p><p>如果使用Learning to hash，只是更换了partition方法，贡献不大。</p><h3 id="负样本增强"><a href="#负样本增强" class="headerlink" title="负样本增强"></a>负样本增强</h3><p>思路也是如何学好Q2Q。<br>使用Q2Q2P的路线挖掘hard-negative</p><h2 id="09-16-小组会议（线上）"><a href="#09-16-小组会议（线上）" class="headerlink" title="09.16 小组会议（线上）"></a>09.16 小组会议（线上）</h2><h3 id="pseudo-query-based-单塔模型-schema"><a href="#pseudo-query-based-单塔模型-schema" class="headerlink" title="pseudo-query-based 单塔模型 schema"></a>pseudo-query-based 单塔模型 schema</h3><p>wenyi、hanzhi</p><p>OpenAI text embedding<br>BGE-m3（M3-Embedding- Multi-Linguality, Multi-Functionality, Multi-Granularity Text Embeddings Through Self-Knowledge Distillation） 就是单塔模型，把Q和P都同等对待。<br>可以做 探索性&#x2F;综述类工作，说明为何现在IR模型基本都是双塔。</p><p>个人猜想：单塔的训练难度 &gt;&gt; 双塔。单塔需要经过大规模无监督语料的预训练 + ……（详见BGE-m3论文）</p><h3 id="pseudo-query-based-样本增强-与-长尾现象"><a href="#pseudo-query-based-样本增强-与-长尾现象" class="headerlink" title="pseudo-query-based 样本增强 与 长尾现象"></a>pseudo-query-based 样本增强 与 长尾现象</h3><p>kaiqian、guohao</p><p>关键词：pseudo-query、augmentation、long-tail</p><p>Q &#x3D;&gt; postive（少数） + negative（多数）……</p><p>缓解 passage-query 的长尾程度。<br>设定：大部分passage无法被 数据集给定的query检索到。<br>因为在IR模型训练时，每个查询都会选出对应的 正样本 + 负样本（随机负样本 &#x2F; 困难负样本）<br>但是（我相信）仍有部分 passage 是自始至终 未曾进入训练样本 的。</p><p>可以做成研究型 &#x2F; 探索性的工作。</p><p>分析点：现有数据集的query相较passage的量级而言非常少。</p><p>DPR论文（Dense Passage Retrieval for Open-Domain Question Answering）使用的数据集：<br>Wikipedia：|P| &#x3D; 21M</p><table><thead><tr><th>Dataset</th><th># Q Train</th><th># Q Dev</th><th># Q Test</th></tr></thead><tbody><tr><td>Natural Questions</td><td>79,168 58,880</td><td>8,757</td><td>3,610</td></tr><tr><td>TriviaQA</td><td>78,785 60,413</td><td>8,837</td><td>11,313</td></tr><tr><td>WebQuestions</td><td>3,417 2,474</td><td>361</td><td>2,032</td></tr><tr><td>CuratedTREC</td><td>1,353 1,125</td><td>133</td><td>694</td></tr><tr><td>SQuAD</td><td>78,713 70,096</td><td>8,886</td><td>10,570</td></tr><tr><td>每个Q对应 7 &#x2F; 31 &#x2F; 127 &#x2F; 256 个负样本。但是大部分负样本是 随机抽样 &#x2F; in-batch负样本。</td><td></td><td></td><td></td></tr></tbody></table><p>给每个文档都生成对应的伪查询，这样能保证绝大部分文档都进入样本，从而被学习。<br>可以对应减少随机负样本的数量。</p><p><strong>如果问题确实存在，且存在影响</strong>。<br>可以考虑构造一个针对长尾Passage的数据集。</p><h3 id="pseudo-query-based-增强负样本"><a href="#pseudo-query-based-增强负样本" class="headerlink" title="pseudo-query-based 增强负样本"></a>pseudo-query-based 增强负样本</h3><p>yitao、xintong</p><p>关键词：pseudo-query、hard-negative、similarity</p><p>ANCE（开源）是从 Q-P 的相似度出发，迭代地挖掘hard negative。</p><p>Q-Q-P检索范式：Offline Pseudo Relevance Feedback for Efficient and Effective Single-pass Dense Retrieval</p><p>可能和ANCE的相似度对不上，需要细化idea。</p><p>Q的相似度是否也能 挖掘 hard negative？</p><h3 id="query-encoder侧的交互"><a href="#query-encoder侧的交互" class="headerlink" title="query encoder侧的交互"></a>query encoder侧的交互</h3><p>提取少量passage，放到query侧</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>论文查找：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">arxiv预印本：https://arxiv.org/<br>acm图书馆：https://dl.acm.org/ <br>google scholar：https://scholar.google.com/<br></code></pre></td></tr></table></figure><p>**<a href="https://github.com/castorini/pyserini">pyserini</a>**（AI框架、训练模型）非常重要！！！以后咱的工作基本都会用到</p><p><a href="https://github.com/castorini/anserini">anserini</a>（稀疏检索 BM25）可以了解，主要用来挖掘 BM25 hard-negative</p><h2 id="09-08"><a href="#09-08" class="headerlink" title="09.08"></a>09.08</h2><h3 id="ideas-on-GNN-graph-based检索的早停"><a href="#ideas-on-GNN-graph-based检索的早停" class="headerlink" title="ideas on GNN + graph-based检索的早停"></a>ideas on GNN + graph-based检索的早停</h3><p>动机：当目标为 recall90%@50时</p><ul><li>80% 简单查询：访问1000个向量即可</li><li>20% 困难查询：访问&gt;10000个向量<br>数据来源于<a href="https://arxiv.org/pdf/2408.13899">Steiner-Hardness: A Query Hardness Measure for Graph-Based ANN Indexes</a></li></ul><p>固定访问次数为1000次。达到1000次访问时，将队列中top-k近的结点取出。</p><p>当快要搜好的时候（recall快到上限），队列中的结点可能相互之间的 拓扑比较像似 &#x2F; 距离比较近。<br>训练这些结点的topo-embedding，结合这些结点的距离，做早停判断。</p><p>思路1：GNN<br>图索引的图规模都很大，最小的 sift1m 数据集都有10M级别的结点数量。显存非常有限，GNN难以应用。<br>改进：也许只需要关注一部分结点。比如只考虑训练数据中，访问次数达到1000次时，对应队列中的结点。这些结点说不定只占全图结点的小部份。只训练这部分结点的topo-embedding，GNN说不定能训练下来。</p><p>大型图GNN算法有GraphSaint、GraphSAGE</p><p>GNN 结点分类</p><p>两段式：1）用GNN训练出结点的 topo-embedding，2）用1）的embedding训练分类模型</p><p>感觉不如端到端地训练，但是很难设计训练方式。</p><p>思路2：Bert<br>借鉴 [[记录 - 信息检索探索（二阶段）#^a788ec]] 候选队列Q中的结点是有序的（距离排序）。<br>把某一时间戳，Q中结点拿出来。每个结点当成一个token，当成Bert的输入，来做分类任务。</p><p>改进：相比起传统的NLP任务背景，图索引的早停涉及到的token会比vocab_size大得多。<br>但同时也没有NLP那么丰富的语意信息（一词多义、语境、情感、上下文……）。<br>而bert_base_uncased每个token对应维度是768，vocab_size只有30k。图早停背景之下，可以把每个token的维度缩到24维左右，vocab_size则需要大得多，得上960k的量级。<br>这样推理成本也能极大降低。</p><p><strong>包装成排序技术</strong></p><h3 id="multi-vector-优化（最適化-さいてきか）"><a href="#multi-vector-优化（最適化-さいてきか）" class="headerlink" title="multi-vector 优化（最適化　さいてきか）"></a>multi-vector 优化（最適化　さいてきか）</h3><p>背景：ColBERT 嵌入模型需要把P侧的每个passage都encode成多个embedding，Q侧也是。</p><p>[NIPS2023]<a href="https://arxiv.org/abs/2210.15748">DESSERT: An Efficient Algorithm for Vector Set Search with Vector Set Queries</a><br>基于LSH，把P侧的每个Passage对应的|P|个向量hash成一个（？有待确认）</p><p><a href="https://arxiv.org/abs/2405.19504">MUVERA: Multi-Vector Retrieval via Fixed Dimensional Encodings</a></p><p>能否用 learning2hash 来替换LSH？<br>考虑query交互</p><table><thead><tr><th>Query Vector</th><th>V0</th><th>V1</th><th>V2</th><th>V3</th></tr></thead><tbody><tr><td>Q0</td><td></td><td></td><td></td><td></td></tr><tr><td>Q1</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Passage Vector</th><th>V0</th><th>V1</th><th>V2</th><th>V3</th></tr></thead><tbody><tr><td>P0</td><td></td><td></td><td></td><td></td></tr><tr><td>P1</td><td></td><td></td><td></td><td></td></tr><tr><td>P2</td><td></td><td></td><td></td><td></td></tr><tr><td>P3</td><td></td><td></td><td></td><td></td></tr><tr><td>P_{fusion}</td><td></td><td></td><td></td><td></td></tr><tr><td>Hash函数:</td><td></td><td></td><td></td><td></td></tr><tr><td>每个维度单独hash：F(P0Vi, P1Vi, P2Vi, P3Vi) &#x3D; P_{fusion}Vi</td><td></td><td></td><td></td><td></td></tr><tr><td>整个向量做hash：F(P0, P1, P2, P3) &#x3D; P_{fusion}</td><td></td><td></td><td></td><td></td></tr><tr><td>使得P_{fusion} * Q0 接近 P0 * Q0 + P1 * Q0…</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="QPP-——-Bert-文本数值交互"><a href="#QPP-——-Bert-文本数值交互" class="headerlink" title="QPP —— Bert 文本数值交互"></a>QPP —— Bert 文本数值交互</h3><h3 id="嵌入模型训练schema"><a href="#嵌入模型训练schema" class="headerlink" title="嵌入模型训练schema"></a>嵌入模型训练schema</h3><p>负样本：从弱到强。<br>先拿BM25之类的简单negative训练，再拿ANCE之类的hard negative训练。</p><p>顺应训练梯度：刷算法题，不能一上来就刷高rating的题，而应该先从低rating的题开始，循序渐进。</p><p>ANCE：只考虑了P侧的相似度，要不把Q侧的相似度也考虑上？</p><h3 id="大模型推理早停"><a href="#大模型推理早停" class="headerlink" title="大模型推理早停"></a>大模型推理早停</h3><p><a href="https://arxiv.org/abs/2405.15198">RAEE: A Training-Free Retrieval-Augmented Early Exiting Framework for Efficient Inference</a></p><h3 id="端到端检索模型"><a href="#端到端检索模型" class="headerlink" title="端到端检索模型"></a>端到端检索模型</h3><p>降低encode成本<br>ELIAS: End-to-End Learning to Index and Search in Large Output Spaces<br><a href="https://proceedings.neurips.cc/paper_files/paper/2022/hash/7d4f98f916494121aca3da02e36a4d18-Abstract-Conference.html">https://proceedings.neurips.cc/paper_files/paper/2022/hash/7d4f98f916494121aca3da02e36a4d18-Abstract-Conference.html</a></p><h3 id="1-样本增强的IR模型"><a href="#1-样本增强的IR模型" class="headerlink" title="1 样本增强的IR模型"></a>1 样本增强的IR模型</h3><p>offline阶段生成大量Q。<br>统一encoder（类似BGE）</p><p>对样本进行分类</p><h3 id="2-Q端的负样本"><a href="#2-Q端的负样本" class="headerlink" title="2 Q端的负样本"></a>2 Q端的负样本</h3><p>加上Q对比损失<br>让Q侧的相似度也能用 Semantic Space 来衡量</p><p>latent pseudo query</p><h3 id="09-14"><a href="#09-14" class="headerlink" title="09.14"></a>09.14</h3><h3 id="图索引早停思路整理"><a href="#图索引早停思路整理" class="headerlink" title="图索引早停思路整理"></a>图索引早停思路整理</h3><p>数据集中的向量&#x2F;点数过多，都是1M起步，训练时的数据应该会比较稀疏，即有部份向量点的embedding学习不好（长尾）。</p><p>解决方法：<strong>聚类</strong>，聚类ID作为Token。能有效降低Token数量，降低训练数据的稀疏性。推理时，将队列中的结点映射成它对应的聚类ID。</p><p>衍生Idea：直接使用聚类ID&#x2F;Token来做早停。对队列中的结点对应的Token做去重操作。</p><p><strong>考察了队列中结点的距离，但没有观察到队列中的结点的规律。</strong></p><h3 id="长尾-检索数据集"><a href="#长尾-检索数据集" class="headerlink" title="长尾 检索数据集"></a>长尾 检索数据集</h3><p>增大 passage-query 的长尾程度。<br>设定：大部分passage无法被 数据集给定的query检索到。</p><h3 id="IR模型调研（pseudo-query）"><a href="#IR模型调研（pseudo-query）" class="headerlink" title="IR模型调研（pseudo-query）"></a>IR模型调研（pseudo-query）</h3><p>主要调研了doc2query和docT5query这些pseudo-query类的工作。<br>训练设备基·本上是4张V100（32GB）左右。<br>推理设备RTX显卡（24GB）</p><p>已有工作：<br><a href="https://dl.acm.org/doi/pdf/10.1145/3539618.3592028">Offline Pseudo Relevance Feedback for Efficient and Effective Single-pass Dense Retrieval</a><br>给每个doc都生成m个伪查询（摘要）。每个伪查询都提前离线好top-k个doc。<br>线上推理时，对q使用BM25检索top-s个伪文档。总共对应s x k个doc。<br>打分：通过q与伪文档的分数 + q与doc的分数，联合打分。</p><h3 id="样本增强"><a href="#样本增强" class="headerlink" title="样本增强"></a>样本增强</h3><p>BGE-m3就是单塔模型，把Q和P都同等对待。<br>可以做 探索性&#x2F;综述类工作，说明为何现在IR模型基本都是双塔。</p><p>个人猜想：单塔的训练难度 &gt;&gt; 双塔。单塔需要经过大规模无监督语料的预训练 + ……</p><h2 id="09-01"><a href="#09-01" class="headerlink" title="09.01"></a>09.01</h2><p>VLDB2024 交流的收获</p><p>BERT的应用：把BERT用于路线补全。每条路作为1个TOKEN。 ^a788ec</p><p>图上也可以应用，比如图基础模型 @龚畅<br><a href="https://arxiv.org/pdf/2402.11235">ZeroG: Investigating Cross-dataset Zero-shot Transferability in Graphs</a><br>貌似用BERT即可，显存要求相对较低</p><p>大模型量化：PKU组<br>与ANNS中的技术有重叠，尤其是向量量化<br>VQ-VAE、VQ-Transformer、PQ-Cache、Distill-VQ</p><p>AI4DB<br>早停，针对图索引的优化。结合GNN。</p><p>multi-vector<br>目前工作较少<br>[NIPS2023] <a href="https://arxiv.org/abs/2210.15748">DESSERT: An Efficient Algorithm for Vector Set Search with Vector Set Queries</a><br><a href="https://arxiv.org/abs/2405.19504">MUVERA: Multi-Vector Retrieval via Fixed Dimensional Encodings</a></p><h2 id="08-25"><a href="#08-25" class="headerlink" title="08.25"></a>08.25</h2><h3 id="計画（けいかく）"><a href="#計画（けいかく）" class="headerlink" title="計画（けいかく）"></a>計画（けいかく）</h3><p>1）如果过第一轮初审，努力rebuttal<br>2）将 BERT-CrossEncoder 融合PIN<br>3）改进PIN本身</p><h3 id="考え（かんがえ）-1"><a href="#考え（かんがえ）-1" class="headerlink" title="考え（かんがえ）"></a>考え（かんがえ）</h3><p>现有一个打分器&#x2F;分类器clf，即一阶段的PIN网络：<br>input：100维的数值向量<br>output：得分<br>目标：将PIN融合进text-based的 BERT-CrossEncoder（特指 [[笔记 - CIKM2021 BERT-QPP Contextualized Pre-trained transformers for Query Performance Prediction]]），提高预测精度。<br>基本想法：结合clf的数值特征和BERT的文本特征，一起做分类微调。</p><p><strong>后期交互</strong><br>clf和BERT各自走自己的流程，到倒数第二步，把 clf_embed 和 BERT_embed 做拼接，得到 fusion_embed，送进最后的 分类层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FusionModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clf, bert_model</span>):<br>        <span class="hljs-built_in">super</span>(FusionModel, self).__init__()<br>        self.clf = clf<br>        self.bert_model = bert_model<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, numerical_inputs, text_inputs</span>):<br>        clf_embed = self.clf(numerical_inputs)<br>        bert_embed = self.bert_model(text_inputs)<br>        combined = torch.cat([clf_embed, bert_embed], dim=-<span class="hljs-number">1</span>)<br>        ...  <span class="hljs-comment"># 接下来可以添加额外的层（如全连接层，dropout层，或激活层等）进行处理</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><p><strong>前期交互</strong><br>在 BERTQPP_QD 进行 tokenize 阶段就讲 clf_embed 的信息注入。<br>核心：如何将clf的输出编码为一个可被BERT识别的token？</p><p>可选方案包括：</p><ol><li>直接将 clf_embed 过Sigmoid + BCEWithLogits，得到最终分数。分数 &#x3D;&gt; 归一化 &#x3D;&gt; int &#x3D;&gt; str，把最终的 PIN_score_str 当成 PIN_TOKEN 送进 BERTQPP_QD。即 <code>qtext [SEP] PIN_score_str [SEP] topdoc</code></li><li>将 clf_embed 做聚类，并且把<code>TOKEN_&#123;clusterid&#125;</code>全部加进BERT的词汇表。训练推理时，拿到一个新的 clf_embed 时，计算它的聚类id。然后把它当作 PIN_TOKEN 送进 BERTQPP_QD。<br>以上方案都无法把PIN和BERT进行联合微调。</li></ol><p>效果肯定比后期交互好，但是训练成本（显存需求）大，因为相当于新加了token词。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 混合检索框架探索</title>
    <link href="/2024/11/12/%E8%AE%B0%E5%BD%95%20-%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%89/"/>
    <url>/2024/11/12/%E8%AE%B0%E5%BD%95%20-%20%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><p>multi-similarity search 问题：</p><p>datacomp数据集中，一条样本有图文两个模态构成。使用CLIP encode，每条样本得到图（768d）+文（768d）embedding。</p><p>匹配指标</p><table><thead><tr><th>class</th><th>image?</th><th>text?</th></tr></thead><tbody><tr><td>0</td><td>✅</td><td>✅</td></tr><tr><td>1</td><td>❌</td><td>✅</td></tr><tr><td>2</td><td>✅</td><td>❌</td></tr><tr><td>Naive方法是根据这3个类别分别构建三个index：1536d x 1 + 768d x 2</td><td></td><td></td></tr></tbody></table><p>一种思路是根据class0建索引，在查询时将对应的模态用0 mask掉。<br>但是会发生ood现象，且十分严重</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">M: 16<br>index_path: /data/disk1/liuchengjun/HNNS/index/datacomp-combined.base.M_16.efc_1000.hnsw<br>[HNSW] Loading HNSW from file: /data/disk1/liuchengjun/HNNS/index/datacomp-combined.base.M_16.efc_1000.hnsw<br>num_test: 10000<br>num_train: 0<br>Build Time: 3.2e-07<br>Search 822 / 10000<br>[Query][HNSW] Params: M: 16, efSearch: 1000<br>[Query][HNSW] Using GT from file: /home/zhengweiguo/liuchengjun/anns/query/datacomp-combined/query.base.norm.gt.ivecs.cpu.1000.mask1<br>[Query][HNSW] Search time: 6.19588<br>[Query][HNSW] Recall@1: 0.1428<br>[Query][HNSW] Recall@10: 0.17212<br>[Query][HNSW] Recall@100: 0.193524<br>[Query][HNSW] Recall@1000: 0.223414<br>[Query][HNSW] avg comparison: 16488.4<br></code></pre></td></tr></table></figure><p>数据集：<br>目前只有2个模态的数据集：图文模态的datacomp。<br>还未发现3个及以上模态的大规模数据集</p><p>直接的思路是应用现有OOD的解决方案：用 OOD的query 指导建图。</p><p>套用在该问题上就是：组合多种mask会产生不同的 OOD 类型。根据OOD严重情况，给不同mask类型OOD不同的权重。</p><p>与陈萌很大的一点不同是：他们的文搜图场景一定需要OOD查询来指导。而本问题大概率可以“自举”（？）&#x2F; 根据自身数据的mask来指导建图。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 10.21-10.27</title>
    <link href="/2024/10/25/%E5%91%A8%E8%AE%B0%20-%202024%2010.21-10.27/"/>
    <url>/2024/10/25/%E5%91%A8%E8%AE%B0%20-%202024%2010.21-10.27/</url>
    
    <content type="html"><![CDATA[<h2 id="10-21-周一-晴"><a href="#10-21-周一-晴" class="headerlink" title="10.21 周一 晴"></a>10.21 周一 晴</h2><p>晚上在公司三楼吃了10个鲜虾鱼籽水饺+半个热狗，就急忙赶回学校了。<br>毕竟有所谓WLB的税务局宣讲，还是杭州+深圳联合宣讲。</p><p>宣讲会上提到了“三师”，查了下是：税务师、会计师和律师。貌似这三个都和我没啥关系。</p><p>QA环节我问了以下4个问题，拿了一个环保袋 + 一块鼠标垫。</p><ol><li>缺乏学生工作：大丈夫です</li><li>暑期实习入选难度</li><li>计算机 统计学：最高学历。悲しね！</li><li>工作内容 报考岗位：统一入职，入职后调配。</li></ol><p>宣讲会结束之后我找了吴JH学姐，加了她的vx。我一过去她就问我是不是蔡YZ的学弟。<br>看来我俩都互相认出了对方。原来她是蔡学长的同乡学姐，蔡学长之前还问她要过物理实验报告，笑死。</p><p>据她说，她考试的那年（2022）超过100人考试，考的行测和申论，进面试12个，最后只录取两个……</p><p>明年就到我考试了，如果我不笨鸟先飞的话，我就是炮灰了。</p><h2 id="10-22-周二-晴"><a href="#10-22-周二-晴" class="headerlink" title="10.22 周二 晴"></a>10.22 周二 晴</h2><p>早上的周会实在是乏善可陈。好在敷衍过去了。</p><p>晚上9点的时候我躺在床上刷iPad，突然收到飞书消息。葛FS把我拉进了一个警报群。</p><p>说不准明天MT王就把我裁了。</p><h2 id="10-23-周三-晴"><a href="#10-23-周三-晴" class="headerlink" title="10.23 周三 晴"></a>10.23 周三 晴</h2><p>早上葛FS和我拉了个下午4-5点的one2one会，直接连开两个，难顶。</p><h2 id="10-24-周四-晴-🧑‍💻节抽中水晶键盘"><a href="#10-24-周四-晴-🧑‍💻节抽中水晶键盘" class="headerlink" title="10.24 周四 晴 🧑‍💻节抽中水晶键盘"></a>10.24 周四 晴 🧑‍💻节抽中水晶键盘</h2><p>今天1024程序员节，好运爆棚！</p><p>中午到4楼吃煲仔饭，干饭排队的时候孔LB说他1024活动线上抽奖抽到了京东5元代金券。<br>然后大家打算饭后到1楼去参加一下1024程序员节的活动。</p><p>我本没打算抽中啥奖品。因为刚刚线上抽奖只抽到了保底。<br>刚到T2b排队抽到的第一个又是京东5元代金券…… 孔LB抽到了个充电宝，张H抽到了一个本子。<br>第二个活动抽奖我居然抽到了水晶键盘！活动工作同学说这是大奖，我前面总共就只有3个同学抽到。<br>我曾经在9月份的某几天在T1的大厅里看到过几次透明的键盘，当时还觉得挺好看的，估计就是我抽到的这个吧。<br>后面我又抽到了一个程序员风格环保袋。满载而归。</p><p>回到恭维工位已经2点多了，下午自然是困的不行。</p><p>晚上想着离职之后，该用啥笔记本来“平替”手上这台MacBook Pro。<br>虽然MacBook的Wi-Fi经常让我血压飙升，但续航、风扇噪音、轻便性我还是很认可的。</p><p>在B站上物色了一圈，目前相中的有以下几款：</p><ol><li>机械革命 翼龙15 Pro</li><li>华硕天选14 Pro</li></ol><h2 id="10-25-周五-小雨"><a href="#10-25-周五-小雨" class="headerlink" title="10.25 周五 小雨"></a>10.25 周五 小雨</h2><p>今早10点20分到公司楼下，看到对面T2门口停着一辆急救车。<br>我拍了张照片，没多做停留。<br>哎昨天才刚过完1024程序员节，今天就有人被抬走了。</p><p>下午葛FS全程没有找我，彼（かれ）はたぶん飛行機（ひこうき）の中（なか）でした。</p><h2 id="10-26-周六-雨"><a href="#10-26-周六-雨" class="headerlink" title="10.26 周六 雨"></a>10.26 周六 雨</h2><p>早上起来发现外面又开始下那种绵绵的雨了，阴间得一。</p><p>晚上6点半，郑老师在群里说明天的大组会暂停，舒服了。<br>紧接着他又在向量DB群里让蔡学长主持明天早上的小组会，录屏 &#x3D;&#x3D; 我不用去线下了。</p><h2 id="10-27-周日-雨转晴"><a href="#10-27-周日-雨转晴" class="headerlink" title="10.27 周日 雨转晴"></a>10.27 周日 雨转晴</h2><p>早上的小组会我直接没去子彬院了。反正之后我也要逐步脱离“前线”了，现在先温水煮青蛙，笑死。</p><p>不过也有点可惜，画的大饼🫓准备了实验结果，可是郑老师却不在。</p><p>这将是我最后的波纹了。</p><p>中午去北食吃了港式滑蛋饭，结果从下午开始就肚子不舒服，晚上还拉肚子了。</p><p>午睡起来，一直都在尝试把GPUFlat矩阵乘法的float换成double，搞到最后5点多我直接红温了。直接放弃。<br>这时我用k&#x3D;1000重跑了下之前的实验，发现wikipedia和gist上的recall@1、10和100都到1了。<br>然后我按k&#x3D;1024再跑了一下，发现recall@1000也到1了。</p><p>于是困扰了我半天的问题算是解决了一大半，可惜的是imagenet的recall@10以上就没法做到1了。<br>我估计在计算精度上还是有问题。<br>打算换个数据集再试试。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 10.21-10.27</title>
    <link href="/2024/10/25/%E5%91%A8%E8%AE%B0%20-%202024%2010.28-11.03/"/>
    <url>/2024/10/25/%E5%91%A8%E8%AE%B0%20-%202024%2010.28-11.03/</url>
    
    <content type="html"><![CDATA[<h2 id="10-28-周一-晴"><a href="#10-28-周一-晴" class="headerlink" title="10.28 周一 晴"></a>10.28 周一 晴</h2><p>今天终于决定写一个vvpred模型的超级详细的文档，毕竟最多只剩一个月的实习时间了。<br>首先肯定是为我自己丰富简历 + 离职之后还能回溯这段工作。</p><p>其次我想着自己在公司呆了3个月了，不说产出有多少，但是至少做个详细的文档，给后人带来一点便利。不然白吃了那么多棒约翰🍕</p><p>下午突然想到一种放置 &#x2F; 模拟经营游戏的idea：从零开始建设互联网帝国。<br>一开始只有Linear Regression这种shallow model用于推荐。<br>甚至说一开始没有推荐模型，只有按照分类给用户推文。总之《今日头条》APP一开始是啥样，游戏初期就啥样。<br>同时，可以拉合伙人，或者拉广告商。这部分玩法可以参考《药剂工艺》。</p><p>随着资金发展，可以购买更多CPU Cores、内存、机房和升级GPU资源。<br>资金和研究力达到一定程度后，可以解锁向量召回模型，但是一开始只有IVF、LSH这类模型，后续可以解锁HNSW这种。这部分参照真实世界的ANNS发展。</p><p>推荐、搜索模型也可以升级到初级的DSSM。<br>再发展可以解锁Transformer，随后解锁Bert、Vision Transformer。再到多模态、内容理解。流量大了还可以拉广告商。</p><p>你说的对，但是目前没有任何关于“搜索”和“广告”的知识文档。<br>睡前我在飞书上搜了下“抖音搜索”、“商业化”、“ads core”等关键词。<br>并没有找到像推荐系统这样充分完备的文档可以学习。</p><h2 id="10-29-周二-晴"><a href="#10-29-周二-晴" class="headerlink" title="10.29 周二 晴"></a>10.29 周二 晴</h2><p>10:10+到公司，到9号会议室开周会as usual。<br>今天我回报完之后除了张H问了个“你现在是在给模型加特征吗？”之外，没有人提问，舒服了。<br>但是今天的周会开到了12:20分……一周比一周久，裂开。</p><p>中午午餐的时候听FS他们说：</p><ol><li>华为和真国企很像，没有社招只有校招。社招只面向顶尖人才。</li><li>OD绝对不要去。只要有过外包经历，就会花简历，留下前科案底。</li><li>OD被裁员后，只有外包“中介”公司会给大礼包，而外包工作的公司不会给。而且工资非常低，因此大礼包也很少。</li></ol><p>晚上在棒约翰排队的时候，刷到了华为2012实验室一位网友的工作分享，他说<strong>强度不高</strong>。我就直接上去问他有没有研究型实习的HC。我俩加了VX。他给我推了一位HR。</p><p>8点多我和那位HR通了电话，他说他们部门是搞理论计算机的，包括组合优化、运筹学这些。我一听就觉得很劝退，看到FOCS就知道打扰了。<br>我问他在哪工作，是不是要到青浦区。他回答说11月就要搬了，我刚好用这个理由搪塞他说不合适，导师不放人异地实习。</p><p>不过这也给我思路，华为2012这种部门说不定真的可以做到WLB呢。</p><h2 id="10-30-周三-晴"><a href="#10-30-周三-晴" class="headerlink" title="10.30 周三 晴"></a>10.30 周三 晴</h2><p>11:12问郑老师HNNS要不要处理流式查询的情况，12:10他让我16点过去找他。<br>这正好和葛FS下午的one2one冲了，于是one2one改到14:00开始。</p><p>和FS开会的时候，收到之前的一位专硕同学于ZC的VX。<br>他问我身边同学今年秋招的情况。<br>细聊起来发现他也是想进游戏大厂做游戏。</p><h3 id="11-02-周六-晴"><a href="#11-02-周六-晴" class="headerlink" title="11.02 周六 晴"></a>11.02 周六 晴</h3><p>中午的时候有蚂蚁集团的搞VectorDB的人过来交流，那又怎样.jpg。</p><p>下午去上第一节团课，人手发了个红本子，让我们记笔记。彳亍。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">HGX204</span> 郭小凡<br><br>主体：国之大者<br><br>青年的微观个体 《-》国家的宏观个体<br><br>中国青年要做到胸怀 “国之大者”<br><br>彰显传统理论主导转为问题导向<br><br>事关根本利益，着眼战略格局，事关政治地位<br>事关科学理论与历史经验<br><br>爱国主义焕发于独领风骚的社会主义文化之中<br><br>要在坚定理想信念上下功夫<br>要在厚植爱国主义情怀上下功夫<br>要在加强品德修养上下功夫<br>增长知识见识<br>培养奋斗精神<br>增强综合素质<br><br>我们赖以生存繁衍的土地<br>作为精神谱系的文化习俗<br>我们身处其中的国体政体<br></code></pre></td></tr></table></figure><p>做我和李TS后面有个键政老哥，和讲课的人撕逼了快半小时。<br>他问现在GCD内是不是真的有在爱guo。<br>说最近泰国啥啥下跪，鉴定为说话不经大脑。<br>也不看啥场合问这种问题……</p><p>晚饭的时候看完了《进击的巨人》最后一部。<br><a href="https://www.bilibili.com/video/BV1CH4y1i7dE?spm_id_from=333.1245.0.0">【Animenz】致两千年后…或是…两万年后的你 – 进击的巨人完结篇 ED主题曲 钢琴改编</a> 好听！</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - Retrieving Multimodal Information for Augmented Generation A Survey</title>
    <link href="/2024/10/16/%E7%AC%94%E8%AE%B0%20-%20Retrieving%20Multimodal%20Information%20for%20Augmented%20Generation%20A%20Survey/"/>
    <url>/2024/10/16/%E7%AC%94%E8%AE%B0%20-%20Retrieving%20Multimodal%20Information%20for%20Augmented%20Generation%20A%20Survey/</url>
    
    <content type="html"><![CDATA[<h2 id="Retrieving-Multimodal-Information-for-Augmented-Generation-A-Survey"><a href="#Retrieving-Multimodal-Information-for-Augmented-Generation-A-Survey" class="headerlink" title="Retrieving Multimodal Information for Augmented Generation: A Survey"></a>Retrieving Multimodal Information for Augmented Generation: A Survey</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>随着大型语言模型（LLMs）变得流行，出现了一个重要的趋势，即使用多模态来增强 LLMs 的生成能力，这使 LLMs 能够更好地与世界互动。然而，对于在哪个阶段以及如何整合不同的模态缺乏统一的认识。在本次调查中，我们回顾了通过检索多模态知识来辅助和增强生成模型的方法，其格式包括图像、代码、表格、图表和音频。这些方法为诸如真实性、推理、可解释性和鲁棒性等重要问题提供了一个有前途的解决方案。通过提供深入的综述，本次调查有望让学者对这些方法的应用有更深入的理解，并鼓励他们将现有技术应用于快速发展的 LLMs 领域。</p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>生成式人工智能（GAI）在文本生成（欧阳等人，2022；乔德赫里等人，2022；布朗等人，2020）和文本到图像生成（拉梅什等人，2021a；普尔等人，2022）等任务中表现出色。多模态大型语言模型（MLLMs）的最新进展（德里尔斯等人，2023；OpenAI，2023；黄等人，2023b）进一步提高了模型处理多格式信息的能力，为开发通用学习者开辟了可能性。</p><p>然而，生成模型并非没有固有的局限性，包括产生幻觉的倾向（叶和杜雷特，2022）、在算术任务上的困难（帕特尔等人，2021）以及缺乏可解释性。因此，增强其能力的一个有前途的解决方案在于使它们能够与外部世界互动，并获取各种格式和模态的知识，从而提高生成内容的真实性和合理性。最近，出现了专注于检索增强方法的研究（米亚隆等人，2023），旨在提供更有根据和事实依赖的信息。其中，大多数（中野等人，2021；古等人，2020b）检索文本信息，这与预训练期间使用的数据格式相匹配，并为交互提供了自然的媒介。然而，在不同的结构和模态（如图像和视频）中存储了更多的世界知识，这些知识在传统的文本语料库中往往无法访问、不可用或无法描述。</p><p>因此，出现了一个重要的研究交叉点，即检索多模态知识以增强生成模型。它为当前的真实性、推理、可解释性和鲁棒性等挑战提供了一个有前途的解决方案。由于这个领域是非常新的，对于将这些方法识别为一个特定的群体、可视化它们的内在联系、连接它们的方法以及概述它们的应用，缺乏统一的理解。</p><p>因此，我们对多模态检索增强生成（RAG）的最新进展进行了调查。具体来说，我们通过将当前的研究分为不同的模态（包括图像、代码、结构化知识、音频和视频）来进行讨论。对于每种模态，我们使用相关的关键字在 ACL 文集和谷歌学术上进行系统搜索，并进行手动筛选以确定它们与本次调查的相关性。结果，我们收集了 146 篇论文进行详细分析。在附录 A.1 中，我们包括了搜索细节、统计数据和趋势分析图，这表明自大规模通用模型（large-scale general-purpose models）出现以来，多模态 RAG 论文确实发展得非常迅速。在每种模态中，我们通过将相关论文分组到不同的应用下进行讨论。通过提供深入的调查，我们希望帮助研究人员认识到纳入不同格式知识的重要性，并鼓励对现有技术进行适应和改进，以应用于快速发展的 LLMs 领域。</p><p>总之，我们的贡献如下：</p><ul><li>我们将具有多模态的检索增强生成确立为随着 LLMs 的最新进展而出现的一组重要方法。</li><li>对于常见的模态，我们通过将其内在联系和共同挑战置于上下文中，对研究论文进行了深入的回顾。</li><li>我们对未来的方向提供了信息丰富的分析，其中可能包含对当前许多挑战的有希望的解决方案。</li></ul><h3 id="2-Definitions-and-Background"><a href="#2-Definitions-and-Background" class="headerlink" title="2 Definitions and Background"></a>2 Definitions and Background</h3><p>为了更好地理解激发多模态检索增强的现状和进展，我们首先定义并讨论两个关键概念的背景：多模态学习和检索增强生成（RAG）。</p><h3 id="2-1-Multimodal-Learning"><a href="#2-1-Multimodal-Learning" class="headerlink" title="2.1 Multimodal Learning"></a>2.1 Multimodal Learning</h3><p>多模态学习是指从不同模态的数据中学习统一的表示。其旨在提取互补信息以促进组合任务（巴尔图沙蒂斯等人，2018；高等人，2020）。在本次调查中，我们包括了所有格式不同于自然语言的模态，包括图像、代码、结构化知识（例如表格、知识图谱）、音频和视频。</p><p>多模态生成模型具有广泛的应用，如文本 - 图像生成、创意写作生成和多语言翻译。例如，图像识别任务可以通过结合分析图像和视频以及文本描述而受益（朱等人，2022；阿拉亚克等人，2022a；贾等人，2021；拉德福德等人，2021b）。相反，纳入视觉信息也有助于语言理解和生成（周等人，2020；雷等人，2021；？）。</p><p>此外，它们有可能通过使模型能够从多个信息源学习并整合信息，从而显著改善各个领域的机器学习系统（蔡等人，2019；阿科斯塔等人，2022；纳格拉尼等人，2021）。</p><p>另外，人们对开发能够输出多种模态数据的生成模型的兴趣日益浓厚（拉梅什等人，2021b；克劳森等人，2022；林和伯恩，2022a；陈等人，2022a）。然而，多模态生成模型仍然存在挑战，例如获取大量的多模态数据以及设计产生语义有意义输出的网络。</p><h3 id="2-2-Retrieval-Augmented-Generation-RAG"><a href="#2-2-Retrieval-Augmented-Generation-RAG" class="headerlink" title="2.2 Retrieval-Augmented Generation (RAG)"></a>2.2 Retrieval-Augmented Generation (RAG)</h3><p>RAG 通常由两个阶段组成：检索上下文相关信息，以及使用检索到的知识指导生成过程。最近，由于通用大型语言模型（LLMs）的兴起（Chowdhery 等人，2022；OpenAI，2023），RAG 在自然语言处理（NLP）中越来越受欢迎，这在各种 NLP 任务中提高了性能。然而，存在两个主要挑战：首先，由于生成模型依赖于内部知识（权重），它们导致了大量的幻觉（Zhao 等人，2023b）。其次，由于它们的参数规模大以及更新成本高，传统的预训练和微调方法变得不可行。作为解决方案，RAG 方法（Gu 等人，2018；Weston 等人，2018；Cai 等人，2019b；Lewis 等人，2020）为 LLMs 与外部世界有效交互提供了一个有前途的解决方案。<br>RAG 被应用于广泛的下游 NLP 任务，包括机器翻译（Gu 等人，2018；Zhang 等人，2018；Xu 等人，2020；He 等人，2021）、对话生成（Weston 等人，2018；Wu 等人，2019；Cai 等人，2019a）、抽象摘要（Peng 等人，2019）和知识密集型生成（Lewis 等人，2020；Izacard 和 Grave，2021）。其中，大多数方法侧重于检索文本信息。例如，Guu 等人（2020b）；Lewis 等人（2020）；Borgeaud 等人（2022）；Izacard 等人（2022）联合训练了一个带有编码器或序列到序列 LM 的检索系统，实现了与使用明显更多参数的更大的 LMs 相当的性能。最近的研究还提出将检索器与思维链（CoT）提示相结合进行推理，以增强语言模型（He 等人，2022a；Trivedi 等人，2022；Zhao 等人，2023c）。</p><h3 id="3-Multimodal-Retrieval-Augmented-Generation"><a href="#3-Multimodal-Retrieval-Augmented-Generation" class="headerlink" title="3 Multimodal Retrieval-Augmented Generation"></a>3 Multimodal Retrieval-Augmented Generation</h3><p>对于每种模态，都有不同的检索和合成程序、目标任务和挑战。因此，我们按照模态对相关方法进行分组讨论，包括图像、代码、结构化知识、音频和视频。</p><h3 id="3-1-Image"><a href="#3-1-Image" class="headerlink" title="3.1 Image"></a>3.1 Image</h3><p>预训练模型的最新进展为通用图像 - 文本多模态模型带来了曙光（Ramesh 等人，2021a；Alayrac 等人，2022b；Aghajanyan 等人，2022；Yu 等人，2022；Dou 等人，2022；Li 等人，2023a）。然而，这些模型在预训练时需要巨大的计算资源和大量的模型参数 —— 因为它们需要记住大量的世界知识。更关键的是，它们不能有效地处理新的或域外的知识。为此，已经提出了多种检索增强方法，以更好地整合来自图像和文本文档的外部知识。在一般的文本生成任务中，图像检索还可以通过用更多的 “想象力” 扩展文本生成上下文来提高生成质量。</p><p><strong>图像描述</strong> 为了生成多风格的描述，Zhou 和 Long（2023）在生成描述之前使用一个风格感知的视觉编码器来检索图像内容。除了简单地编码视觉信息，Cho 等人（2022）还进一步使用图像 - 文本对之间的多模态相似性作为奖励函数来训练更细粒度的描述模型。除了检索图像元素，Sarto 等人（2022）；Shi 等人（2021）；Ramos 等人（2023）；Yang 等人（2023b）检索与输入相关的描述。Zhou 等人（2022a）通过检索新闻文章中基于视觉的实体来解决新闻图像描述问题。</p><p><strong>基于视觉的对话</strong> 这项任务（Lee 等人，2021b）需要检索视觉信息以产生相关的对话响应。Fan 等人（2021）使用基于 KNN 的信息获取（KIF）模块来增强生成模型，该模块检索图像和维基知识。Liang 等人（2021）从图像索引中检索与对话相关的图像来为响应生成器提供基础。Shen 等人（2021）训练一个词 - 图像映射模型来检索响应的视觉印象，然后使用文本和视觉信息进行响应生成。</p><p><strong>文本生成</strong> 对于一般的文本生成任务，图像检索也有助于扩展上下文。Yang 等人（2022a）通过检索现有图像和合成新生成的图像来增强文本模型的 “想象力”。因此，为语言模型注入想象力可以提高许多下游自然语言任务的性能。同样，Zhu 等人（2023）比较了 “想象力” 增强与合成和检索图像，并认为机器生成的图像由于更好地考虑了上下文，可以提供更好的指导。此外，Fang 和 Feng（2022）表明，在短语级别检索视觉信息可以显著提高机器翻译，特别是在文本上下文有限的情况下。图像 RAG 还可以帮助低资源任务，如医疗报告生成（Wu 等人，2022a）和建筑描述生成（Mille 等人，2020）。</p><p>除了在生成文本之前检索图像之外，Re-Imagen（Chen 等人，2022c）利用多模态知识库来检索图像 - 文本对，以促进图像生成。RA-CM3（Yasunaga 等人，2022）可以生成图像和文本的混合物。它表明，检索增强的图像生成在知识密集型生成任务上表现得更好，并开辟了新的能力，如多模态上下文学习。</p><h3 id="3-2-Code"><a href="#3-2-Code" class="headerlink" title="3.2 Code"></a>3.2 Code</h3><p>软件开发人员试图从大量可用资源中搜索相关信息以提高其生产力，例如未知术语的解释、可重用的代码补丁以及常见编程错误的解决方案（Xia 等人，2017）。受深度学习在自然语言处理中的进展启发，通用的检索增强生成范式使广泛的代码智能任务受益，包括代码补全（Lu 等人，2022b）、代码生成（Zhou 等人，2022b）和自动程序修复（APR）（Nashid 等人，2023）。然而，这些方法通常将编程语言和自然语言视为等效的标记序列，并忽略了源代码固有的丰富语义。为了解决这些限制，最近的研究工作集中在通过多模态学习来提高代码的泛化性能，即将诸如代码注释、标识符标签和抽象语法树（AST）等其他模态纳入代码预训练模型（Wang 等人，2021b；Guo 等人，2022；Li 等人，2022d）。为此，多模态检索增强生成方法已在各种特定于代码的任务中证明了其可行性。</p><p><strong>文本到代码生成</strong> 众多研究已经对利用相关代码和相关文档来造福代码生成模型进行了研究。一个突出的例子是 REDCODER（Parvez 等人，2021），它从现有的代码库中检索排名靠前的代码片段或摘要，并将它们与源代码序列聚合，以增强生成或总结能力。作为另一种这样的方法，DocPrompting（Zhou 等人，2022b）使用一组相关文档作为上下文提示，通过检索生成相应的代码。除了这些词汇模态之外，Hayati 等人（2018）提出了一种基于语法的代码生成方法，以明确地参考 AST 中现有的子树作为模板来指导代码生成。</p><p><strong>代码到文本生成</strong> 基于检索的代码摘要方法得到了广泛研究。例如，RACE（Shi 等人，2022）利用相关的代码差异及其相关的提交消息来增强提交消息的生成。此外，RACE 计算源代码差异与检索到的差异之间的语义相似度，以权衡不同输入模态的重要性。Rencos（Zhang 等人，2020）根据给定查询代码的语法级相似度和语义级相似度方面检索两个相似的代码片段。然后在解码阶段将这些相似的上下文合并到摘要模型中。Liu 等人（2021）进一步探索了这个想法，其中检索到的代码 - 摘要对通过局部注意力机制用于增强源代码的原始代码属性图（Yamaguchi 等人，2014）。为了捕获全局语义以更好地进行代码结构学习，进一步采用了全局结构感知的自注意力机制（Zhu 等人，2019）。</p><p><strong>代码补全</strong> 基于检索的代码补全任务（McConnell，2004）的最新进展越来越受到关注。值得注意的是，Hashimoto 等人（2018）采用了检索和编辑框架来提高模型在代码自动补全任务中的性能。为了解决实际的代码补全场景，ReACC（Lu 等人，2022b）同时考虑了未完成代码片段的词汇和语义信息，利用混合技术将基于词汇的稀疏检索器和基于语义的密集检索器相结合。首先，混合检索器根据给定的不完整代码从代码库中搜索相关代码。然后，将未完成的代码与检索结果连接起来，一个自回归代码补全生成器将基于它们生成完整的代码。为了解决项目关系，CoCoMIC（Ding 等人，2022）将一个代码文件分解为四个组件：文件、全局变量、类和函数。它基于所有相关代码组件之间的层次关系构建一个文件内上下文图，并通过考虑文件内和跨文件的依赖关系形成一个项目级上下文图。给定一个不完整的程序，CoCoMIC 从其项目级上下文图中检索最相关的跨文件实体，并联合学习不完整的程序和检索到的跨文件上下文以完成代码补全。</p><p><strong>自动程序修复（APR）</strong> 受到很大一部分提交是由现有代码提交组成这一性质的启发（Martinez 等人，2014），APR 通常被视为一个搜索问题，通过遍历修复成分的搜索空间来确定正确的修复（Qi 等人，2014），基于一个冗余假设（White 等人，2019），即目标修复通常可以在搜索空间中重建。最近的研究表明，从现有的搜索空间中挖掘相关的错误修复模式（Jiang 等人，2018）以及从 StackOverflow 中获取外部修复模板（Liu 和 Zhong，2018）可以极大地有益于 APR 模型。Joshi 等人（2022）根据错误消息的相似性直观地对一组错误修复对进行排名，以开发少样本提示。他们将编译器错误消息纳入大型编程语言模型 Codex（Chen 等人，2021）以进行多语言 APR。CEDAR（Nashid 等人，2023）进一步将这一想法扩展到使用相关代码演示的基于检索的提示设计，包括更多模态，如单元测试、错误类型和错误信息。此外，Jin 等人（2023）利用静态分析器 Infer 提取错误类型、错误位置和语法层次结构（Clement 等人，2021）来确定重点上下文的优先级。然后，他们从现有的错误修复代码库中检索语义相似的修复，并将检索到的修复和重点上下文连接起来，形成程序修复的指令提示。</p><p><strong>将代码作为中间步骤进行推理</strong> 虽然大型语言模型（LLMs）最近已经展示了其执行推理任务的令人印象深刻的能力，但它们仍然容易出现逻辑和算术错误（Gao 等人，2022a；Chen 等人，2022d；Madaan 等人，2022）。为了缓解这个问题，新兴的研究论文专注于使用代码的大型语言模型（例如，Codex（Chen 等人，2021））来生成用于解决逻辑和算术任务的代码命令，并调用外部解释器来执行这些命令以获得结果。值得注意的是，Gao 等人（2022a）提议生成 Python 程序作为中间推理步骤，并将解决方案步骤卸载到 Python 解释器。此外，Chen 等人（2022d）探索不仅为文本而且为编程语言语句生成思维链（CoT）（Wei 等人，2022）作为推理步骤来解决问题。在推理阶段，通过外部解释器获得答案。类似地，Lyu 等人（2023）提出了忠实的 CoT，它首先将自然语言查询转换为符号推理链，然后通过调用外部执行器来解决推理链以得出答案。</p><p>另一个例子是 Ye 等人（2023），它利用大型语言模型将基于表格的推理任务分解为子任务，通过 Codex 的 SQL 查询在每个步骤中分离逻辑和数值计算，并调用 SQL 解释器来解决它们（这个过程称为 “解析 - 执行 - 填充”）。</p><p>代码的大型语言模型也被称为结构良好的常识推理器，甚至比大型语言模型具有更好的结构（Madaan 等人，2022）。因此，先前的研究也研究了将结构化常识生成任务转换为代码生成问题，并使用代码的大型语言模型作为求解器的想法。其中一项工作是 CoCoGen（Madaan 等人，2022），它将每个训练样本（由文本输入和输出结构组成）转换为 Python 中的 Tree 类。然后，代码的大型语言模型对文本输入进行少样本推理以生成 Python 代码，然后将 Python 代码转换回原始结构进行评估。此外，像 Codex 这样的代码大型语言模型在合成计算机代码方面的成功也使它们适合生成正式代码。受此启发，Wu 等人（2022b）提议通过采用 Codex 从自然语言数学中为交互式定理证明器 Isabelle（Wenzel 等人，2008）生成形式化定理来证明数学定理。</p><h3 id="3-3-Structured-Knowledge"><a href="#3-3-Structured-Knowledge" class="headerlink" title="3.3 Structured Knowledge"></a>3.3 Structured Knowledge</h3><p>生成模型中的一个公开挑战是幻觉，即模型很可能输出错误的信息。因此，一个潜在的解决方案是利用检索到的结构化知识来支撑生成，例如知识图谱、表格和数据库。</p><p><strong>问答（QA）</strong> 使用知识的一个自然场景是问答。为了通过提取最相关的知识来增强知识库（KB）问答，Hu 等人（2022b）使用密集检索，Liu 等人（2022b）使用交叉编码器排序器。Shu 等人（2022）采用多粒度检索来提取相关的 KB 上下文，并使用受限解码来控制输出空间。在表格问答中，Nan 等人（2022）提出了一个需要检索相关表格以生成答案的数据集。Pan 等人（2021）随后提出了一种使用基于变压器的系统来检索最相关的表格并定位正确单元格的方法。此外，为了改进视频问答，Hu 等人（2023）从存储在内存中的知识图谱（KG）编码中进行检索。RAG 最突出的应用仍然在开放域问答中，其中提出了多个数据集（Lin 等人，2023；Ramnath 等人，2021）。对于检索，Ma 等人（2022）将 KG 进行语言化，然后使用密集段落检索。Fan 等人（2019）；Gupta 等人（2018）将 KG 信息编码为密集表示。Pramanik 等人（2021）；Jin 等人（2022）构建图嵌入来检索与问题相关的证据。Xu 等人（2021）；Baek 等人（2023）使用语义相似度和文本匹配方法。综合可以在不同阶段发生。在输入阶段，Xu 等人（2021）；Baek 等人（2023）将检索到的上下文作为额外的输入或提示输入到 PLM 中。（Ma 等人，2022；Fan 等人，2019）调整生成器以接受上下文表示作为输入。在模型推理阶段，一个有趣的工作是 Hu 等人（2022c），它在 PLM 中插入一个交互层来引导外部 KG 推理模块。</p><p><strong>一般文本生成</strong> 外部知识检索可以改进一般文本生成，使其在事实上更有依据。Liu 等人（2022a）提出了一种记忆增强方法，以根据知识图谱（KG）来调节自回归语言模型。在推理过程中，Tan 等人（2022）通过密集检索选择知识条目，然后将它们注入到预训练语言模型（PLM）的输入编码和输出解码阶段。对于特定领域的文本生成，Frisoni 等人（2022）；Yang 等人（2021）；Li 等人（2019）检索医疗报告块或报告模板以扩充输入提示。然后，他们使用自行设计的解码器或图形转换器来生成有依据的报告。为了提高可解释性，RAG 可用于选择事实作为可解释的推理路径（Aggarwal 等人，2021；Jansen 和 Ustalov，2019）。此外，RAG 对于低资源生成任务特别有用，例如问题生成（Yu 和 Jiang，2021；Xin 等人，2021；Gu 等人，2019）、文档到幻灯片（Sun 等人，2021）、表到文本（Su 等人，2021）、反驳生成（Jo 等人，2021）、实体描述生成（Cheng 等人，2020）和基于文本的游戏（Murugesan 等人等人，2021）。  </p><p>最近的研究试图通过利用外部结构化知识来减少大型语言模型中的幻觉。例如，在微调期间，LaMDA（Thoppilan 等人，2022）学会在响应用户之前咨询外部知识源，包括能够检索知识三元组和网页 URL 的信息检索系统。一些论文将生成模型（通常是大型语言模型）视为黑箱，并在不进行微调的情况下检索结构化信息。例如，BINDER（Cheng 等人，2023）使用上下文学习来输出设计的 API 调用，从表中检索与问题相关的列。</p><p><strong>利用知识进行推理</strong> 通过选择知识，可以以更有依据和可解释的方式解决推理任务。为了为给定的假设生成一个蕴涵树解释，Neves Ribeiro 等人（2022）从文本前提中迭代检索并将它们与生成相结合。Yang 等人（2022c）提出了一个数学推理器，它首先检索高度相关的代数知识，然后将它们作为提示传递，以改进生成任务的语义表示。随着大型语言模型的最新进展，He 等人（2022a）；Li 等人（2023b）根据从思维链（CoT）提示（Wei 等人，2022）中获得的推理步骤，从诸如 Wikidata 等知识图谱（KG）和知识库（KB）中进行检索。</p><h3 id="3-4-Audio"><a href="#3-4-Audio" class="headerlink" title="3.4 Audio"></a>3.4 Audio</h3><p>音频 RAG 在将音频信息纳入特定的音频语言任务（如音乐字幕、音乐和文本生成以及语音识别）中很有用。此外，使用音频 RAG 进行音频数据增强在缓解音频文本训练数据的缺乏方面也被证明是有用的。这可能是一个有前途的未来方向（Li 等人，2022a）。</p><p><strong>音乐字幕</strong> 音乐字幕是给定音乐音频生成文本描述或歌词的任务。并且探索了 RAG 以学习更好的音频 - 歌词对齐。Manco 等人（2021）提出了第一个音乐音频字幕模型 MusCaps。首先，一个预训练的多模态编码器获得音频表示，该表示在输入中检索音乐特征。由于预训练弥合了音频模态和文本理解之间的差距，该方法提高了任务性能。He 等人（2022b）通过对比学习学习音频 - 歌词对齐，从而为音乐生成更高质量的字幕。</p><p><strong>音乐生成</strong> Royal 等人（2020）使用深度神经哈希来检索音乐构建块，然后通过使用当前音乐片段来检索下一个片段进行生成。在自动语音识别（ASR）中，Chan 等人（2023）使用 k 近邻（KNN）方法检索与音频和文本嵌入相关的外部知识。检索到的知识显著减少了 ASR 的领域适应时间。<br>音频模态与其他模态（如视频）紧密交织在一起。因此，在使用音频特征进行文本 - 视频检索方面的最新进展（Falcon 等人，2022；Mithun 等人，2018）可以使涉及其他模态的 RAG 任务受益。此外，尽管音频 - 文本检索是一项长期存在的任务（Liu 等人，2015；Milde 等人，2016a，b），探索最近发现的技术（Hu 等人，2022a；Lou 等人，2022；Koepke 等人，2022）可能会带来进一步的改进。</p><h3 id="3-5-Video"><a href="#3-5-Video" class="headerlink" title="3.5 Video"></a>3.5 Video</h3><p>用于生成的视频片段检索主要用于两个任务：基于视频的对话和视频字幕。最近，通过视频检索增强大型语言模型也表现出良好的性能，尤其是在少样本设置中。</p><p><strong>基于视频的对话</strong> 给定视频上下文，模型学习参与相关对话。Pasunuru 和 Bansal（2018）引入了一个视频上下文、多说话者对话数据集，这对研究人员提出了挑战，要求他们开发出能够从实时视频中生成相关响应的基于视觉的对话模型。类似地，Lei 等人（2020）提出了 TVQA+，这是一个需要检索相关视频时刻来回答关于视频的文本问题的数据集。然后，它提出了一个统一的框架，将视频片段编码为表示，使用注意力机制定位相关信息，并生成文本答案。<br>为了更好地执行基于视觉的对话任务，Le 等人（2020）从先前的用户查询中检索视觉线索。这些线索随后被用作上下文信息来构建相关响应。在视频问答方面，它大大优于以前的方法。最近，Le 等人（2022）从视频中提取视觉线索以增强基于视频的对话。视频检索是通过神经模块网络执行的，这些网络由先前对话中的实体和动作实例化。</p><p><strong>视频字幕</strong> 出于与 RAG 相似的动机，Long 等人（2018）首先提议使用注意力层自动选择最显著的视觉或语义特征，并使用它们来增强字幕生成。结果，它稳定地优于以前的方法。（Whitehead 等人，2018）随后开发了一种基于检索的视频描述生成方法。对于新闻视频，它检索主题相关的新闻文档，然后使用知识感知的视频描述网络生成描述。</p><p><strong>大型语言模型增强</strong> Wang 等人（2022）试图增强大型语言模型，使其能够从几个示例推广到各种视频到文本的任务。由于大型语言模型无法接受视频输入，它首先使用图像 - 语言模型将视频内容转换为属性，然后提示检索到的内容来指导大型语言模型。它在广泛的视频 - 语言任务中表现出良好的少样本性能。  </p><p>目前，视频 - 文本研究的瓶颈主要在于不同模态之间的表示差距。研究一直在尝试通过联合学习来学习视频 - 文本之间更好的映射（Xu 等人，2015；Sun 等人，2019）。关于密集视频表示学习的近期研究对未来的视频 RAG 也可能有用。此外，一些论文（Yang 等人，2023a；Wang 等人，2021a）试图引入不同模态之间的细粒度交互，以学习更好的对齐表示。Zeng 等人（2022）鼓励不同模态的多个预训练模型以零样本的方式相互交换信息。最近，Zhang 等人（2023a）训练 Video-Llama 以更好地将预训练的视频和音频编码器与大型语言模型的嵌入空间对齐。</p><h3 id="4-Future-Directions"><a href="#4-Future-Directions" class="headerlink" title="4 Future Directions"></a>4 Future Directions</h3><p>随着多模态大型语言模型的发展，检索多模态信息以增强文本生成将是一个有前途的方向，以便在现实世界的背景下更好地为文本生成提供依据，有助于构建一个完全有意识并且能够更好地与世界互动的模型。具体来说，我们描述了一些可能对社区有益的潜在方向。</p><h3 id="4-1-Retrieval-Augmented-Multimodal-Reasoning"><a href="#4-1-Retrieval-Augmented-Multimodal-Reasoning" class="headerlink" title="4.1 Retrieval Augmented Multimodal Reasoning"></a>4.1 Retrieval Augmented Multimodal Reasoning</h3><p>多模态 RAG 的一个潜在应用是多模态推理。Lu 等人（2022a）首先引入了 ScienceQA，这是一个带有讲座和解释注释的大规模多模态科学问题数据集。然后，Zhang 等人（2023b）提出了多模态思维链（Multimodal-CoT），它将语言和视觉模态纳入一个两阶段（推理生成和答案推断）框架，用一个小得多的微调模型大幅超越 GPT-3.5。与 Zhang 等人（2023b）类似，kosmos-1（Huang 等人，2023b）将多模态推理分解为两个步骤。它首先根据视觉信息生成中间内容作为推理依据，然后使用生成的推理依据得出结果。然而，这两种方法在理解某些类型的图像（例如地图）时可能存在困难，这可以通过检索信息丰富的图像 - 文本对来缓解。</p><h3 id="4-2-Building-a-Multimodal-Knowledge-Index"><a href="#4-2-Building-a-Multimodal-Knowledge-Index" class="headerlink" title="4.2 Building a Multimodal Knowledge Index"></a>4.2 Building a Multimodal Knowledge Index</h3><p>为了促进多模态 RAG，最基本的方面之一是构建多模态知识索引。其目标有两个：首先，密集表示应支持低存储、知识库的动态更新和准确搜索。其次，在局部敏感哈希（Leskovec 等人，2014）的帮助下，它可以实现更快的搜索速度，解决了知识库极大扩展时的缩放和鲁棒性问题。  </p><p>目前，对于文档（Karpukhin 等人，2020b；Gao 和 Callan，2021；Gao 等人，2021）、实体（Sciavolino 等人，2021；Lee 等人，2021a）和图像（Radford 等人，2021a）的文本片段的密集表示已得到广泛研究。此外，还有研究以端到端的方式优化密集表示（Lewis 等人，2020）。然而，很少有论文（Chen 等人，2022a）同时探索为下游生成任务构建多模态索引。如何将多模态知识索引映射到统一空间仍然是一个长期的挑战。</p><h3 id="4-3-Pretraining-with-Multimodal-Retrieval"><a href="#4-3-Pretraining-with-Multimodal-Retrieval" class="headerlink" title="4.3 Pretraining with Multimodal Retrieval"></a>4.3 Pretraining with Multimodal Retrieval</h3><p>本次调查回顾了通过检索多模态信息来增强生成模型的研究。具体来说，我们将当前领域分类为通过不同模态进行增强，包括图像、代码、结构化知识、语音和视频。随着大型多模态模型的出现，我们相信本次调查可以作为这个新兴且有前途的领域的综合概述。此外，我们希望它能够鼓励该领域未来的研究，包括检索增强的多模态推理、构建多模态知识索引以及将检索与预训练相结合。</p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>RAG 也有一些局限性。例如，存在归因 - 流畅性的权衡（Aksitov 等人，2023），其中由于检索到的知识所增加的约束，输出质量会受到影响。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 09.23-09.29</title>
    <link href="/2024/09/29/%E5%91%A8%E8%AE%B0%20-%202024%2009.23-09.29/"/>
    <url>/2024/09/29/%E5%91%A8%E8%AE%B0%20-%202024%2009.23-09.29/</url>
    
    <content type="html"><![CDATA[<h2 id="09-23-周一-晴"><a href="#09-23-周一-晴" class="headerlink" title="09.23 周一 晴"></a>09.23 周一 晴</h2><p>今早一早起来第一件事就是打开看牛客竞赛加了多少分。<br>昨晚的《牛客周赛 Round 61》真的太抓马了。</p><p>赛后重测，我的T4居然过了。拿下真正意义上的AK + rank 1。<br>最后直接加TM244分！<br>舒服了。</p><p>今天辅导员还发了十月评优的通知，一看我的绩点刚好在50%线（3.44 vs 3.45）以下，蚌埠住了。<br>不过想到应该还有一部份同学没修完课程，也不知道最后结算下来排名多少，希望在前50%吧（悲）</p><h2 id="09-24-周二-晴"><a href="#09-24-周二-晴" class="headerlink" title="09.24 周二 晴"></a>09.24 周二 晴</h2><h2 id="09-25-周三-晴"><a href="#09-25-周三-晴" class="headerlink" title="09.25 周三 晴"></a>09.25 周三 晴</h2><p>今天一早去子彬院交证明材料。</p><p>老爸在群里说让我赶紧把基金里的钱转出来买股票。还说国家队亲自下场了。<br>我说我上班没时间，就没空弄了。</p><p>2024 10.26评：</p><blockquote><p>没想到老爸说的居然是真的，一波大牛市没赶上……</p></blockquote><h2 id="09-26-周四-晴"><a href="#09-26-周四-晴" class="headerlink" title="09.26 周四 晴"></a>09.26 周四 晴</h2><h2 id="09-27-周五-大雨转晴"><a href="#09-27-周五-大雨转晴" class="headerlink" title="09.27 周五 大雨转晴"></a>09.27 周五 大雨转晴</h2><p>早上一起床外面就在下大雨（あめ），等了有一会儿雨就停了。<br>中午在工位上摸鱼，居然就出太阳了，简直神金。</p><p>中午在公司依旧是捣鼓 <code>muse_guarantee_service</code>。搞这个已经拖了一周了，前天刚刚把FS的v4模型接上，终于输出正常值了。今天又遇到了个巨坑，从早上开始我就一直在骚扰FS，一开始FS一度认为是我的代码有问题。到后面逐步发现是我没法make_redis_client。</p><p>这破班是真的不想上了。</p><p>中午和XP、张H一起到T4吃，我自然是吃了棒约翰。<br>晚上就和XP一起在F3吃自助。</p><p>晚上回到宿舍发现Mac连不上Wi-Fi了，真的让人红温。手机和iPad都能连。<br>这Mac系统是真的一坨屎。</p><h2 id="09-28-周六-晴"><a href="#09-28-周六-晴" class="headerlink" title="09.28 周六 晴"></a>09.28 周六 晴</h2><p>今天就能run了。早上7点就被舍友吵醒了，才想起他昨晚说今天要和本科同学玩上一天，羡慕。</p><p>打开微信，发现之前申请的十月评优落选了。到最后去掉优秀学生干部的重叠名额，发现我还差两个顺位。<br>说实话，我不是垫底已经满足了😌</p><p>下午5点半坐 Z99溜了。</p><h2 id="09-29-周日-晴"><a href="#09-29-周日-晴" class="headerlink" title="09.29 周日 晴"></a>09.29 周日 晴</h2><p>早上10点不到，刚上地铁，蔡YZ就让我进群开小组会。蚌埠住了，我都给忘了。</p><p>在地铁上自然是没法好好开会，我一开口，郑老师就说信号差听不清。<br>然后由于我没有把周报放到语雀上，又被他数落了一番。</p><p>在地铁出站的时候，我把我那个</p><p>2024 10.26评：</p><blockquote><p>说到语雀，我就来气。<br>就算到现在回去看语雀文档的VectorDB知识 贡献度。我还是排在第三位。<br>可是我换来啥呢？参加的NIPS23 ANNS大赛，我连个作者名字都没🤡……<br>我以后的知识记录，絶対に不会再放到语雀上了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 09.09-09.15</title>
    <link href="/2024/09/15/%E5%91%A8%E8%AE%B0%20-%202024%2009.09-09.15/"/>
    <url>/2024/09/15/%E5%91%A8%E8%AE%B0%20-%202024%2009.09-09.15/</url>
    
    <content type="html"><![CDATA[<h2 id="09-09-周一-晴"><a href="#09-09-周一-晴" class="headerlink" title="09.09 周一 晴"></a>09.09 周一 晴</h2><p>朝（あさ）、電話（でんわ）がありました。<br>是顺丰要问我确定有没有收到嘴贴，宿舍东西太多了我就管不着了。<br>结果他们说不要没确认就投诉他们，不然他们要调监控报警……</p><p>另外字节的中秋礼盒送到广州了，里面有6盒月饼 + 一床被子（填充物大豆纤维，200*239）。感觉还不错。</p><p>晚上去4楼试了下左转第一家，就是麻辣烫。我选的无辣汤底，加芝麻酱。还是觉得有些刺激性。</p><h2 id="09-10-周二-晴"><a href="#09-10-周二-晴" class="headerlink" title="09.10 周二 晴"></a>09.10 周二 晴</h2><p>上周和辅导员约好了今早去找她，咨询选调相关的事宜。<br>谈了大概半小时，总结下来就是入党来不及，最多只能以积极分子的身份参加选调。<br>并且由于我先前的学生工作不足，竞选参加政务实习的机会也不大。<br>だから，我选调上岸的希望不大。</p><p>我们实验室学硕博小群约好了今天下午三点一起到郑老师办公室送他教师节礼物。<br>结果我直到下到楼下才发现下了小雨，又倒回去拿雨伞。最后在雨中一路狂飙。<br>迟到2分钟，到老师办公室才发现已经站满了人。</p><h2 id="09-11-周三-晴"><a href="#09-11-周三-晴" class="headerlink" title="09.11 周三 晴"></a>09.11 周三 晴</h2><p>早上到郑老师办公室和他讨论新专硕同学 + 我自己之后的研究课题。<br>又是和他互相画大饼🫓环节。<br>到最后他问我有没有转博意愿，我很委婉地表达了自己还要再考虑下。</p><p>得知幼儿园 + 小学同学 何QS考了雅思，到英国的六普大学读CS了。<br>㊗️他学业顺利～</p><p>和家人聊天，聊到了进大学当老师的职业路线。<br>我问老爸广工教授待遇怎么样，他说他想加之前留校任教同学VX，但是对方没同意。<br>看得出老爸还是比较希望我去当教授的，毕竟他自己的</p><h2 id="09-12-周四-晴"><a href="#09-12-周四-晴" class="headerlink" title="09.12 周四 晴"></a>09.12 周四 晴</h2><h2 id="09-13-周五-晴"><a href="#09-13-周五-晴" class="headerlink" title="09.13 周五 晴"></a>09.13 周五 晴</h2><h2 id="09-14-周六-晴"><a href="#09-14-周六-晴" class="headerlink" title="09.14 周六 晴"></a>09.14 周六 晴</h2><h2 id="09-15-周日-晴"><a href="#09-15-周日-晴" class="headerlink" title="09.15 周日 晴"></a>09.15 周日 晴</h2>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - VLDB2024 Kamel - A Scalable BERT-based System for Trajectory Imputation</title>
    <link href="/2024/09/11/%E7%AC%94%E8%AE%B0%20-%20VLDB2024%20Kamel%20-%20A%20Scalable%20BERT-based%20System%20for%20Trajectory%20Imputation/"/>
    <url>/2024/09/11/%E7%AC%94%E8%AE%B0%20-%20VLDB2024%20Kamel%20-%20A%20Scalable%20BERT-based%20System%20for%20Trajectory%20Imputation/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/3539618.3591919">ACM-digital-library</a><br><a href="https://www.vldb.org/pvldb/vol17/p525-musleh.pdf">https://www.vldb.org/pvldb/vol17/p525-musleh.pdf</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>许多重要的应用依赖于详细的轨迹数据。 然而，不幸的是，轨迹数据集通常稀疏，在每两点之间存在较大的空间和时间间隔，这是影响其准确性的主要障碍。本文介绍了Kamel；这是一个可扩展的轨迹插补系统，它插入额外的真实轨迹点，从而提高轨迹应用的准确性。Kamel将轨迹插补问题映射到寻找缺失词的问题；这是自然语言处理（NLP）领域中的一个经典问题。这使得可以使用广泛采用的BERT模型来进行轨迹插补。然而，原版BERT并不适用于轨迹的特殊特性。因此，Kamel基于BERT，但随后在其操作中增加了空间意识，调整轨迹数据使其更接近语言数据的性质，并增加了多点插补能力；所有这些都封装在一个系统中。基于真实数据集的实验结果显示，Kamel显著优于其竞争对手，并适用于城市规模的轨迹、大的间隔以及严格的精度阈值。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>在本文中，我们介绍了Kamel；这是一种新的可扩展轨迹插补框架，首次结合了以下独特特征：(1) 不需要了解底层的道路网络，因为它是仅基于输入轨迹进行插补的；(2) 不需要先前高度密集的轨迹数据（即，在小范围内有大量轨迹）；(3) 能够扩展以支持超出交叉路口或小城市区域的大地理区域；(4) 支持离线批量模式和在线模式下的轨迹插补，适用于传入的轨迹流。</p><p>Kamel的核心思想是将轨迹插补映射到自然语言处理（NLP）中的“寻找缺失词”问题，这一问题通常使用广泛使用的BERT模型来解决。例如，给定一个陈述如“巴黎是法国的…”，其中“…”代表一个由于语音识别、翻译或拼写错误而缺失的词，BERT能够找出缺失的词是“首都”。为此，BERT首先通过大量陈述进行训练。Kamel将轨迹视为陈述，其中轨迹&#x2F;陈述由从有限的可能点&#x2F;词集合中抽取的一组有序点&#x2F;词组成。此外，轨迹&#x2F;陈述中的点&#x2F;词在空间上&#x2F;语义上是相关的，并受底层道路网络&#x2F;语言语法规则的约束。因此，Kamel的核心装备了一个通过一组轨迹训练的BERT模型，然后用于插补稀疏轨迹。</p><p>然而，直接在Kamel中使用BERT并不直接且会导致非常差的准确性和性能。这主要是由于三个主要挑战：<br>(1) 空间感知。BERT不具备空间感知能力，可能会因包含与空间无关的数据集而导致模型训练不佳，或者产生在空间上不可行的结果。<br>(2) 训练数据因素。这是每个词在训练数据集中平均出现的次数。原始的BERT模型是在包含约30,000（30,522）个不同词汇的约33亿词的语料库上训练的，因此每个词在训练集中平均出现约10万次。相比之下，轨迹数据远未达到这些数量级。一个典型的轨迹数据集（例如 Portland 数据集）可能包含约200万个GPS点，其中有约150万个不同的点，这意味着每个点在训练数据集中平均只出现一次。这种极低的训练数据量显著降低了BERT的质量，几乎使其无用。<br>(3) 多个缺失点。BERT通常旨在在一个陈述中找到一个缺失的词，而轨迹插补可能需要在两个已知点之间找到多个缺失点。重复应用BERT会显著降低插补质量和性能。</p><p>Kamel通过由五个主要模块组成的架构克服了使用BERT的所有挑战，这些模块分别是：分词(Tokenization)、分区(Partitioning)、空间约束(Spatial Constraints)、多点插补(Multipoint Imputation) 和反分词(Detokenization)。分区模块和空间约束模块通过分别在BERT的训练过程和输出结果中注入空间感知来应对空间感知挑战。分词模块和反分词模块通过将点聚类成分词来增加其在训练数据集中的出现次数，从而应对训练数据因素挑战。多点插补模块通过估计多个点一起形成插补段的概率来应对多个缺失点的挑战。</p><p>我们的目标是展示NLP模型（如BERT），在使用轨迹数据训练后，具有推动轨迹插补技术前沿的潜力。我们并不是要寻找最适合轨迹处理的最佳NLP模型。我们选择了BERT，因为它是最常用的模型之一。然而，其他BERT变体或语言模型也可以通过不同的适应性调整来使用。我们选择了一种设计，即将BERT作为架构的一部分直接应用于轨迹数据的训练，而不是语言数据，这使得Kamel对于已经熟悉该模型的工业界和开源市场更具吸引力，并且对现有系统的干扰较小。基于Kamel系统部署和真实数据集的实验评估表明，Kamel能够从实际轨迹中以高达89%的召回率和高精度识别出缺失点。与其他方法相比，Kamel的得分几乎是基线和其他最先进方法的三倍，并且能够在最大间隙达2.5公里的各种直线和曲线轨迹上工作。</p><p>本文其余部分组织如下：第2节介绍了Kamel架构。第3至7节描述了Kamel的五个模块。第8节展示了实验结果。第9节讨论了相关工作。第10节总结了全文。</p><h2 id="2-KAMEL-ARCHITECTURE"><a href="#2-KAMEL-ARCHITECTURE" class="headerlink" title="2 KAMEL ARCHITECTURE"></a>2 KAMEL ARCHITECTURE</h2><p>图1展示了Kamel的架构，它接收两种类型的输入：(1) 训练数据；新的轨迹数据集不会产生任何输出，而是Kamel用来丰富其模型的数据。(2) 稀疏轨迹；用户想要插补的轨迹。Kamel可以批量离线模式或流式接收这些数据。在这两种情况下，Kamel都会输出与稀疏输入对应的密集轨迹。Kamel是一个基于BERT的系统，其中BERT作为核心组件，在图1底部以一个黑盒形式展示。然而，正如前面提到的，直接使用BERT会导致较差的准确性和性能，因为存在三个主要挑战：空间感知、训练数据因素以及多个缺失点。因此，Kamel内部由五个主要模块组成，以应对这些挑战，分别是：标记化、分区、空间约束、多点插补和去标记化，简要介绍如下：</p><ul><li><p><strong>标记化（Tokenization）</strong>：这个模块是通往Kamel的入口，所有输入首先经过这个模块。它通过将每个输入点转换为覆盖特定空间区域的标记来解决训练数据因素挑战。这减少了不同项目的数量并增加了它们在训练集中的出现频率。该模块的输出是一组发送到分区模块的标记。详情见第3节。</p></li><li><p><strong>分区（Partitioning）</strong>：这个模块解决了空间感知挑战，因为它根据输入数据的空间覆盖范围构建了多种BERT模型。它接收来自标记化模块的一组标记作为输入。如果这些标记代表训练数据，分区模块会将此类数据存储在其原始轨迹存储中。然后，它决定是否需要丰富或扩展现有的某个模型，甚至构建一个新的模型，并相应地调用BERT。新模型或更新后的模型将存储在一个专用的模型仓库中。如果输入标记代表需要插补的稀疏轨迹，则分区模块确定需要使用哪个BERT模型来插补每条轨迹。对于每一条由两个终端标记表示的轨迹间隙，它调用选定的BERT模型，在两个终端标记之间插补一个标记。BERT的输出是一组候选标记（带概率值），发送到空间约束模块。详情见第4节。</p></li><li><p><strong>空间约束（Spatial Constraints）</strong>：这个模块解决了BERT输出中的空间感知问题。它的输入是从BERT产生的候选标记集合。然后，它会丢弃一些不满足一组空间约束的标记。剩余的标记传递给多点插补模块。详情见第5节。</p></li></ul><ul><li><p>多点插补（Multipoint Imputation）。这个模块解决了多个缺失点的挑战。它通过迭代调用BERT将输入从候选插补标记转换为一系列标记。它输出每个轨迹间隙中最有可能的标记序列，并将其发送到去标记化模块。详情见第6节。</p></li><li><p>去标记化（Detokenization）。这个模块解决了训练数据因素挑战，并在某种程度上逆转了标记化模块的功能。该模块的输入是用标记表示的插补轨迹。输出是以点表示的插补轨迹，这是Kamel的最终输出。详情见第7节。</p></li></ul><h2 id="3-TOKENIZATION"><a href="#3-TOKENIZATION" class="headerlink" title="3 TOKENIZATION"></a>3 TOKENIZATION</h2><p>这个模块是Kamel的入口，所有输入数据（无论是训练数据还是稀疏轨迹）都必须先经过这个模块才能进入其他任何Kamel模块。一个典型的轨迹输入由若干点组成，每个点由其经纬度坐标表示。由于这些坐标的高精度，某个特定点在训练数据集中很少出现超过一两次，这不足以训练BERT模型。相比之下，BERT处理的语言中的每个词在训练过程中可能会出现十多万次。该模块旨在通过将整个空间划分为一组不重叠的单元格来解决这一挑战，在同一个单元格中的所有点都被赋予相同的标记，即单元格ID。这意味着轨迹数据集将以一组标记（单元格ID）的形式呈现，而不是一组点。因此，不同的点将具有相同的标记，因此它们在由标记组成的训练数据集中可以更频繁地出现。为了提高准确性和效率，标记化模块必须决定如何将空间划分为单元格（第3.1节）以及每个数据集的最佳单元格大小（第3.2节）。</p><h3 id="3-1-六边形空间划分"><a href="#3-1-六边形空间划分" class="headerlink" title="3.1 六边形空间划分"></a>3.1 六边形空间划分</h3><p>对于其标记方案，Kamel使用基于Uber的H3六边形分层空间索引的密集六边形网格结构。在这个索引中，整个世界地理区域被划分为一组不重叠的六边形，每个六边形都有一个唯一的ID hh。图2展示了使用六边形网格的标记化过程。图的上半部分显示了一个包含五个点 p1p1​ 到 p5p5​ 的输入轨迹，而下半部分显示了由五个标记 t1t1​ 到 t5t5​ 组成的输出标记化轨迹，其中每个标记对应一个输入点。需要注意的是，背景中的道路网络仅用于说明，但插补过程并不依赖于（甚至不知道）它。其他替代标记方法如Google S2 方块分区也是一种可能的选择，但实验结果表明（第8.5节），六边形有助于实现更精确的插补。</p><p>使用六边形而非常见的方形或矩形划分的原因在于：在六边形网格中，每个单元格 cc 的六个邻近单元格在距离 cc 的中心和与 cc 共享边界的长度方面具有完全相同的属性。而在矩形划分中，每个单元格会有四个角上的邻居共享一个点，两个邻居共享一条边长，另外两个邻居共享一条宽度。确保所有邻居具有相同的属性使它更适合BERT，因为从一个标记（六边形）到其邻近标记的转换不会受到我们的划分方式的影响。同时，我们承认与矩形不同，六边形不是分层的，我们无法将一组相邻的六边形单元格拟合进一个更大的六边形单元格中。然而，这对Kamel来说并不是问题，因为它不需要这种层次结构。六边形仅用于将点标记化为单元格，之后再将单元格去标记化为点（第7节）。将点映射到其对应的六边形单元格所需的时间是常数时间，这可以通过一系列坐标系统转换来完成。</p><h3 id="3-2-Cell-Size-Optimization"><a href="#3-2-Cell-Size-Optimization" class="headerlink" title="3.2 Cell Size Optimization"></a>3.2 Cell Size Optimization</h3><p>选择正确的单元格大小将会显著影响Kamel的准确性。图3(a)-(c)展示了三种不同大小的单元格，其边长分别为25米、75米和200米，覆盖在同一段路网之上。单元格大小与不同单元格（标记）的数量成反比；单元格越大，不同标记的数量就越少，因此标记在训练集中出现的次数就会更多。因此，较大的单元格大小有助于解决训练数据因素的问题，并推动更好的插值精度。同时，随着单元格大小的增加，每个单元格变得不再能很好地代表其中的点，因为太多的点会被映射到同一个单元格上，这将对标记化和去标记化模块（第7节）的准确性产生负面影响。此外，较大的单元格使得BERT难以学习轨迹之间的可区分上下文，因为一个大的单元格会包含来自许多道路和方向的轨迹。这可能需要使用较小的单元格大小，这样会大大增加数据集中不同标记的数量。这就使得选择合适的单元格大小成为一个优化问题，如图3(d)所示，极端情况下的两端都会导致较低的准确性。Kamel附带了一个默认的单元格大小，这是根据我们在第8节中的详尽实验得出的结果。然而，Kamel意识到，对于每个数据集而言，最佳的单元格大小可能是不同的，因为这取决于轨迹和区域特性。因此，Kamel配备了一个自动调优模块，可以根据给定的训练数据集设置系统的单元格大小。当输入标记化模块的是一个训练数据集时，我们会对该输入数据进行采样，并尝试使用不同的单元格大小训练多个BERT模型，然后选择能够实现最高准确性的单元格大小。</p><h2 id="4-PARTITIONING"><a href="#4-PARTITIONING" class="headerlink" title="4 PARTITIONING"></a>4 PARTITIONING</h2><p>原始的BERT模型是针对每种语言单独训练的。例如，用于英语的BERT模型与用于韩语的BERT模型有很大的不同，因为它们是由完全不同的数据集训练而成的。虽然语言之间的界限是明确的，但对于地理空间区域来说则并非如此。轨迹数据集可能来自邻近、重叠或遥远的空间区域。Kamel中的分区模块通过为不同的空间区域维护多种模型来使BERT模型具有空间感知能力，即使这些区域的边界并不十分明确。可以把Kamel中的每一个BERT模型看作是一种不同语言的模型。因此，我们维护了两个数据存储：一个是简单的轨迹存储，用于保存作为输入训练数据集传入的标记化轨迹；另一个是模型存储库，用于保存Kamel为不同空间区域构建的所有BERT模型。构建和&#x2F;或更新这些模型完全是在离线状态下完成的，所需时间取决于模型和轨迹的数量。但是，这并不会影响插值过程本身的可扩展性，因为这个过程是在在线状态下完成的，并且只使用预先计算好的模型。通过这种方式，Kamel可以扩展以支持大面积的地理区域。分区模块接收到的标记化输入轨迹要么代表一组需要插值的稀疏轨迹，要么代表训练轨迹。在前者的情况下，分区模块基本上会查询其模型存储库（第4.1节），以检索最适合插值过程的BERT模型。对于训练轨迹，分区模块则使用它们来更新其模型存储库（第4.2节）。 </p><h3 id="4-1-模型存储库结构和检索"><a href="#4-1-模型存储库结构和检索" class="headerlink" title="4.1 模型存储库结构和检索"></a>4.1 模型存储库结构和检索</h3><p>Kamel在其模型存储库中采用了一种基于磁盘的层次金字塔数据结构，该结构由层级组成，每一层由4h个等分单元构成。金字塔的根节点高度为零，只有一个覆盖整个空间的单元。金字塔从下往上构建，并非所有层级都需要维护。实际上，我们只维护金字塔的最低ℓ层，因为通常没有足够的轨迹数据来为更高的层级建立模型。层级数量ℓℓ和hh是平衡模型高分辨率与金字塔结构维护开销的参数。图4给出了这样一个结构的例子，其中ℓ&#x3D;5，h&#x3D;3。阴影部分的单元格是有模型的，而空白部分则没有需要维护的内容。</p><p>我们维护了两种类型的模型：(1) 单元格模型，它是基于单个单元格的内容构建的；(2) 邻近单元格模型，它是基于两个相邻且共享一条边的单元格的内容构建的，并存储在这两个邻近单元格的北侧或西侧单元格中。邻近单元格模型的目标是在边界情况中提供帮助，即我们需要一个模型跨越两个相邻单元格的内容，特别是在它们没有共同的父单元格时，或者它们的父单元格没有模型时。为了确保模型的准确性，只有当某个单元格中有至少 T×4(ℓ−h) 个标记时，我们才会在层级 ℓ 的单元格 c 中构建一个模型，其中 T 是系统参数（默认为20,000），h 是金字塔的高度。这意味着我们需要至少 T 个标记来在叶节点上构建一个模型，并且需要 4T 个标记来在比叶节点高一层的单元格上构建一个模型。对于邻近单元格模型，我们将这个阈值翻倍。每个单元格 c 包含以下一项或多项内容：(1) 轨迹存储中位于单元格 c 内的标记数量；(2) 用于单元格 c 内容的单单元格BERT模型及其元数据（包括模型统计信息和最后更新日期）；(3) 最多两个邻近单元格BERT模型（带元数据），用于单元格 c 及其东侧和&#x2F;或南侧的邻近单元格的内容；(4) 最多两个指向存储在北侧和&#x2F;或西侧邻近单元格中的邻近单元格BERT模型的指针。</p><p>当输入到分区模块的是一个待插值的稀疏轨迹时，我们会找到完全包含轨迹最小边界矩形的最小单元格 c 或一对邻近单元格 ci 和 cj​，并相应地选择用于插值过程的BERT模型。调用模型不会在离线训练后扫描或读取任何轨迹数据，这使得Kamel具有很高的可扩展性。如果没有单个或一对带有模型的单元格能够覆盖轨迹，则将其分割成子轨迹，这些子轨迹可以被包含在一个模型内。对于那些无法适应我们任何模型的子轨迹，我们只需用简单的直线进行插值处理。</p><h3 id="4-2-Models-Repository-Maintenance"><a href="#4-2-Models-Repository-Maintenance" class="headerlink" title="4.2 Models Repository Maintenance"></a>4.2 Models Repository Maintenance</h3><p>每当接收一个新的训练轨迹数据集 T 时，我们首先将其添加到我们的轨迹存储中。然后，我们找到包含 T 中所有轨迹的最小边界矩形的最小金字塔单元格 c 。接着，我们将存储中完全包含在单元格 c 内的所有轨迹集加入到 T 中，从而丰富 T 。有了 c ，我们执行以下四个步骤：<br>(1) 如果 T 中的标记数量超过了模型阈值，我们将构建一个BERT模型并将其存储在 c 中，这将更新现有模型或创建一个新的模型。<br>(2) 对于 c 的四个邻近单元格中的每一个 ci​，如果 c 和 ci​ 中的总标记数超过了我们的模型阈值，我们检索 ci​ 中的所有轨迹，并使用这些轨迹与 T 构建邻近单元格模型。该模型存储在 c 和 ci​ 的北侧或西侧单元格中，并在另一个单元格中设置指向该模型的指针。<br>(3) 如果 c 和它的三个同级单元格中的总标记数超过了在其父单元格中构建模型的阈值，我们就这样做。这一过程会递归地应用于 c 的祖先单元格，直到达到我们维护的最低层级。<br>(4) 如果 c 不是叶节点，我们将 T 中的轨迹分配给 c 的四个子单元格，并检查是否有必要在这些子单元格中的任何一个上构建新的模型。我们递归地进行这一操作，直到没有足够的标记来构建模型为止。需要注意的是，这并不需要针对每一个单独的轨迹发生。相反，当一批新的轨迹需要时，它会被安排为后台进程进行处理，而不会导致系统的任何停机时间。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 09.02-09.08（研二上返校+字节第一次团建）</title>
    <link href="/2024/09/08/%E5%91%A8%E8%AE%B0%20-%202024%2009.02-09.08%EF%BC%88%E7%A0%94%E4%BA%8C%E4%B8%8A%E8%BF%94%E6%A0%A1+%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E5%BB%BA%EF%BC%89/"/>
    <url>/2024/09/08/%E5%91%A8%E8%AE%B0%20-%202024%2009.02-09.08%EF%BC%88%E7%A0%94%E4%BA%8C%E4%B8%8A%E8%BF%94%E6%A0%A1+%E5%AD%97%E8%8A%82%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9B%A2%E5%BB%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="09-02-周一-晴"><a href="#09-02-周一-晴" class="headerlink" title="09.02 周一 晴"></a>09.02 周一 晴</h2><h2 id="09-03-周二-晴"><a href="#09-03-周二-晴" class="headerlink" title="09.03 周二 晴"></a>09.03 周二 晴</h2><h2 id="09-04-周三-晴"><a href="#09-04-周三-晴" class="headerlink" title="09.04 周三 晴"></a>09.04 周三 晴</h2><p>又得滚回学校了，很烦。<br>也不想太为难郑老师报销往返学校的路费，所以来回广州都是坐的硬卧。<br>18:10的车票，老爸下午4点就开车送我去车站。跟着缺德地图一顿乱走走到广州白云站，才发现Z100是在老广州站。<br>于是赶紧切导航，但是缺德地图在这片地区的效果非常差，甚至把我们导到只通公交车的路线上……</p><p>得亏出发得早，最后只剩10分钟就开始检票了。</p><h2 id="09-05-周四-晴"><a href="#09-05-周四-晴" class="headerlink" title="09.05 周四 晴"></a>09.05 周四 晴</h2><p>下午飞书有个消息@我，打开一看是一个新群，叫做Rec-Core上海团建。<br>里面说明天计划去团建，我点开活动安排文档：午餐牛扒人均经费200+，皮划艇人均150+，来回路费100+。<br>what can i say？一整天的工资就无了……<br>晚上久违地吃上了棒约翰，孔LB问我明天的团建去不去，那我回答肯定是说去。</p><h2 id="09-06-周五-晴"><a href="#09-06-周五-晴" class="headerlink" title="09.06 周五 晴"></a>09.06 周五 晴</h2><p>到了中午饭点，我和葛FS说我先下去吃了。<br>吃的是4楼的腊味煲仔饭，吃的时候十分痛苦，因为右边嘴巴起了两个溃疡。<br>刚吃饱就收到FS发来的飞书消息，问我是不是不在牛扒店吃午饭，不去团建了。<br>他还说这是为数不多的团建的机会。<br>我表示可惜，然后问了问负责团建的王尚同学可不可以只参加下午的划船活动。<br>随后他拉我进了一个微信群，也就算in了。</p><p>晚上回江湾花了快2小时，18:00开的车，19:50才到，和LB一起回到T4，走到4楼发现门口已经立了个牌：半小时就餐指南。接待员说只剩3F有档口了。</p><h2 id="09-07-周六-晴"><a href="#09-07-周六-晴" class="headerlink" title="09.07 周六 晴"></a>09.07 周六 晴</h2><p>和杨M约了今早见个面，顺便一起出去逛一逛。<br>我和他已经是1年多的网友了，今天才终于线下见面。<br>听他说他住在 栋，所以我下楼走到路口面朝北区门口等他。</p><p>6点吃饭的时候，突然想起明天组会要把报销凭证给郑老师，而我的两张火车票却一直忘了去拿纸质票。所以被迫在18:40出门，去上海火车站取报销凭证。</p><h2 id="09-08-周日-晴（研二开学1st组会）"><a href="#09-08-周日-晴（研二开学1st组会）" class="headerlink" title="09.08 周日 晴（研二开学1st组会）"></a>09.08 周日 晴（研二开学1st组会）</h2><p>今早提前5分钟到了子彬院，想着先把海报的发票和来回火车票给郑老师报销下，却发现301门口已经站了挺多人，郑老师却不在。<br>这些站着的同学里面有几个陌生的面孔，彼（かれre）らわたぶん新入组的专硕新生。<br>10:30+的时候，我们几个人已经在会议室静坐了半个多小时了。蔡学长才说郑老师得线上参加。<br>剩下的时间我们各自介绍了下自己，我的一句“群里头像那只黄色的鸡就是我”，想必已经给大家留下深刻印象了hhh。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 看番记录</title>
    <link href="/2024/09/06/%E8%AE%B0%E5%BD%95%20-%20%E7%9C%8B%E7%95%AA%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/09/06/%E8%AE%B0%E5%BD%95%20-%20%E7%9C%8B%E7%95%AA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>备注</p><blockquote><p>A叔: Animenzzz</p><p>猪仔: 和音社-猪仔很忙</p><p>P大: Phyxinon</p><p>T叔: Theishter</p></blockquote><h2 id="已看"><a href="#已看" class="headerlink" title="已看"></a>已看</h2><p>【2016】🌟 <strong>你的名字</strong>（Film 1&#x2F;1）</p><blockquote><p>OP &amp; ED: 梦灯笼 (黄昏之时)<br>OST: sparkle火花 (A叔)、前前前世 (A叔)、三叶的主题曲</p></blockquote><p>【2002】🌟火影忍者TV版（Episode 720&#x2F;720）</p><blockquote><p>OP: Sign、silhouette剪影 (A叔)、形势逆转、动天</p></blockquote><p>【2022】继母的拖油瓶是我的前女友（Episode 12&#x2F;12）</p><p>【2021】剃须。然后捡到女高中生（Episode 13&#x2F;13）</p><p>【2018】🌟<strong>青春猪头少年不会梦到兔女郎学姐</strong>（Episode 13&#x2F;13）</p><blockquote><p>ED: 不可思議のカルテ</p></blockquote><p>【2017】埃罗芒阿（&#x2F;情色漫画）老师（Episode 12&#x2F;12）</p><blockquote><p>OP ヒトリゴト</p></blockquote><p>【2013】尸体派对OVA：被暴虐的灵魂的咒叫（Episode 4&#x2F;4）</p><p>【2019】青春猪头少年不会梦到怀梦美少女（Film 1&#x2F;1）</p><p>【2019】辉夜大小姐想让我告白 (天才们的恋爱头脑战) S1（Episode 12&#x2F;12）</p><p>【2015】Charlotte（Episode 14&#x2F;14）</p><p>【2014】🌟<strong>四月是你的谎言</strong>（Episode 23&#x2F;23）</p><blockquote><p>OP: <strong>若能绽放光芒</strong> (A叔)、七色交响曲<br>ED: <strong>オレンジ Orange</strong> (猪仔、T叔)、キラメキ闪烁微光<br>OST: 私の嘘、Again、弟弟一般的存在、友人A<br>古典: 爱的忧伤、冬风、肖邦第一叙事曲、圣桑:引子与回旋</p></blockquote><p><strong>天气之子</strong></p><blockquote><p>OST: <strong>Grand Escape</strong> (A叔、P大)</p></blockquote><p>通往夏天的隧道（难懂）</p><p>辉夜大小姐想让我告白 S2</p><p><strong>鬼灭之刃-立志篇</strong></p><blockquote><p>OP: 红莲华<br>OST: 灶门炭治郎之歌</p></blockquote><p>鬼灭之刃-无限列车篇</p><p>鬼灭之刃-游郭篇</p><p>看得见的女孩</p><p>鬼灭之刃-锻刀村篇</p><p>【2018】比宇宙还远的地方（Episode 13&#x2F;13）<br>2023-07-22</p><p><strong>紫罗兰永恒花园 (1-3集 + OVA + 4-6集 + 外传 + 7-13集)</strong></p><blockquote><p>OP: <strong>Sincerely</strong> (A叔、猪仔)<br>ED: <strong>みちしるべ 路标</strong> (A叔)<br>みち：道 &#x2F; まち：街 &#x2F; しるべ：導</p></blockquote><p>&#x3D;&#x3D;剧场版待看&#x3D;&#x3D;</p><p>【2007】秒速五厘米（Film 1&#x2F;1）<br>2023-11-01</p><blockquote><p>OST: 回忆遥远的日子<br>主题曲: One more time、one more chance</p></blockquote><p>【2013】🌟 <strong>来自风平浪静的明天</strong>*（Episode 26&#x2F;26）<br>2024-03-16</p><blockquote><p>OST: Cry for the moon<br>OP: lull～そして仆らは～、ebb and flow<br>ED: アクアテラリウム、三つ叶の结びめ<br>OPED串烧：<a href="https://www.youtube.com/watch?v=1zKejX-up-k">Nagi no Asu kara Piano Medley - All OPs and EDs</a></p></blockquote><p>【2015】干物妹！小埋（Episode 12&#x2F;12）<br>2024-04-05</p><blockquote><p>かくしん的☆めたまるふぉ～ぜっ! (猪仔)<br>かくしん：革新</p></blockquote><p>【2017】干物妹！小埋R（Episode 12&#x2F;12）<br>2024-04-12</p><p>🌟<strong>我们仍未知道那天所看见的花的名字</strong><br>【2011】tv版（Episode 11&#x2F;11）<br>【2013】剧场版（Film 1&#x2F;1）<br>2024-04-19</p><blockquote><p>ED: secret base 〜你给我的所有〜（A叔）</p></blockquote><p>【2015】樱子小姐的脚下埋着秘密&#x2F;尸体（Episode 12&#x2F;12）<br>2024-05-05</p><p>甲铁城的卡巴内利<br>【2016】tv版（Episode 13&#x2F;13）<br>【2019】剧场版：海门决战 （Film 1&#x2F;1）<br>2024-05-07</p><blockquote><p>ED：Ninelie（A叔）</p></blockquote><p>一拳超人 第一季<br>2024-05-10</p><p>一拳超人 第二季<br>2024-05-11</p><p>尸者的帝国（Film 1&#x2F;1）<br>2024-05-13</p><p>蒸汽男孩 steamboy （Film 1&#x2F;1）<br>2024-05-13</p><p>【2009】🌟<strong>钢之炼金术师FA</strong>（Episode 64&#x2F;64）<br>2024-06-18</p><blockquote><p>OP: Again (A叔)</p></blockquote><p>打工吧！魔王大人 S1（Episode 13&#x2F;13）<br>2024-06-24</p><blockquote><p>ED：月花</p></blockquote><p>鬼灭之刃-柱训练（Episode 8&#x2F;8）<br>2024-07-01</p><p>打工吧！魔王大人 S2（Episode 24&#x2F;24）<br>2024-07-27</p><p>kiss×sis （Episode 12&#x2F;12 + OAD 10&#x2F;10）<br>キスシス（きすしす）<br>2024-08-17</p><p>【2014】东京食尸鬼 S1（Episode 12&#x2F;12）<br>2024-08-18</p><blockquote><p>OP：Unravel (A叔)</p></blockquote><p>【2015】东京食尸鬼 S2（Episode 12&#x2F;12）<br>2024-08-19</p><p>【2018】东京食尸鬼 S3（Episode 12&#x2F;12）<br>2024-08-20（于字节跳动 新江湾T4 12F工位）</p><p>【2023】你想活出怎么样的人生（Film 1&#x2F;1）<br>2024-08-21</p><p>【2023】青春猪头少年不会梦到红书包女孩（Film 1&#x2F;1）<br>2024-08-21</p><p>【2016】🌟声之形（Film 1&#x2F;1）</p><blockquote><p>OST：lit（A叔 version：《5 Variations on “lit”》） </p></blockquote><p>【2023】【伊藤润二】狂热：日本恐怖故事（Episode 12&#x2F;12）<br>2024-09-07</p><p>【2018】东京食尸鬼 S4（Episode 12&#x2F;12）<br>2024-09-08</p><p>【2018】【伊藤润二】惊选集（Episode 14&#x2F;14）<br>2024-09-09</p><p>🌟<strong>进击的巨人系列</strong><br>【2013】进击的巨人 第一季（Episode 25&#x2F;25）</p><blockquote><p>OP：紅蓮の弓矢 (A叔)</p></blockquote><p>【2014】进击的巨人剧场版：前篇·红莲的弓矢（Film 0&#x2F;1）<br>【2015】进击的巨人剧场版：后篇·自由之翼（Film 0&#x2F;1）<br>【2017】进击的巨人 第二季（Episode 12&#x2F;12）</p><blockquote><p>OP1: 心臓を捧げよ</p></blockquote><ul><li><input disabled="" type="checkbox"> SP </li><li><input disabled="" type="checkbox"> 集篇<br>【2018】进击的巨人 第三季（Episode 12&#x2F;12）<br>【2018】进击的巨人剧场版：觉醒的咆哮（Film 0&#x2F;1）<br>【2018】进击的巨人OAD（Episode 5&#x2F;5）<br>【2019】进击的巨人 第三季Part2（Episode 10&#x2F;10）<br>2024-10-08<br>【2023】进击的巨人 最终季 完结篇 前篇（Film 1&#x2F;1）<br>2024-11-01<blockquote><p>OP: 僕の戦争</p></blockquote></li></ul><p>【2023】进击的巨人 最终季 完结篇 后篇（Film 1&#x2F;1）<br>2024-11-02</p><blockquote><p>ED：致两千年后…或是…两万年后的你（A叔）</p></blockquote><p>【2024】败犬女主太多了（Episode 12&#x2F;12）<br>2024-11-09</p><blockquote><p>OST<br>ED：LOVE2000</p></blockquote><p>【2023】葬送的芙莉莲（Episode 28&#x2F;28）<br>2024-11-20</p><blockquote><p>E23 17:22：“我是为了报答某个人的恩情。才称为独当一面的魔法师的……一定是那个时候，就耗尽了自己全部的热情和执念了吧”</p></blockquote><p>【2011】罪恶王冠（Episode 5&#x2F;22）</p><blockquote><p>OP：My Dearest（ryo supercell &amp; A叔）</p></blockquote><h2 id="未看"><a href="#未看" class="headerlink" title="未看"></a>未看</h2><ul><li><input disabled="" type="checkbox"> 辉夜大小姐想让我告白 S3</li><li><input disabled="" type="checkbox"> 辉夜大小姐想让我告白 剧场版 初吻不会结束</li><li><input disabled="" type="checkbox"> 我的青春恋爱物语果然有问题</li><li><input disabled="" type="checkbox"> 物语系列（都有啥，观看顺序？）</li><li><input disabled="" type="checkbox"> 轻音少女</li><li><input disabled="" type="checkbox"> 路人女主的养成方法</li><li><input disabled="" type="checkbox"> 冰菓</li><li><input disabled="" type="checkbox"> 中二病也要谈恋爱</li><li><input disabled="" type="checkbox"> 工作细胞</li><li><input disabled="" type="checkbox"> 会长是女仆大人</li><li><input disabled="" type="checkbox"> 堀与宫村</li><li><input checked="" disabled="" type="checkbox"> 干物妹小埋</li><li><input disabled="" type="checkbox"> 今天妹妹的样子有些怪</li><li><input checked="" disabled="" type="checkbox"> 钢之炼金术师FA</li><li><input disabled="" type="checkbox"> 来自深渊</li><li><input disabled="" type="checkbox"> 怪兽八号</li><li><input disabled="" type="checkbox"> 月色真美</li><li><input disabled="" type="checkbox"> 天使降临到我身边</li><li><input disabled="" type="checkbox"> 吹响! 上低音号</li><li><input disabled="" type="checkbox"> 小林家的龙女仆 12季</li><li><input disabled="" type="checkbox"> 逆转裁判 12季</li><li><input disabled="" type="checkbox"> Jose与虎与鱼</li><li><input disabled="" type="checkbox"> 天降之物</li><li><input checked="" disabled="" type="checkbox"> 甲铁城的卡巴内利</li><li><input disabled="" type="checkbox"> 从零开始的异世界生活</li><li><input disabled="" type="checkbox"> 关於我转生变成史莱姆这档事</li><li><input disabled="" type="checkbox"> blood c</li><li><input disabled="" type="checkbox"> 灵能百分百</li><li><input disabled="" type="checkbox"> 刀剑神域</li><li><input disabled="" type="checkbox"> fate</li><li><input checked="" disabled="" type="checkbox"> 一拳超人 one punch man</li><li><input disabled="" type="checkbox"> 咒术回战</li><li><input disabled="" type="checkbox"> 进击的巨人</li><li><input disabled="" type="checkbox"> 夏日重现</li><li><input disabled="" type="checkbox"> 一人之下</li><li><input disabled="" type="checkbox"> 罪恶王冠</li><li><input disabled="" type="checkbox"> 新世纪福音战士 EVA</li><li><input disabled="" type="checkbox"> 我推的孩子</li><li><input disabled="" type="checkbox"> 虚构推理</li><li><input disabled="" type="checkbox"> 命运石之门</li><li><input checked="" disabled="" type="checkbox"> 樱子小姐的脚下埋着秘密</li><li><input disabled="" type="checkbox"> 奇巧出租车</li><li><input disabled="" type="checkbox"> 漂流少年</li><li><input disabled="" type="checkbox"> Angel Beats</li><li><input checked="" disabled="" type="checkbox"> 葬送的芙莉莲</li><li><input disabled="" type="checkbox"> another</li><li><input disabled="" type="checkbox"> 寒蝉鸣泣之时</li><li><input disabled="" type="checkbox"> 死亡笔记</li><li><input disabled="" type="checkbox"> Clannad</li><li><input disabled="" type="checkbox"> 水星领航员</li><li><input disabled="" type="checkbox"> 超时空要塞</li><li><input disabled="" type="checkbox"> 花与爱丽丝杀人</li><li><input disabled="" type="checkbox"> 空之境界</li><li><input disabled="" type="checkbox"> </li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 07.29-08.18（AAAI投稿工作）</title>
    <link href="/2024/08/18/%E5%91%A8%E8%AE%B0%20-%202024%2007.29-08.18%EF%BC%88AAAI%E6%8A%95%E7%A8%BF%E5%B7%A5%E4%BD%9C%EF%BC%89/"/>
    <url>/2024/08/18/%E5%91%A8%E8%AE%B0%20-%202024%2007.29-08.18%EF%BC%88AAAI%E6%8A%95%E7%A8%BF%E5%B7%A5%E4%BD%9C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="07-29-周一-晴"><a href="#07-29-周一-晴" class="headerlink" title="07.29 周一 晴"></a>07.29 周一 晴</h2><h2 id="07-29-周一-晴-1"><a href="#07-29-周一-晴-1" class="headerlink" title="07.29 周一 晴"></a>07.29 周一 晴</h2><h2 id="07-24-周三-晴"><a href="#07-24-周三-晴" class="headerlink" title="07.24 周三 晴"></a>07.24 周三 晴</h2><h2 id="08-13-周二-晴（AAAI-DDL-3-Day）"><a href="#08-13-周二-晴（AAAI-DDL-3-Day）" class="headerlink" title="08.13 周二 晴（AAAI DDL -3 Day）"></a>08.13 周二 晴（AAAI DDL -3 Day）</h2><p>今天早上在工位摸鱼，搞AAAI实验的时候，葛FS突然飞书问我特征加完了没。<br>大无语了，只能跟他说我周五有个DDL，并且明天开始要请假。<br>本来想着如果没人催我公司的活，我就继续在公司摸鱼，混工资挺爽。<br>但是被问了，那也不好意思继续呆着摸鱼，只好请假。</p><h2 id="08-14-周三-晴（AAAI-DDL-2-Day）"><a href="#08-14-周三-晴（AAAI-DDL-2-Day）" class="headerlink" title="08.14 周三 晴（AAAI DDL -2 Day）"></a>08.14 周三 晴（AAAI DDL -2 Day）</h2><p>昨天在字节那边提前请好了假。</p><p>中餐和晚餐都还是去公司吃。午餐在T1的尚客牛扒吃的海鲜披萨，晚餐在T4的棒约翰吃的还是海鲜披萨。</p><p>全集中 改论文。</p><h2 id="08-15-周四-晴（AAAI-DDL-1-Day）"><a href="#08-15-周四-晴（AAAI-DDL-1-Day）" class="headerlink" title="08.15 周四 晴（AAAI DDL -1 Day）"></a>08.15 周四 晴（AAAI DDL -1 Day）</h2><p>下午睡醒之后，找了辆单车匆忙赶去子彬院，2点左右到zls办公室。<br>和zls改论文改到4点左右，他出去了很久。<br>回来的时候把他儿子也带过来了，zls让他抄汉字。<br>zls看起来不是那种凶儿子的父亲，<br>可是他儿子一直在赌气，看上去有些任性的样子。</p><p>本来还做好了晚上要在这继续改论文的准备，用袋子装了几块奥利奥过来。<br>实际上到了5点多zls就说回去线上改。<br>然后zls就带他儿子去北区食堂吃晚餐了。</p><h2 id="08-16-周五-晴（AAAI-DDL-0-Day）"><a href="#08-16-周五-晴（AAAI-DDL-0-Day）" class="headerlink" title="08.16 周五 晴（AAAI DDL -0 Day）"></a>08.16 周五 晴（AAAI DDL -0 Day）</h2><p>晚上7点多的时候，zls让我把项目代码的匿名链接放进code appendix。<br>之前的代码一点都没整理，眼看只有半小时时间了，只好先用 <a href="anonymous.4open.science/">anonymous.4open.science</a> 这个工具先建了个空的仓库</p><h2 id="08-17-周六-晴（AAAI-DDL-1-Day）"><a href="#08-17-周六-晴（AAAI-DDL-1-Day）" class="headerlink" title="08.17 周六 晴（AAAI DDL +1 Day）"></a>08.17 周六 晴（AAAI DDL +1 Day）</h2><p>突然没事情做了，反而有点不适应。</p><p>早上花了些时间把QPP的仓库建了下，这次的仓库弄的比上次VLDB那篇FSM的还要烂。甚至连README都没搞。</p><p>下午去理了个发，跟人感觉效果很烂。<br>虽然都是同一家店——上海财经大学地铁站那家蒂奇尼。但远不如上次……</p><p>晚上把kissxsis的OAD看完了。<br>这几天天天听《unravel》，于是心血来潮想看看这首歌的出处——《东京喰种》。<br>晚上一口气看到23:30。直接把第一季看完了。<br>最后金木研被壁虎折磨黑化那段确实挺扎心的。</p><h2 id="08-18-周日-雨🌧️"><a href="#08-18-周日-雨🌧️" class="headerlink" title="08.18 周日 雨🌧️"></a>08.18 周日 雨🌧️</h2><p>早上下了会雨，不过在中午饭点前就停了。</p><p>中午去北食吃碗面的功夫，外面就开始下暴雨……<br>傻愣愣在北食门口坐了20+分钟，好不容易雨小了，旁边那个跟我一起坐着等雨停的哥们就冒着雨冲出去了。<br>我心想这雨应该还能再小些。就没跟着一起出去，没想到雨反而下大了。又被迫坐了10+分钟。<br>刚看雨小了些，就冲了。刚走过北食门口的桥，雨又TM下大了。</p><p>鉴定为运气不佳。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 混合检索框架探索</title>
    <link href="/2024/08/16/%E8%AE%B0%E5%BD%95%20-%20%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%89/"/>
    <url>/2024/08/16/%E8%AE%B0%E5%BD%95%20-%20%E6%B7%B7%E5%90%88%E6%A3%80%E7%B4%A2%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="08-18"><a href="#08-18" class="headerlink" title="08.18"></a>08.18</h2><p>このたび、私わAAAIの論文（ろんぶん）提出（ていしゅつ）を一生（isshou）懸命（けんめ）に完成（かんせい）しました　<br>ー０８１６</p><h3 id="今後（こんご）の計画（けいかく）"><a href="#今後（こんご）の計画（けいかく）" class="headerlink" title="今後（こんご）の計画（けいかく）"></a>今後（こんご）の計画（けいかく）</h3><p>PINおBERTに融合（ゆうごう）します</p><p>信（しんん）じて、効果ありますよ</p><h2 id="08-11"><a href="#08-11" class="headerlink" title="08.11"></a>08.11</h2><p>ODR和IDR选用的模型参数是否要一致？</p><h3 id="大進展（だいしんてん）"><a href="#大進展（だいしんてん）" class="headerlink" title="大進展（だいしんてん）"></a>大進展（だいしんてん）</h3><p>加入了position encoding，効果（こうか）アップ（appu）です<br>消融实验が必要（ひつよう）です</p><h2 id="08-04"><a href="#08-04" class="headerlink" title="08.04"></a>08.04</h2><h3 id="动机部分"><a href="#动机部分" class="headerlink" title="动机部分"></a>动机部分</h3><p>讲故事、统计指标、方法无关、现象</p><p>当前问题：</p><p>DCN显著有效，但是手动交叉探索了一整周没有找到满意的交叉方法</p><ul><li><del>手动做的2阶、3阶、4阶、5阶交叉 + raw特征 塞MLP没有效果。</del></li><li>先对100个信号做相关性分析得到相关矩阵，然后获取$C_{2}^{100}&#x3D;4950$个signal_pairs代表两两之间的相关度。取其中相关度最低的100个pairs，求几何平均，得到100个二阶交叉的特征。</li><li>甚至可以以此类推做三阶的交叉。</li></ul><p><img src="https://img.picgo.net/2024/08/04/correlation_heatmap_signal1004c08acc6c0babf3c.png" alt="correlation heatmap signal100"></p><p>是否需要一些理论分析？</p><ul><li><input checked="" disabled="" type="checkbox"> 相关性热力图（如上图所示）</li><li><input checked="" disabled="" type="checkbox"> 特征重要性（烂）</li><li><input disabled="" type="checkbox"> SHAP值</li></ul><p>如何做验证？raw100 + cross100 vs raw100<br>用什么指标评估？二分类的AUC - ROC还是直接把实验部分的指标拿来用（相当于直接在测试集上调参）？</p><h3 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h3><ul><li><input disabled="" type="checkbox"> FLiQ: A Lightweight Retriever Feedback-Driven Strategy for Query Retrieval</li><li><input disabled="" type="checkbox"> LiRQ: Leveraging Lightweight Retriever Feedback for Enhanced Query Retrieval</li><li><input disabled="" type="checkbox"> Towards Lightweight Query Retrieval: A Retriever Feedback-Driven Approach</li><li><input disabled="" type="checkbox"> Harnessing Retriever Feedback for a Lightweight Query Retrieval Framework</li><li><input checked="" disabled="" type="checkbox"> Harnessing Crossed Signals from Retrievers for a Lightweight Query Retrieval Framework<br>Features改称Signals<br>Lightweight既体现在框架的简洁，又体现在预测模型的轻量。</li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>训练集：in-DR vs out-DR？</p><blockquote><p>使用DR没见过的数据集训练QA分类器。<br>使用DR训练数据来训练QA分类器。</p><p>实验表明使用DR没见过的数据集效果普遍更好，尤其是BERT，提升明显</p><p>不打算在本次投稿中涉及，<strong>本次投稿in-DR</strong></p></blockquote><p>label标记策略</p><blockquote><p>我们的方法：SRmiss_DRHRhit。若一条query的sparse全部（前100个）docid都命中，且HR能命中，则<code>label=1</code>；否则为0</p><p>CIKM2021：SRmiss。若一条query的sparse前50个候选docid中都没命中，则<code>label=1</code>；否则<code>label=0</code>。</p><p>实验表明BERT在SRmiss_DRHRhit上提升明显<br>不打算在本次投稿中涉及，<strong>本次投稿SRmiss</strong></p></blockquote><p>CIKM的label策略存在问题：如果一条query不能被SR、DR和HR命中，此时CIKM2021还会把它<code>label=1</code>。这个时候会增加检索成本。对于无法命中的query，不应该再给它进一步的HR的机会。</p><p>每个rk上的分数，应该有不同的权重。</p><p>IDR（In-DenseRetriever）上的q2qdd问题：</p><blockquote><p>q2qdd需要获得$emb_q$ 到训练集所有query的cos距离。<br>在IDR的问题背景下，IDR数据集的$emb_q$和$emb_{doc}$都是通过DR得到的，而DR的训练来源就是IDR的语意空间。<br>IDR下，单单使用SR的BM25距离，不会影响DCN的性能。但是加上IDR的dense dist：q2qdd和q2ddd，效果会下降<br>ODR下，加上ODR的dense dist：q2qdd和q2ddd，效果会提升，且两者同时使用，提升更大。</p><p>若把$\operatorname{DCN_{enhanced}}$也加入，但需要涉及到ODR和IDR，所以<strong>本次投稿中仅涉及q2dsd</strong></p></blockquote><p>只关注了SR（BM25）本身能否hit，而没有考虑交给DPR+HR后，能否hit。</p><h3 id="GPT4咨询"><a href="#GPT4咨询" class="headerlink" title="GPT4咨询"></a>GPT4咨询</h3><p>Q：我当前的工作并没有提出新模型，而是用了现有的交叉网络DCN。只不过是把旧模型用到了新的问题之下，我有必要提出一个手动筛选交叉信号的算法吗？DCN本身已经很有效了</p><blockquote><p>你的问题十分重要，确实，在许多研究中，不一定需要提出新的模型或算法。将现有的模型或方法用于新的、前所未有的问题，本身就是一项有价值的贡献。如你所说，深度交叉网络（DCN）在你的问题上已经表现得十分有效。<br>提出一个手动筛选交叉信号的算法的决定，主要取决于你是否认为现有的 DCN 的使用还有改进的潜力。如果你认为在特性交叉的选择或应用上，有一些未发掘的潜力可以进一步提升模型的性能，那么提出并实现这种算法可能是一个好主意。这将不借助于改变模型本身，而是通过你的算法优化提升结果。<br>然而，如果 DCN 已经在你的问题上取得了你满意的结果，并且你认为进一步的细微提升可能收效甚微，那么专注于详细描述并解释 DCN 如何在你的新问题上实现效果，可能是一个更好的选择。<br>无论你选择如何进行，都记得清晰地展示你的贡献：将现有模型成功应用于新问题，以及（如果适用）通过手动筛选算法进一步改善了模型的性能。</p></blockquote><p>Q：手动筛选特征只是想说明用DCN的合理性，并不能进一步提高模型性能。或者说手动筛选之后，过一个MLP，这个模型比DCN更轻量。我还要做这个手动筛选特征的算法吗？</p><blockquote><p>如果手动筛选交叉特征主要用于证明深度交叉网络 (DCN) 的应用合理性，并且你认为该策略无法进一步提升模型性能，那么设计一个专门的手动筛选算法可能不是必要的。<br>另一方面，如果你的目标是实现一个更轻量的模型，并且你相信通过手动筛选的特征过一个多层感知机 (MLP) 的方法可以达到这个目标，那么你可能会想要试试这种方法。这基本上会在权衡模型性能和计算效率之间找到一个最佳点。<br>总的来说，是否要设计和实现这样一个算法取决于你的研究目标和你的优先级。既然你已经发现 DCN 在你的问题上表现出色，你可能会选择聚焦于如何优雅地应用它，而不是设计新的、更复杂的策略。不过，如果你觉得有足够的理由去尝试这种新的策略，那也没有问题。只要你清晰地列出你的理由和你的决定，你的研究就会让人信服。</p></blockquote><h2 id="07-28"><a href="#07-28" class="headerlink" title="07.28"></a>07.28</h2><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>能否做成实验性、结论性的论文？就像之前看到TOIS2023上的关于插值融合 vs 倒数平均融合的比对论文一样。</p><ul><li>uplift的动机&#x2F;收益：<ul><li>【降低成本】保证ROI (Return-on-investment)，以低成本实现更高recall</li><li>【超额收益】某些情况下达到超越纯HR的recall</li></ul></li><li>能做的实验包括：<ul><li>不同DR（ANCE、DPR等），不同DR分数带来的影响</li><li>✅不同特征数量带来的影响：q2dsd -&gt; q2qdd -&gt; q2ddd 成本依次变大</li><li>不同数据集，Corpus对齐良好和欠佳两类数据集</li><li>✅不同的资源下，uplift模型的效果<ul><li>不同线程</li><li>不同ANNS索引：包括加载预热时间</li></ul></li><li>✅不同uplift模型下（BERT、树模型、MLP）<ul><li>AUUC、Cost @99.5%RRF等各种指标</li><li>模型参数量、FLOPs、推理时间等指标</li></ul></li><li>【可选】不同训练数据，比如in-DR和out-DR两种数据集的效果。in-DR的数据集用来数据大概率会有bias。CIKM2021原文只提到用MSMarco训练分类器，并且还在MSMarco上做测试。实际上由于DR本来就是在MSMarco上训练的。因此DR、HR在in- DR数据集上测试，查询命中的概率也会偏高。我认为应该用DR没见过的数据集，即out- DR数据集上训练分类器。</li><li>【数据增强】分数特征是否服从一定规律？能否随机构造更多正例？<br>  <code>[100, 80, 76, 75...60, 60]</code>是正例<br>  <code>[100+5, 80+3, 76, 75...,60-3 60-5]</code>是否还会是正例？<br>  <strong>排名靠前的doc对应分数，直觉上更有可能对hit recall作出贡献</strong><br>  统计每个rank位次上，hit的次数。比如rk1大概率会比rk100上hit的次数多得多。<br>  把这个hit次数转化成weight，衡量两个样本分数序列的相似度&#x2F;距离。<br>  每条召回分数特征（100维&#x2F;条）的weight是不一样的。</li></ul></li><li>打散排序能否用于Retriever？<ul><li>DPP打散</li><li>Centroid打散</li></ul></li><li>特征选择？现在直接将100维分数特征丢进DCN自动特征交叉。可能有点草率。</li><li>【可选】分数特征：BruteForce的分数和HNSW的分数会有出入，可以评估分类器对这种出入的敏感度</li><li>特征融合：文本特征 + 分数数值特征 如何更好的融合？<br>  最浅显的方法：直接concat BERT最后一层CLS对应的768维向量 + 数值特征。尝试过直接微调的方法，效果不佳。</li></ul><h3 id="Done"><a href="#Done" class="headerlink" title="Done"></a>Done</h3><ul><li>初步测试Conv1d，效果一般</li><li><del>尝试$\log (x + 1)$的特征预处理，<strong>DCN和MLP上均观察到收益</strong>，确切效果待更多模型验证</del></li></ul><blockquote><p>注意：这里的实验结果不是最标准的。因为没有做train-test-split</p></blockquote><table><thead><tr><th></th><th></th><th>raw</th><th>log2(x+1)</th></tr></thead><tbody><tr><td>DCN</td><td>AdversarialQA</td><td>0.6116</td><td>0.6118</td></tr><tr><td></td><td>SearchQA</td><td>0.8396</td><td>0.8405</td></tr><tr><td></td><td>SQuAD</td><td>0.83617</td><td>0.83624</td></tr><tr><td></td><td>FreebaseQA</td><td>0.9689</td><td>0.9701</td></tr><tr><td>MLP</td><td>AdversarialQA</td><td>0.6077</td><td>0.6100</td></tr><tr><td></td><td>SearchQA</td><td>0.8362</td><td>0.8380</td></tr><tr><td></td><td>SQuAD</td><td>0.8350</td><td>0.8360</td></tr><tr><td></td><td>FreebaseQA</td><td>0.9673</td><td>0.9683</td></tr></tbody></table><ul><li><p>尝试手动特征交叉，确切效果待验证（初步观察效果不佳）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">indices = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br>indices = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]<br>q2q_ddist_slim = q2q_ddist[:, indices]<br>q2d_sdist_slim = q2d_sdist[:, indices]<br><span class="hljs-built_in">print</span>(q2q_ddist_slim.shape, q2d_sdist_slim.shape)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_features</span>(<span class="hljs-params">tensor</span>):<br>    num_samples, num_features = tensor.shape<br>    crossed_features = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_features):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, num_features):<br>            crossed = np.sqrt(tensor[:, i] * tensor[:, j])<br>            crossed_features.append(crossed)<br><br>    crossed_features_tensor = torch.stack(crossed_features, dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> crossed_features_tensor<br></code></pre></td></tr></table></figure></li><li><p>发现直接微调BERT的性能远不如使用CrossEncoder的性能<br>  混合特征uplift模型的实现最好要基于CrossEncoder，普通的BERT微调效果很差。改CrossEncoder工程量很大，需要阅读 + 修改<code>transformer库</code>和<code>sentense_transformer</code>两个库</p></li><li><p>规范化实验：种子固定为42，学习率固定为2e-5，epoch上限为2000</p></li><li><p>引入q2qdd，对于DCN交叉网络效果提升；对于MLP看不到提升</p></li></ul><h3 id="Speed-Perf-16-thread-2080ti"><a href="#Speed-Perf-16-thread-2080ti" class="headerlink" title="Speed Perf (16-thread + 2080ti)"></a>Speed Perf (16-thread + 2080ti)</h3><p>BERT-CrossEncoder：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BERT-CrossEncoder latency</span><br><span class="hljs-comment"># 2.2s</span><br>latency_pred = BERT_inference<br><span class="hljs-comment"># 30s</span><br>latency_sparse = bm25_java21<br><span class="hljs-comment"># 4.3 + 27 + 5</span><br>latency_rrf = Q_encode + Q2DDD_HNSW + RRFusion<br></code></pre></td></tr></table></figure><p>DCN（CPU+GPU环境）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DCN latency</span><br><span class="hljs-comment"># 30 + 4.3 + 0.2 + 0.01s</span><br>latency_pred = bm25_java21 + Q_encode + Q2QDD_HNSW + DCN_inference<br>latency_sparse = <span class="hljs-number">0</span><br><span class="hljs-comment"># 27 + 5</span><br>latency_rrf = Q2DDD_HNSW + RRFusion<br></code></pre></td></tr></table></figure><p>DCN-lite（纯CPU环境适用）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DCN latency</span><br><span class="hljs-comment"># 30 + 0.01s</span><br>latency_pred = bm25_java21 + DCN_inference<br>latency_sparse = <span class="hljs-number">0</span><br>latency_rrf = Q_encode + Q2DDD_HNSW + RRFusion<br></code></pre></td></tr></table></figure><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BERT query encoder</td><td>16.31</td><td>2080ti</td><td>TriviaQA-Train</td><td>78785</td></tr></tbody></table><h4 id="4-thread"><a href="#4-thread" class="headerlink" title="4-thread"></a>4-thread</h4><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Memory</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BM25 (java21)</td><td>39.33</td><td>4-thread</td><td>10.4GB</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>ANNS-HNSW</td><td>17.00</td><td>4-thread</td><td>73.8GB</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>Reciprocal Rank Fusion</td><td>11.61</td><td>4-thread</td><td></td><td>AdversarialQA-Val</td><td>3000</td></tr></tbody></table><h4 id="8-thread"><a href="#8-thread" class="headerlink" title="8-thread"></a>8-thread</h4><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Memory</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BM25 (java21)</td><td>20.65</td><td>8-thread</td><td></td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>ANNS-HNSW</td><td>13.09</td><td>8-thread</td><td>73.8GB</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>Reciprocal Rank Fusion</td><td></td><td>8-thread</td><td></td><td>AdversarialQA-Val</td><td>3000</td></tr></tbody></table><h4 id="16-thread"><a href="#16-thread" class="headerlink" title="16-thread"></a>16-thread</h4><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Memory</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BM25 (java21)</td><td>10.73</td><td>16-thread</td><td></td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>ANNS-HNSW</td><td>9.72</td><td>16-thread</td><td>73.8GB</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>Reciprocal Rank Fusion</td><td></td><td>16-thread</td><td></td><td>AdversarialQA-Val</td><td>3000</td></tr></tbody></table><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>类别不平衡的处理</p><ul><li><input checked="" disabled="" type="checkbox"> Focal Loss 性能下降</li><li><input disabled="" type="checkbox"> 上采样</li><li><input disabled="" type="checkbox"> 🌟数据增强<br>不同的特征交叉网络效果，当前只有DCN</li><li><input checked="" disabled="" type="checkbox"> SENet + Bilinear 不如DCN<br>当前BM25的测速部分，计时还包括了加载预热时间，需要修正</li></ul><h2 id="07-21"><a href="#07-21" class="headerlink" title="07.21"></a>07.21</h2><h3 id="Done-1"><a href="#Done-1" class="headerlink" title="Done"></a>Done</h3><ul><li>把uplift图改成：打分排序，取得分前top k%（0.5%为step）的query做uplift。这样能固定打点数量，便于比较AUUC</li><li>接通HNSW索引</li><li>测试E2E各环节平均时间，得到最终提速效果[[记录 - 混合检索框架探索（一阶段）#^79735c|记录 - 混合检索框架探索]]</li><li>改进模型，迭代至DCN（特征交叉）</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>采用 DCN（Deep Cross Network）架构，替代了之前的MLP。<br>AUUC差强人意，整体打不过BERT。<br>且在SQuAD上存在eval mode性能骤降的问题。<br>可以<strong>考虑把DCN的DNN换成Conv1d来提高性能、novelty</strong><br>主力模型：[[记录 - 混合检索框架探索（一阶段）#^e998c8]]</p><h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><ul><li>用多个embedding表征一个query？ref：推荐系统中的多兴趣召回</li><li>E2E检索。encoder、hard-negative样本采样、index全部端到端。甚至还可以包括搜索参数的预测，都可以端到端。<br>  比较理想的模型是 ANCE + L2H index + 搜索参数预测。<br>  根据损失函数之类的来评估某些查询学习成都的好坏：学得好，搜的块就少；学得差，就多搜</li><li>重新获取gt，目前的gt_cache存在问题。IVFPQ、HNSW等近似算法，可能会搜出一些BruteForce没找到的，但包含gt的passage。</li><li>tokenized query 的长度需不需要加入特征？</li><li>如果模型升级了，可以尝试把DR only的类也加入分类</li></ul><h3 id="AUUC-Perf"><a href="#AUUC-Perf" class="headerlink" title="AUUC Perf"></a>AUUC Perf</h3><blockquote><p>省流：2负1胜1平</p></blockquote><table><thead><tr><th>name</th><th>size</th><th>FLOPS</th></tr></thead><tbody><tr><td><code>mlp.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.768x64.lr-1e-4</code></td><td>1.3M</td><td></td></tr><tr><td><code>DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-5.dh-[256, 256].lr-1e-3.pth</code></td><td>2.1M</td><td></td></tr><tr><td><code>DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-3.dh-[256, 256].lr-1e-3.pth</code></td><td>1.7M</td><td></td></tr><tr><td><code>SR_DR.squad_search_freebase.bert-base-uncased.epoch-2.batch-32</code></td><td>418M</td><td></td></tr></tbody></table><p>^e998c8</p><table><thead><tr><th></th><th>SR-DR</th><th>DCN</th><th>MLP</th></tr></thead><tbody><tr><td>AdversarialQA-Val</td><td><img src="https://img.picgo.net/2024/07/21/AdversarialQA-Val-SR_DR.squad_search_freebase.bert-base-uncased.epoch-2.batch-32a7e947612ae101a7.png" alt="AdversarialQA Val SR DR.squad search freebase.bert base uncased.epoch 2.batch 32"></td><td><img src="https://img.picgo.net/2024/07/21/Adversarial-Val-DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-5.dh-256-256.lr-1e-35298c5569f429e3c.png" alt="Adversarial Val DCN.squad search freebase.q2q ddist q2d sdist.k 100.cl 5.dh [256, 256].lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/21/AdversarialQA-Val-mlp.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-360a9948f89df5b21.png" alt="AdversarialQA Val mlp.squad search freebase.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>FreebaseQA-Eval</td><td><img src="https://img.picgo.net/2024/07/21/FreeBaseQA-Eval-SR_DR.squad_search_freebase.bert-base-uncased.epoch-2.batch-3223fbdf7192a6de9b.png" alt="FreeBaseQA Eval SR DR.squad search freebase.bert base uncased.epoch 2.batch 32"></td><td><img src="https://img.picgo.net/2024/07/21/FreebaseQA-Eval-DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-5.dh-256-256.lr-1e-3435855286b484427.png" alt="FreebaseQA Eval DCN.squad search freebase.q2q ddist q2d sdist.k 100.cl 5.dh [256, 256].lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/21/FreeBaseQA-Eval-mlp.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-30e2ed320f9799093.png" alt="FreeBaseQA Eval mlp.squad search freebase.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>SearchQA-Val</td><td><img src="https://img.picgo.net/2024/07/21/SearchQA-Val-SR_DR.squad_search_freebase.bert-base-uncased.epoch-2.batch-329f706021654f84bd.png" alt="SearchQA Val SR DR.squad search freebase.bert base uncased.epoch 2.batch 32"></td><td><img src="https://img.picgo.net/2024/07/21/SearchQA-Val-DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-5.dh-256-256.lr-1e-3ddfb6ce7a5409861.png" alt="SearchQA Val DCN.squad search freebase.q2q ddist q2d sdist.k 100.cl 5.dh [256, 256].lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/21/SearchQA-Val-mlp.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-3d94d9e7d606fda68.png" alt="SearchQA Val mlp.squad search freebase.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>SQuAD-Test</td><td><img src="https://img.picgo.net/2024/07/21/SQuAD-Test-SR_DR.squad_search_freebase.bert-base-uncased.epoch-2.batch-32955de3140509c1bb.png" alt="SQuAD Test SR DR.squad search freebase.bert base uncased.epoch 2.batch 32"></td><td><img src="https://img.picgo.net/2024/07/21/SQuAD-Test-DCN.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.cl-5.dh-256-256.lr-1e-35c31093ad6e78968.png" alt="SQuAD Test DCN.squad search freebase.q2q ddist q2d sdist.k 100.cl 5.dh [256, 256].lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/21/SQuAD-Test-mlp.squad_search_freebase.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-390a2456fc11a2909.png" alt="SQuAD Test mlp.squad search freebase.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr></tbody></table><h3 id="Speed-Perf："><a href="#Speed-Perf：" class="headerlink" title="Speed Perf："></a>Speed Perf：</h3><p>^79735c</p><blockquote><p>省流：寄了。07-16的实验中，<strong>BM25速度远低于 DPR+HNSW</strong>。<br>这与[[笔记 - CIKM2021 Predicting Efficiency Effectiveness Trade-offs for  Dense vs. Sparse Retrieval Strategy Selection]]中BM25在msmarco上 55ms &#x2F; query的性能差太多了。</p></blockquote><h4 id="1-thread"><a href="#1-thread" class="headerlink" title="1-thread"></a>1-thread</h4><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BM25 (java8)</td><td>190.0</td><td>1-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>BM25 (java21)</td><td>158.67</td><td>1-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>BERT query encoder</td><td>16.31</td><td>2080ti</td><td>TriviaQA-Train</td><td>78785</td></tr><tr><td>ANNS-HNSW</td><td>38.67</td><td>1-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>Reciprocal Rank Fusion</td><td>22.63</td><td>1-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">bm25_java8 = <span class="hljs-number">190.0</span><br>bm25_java21 = <span class="hljs-number">158.67</span><br>bert_encoder = <span class="hljs-number">16.31</span><br>anns_hnsw = <span class="hljs-number">38.67</span><br>rrf = <span class="hljs-number">22.63</span><br><br><span class="hljs-comment"># latency</span><br>latency_rrf = bm25_java21 + bert_encoder + anns_hnsw + rrf<br>latency_60_cost = bm25_java8 + bert_encoder + <span class="hljs-number">0.6</span> * (anns_hnsw + rrf)<br>latency_50_cost = bm25_java8 + bert_encoder + <span class="hljs-number">0.5</span> * (anns_hnsw + rrf)<br><span class="hljs-comment"># ratio</span><br>ratio_60_cost = latency_60_cost / latency_rrf<br>ratio_50_cost = latency_50_cost / latency_rrf<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;latency_rrf = <span class="hljs-subst">&#123;latency_rrf&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;latency_60%-cost = <span class="hljs-subst">&#123;latency_60_cost&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;latency_50%-cost = <span class="hljs-subst">&#123;latency_50_cost&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;ratio_60%-cost = <span class="hljs-subst">&#123;ratio_60_cost&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;ratio_50%-cost = <span class="hljs-subst">&#123;ratio_50_cost&#125;</span>\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Java8：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">latency_rrf = 267.61<br>latency_60%-cost = 243.09<br>latency_50%-cost = 236.96<br>ratio_60%-cost = 0.9083741265274092<br>ratio_50%-cost = 0.8854676581592617<br></code></pre></td></tr></table></figure><p>Java21：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">latency_rrf = 236.27999999999997<br>latency_60%-cost = 211.76<br>latency_50%-cost = 205.63<br>ratio_60%-cost = 0.8962248180125276<br>ratio_50%-cost = 0.8702810225156594<br></code></pre></td></tr></table></figure><h4 id="4-thread-1"><a href="#4-thread-1" class="headerlink" title="4-thread"></a>4-thread</h4><table><thead><tr><th>Stage</th><th>latency (ms&#x2F;query)</th><th>device</th><th>Data-Split</th><th># qas</th></tr></thead><tbody><tr><td>BM25 (java8)</td><td></td><td>4-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>BM25 (java21)</td><td>39.33</td><td>4-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>BERT query encoder</td><td>16.31</td><td>2080ti</td><td>TriviaQA-Train</td><td>78785</td></tr><tr><td>ANNS-HNSW</td><td>17.00</td><td>4-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr><tr><td>Reciprocal Rank Fusion</td><td>11.61</td><td>4-thread</td><td>AdversarialQA-Val</td><td>3000</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bm25_java21 = <span class="hljs-number">39.33</span><br>bert_encoder = <span class="hljs-number">16.31</span><br>anns_hnsw = <span class="hljs-number">17.00</span><br>rrf = <span class="hljs-number">11.61</span><br></code></pre></td></tr></table></figure><p>Java21：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">latency_rrf = 84.25<br>latency_60%-cost = 72.806<br>latency_50%-cost = 69.945<br>ratio_60%-cost = 0.8641661721068249<br>ratio_50%-cost = 0.8302077151335311<br></code></pre></td></tr></table></figure><h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><blockquote><p>尽可能拖慢DR、RRF的检索速度，并且提高SR的检索速度。（）</p></blockquote><ul><li>尝试不同ANNS索引。把召回率目标定在BF的99～99.5%。<ul><li><input disabled="" type="checkbox"> IVFPQ（撑死20G）</li><li><input checked="" disabled="" type="checkbox"> HNSW（已初步接通）（内存占用70+G）</li><li><input checked="" disabled="" type="checkbox"> BruteForce</li></ul></li><li>周会上，郑老师提出的：<ul><li>线程数调高 </li><li>ANNS索引更换</li><li>调模型 + CNN</li></ul></li></ul><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><ul><li>是否需要将对齐不佳的QA数据集AdversarialQA等加入？<br>  加入有利于说明uplift模型泛化能力。但是可能不利于后续工作。</li><li>query encode时间开销和显卡有关，可以控制。<ul><li>encode时间短，有利于当前工作，uplift模型的开销降低</li><li>encode时间长，有利于后续工作，后续工作如果去掉dense特征，就可以省出一定比例的encode时间</li></ul></li><li>uplift曲线的纵坐标应该是 召回率 or 相较于100%rrf的百分比？</li><li>如何实现CIKM2021？CIKM2021 &#x3D; 文本作为特征 + BERT + label策略。label策略与我们不同，他是sparse前50 &#x2F; 100没检索到gt就当成正例，我们是100</li></ul><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc."></a>Misc.</h3><p>在小红书上看到一张关于广告发放uplift模型的有趣的图，大概长这样：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>🎯 if ✅ <br>uplift</td><td>HR&#x2F;DR🎯</td><td>SR&#x2F;HR均可🎯</td></tr><tr><td>🎯 if ❌<br>uplift</td><td>只能由DR🎯<br></td><td>只能由SR🎯</td></tr><tr><td></td><td>🎯 if ❌ uplift</td><td>🎯 if ✅ uplift</td></tr><tr><td>这里先存一下，以备之后之需。</td><td></td><td></td></tr></tbody></table><p><img src="https://liuzaoqi.com/assets/images/uplift_2024-01-31-15-27-31-f97950ed9f17569a53f7f0910f55af7e.png" alt="uplift"></p><h2 id="07-14"><a href="#07-14" class="headerlink" title="07.14"></a>07.14</h2><h3 id="Done-2"><a href="#Done-2" class="headerlink" title="Done"></a>Done</h3><ul><li>[[笔记 - IR &amp; ODQA Wiki#SearchQA]] train+val的gt查询</li><li>[[笔记 - IR &amp; ODQA Wiki#WikiHop]] -train+val的gt查询</li><li>[[笔记 - IR &amp; ODQA Wiki#FreeBaseQA]] -train+val的gt查询</li><li>[[笔记 - IR &amp; ODQA Wiki#AdversarialQA]] -train+val的gt查询</li><li>将SearchQA-train加入分类器训练，验证多个数据集上的性能（包括跨数据集泛化实验）。<strong>当前训练数据：SQuAD + SearchQA</strong></li><li>将HotpotQA train+dev的yes &#x2F; no question删除，重新加入分类器训练并在dev验证效果。仍然烂</li><li>尝试隐藏层更大的MLP<ul><li>从128x64改到256x64，效果提升</li><li>再改到512x64，提升不明显</li><li>可能原因：</li></ul><ol><li>不同模型绘制的样本点数不一样，比如TriviaQA 512x64画了289个点；256x64：292；128x64：389</li><li>现在的模型太小欠拟合？</li></ol></li><li>多个数据集初步验证Recall@100。所有数据集汇总：[[笔记 - IR &amp; ODQA Wiki#Wikipedia上的抽取式问答]]</li></ul><p> 数据集选取原则：</p><ol><li>bonus足够高</li><li>uplift能在足够低的budget下达到</li><li>与corpus（Wikipedia的21M个passage）能够对齐的数据集x2 + 对齐较差的数据集x2</li><li>领域数据集：BioASQ + WikiMovies（前提：效果能接受）</li></ol><h3 id="Perf"><a href="#Perf" class="headerlink" title="Perf"></a>Perf</h3><blockquote><p>省流</p><ol><li>AdversarialQA、SQuAD、SearchQA、FreeBase均能以60%的cost，达到99.5%纯RRF召回率</li><li>DROP表现最差，WikiHop次之。这两者都跟我们选用的Corpus对的不齐。它们的100% rrf召回率都只有69.26%和65.24%。WikiHop上甚至有很多BM25检索结果数不够100条。再者，它们rrf-sparse-bonus不高，也可能是一个原因。</li></ol></blockquote><table><thead><tr><th>Data</th><th>128x64</th><th>256x64</th><th>512x64</th></tr></thead><tbody><tr><td>AdversarialQA</td><td><img src="https://img.picgo.net/2024/07/14/AdversarialQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-36ba8e080efc37de6.png" alt="AdversarialQA Val mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/AdversarialQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-33413de33887b910c.png" alt="AdversarialQA Val mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/AdversarialQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-38a6c742b0e52100a.png" alt="AdversarialQA Val mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>CuratedQA</td><td><img src="https://img.picgo.net/2024/07/14/CuratedQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-3227d95ffb4ed1cc6.png" alt="CuratedQA Test mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/CuratedQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-36ad90251d3e45f17.png" alt="CuratedQA Test mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/CuratedQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-3ddd4e461584e12bd.png" alt="CuratedQA Test mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>DROP</td><td><img src="https://img.picgo.net/2024/07/14/DROP-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-39cf48530b01208ad.png" alt="DROP Val mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/DROP-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3356c726058bf5111.png" alt="DROP Val mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/DROP-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-3f11af4db0a8a5d2d.png" alt="DROP Val mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>FreeBase</td><td><img src="https://img.picgo.net/2024/07/14/FreeBaseQA-Eval-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-3f8a4f14ba2e091b7.png" alt="FreeBaseQA Eval mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/FreeBaseQA-Eval-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3c482a8a3389afdb0.png" alt="FreeBaseQA Eval mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/FreeBaseQA-Eval-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-33b60172fbf8ccf61.png" alt="FreeBaseQA Eval mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>NaturalQ</td><td><img src="https://img.picgo.net/2024/07/14/NaturalQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-31823fba1b7f82b7b.png" alt="NaturalQ Test mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/NaturalQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3a74563e5aa316399.png" alt="NaturalQ Test mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/NaturalQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-36ac41230ca02a8e7.png" alt="NaturalQ Test mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>SearchQA</td><td><img src="https://img.picgo.net/2024/07/14/SearchQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-3b7d4568bfa75c453.png" alt="SearchQA Val mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/SearchQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3312dd6052879e0f0.png" alt="SearchQA Val mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/SearchQA-Val-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-322cf4e0d3bd8c882.png" alt="SearchQA Val mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>SQuAD</td><td><img src="https://img.picgo.net/2024/07/14/SQuAD-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-36cf238fca387fdde.png" alt="SQuAD Test mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/SQuAD-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-395e98554c56d926c.png" alt="SQuAD Test mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/SQuAD-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-3413d8c8988e7248f.png" alt="SQuAD Test mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>TriviaQA</td><td><img src="https://img.picgo.net/2024/07/14/TriviaQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-38887cbb4bec97453.png" alt="TriviaQA Test mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/TriviaQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3b2376a2cfd2b3e12.png" alt="TriviaQA Test mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/TriviaQA-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-36a5fba8ee7b248f1.png" alt="TriviaQA Test mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>WebQ</td><td><img src="https://img.picgo.net/2024/07/14/WebQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-3f7bdce41935a2625.png" alt="WebQ Test mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/WebQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-3486ab2bbaffa0f3b.png" alt="WebQ Test mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/WebQ-Test-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-33af7b13a0507de32.png" alt="WebQ Test mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr><tr><td>WikiHop</td><td><img src="https://img.picgo.net/2024/07/14/WikiHop-Val-100r-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.128x64.lr-1e-3189740bf005b3a71.png" alt="WikiHop Val 100r mlp.squad search.q2q ddist q2d sdist.k 100.128x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/WikiHop-Val-100r-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.256x64.lr-1e-30f5c1b60030fcc09.png" alt="WikiHop Val 100r mlp.squad search.q2q ddist q2d sdist.k 100.256x64.lr 1e 3"></td><td><img src="https://img.picgo.net/2024/07/14/WikiHop-Val-100r-mlp.squad_search.q2q_ddist_q2d_sdist.k-100.512x64.lr-1e-3f193d836bddc47ce.png" alt="WikiHop Val 100r mlp.squad search.q2q ddist q2d sdist.k 100.512x64.lr 1e 3"></td></tr></tbody></table><p>框架流程图：</p><p>q2q_ddist + q2d_sdist 双特征分类器：</p><pre><code class=" mermaid">graph TD A[拿到查询] --&gt; B[使用BM25在corpus中检索,得到q2d_sdist] B --&gt; C[DPR encode] C --&gt; E[将q2d_sdist和q2q_ddist送入分类器] E --&gt;|不需要混合检索| F[返回BM25的结果] E --&gt;|需要混合检索| G[在corpus中搜索得到q2d_ddist] G --&gt; H[拿q2d_ddist和q2d_sdist做rrf排名] H --&gt; I[返回结果]</code></pre><p>q2d_sdist 单特征分类器：</p><pre><code class=" mermaid">graph TD A[拿到查询] --&gt; B[使用BM25在Corpus中检索,得到q2d_sdist] B --&gt; C[将q2d_sdist送入分类器] C --&gt;|不需要混合检索| E[返回BM25的结果] C --&gt;|需要混合检索| F[DPR encode] F --&gt; G[在corpus中搜索得到q2d_ddist]G --&gt; H[拿q2d_ddist和q2d_sdist做rrf排名] H --&gt; I[返回结果]</code></pre><h3 id="TODO-2"><a href="#TODO-2" class="headerlink" title="TODO"></a>TODO</h3><ul><li>改进分类模型<ul><li>加入特征交叉[[#^d4c52f]]：</li><li><input disabled="" type="checkbox"> $x_1 * w * x2$的形式</li><li><input disabled="" type="checkbox"> attention机制</li><li>尝试使用consup替换交叉熵</li><li>去掉q2q_ddist特征，验证只用q2d_sdist的分类效果</li></ul></li><li>增加端到端实验，或等效的效率测试实验。直接的E2E实验很困难，因为BM25检索需要“预热”，预热速度和正常速度差距巨大，会极大拖累平均时间。比较好的办法是用很大一个batch测试得到每个查询对应BM25、encode和ANNS的平均时间。用这个平均时间x查询数量，结合uplift模型的决策作为总时间。</li></ul><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul><li>特征交叉：比如top-1 dist和top-100 dist的交叉：top-1 dist非常近，但top-100却非常远，和top-1 dist 约等于 top-100 dist，这两种情况能反映的问题是不一样的 ^d4c52f</li><li>“时序” &#x2F; 局部特征：分数可能在top-10&#x2F;20&#x2F;50处下降幅度明显，也应该被作为局部特征捕获</li><li>预先使用attention训练得到每个特征对应分数的权重，用加权距离做kNN分类（如果可以用ANNS就更好了）</li></ul><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><ul><li>本质可以建模成一个uplift问题（有待深入了解）：我们需要对每个查询的处理策略进行决策。<ul><li>默认策略：BM25检索，计作SR</li><li>“处理”：将一个查询从SR 转变为RRF（计作HR，即BM25 + DPR + RRF）</li><li>“Uplift”：HR相对于SR在召回率上的提升。</li><li>打分排序？or 设置分数阈值？</li></ul></li><li>指标选取问题[[记录 - 混合检索框架探索（一阶段）#^ed6867]]：可以把AUUC（area under uplift curve）作为指标</li><li>需不需要汇报Recall@20？</li><li>是否需要剔除BM25无返回结果的qa？[[_posts&#x2F;笔记 - IR &amp; ODQA Wiki#BM25空结果情况]]</li><li>E2E实验形式？单线程（embed慢） or 多线程？</li><li>加入数据集作为二分类器训练数据后，效果反而下降？比如加入SearchQA的不如纯SQuAD。可能和数据集正负样本比例有关？</li></ul><h3 id="OLD-TODO"><a href="#OLD-TODO" class="headerlink" title="OLD-TODO"></a>OLD-TODO</h3><ul><li>更换不同的参数验证half-top merge算法的效果</li><li>计算二分类模型下，oracle对应的召回率</li><li>复现CIKM2021的BERT-based分类方法作为baseline</li></ul><h2 id="07-07"><a href="#07-07" class="headerlink" title="07.07"></a>07.07</h2><h3 id="Done-3"><a href="#Done-3" class="headerlink" title="Done"></a>Done</h3><ul><li><p>在hugging-face上搜罗了合适的数据集。<br>  合适：目前的doc语料库是wikipedia的500+（待确认？）篇文章。而QA数据集很多都无法在这些corpus上找到包含answer的passage。</p><p>  目前觉得比较合适的数据集有：HotpotQA、SearchQA、WikiQA、NarrativeQA、<a href="https://hf-mirror.com/datasets/lmqg/qa_harvesting_from_wikipedia">HarvestWikiQA</a>、<a href="https://hf-mirror.com/datasets/UCLNLP/adversarial_qa">AdversarialQA</a>、<a href="https://hf-mirror.com/datasets/ibm/duorc">duorc</a></p></li><li><p>HotpotQA 数据集-train（90447 qas）查询groundtruth完毕，分类器训练ready</p></li><li><p>HotpotQA 数据集-dev（7405 qas）查询groundtruth完毕</p></li><li><p>改善pyserini查询gt时log输出的io，稍微加快gt查询</p></li><li><p>尝试128x64的MLP，在训练数据（SQuAD）上做二分类，效果普遍优于Lightgbm</p></li><li><p>初步分析了HotpotQA-train、SQuAD-train和SearchQA-train-slim（前1000条）数据集上dense、hybrid和sparse三者能力上的重合度（jacard相似度）[[#^b8894a]]</p></li><li><p>尝试使用in-DPR的数据集（NaturalQ、WebQ、TriviaQA和CutatedTrec）作为分类器，效果很烂</p></li></ul><h3 id="Perf-1"><a href="#Perf-1" class="headerlink" title="Perf"></a>Perf</h3><table><thead><tr><th><img src="https://img.picgo.net/2024/07/07/squad.mlp.128x64.hotpot-dev1586575697771996.png" alt="squad.mlp.128x64.hotpot dev"></th><th><img src="https://img.picgo.net/2024/07/07/squad.mlp.128x64.naturalq-testb9631681cfc63f4f.png" alt="squad.mlp.128x64.naturalq test"></th></tr></thead><tbody><tr><td><img src="https://img.picgo.net/2024/07/07/squad.mlp.128x64.squad-testebe0103ba626024d.png" alt="squad.mlp.128x64.squad test"></td><td><img src="https://img.picgo.net/2024/07/07/squad.mlp.128x64.webq-test4fb2214d34367571.png" alt="squad.mlp.128x64.webq test"></td></tr></tbody></table><p>baseline是random，但没有实际对query进行随机选取加入到budget来计算recall。仅仅为理论值</p><p>HotpotQA上表现不佳，在高budget (budget)下效果不如random</p><p>在cost&#x3D;0.9附近能取得最高的recall</p><p>即便不能超过100%rrf，也能以较少的cost达到100%rrf的recall</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><blockquote><p>[[笔记 - IR &amp; ODQA Wiki#HotpotQA]]</p><p>[[笔记 - IR &amp; ODQA Wiki#yes &#x2F; no 问题对分类器的影响]]</p></blockquote><ul><li>HotpotQA问题较难，属于multi-hop查询，且train与dev上的难度分布不一样</li><li>HotpotQA的问题类型包含6%的<code>yes / no question</code>，导致retriever难以得分</li></ul><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><ul><li><p>能否将recall-cost曲线的AUC作为检索策略的指标？有没有更好的指标？ ^ed6867</p></li><li><p>HotpotQA的qas中，dense、hybrid和sparse能回答的问题的重合度较高。是否为训练数据好坏的指标？是否会影响分类器训练？<br>  SQuAD-train<br>  jacard hybrid vs sparse: 0.9184879764719451<br>  jacard dense vs sparse: 0.70026646147708<br>  jacard dense vs hybrid: 0.7697610961130947</p><p>  HotpotQA-train<br>  jacard hybrid vs sparse: 0.9374225526641884<br>  jacard dense vs sparse: 0.7616772386522778<br>  jacard dense vs hybrid: 0.8116730865851616</p><p>  search<br>  jacard hybrid vs sparse: 0.9469525959367946<br>  jacard dense vs sparse: 0.8815642458100559<br>  jacard dense vs hybrid: 0.9270482603815937<br>  ^b8894a</p></li><li><p>实验需要几个not-in-DPR的数据集？目前只有一个SQuAD</p></li><li><p>实验需要用多个不同的dense retriever来验证检索策略吗？目前只有开源的DPR模型，练其他DR需要大量的算力</p></li><li><p>为何in-DPR作为训练数据的效果很烂？为何使用out- DPR作为训练数据能提高效果？<br> CIKM2021只在MSMarco上进行了实验，因此他们的分类器是in-retriever的。<br> 我认为用out-retriever的训练数据更能提高检索框架的性能</p></li><li><p>实际检索时间开销存疑，<strong>冲击顶会可能需要进行端到端的检索实验验证效率</strong></p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>当前查询gt仍然过慢，HotpotQA <code>(train+dev) * (dense+sparse+hybrid)</code>得2+天</li><li>使用更复杂的模型不一定会更好，目前使用208的CPU进行简单的MLP训练</li><li>加入更多的训练数据（目前只有SQuAD）效果也不一定会更好。</li></ul><h3 id="TODO-3"><a href="#TODO-3" class="headerlink" title="TODO"></a>TODO</h3><ul><li><del>[[笔记 - IR &amp; ODQA Wiki#SearchQA]] 数据集-train（117,384 qas）+val（16,980 qas）的gt查询</del></li><li><del>将SearchQA-train加入分类器训练，验证val上的性能</del></li><li><del>将HotpotQA train+dev的<code>yes / no question</code>删除，重新加入分类器训练并在dev验证效果</del></li><li>复现CIKM2021的BERT-based分类方法作为baseline</li><li>加入更多训练数据<ul><li>NarrativeQA</li><li>AdversarialQA</li><li>WikiQA</li><li>Harvest</li><li>DuoRC（SelfRC）</li></ul></li></ul><h3 id="OLD-TODO-1"><a href="#OLD-TODO-1" class="headerlink" title="OLD-TODO"></a>OLD-TODO</h3><ul><li>更换不同的参数验证half-top merge算法的效果</li><li>计算二分类模型下，oracle对应的召回率</li></ul><h2 id="06-30"><a href="#06-30" class="headerlink" title="06.30"></a>06.30</h2><h3 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h3><ul><li>之前的label策略是站在dense retriever的角度。对于一条query，预测它能否被dense检索。分类器有点类似于dense retriever的向导，知道dense retriever的知识和<br>能力，从而能够预测query是否会被检索到。</li><li>现在改成了sparse retriever的角度。对于一条query，预测它能否被sparse检索到。策略是把所有sparse检索不到的query且能被hybrid或dense检索到的，都标记为正样本。</li></ul><h3 id="Done-4"><a href="#Done-4" class="headerlink" title="Done"></a>Done</h3><ul><li>SQuAD 数据集-train（80599 qas）查询groundtruth完毕，分类器训练ready</li><li>在SQuAD-train上使用Lightgbm训练了分类器</li><li>特征选取只选了q2d_sdist + q2q_ddist</li></ul><h3 id="TODO-4"><a href="#TODO-4" class="headerlink" title="TODO"></a>TODO</h3><ul><li>更换不同的参数验证half-top merge算法的效果</li><li>计算二分类模型下，oracle对应的召回率</li></ul>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - ICTIR2023 Towards Query Performance Prediction for Neural Information Retrieval - Challenges and Opportunities</title>
    <link href="/2024/08/05/%E7%AC%94%E8%AE%B0%20-%20ICTIR2023%20Towards%20Query%20Performance%20Prediction%20for%20Neural%20Information%20Retrieval%20-%20Challenges%20and%20Opportunities/"/>
    <url>/2024/08/05/%E7%AC%94%E8%AE%B0%20-%20ICTIR2023%20Towards%20Query%20Performance%20Prediction%20for%20Neural%20Information%20Retrieval%20-%20Challenges%20and%20Opportunities/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在本工作中，我们提出了一种新颖的框架来设计可用于神经信息检索（NIR）中查询性能预测（QPP）模型的特征。使用该提出的框架作为QPP组件的周期表，从业者可以开发出更适合NIR的新预测器。通过该框架，我们详细阐述了在NIR管道的不同阶段QPP面临的挑战和机遇。我们展示了所提框架的潜力，利用它设计了两种新型预测器。第一个被命名为基于内存的QPP（MEM-QPP），它利用测试查询与训练查询之间的相似性来衡量NIR系统能够记忆的程度。第二个则是通过计算查询与语料库之间的语义相似性，将传统的QPP方法转变为面向NIR的方法。通过利用NIR系统的固有特性，所提出的预测器在多种设置下超越了当前的技术前沿，同时突出了该框架在描述不同类型QPP方面的灵活性。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>神经信息检索（NIR）涵盖了广泛的信息检索（IR）技术，这些技术依赖于神经网络[42, 49, 50, 66, 99]。大型预训练语言模型（PLM）对IR的影响超出了预期，在各种基准测试[11–13, 18, 68, 92]以及IR评估[26, 64]中取得了前所未有的成果。这些系统最初是为了学习排序和重新排序传统信息检索（TIR）方法如BM25[68]的结果而开发的，但最近被用于直接解决第一阶段检索问题[41]。为了在没有人工标注的相关性判断的情况下评估IR系统的性能，查询性能预测（QPP）[7]已经被研究了几十年，并被用于各种任务，包括模型选择[7, 93]、查询重写[25, 83, 93]、排名融合[76]、查询诊断[7]，以及预测最佳池的截止点以减少注释成本[38]。</p><p>QPP对于NIR尤其重要，原因有多个：</p><ol><li>与TIR模型不同，NIR模型具有不同的架构，每种都有其独特的特点。因此，为特定查询选择最佳方法可以显著提升整体性能。</li><li>训练NIR模型可能既耗时又昂贵。有效的QPP模型可以识别表现不佳的查询，并指导研究者收集额外的训练示例来改善这类查询的性能。</li><li>NIR模型经常以零样本的方式被应用[92]，针对性的QPP可以帮助预先确定在目标集合上训练的模型是否能表现良好。</li></ol><p>然而，将QPP应用于NIR存在一些尚未解决的关键挑战[27, 29]。特别是，传统的QPP通常依赖于测量查询与检索文档之间的词汇匹配程度[14, 88, 90, 109]，而NIR模型则明确设计为使用语义匹配。QPP考虑的信号与NIR系统使用的信号之间的不一致阻碍了NIR性能的成功预测。此外，NIR系统是在标记数据上进行训练的，这与TIR系统的无监督性质形成对比。因此，它们的性能与从训练集中学到的内容紧密相关，这对于零样本设置下的系统尤为重要[36, 63, 72, 85, 92, 106]。</p><p>为了克服这些局限性，我们提出了一种新的QPP框架，该框架超越了传统的检索前和检索后二分法。该框架以通用的NIR管道作为参考点，并将其用作周期表来识别应用QPP时可能出现的潜在挑战。该框架的基础在于𝑛阶段特征的概念。我们将这些特征与检索前和检索后的预测器所使用的特征关联起来，并指出哪些信号是NIR模型特有的。我们展示了所提框架的强大能力，通过它开发了两种超出当前技术水平的QPP方法。第一个方法名为基于记忆的QPP（MEM-QPP），它直接利用NIR模型的监督特性，通过测量训练查询与测试查询之间的相似性来预测性能。通过利用训练过程中获得的信息，MEM-QPP相较于经典的检索前和检索后的预测器取得了更好的结果。第二个方法基于检索后的信息，对许多传统QPP中使用的正则化项——例如Clarity[14]、WIG[109]、NQC[88]、SMV[90]——进行了适应，使之适用于NIR环境。我们的实验结果显示，这种方法在预测NIR模型性能时比当前的技术水平有着显著更好的性能。</p><p>总结而言，我们的贡献包括：</p><ul><li>我们提出了一种新颖的QPP框架，该框架基于阶段概念，克服了传统的检索前和检索后的QPP二分法。此外，我们还展示了如何在这一框架内解读经典预测器。</li><li>利用我们的框架，我们设计了MEM-QPP，这是一种模型无关的预测器，它利用训练查询与测试查询之间的语义相似性来预测NIR系统在领域内(In-Domain)情景下的性能。</li><li>我们进一步使用该框架来将经典预测器适应到NIR情景下。具体来说，我们比较了TIR和NIR系统的检索分数分布，并展示了它们具有高度相似性。受此启发，我们提出了两组QPP预测器，即SPLADE-和DenseCentroid-预测器。这两组预测器都将经典QPP适配到了NIR情景下，超越了当前的技术水平。</li></ul><p>本文的其余部分组织如下：</p><ul><li>第2节回顾了NIR和QPP领域的主要研究进展。</li><li>第3节描述了我们为NIR提出的QPP框架。</li><li>第4节阐述了框架突出显示的挑战，并概述了可能的解决方案，这些可以指导未来的研究人员。</li><li>最后，第5节总结了本文，并介绍了由我们的框架所支持的未来研究方向。</li></ul><h2 id="3-A-FRAMEWORK-TO-MODEL-QPP-FOR-NIR-AND-ITS-CHALLENGES"><a href="#3-A-FRAMEWORK-TO-MODEL-QPP-FOR-NIR-AND-ITS-CHALLENGES" class="headerlink" title="3 A FRAMEWORK TO MODEL QPP FOR NIR AND ITS CHALLENGES"></a>3 A FRAMEWORK TO MODEL QPP FOR NIR AND ITS CHALLENGES</h2><p>图1展示了所提出的框架的可视化描述，该框架按阶段组织。该图由三层组成，分别对应于检索、QPP操作以及在每个阶段可提取的特征。前三个阶段关注的是学习方法，无论是针对NIR还是QPP。它们包括选择训练和测试语料库（阶段0）、收集训练查询和标注（阶段1）以及学习过程（阶段2）。随后是阶段3，它涉及收集测试查询。这一阶段，以及阶段4和5，都是NIR、TIR和QPP共有的。阶段4代表计算查询和文档表示的时刻。从阶段4开始，IR和QPP操作可能会有所不同。例如，IR模型可能基于词汇表示，而QPP则可能使用密集表示。在阶段5，查询与文档之间的相似度计算对于IR和QPP操作都是适用的。另一方面，对于QPP而言，阶段5还可能包含整个语料库上的操作，如计算其语言模型或响应查询时所能达到的检索分数。阶段6涉及计算检索文档得分的分布，从而选出与查询最相似的前k个文档。最后，可以计算一个性能指标，这个指标反过来成为QPP的真值。</p><p>就QPP特征而言，目前还没有模型利用来自前三个阶段的特征。这是因为这些特征与NIR模型的监督性质有关。阶段3和4的特征是传统检索前QPP最常使用的。最后，阶段5和6允许开发通常被检索后QPP使用的特征。为了展示框架的优势，我们将详细介绍每个阶段——展示与每个阶段相关的挑战、陷阱和机会，以及可以收集哪些特征。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - CIKM2023 Neural Disentanglement of Query Difficulty and Semantics</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20CIKM2014%20Query%20Performance%20Prediction%20By%20Considering%20Score%20Magnitude%20and%20Variance%20Together/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20CIKM2014%20Query%20Performance%20Prediction%20By%20Considering%20Score%20Magnitude%20and%20Variance%20Together/</url>
    
    <content type="html"><![CDATA[<p>原文链接： <a href="https://dl.acm.org/doi/10.1145/2661829.2661906">Query Performance Prediction By Considering Score Magnitude and Variance Together</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - SIGIR2007 Query performance prediction in web search environments</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2007%20Query%20performance%20prediction%20in%20web%20search%20environments/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2007%20Query%20performance%20prediction%20in%20web%20search%20environments/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/1277741.1277835">Query performance prediction in web search environments</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - SIGIR2010 Using statistical decision theory and relevance models for query-performance prediction</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2010%20Using%20statistical%20decision%20theory%20and%20relevance%20models%20for%20query-performance%20prediction/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2010%20Using%20statistical%20decision%20theory%20and%20relevance%20models%20for%20query-performance%20prediction/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/1835449.1835494">Using statistical decision theory and relevance models for query-performance prediction</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - SIGIR2018 Neural Query Performance Prediction using Weak Supervision from Multiple Signals</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2018%20Neural%20Query%20Performance%20Prediction%20using%20Weak%20Supervision%20from%20Multiple%20Signals/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2018%20Neural%20Query%20Performance%20Prediction%20using%20Weak%20Supervision%20from%20Multiple%20Signals/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>预测给定查询下搜索引擎的表现是一项信息检索领域中基本而富有挑战性的任务。准确的性能预测器可以被用于多种用途，例如触发某个动作、针对每个查询选择最有效的排名函数，或是从多个查询表述中挑选最佳版本。本文提出了一种基于神经网络的通用端到端查询性能预测框架，称之为NeuralQPP。我们的框架包含多个组件，每个组件学习适合于性能预测的表示形式。这些表示随后被聚合起来并输入到预测子网络中。我们利用多种弱监督信号来训练我们的模型，这是一种无监督的学习方法，使用现有的无监督性能预测器提供的弱标签。此外，我们还提出了一种简单而有效的组件丢弃技术来正则化我们的模型。我们在四个新闻报道和网页数据集上的实验表明，NeuralQPP在几乎所有情况下都显著优于最先进的基线方法。此外，我们还全面分析了实验中每个组件、每种弱监督信号及其所有组合的有效性。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><h3 id="2-1-查询性能预测-Query-Performance-Prediction"><a href="#2-1-查询性能预测-Query-Performance-Prediction" class="headerlink" title="2.1 查询性能预测 &#x2F;&#x2F; Query Performance Prediction"></a>2.1 查询性能预测 &#x2F;&#x2F; Query Performance Prediction</h3><p>质量估计是一项基本任务，能够帮助在多种应用中提高效率或效能，例如机器翻译 [45] 和自动语音识别 [4, 31]。对于搜索引擎而言，这项任务被称为查询性能或查询难度预测。这一任务已经在信息检索（IR）文献中被广泛研究 [5, 11, 12, 14, 18, 22, 42–44, 47, 56, 57]。查询性能预测的任务定义为，在没有隐式或显式的相关性信息的情况下，预测一个给定查询在搜索引擎中的检索效果。</p><p>查询性能预测方法可以分为两个互斥的集合：检索前方法和检索后方法。检索前的查询性能预测方法基于查询的内容、上下文以及语料库统计信息来预测每个查询的表现。检索前的预测器通常源自语言学或统计信息。查询术语的部分词性标签，以及语法和形态特征是用于查询性能预测的语言学特征之一 [30]。逆文档频率 [11] 和平均查询术语一致性 [19] 是用于此任务的统计信息的例子。Hauff等人 [18] 提供了检索前的查询性能预测方法的详尽综述。</p><p>另一方面，本文关注的重点——检索后的查询性能预测方法通过分析由检索引擎针对查询返回的结果列表来估算查询性能。Carmel和Yom-Tov [5] 将检索后的预测器归类为基于清晰度、基于稳健性和基于得分的方法：</p><ul><li><p><strong>基于清晰度的方法</strong> [11, 12] 通过测量结果列表相对于整个语料库的连贯性（清晰度）来估计查询性能。这些方法假设结果列表越集中，检索就越有效。</p></li><li><p><strong>基于稳健性的方法</strong> 通过估算结果列表的稳健性来预测查询性能。稳健性可以通过多种方式衡量。例如，Zhou和Croft [57] 在查询反馈（QF）模型中基于查询扰动来衡量它。在其他工作中，同一作者 [56] 通过向顶部结果注入噪声来衡量排名稳健性。Vinay等人 [49] 也研究了查询和文档扰动。Aslam和Pavlu [2] 基于检索引擎扰动研究了排名稳健性。除了扰动方法之外，Diaz [17] 使用聚类假设 [48] 通过规范化给定文档最相似文档的检索得分来衡量排名稳健性。这种方法被称为空间自相关。</p></li><li><p><strong>基于得分的方法</strong> 通过分析检索得分分布来预测查询性能，这类方法通常被称为基于得分的方法。其中，Zhou和Croft [57] 的加权信息增益（WIG）和Shtok等人 [44] 的标准化查询承诺（NQC）是最流行的查询性能预测模型，被认为是当前的最佳实践。WIG衡量平均检索得分与语料库得分之间的偏离度，而NQC则衡量归一化后的检索得分的标准偏差。检索得分分布还被用于其他模型 [14, 34] 中进行查询性能预测任务。最近，Roitman等人 [40] 提出了一种自助法（bootstrapping）方法，以提供检索得分的稳健标准差估计。</p></li></ul><p>此外，还有一些研究结合了来自多个类别的多个预测器。Shtok等人 [42] 的效用估计框架（UEF）就是这一查询性能预测家族的一个例子，它是基于统计决策理论的。Kurland等人 [22]、Shtok等人 [43] 和Roitman [38] 进一步研究了利用伪有效和伪无效参考列表的方法。</p><p>对于查询性能预测，还存在一些监督学习方法。例如，Raiber和Kurland [36] 提出了基于马尔可夫随机场的学习排序模型，并观察到了显著的改进。最近，Roitman等人 [39] 引入了一种基于坐标上升的监督组合方法。我们的模型不需要人为标注的数据来进行训练，因此监督学习方法不在本文的研究范围内。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - SIGIR2023 Query Performance Prediction - From Ad-hoc to Conversational Search</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2023%20Query%20Performance%20Prediction%20-%20From%20Ad-hoc%20to%20Conversational%20Search/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20SIGIR2023%20Query%20Performance%20Prediction%20-%20From%20Ad-hoc%20to%20Conversational%20Search/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/3539618.3591919">ACM-digital-library</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>查询性能预测（QPP）是信息检索（IR）领域中的一个基本任务。它的目标是在没有相关性判断的情况下估计给定查询的检索质量[13, 15, 21, 25, 56, 59]。QPP一直是IR社区长期研究的主题[9]。已经识别出QPP的诸多益处，包括根据输入查询的难度选择最有效的排序算法[25, 26, 56]。</p><p>在对话式搜索（CS）领域，已经在多个子任务上取得了显著进展[58]，其中包括段落检索[12, 55]、查询重写[51, 54]、混合主动交互[3, 57]、响应生成[37–39]以及评估[17, 18]。具体而言，段落检索一直是TREC CAsT 2019–2022的主要关注点[12]，其中研究表明建模长对话上下文来进行检索是非常具有挑战性的[2]。此外，研究还表明，混合主动交互可以导致用户和系统的性能提升[3, 60]。就像即席检索一样，QPP在多个方面对对话式搜索有益。例如，有效的QPP可以帮助对话式搜索系统在下一个回合采取适当的行动，比如当估计的检索质量对于当前用户查询较低时，主动提出澄清问题或告诉用户“我无法回答你的问题”，而不是给出低质量或冒险的答案[5, 44]。</p><p>(1) 对话中的用户查询依赖于对话上下文，也就是说，它可能包含省略、共指或歧义，从而导致难以预料的QPP挑战； (2) 对话式搜索（CS）中的QPP需要预测专门为CS设计的新颖检索方法的性能；为了解决CS中的查询理解挑战，提出了两种主要的CS方法，即基于查询重写的检索[32, 35, 49, 51, 52, 54]和对话式密集检索方法[28, 31, 33, 33, 34, 42, 55]； (3) CS中的QPP应该侧重于估计排名靠前的结果的检索质量，而不是整个排名列表的质量，因为CS系统需要返回简短的回答以适应有限带宽的接口，例如移动屏幕[58]。</p><p>在这篇可重复性研究论文中，我们根据这些CS特征设计实验，并检验关于即席搜索中QPP的既定发现是否在这些条件下仍然成立。具体来说，我们研究了文献中关于即席搜索中QPP的以下发现：<br>(i) 监督式QPP方法优于无监督式QPP方法[4, 7, 13, 15, 22, 56]；<br>(ii) 列表式的监督式QPP方法优于其点式对应方法[7, 15]；以及<br>(iii) 基于检索分数的无监督式QPP方法在估计基于神经网络的检索器的检索质量方面表现不佳[14, 22]。通过在CS设置下检验上述每一条即席搜索中的QPP发现，我们旨在描述应用于CS的QPP问题，并获得新的发现及未来研究的方向作为额外成果。</p><p>在这篇论文中，我们在三个对话式搜索数据集上进行了实验：(i) CAsT-19 [12]，(ii) CAsT-20 [11]，以及(iii) OR-QuAC [42]。我们的实验表明，在对话式搜索的设置下，(i) 监督式QPP方法仅在有大量训练数据可用时明显优于无监督式方法；而在少量样本设置中以及预测更深排名列表的检索质量时，无监督式QPP方法表现出强劲的性能；(ii) 点式监督式QPP方法在大多数情况下优于其列表式对应方法；然而，在少量样本设置中以及预测更深排名列表的检索质量时，列表式QPP方法显示出轻微的优势；以及(iii) 基于检索分数的无监督式QPP方法在估计对话式密集检索方法ConvDR的检索质量方面显示出很高的有效性，无论是在顶级排名还是更深层的排名列表中。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><strong>实现细节</strong></p><p>我们使用 PyTorch 实现所有 QPP 方法。对于无监督的 QPP 方法，我们采用先前研究证明有效的超参数设置。遵循 [59] 的做法，我们将 WIG 中的 𝑘k 设置为 5。根据 [47, 48] 的建议，NQC 和 SMV 中的 𝑘k 设置为 100；同样地，按照 [48] 的建议，我们使用前 1000 篇文档的平均检索得分作为语料库得分 Score(𝑞q;𝐷D)。根据 [10] 的做法，我们为 n(𝜎𝑥σx​) 设置 𝑥x 为 50。𝜎𝑚𝑎𝑥σmax​ 不使用任何超参数。遵循 [47] 的建议，我们使用基于求和归一化的检索得分（在我们的设置中来自 BM25 或 ConvDR）的 Clarity 变体来构建相关模型 [30]；我们的初步实验表明这种变体比使用查询似然得分来加权文档的原始 Clarity 表现更好；我们使用前 100 篇文档来构建相关模型，并在前 100 个术语处裁剪该模型 [46]。</p><p>对于所有的监督式 QPP 方法，我们使用 <code>bert-base-uncased</code> 模型，固定的学习率（0.00002），以及 Adam 优化器 [29]。所有方法都在 NVIDIA RTX A6000 GPU 上进行训练和推理。遵循 [33, 55] 的做法，我们在 CAsT-19 或 CAsT-20 上的所有训练都采用五折交叉验证；我们使用 [55] 中的数据划分，并将所有监督式 QPP 方法训练 5 个周期。对于 OR-QuAC 的训练，我们让所有 QPP 方法在 OR-QuAC 的训练集上训练 1 个周期；我们向 QPP 方法提供人工重写的查询，并训练它们估计使用人工重写查询的 BM25 的检索质量。为了应对 CAsT-19 和 CAsT-20 上的数据稀缺问题，我们考虑了一种预热设置，在这种设置下，我们首先在 OR-QuAC 的训练集上预训练监督式 QPP 方法 1 个周期，然后在 CAsT 上进行五折交叉验证训练 5 个周期。为了确保未来的可复现性，我们的代码和数据资源可在 <a href="https://github.com/ChuanMeng/QPP4CS">https://github.com/ChuanMeng/QPP4CS</a> 找到。</p><h2 id="6-CONCLUSION"><a href="#6-CONCLUSION" class="headerlink" title="6 CONCLUSION"></a>6 CONCLUSION</h2><p>在这项可重复性研究中，我们考察了随机搜索中针对 QPP 的三项关键发现是否适用于会话搜索（CS）。我们在三种 CS 设置中试验了为随机搜索设计的 QPP 方法：(i) 预测 BM25 的检索质量同时研究查询重写的影响；(ii) 预测会话密集检索方法 ConvDR 的检索质量；以及 (iii) 预测前几条结果与更深层结果列表的检索质量。</p><p>我们发现，随机搜索中的三项关于 QPP 的发现并不完全适用于 CS。具体来说，我们发现： (i) 监督式 QPP 方法仅在有足够的训练数据时才明显优于无监督方法；而在少样本设置下，无监督 QPP 方法在预测更深层结果列表的检索质量时表现出很强的性能； (ii) 基于点的监督式 QPP 方法在大多数情况下优于基于列表的方法；然而，基于列表的 QPP 方法更节省数据，在预测更深层结果列表的检索质量时显示出轻微的优势； (iii) 基于检索分数的无监督 QPP 方法无论是在预测前几条结果还是更深层结果列表时都能有效地估计会话密集检索方法 ConvDR 的检索质量；分数基础方法的有效性依赖于特定检索器的检索分数分布，无论这些检索器是基于词汇的还是基于神经网络的。</p><p>我们的论文揭示了将经过 T5 或 QuReTeC 重写的查询输入到 QPP 方法中以评估会话搜索（CS）方法的检索质量表现出色。我们还指出了为随机搜索设计的 QPP 方法在 CS 上的不足之处，这为会话搜索中 QPP 的建模提供了未来的研究方向。我们表明，查询重写的质量非常重要，突显了提高查询编写质量的需求。这也显示了需要开发一种理解会话上下文的机制，以便 QPP 方法能够直接理解原始的历史对话。此外，我们还揭示了会话搜索中的数据稀疏问题严重降低了监督式 QPP 方法的性能。因此，使用少样本学习技术来设计 QPP 方法是一种可能的方式。</p><p>我们指出了研究中的两个局限性，即：(i) 我们只考虑了一种会话密集检索方法的检索质量评估；(ii) 我们仅使用相关性指标来评估 QPP 方法的性能。在未来的工作中，我们计划 (i) 考虑更多的会话密集检索方法，如 CQE [31] 以及其他会话搜索中的密集检索方法，例如基于 T5 的重写器 + ANCE [53]；(ii) 引入专门针对 QPP 的评估指标，如缩放绝对排名误差 (sARE) 和缩放平均绝对排名误差 (sMARE) [19, 20]。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - TOIS2022 Predicting Query Performance by Query-Drift Estimation</title>
    <link href="/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20TOIS2022%20Predicting%20Query%20Performance%20by%20Query-Drift%20Estimation/"/>
    <url>/2024/07/31/%E7%AC%94%E8%AE%B0%20-%20TOIS2022%20Predicting%20Query%20Performance%20by%20Query-Drift%20Estimation/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/2180868.2180873">Predicting Query Performance by Query-Drift Estimation</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>预测查询性能，即针对查询执行搜索的有效性，是一个极其重要且富有挑战性的问题。我们提出了一种新颖的方法来解决这一任务，该方法基于测量排名最高的文档结果列表中检索得分的标准差。我们认为，对于基于文档与查询表面相似性的检索方法而言，标准差可以作为估算结果列表中的查询漂移量的一个替代指标，即列表中的文档存在（并且占主导地位）与查询无关的方面或主题。经验评估证明了我们方法在几种检索模型上的预测有效性。具体而言，预测质量通常超越当前最先进的预测方法。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - CIKM2021 BERT-QPP Contextualized Pre-trained transformers for Query Performance Prediction</title>
    <link href="/2024/07/30/%E7%AC%94%E8%AE%B0%20-%20CIKM2021%20BERT-QPP%20Contextualized%20Pre-trained%20transformers%20for%20Query%20Performance%20Prediction/"/>
    <url>/2024/07/30/%E7%AC%94%E8%AE%B0%20-%20CIKM2021%20BERT-QPP%20Contextualized%20Pre-trained%20transformers%20for%20Query%20Performance%20Prediction/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://dl.acm.org/doi/10.1145/3459637.3482063">ACM-digital-library</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>查询性能预测 (QPP) 致力于估计使用特定检索方法满足用户查询的难度。虽然大多数最先进的 QPP 方法基于词频和语料库统计，但最近的研究开始探索预训练神经嵌入、神经网络架构和上下文嵌入的效用。这些方法从预训练或上下文嵌入中提取特征，以便训练监督性能预测器。在本文中，我们采用上下文嵌入来进行性能预测，但我们与现有技术的不同之处在于提出直接微调上下文嵌入模型——即 BERT——专门用于查询性能预测任务。因此，我们的工作允许微调后的上下文表示根据查询表示与检索到的文档之间的关联来估计查询的性能。我们根据 MS MARCO 段落检索语料库及其三个相关的查询集比较了我们方法的性能：(1) MS MARCO 开发集，(2) TREC DL 2019，以及 (3) TREC DL 2020。我们表明，与所有现有的方法相比，我们的方法不仅显示出显著改进的预测性能，而且与过去的神经预测器不同，它还显示出明显更低的延迟，使其在实践中成为可能。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>随机检索任务专注于从大型文档集合中检索出按相关性排序的文档列表，以满足通过查询表达的信息需求。尽管在随机检索任务上取得了进展，从传统的基于词频的统计和查询似然语言模型 [16, 20] 到更近的深度神经排名器 [18, 40]，但仍有一些难以处理的查询无法被检索方法有效满足。因此，查询性能预测 (QPP) 任务的目标是预测检索方法对于给定的用户查询可能的表现。换句话说，QPP 任务旨在预测检索方法是否能够为特定查询检索出相关文档，而无需访问该查询的相关性标准信息。有效的 QPP 方法在随机检索过程中扮演着重要角色，例如实现查询路由或查询重写 [5, 34]。QPP 方法的更多近期应用可见于智能助手领域，在该领域中，用户对其从助手处获得的响应非常敏感 [31]。</p><p>在本文中，我们通过采用上下文化神经嵌入来预测查询性能，从而推进了该领域的研究前沿。我们的工作提出对预训练的转换器(transformer)进行微调，以学习估计查询在其相关文档集下的性能。我们提出了一种架构，称为BERT-QPP，它直接通过微调BERT来学习查询性能。与用于即席检索的其他基于BERT的模型[17, 40, 42]不同，我们提出的BERT-QPP方法侧重于学习检索到的文档的质量，因此，基于检索到的文档的检索得分学习查询的潜在性能。这使得BERT-QPP能够直接通过微调BERT来学习查询性能，而无需额外的训练。我们考虑了两种广泛使用的架构，即交叉编码器(cross-encoder)和双编码器(bi-encoder)架构，来实现BERT-QPP。我们在这两种架构中使用查询及其相关检索到的文档来微调BERT。BERT-QPP与最先进的NQA-QPP方法[12]的区别在于，在NQA-QPP的上下文中，查询和文档的BERT表示被视为第二个前馈神经网络的输入特征，该网络被训练来预测查询的性能。相反，通过在我们提出的框架中微调BERT，BERT-QPP可以直接基于检索到的文档来学习预测查询性能，因此，我们提出的方法不需要除了微调过的BERT之外的单独训练模型。这使得我们提出的方法计算上更为简便且更易于部署。此外，大多数QPP方法对于其超参数具有高度敏感性。然而，我们提出的BERT-QPP方法没有任何参数，因此更加稳定可靠。为了展示我们提出的QPP方法的有效性，我们在著名的MS MARCO段落检索数据集[24]以及TREC深度学习赛道2019年和2020年的查询上进行了实验，这些查询是在不同的评估方案下进行判断的，以表明不完整的标签不会影响我们BERT-QPP方法的训练。我们证明了我们的方法能够在所有查询集上展现出更好的性能预测性能，这是基于Pearson ρ、Kendall τ 和Spearman ρ 相关性度量指标的。</p><h2 id="2-PROPOSED-APPROACH"><a href="#2-PROPOSED-APPROACH" class="headerlink" title="2 PROPOSED APPROACH"></a>2 PROPOSED APPROACH</h2><p>首先，让我们正式定义在非特定需求检索(ad hoc retrieval)上下文中查询性能预测(QPP)任务。给定一个文档集合 C，一个检索到的文档列表 Dq​，一个输入查询 q，以及一个检索方法 R，查询性能预测器 $\mu$ 需要估计 R 对于查询 q 相对于某个期望的评价指标 M（例如，平均精度或倒数排名）的表现。预测器 $\mu$  可以定义如下：</p><p>为了实现预测器 $\mu$，我们提出通过微调一个预训练的上下文感知变换器模型，即BERT，并使用回归模型输出一个连续得分来体现查询对于检索方法的难度。这一过程将在两种架构下进行，分别是交叉编码器网络(cross-encoder network)和双编码器网络(bi-encoder network)。</p><h3 id="2-1-Cross-Encoder-Network"><a href="#2-1-Cross-Encoder-Network" class="headerlink" title="2.1 Cross-Encoder Network"></a>2.1 Cross-Encoder Network</h3><p>为了训练交叉编码器网络以开发高效的预测器 $\mu$，我们基于输入查询与由检索方法 R 对查询 q 检索出的前 k 个文档之间的关联性来学习一个连续的难度评分。具体做法是，我们将输入查询和检索出的前 k 个文档 Dqk​ 使用特殊的分隔符令牌连接起来。然后，在由变换器产生的第一个向量上应用一个线性层，以产生一个标量值，我们称之为 QPPCross(q,Dqk​)。我们利用了一个Sigmoid层和一个单类别的二元交叉熵损失函数。更正式地，我们的交叉编码器网络的损失函数可以定义如下，其中M(q,Dq​) 是期望的排序指标，例如平均精确度（Average Precision）：</p><p>将查询和前 k 个文档放在同一个变换器中的优势在于，这能增加查询与前 k 个文档之间的交互，从而可能捕捉到查询与文档空间之间更深层次的关联。然而，这样做会增加计算成本 [14, 29, 38, 39]。此外，该模型需要在运行时即时计算查询与前 k 个文档之间的关联，一旦接收到查询即开始计算。这意味着无法预先进行任何可能的离线计算，因为这些计算都是根据输入查询上下文得出的。因此，在实践中可能会遇到推理时间较慢的问题。</p><h3 id="3-2-Baselines"><a href="#3-2-Baselines" class="headerlink" title="3.2 Baselines"></a>3.2 Baselines</h3><p>我们将所提出的方法与文献中已经显示出有前景的几种检索后查询性能预测器进行了比较 [5]。WIG [43] 通过测量顶级文档的检索得分与其文档集合之间的偏差来预测查询难度。Clarity [8] 通过测量检索到的文档的语言模型与语料库之间的偏差来运作。Query Feedback (QF) [43] 使用低成本且直接的技术如伪相关反馈 [21] 来衡量从原始查询和修订查询中检索出的顶级文档之间的重叠度。大多数在大多数基准测试中表现出最高性能的检索后 QPP 指标 [5] 使用顶级检索文档的检索得分的标准差。NQC [36]、σk [27]、n(σ%) [9] 和 SMV [37] 以及 RSD [32] 利用了这种标准差的变化。效用估计框架 (UEF) [35] 在表现良好的 QPP 基线方法上运行，例如 NQC [36]。此外，我们还考虑了三种最先进的监督式 QPP 基线。NeuralQPP [41] 是一个使用其他无监督 QPP 方法作为弱监督学习信号的框架。类似地，LTRoq [28] 是一个利用学习排序框架的监督式 QPP 方法，它将其他 QPP 方法作为特征。我们还包括最新的基于 BERT 的 QPP 方法，即 NQA-QPP [12]，并指出这是文献中最新的基于上下文预训练嵌入的 QPP 方法。由于大多数介绍的 QPP 基线需要超参数调整，我们从 MS MARCO 训练集中随机留出了一个小子集的查询（5,000 个查询）来调整基线的超参数。此外，我们在 TREC 2020 查询上调整了 TREC 2019 的基线超参数，反之亦然。</p><h2 id="4-CONCLUSION"><a href="#4-CONCLUSION" class="headerlink" title="4 CONCLUSION"></a>4 CONCLUSION</h2><p>我们提出了一种基于微调预训练变换器的方法，该方法使模型学会估算给定输入查询下检索到的文档列表的性能，针对的是临时检索（ad hoc retrieval）场景下的查询性能预测。我们提出了两种变体，分别是采用交叉编码器架构的BERT-QPP𝑐𝑟𝑜𝑠𝑠和采用双编码器架构的BERT-QPP𝑏𝑖。前者相较于基线模型展现出持续且强大的性能，而后者则更为高效，具有相对较小的延迟。我们的实验表明，BERT-QPPs在与MS MARCO数据集相关的三个查询集上超越了现有的最先进QPP基线模型。此外，我们还展示了BERT-QPP𝑐𝑟𝑜𝑠𝑠和BERT-QPP𝑏𝑖均比现有的神经网络QPP方法快得多。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - ECIR2023 Learning to Jointly Transform and Rank Difficult Queries</title>
    <link href="/2024/07/30/%E7%AC%94%E8%AE%B0%20-%20ECIR2023%20Learning%20to%20Jointly%20Transform%20and%20Rank%20Difficult%20Queries/"/>
    <url>/2024/07/30/%E7%AC%94%E8%AE%B0%20-%20ECIR2023%20Learning%20to%20Jointly%20Transform%20and%20Rank%20Difficult%20Queries/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://link.springer.com/chapter/10.1007/978-3-031-56066-8_5">ECIR</a><br>代码链接：</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>最近的经验研究表明，在诸如即席检索(ad hoc retrieval)这样的任务上，虽然神经排序器展现出越来越高的检索有效性，但这种性能提升并不是所有查询都能均匀体验到的。通常存在大量的查询无法被神经排序器满意地解决。这些查询常被称为困难查询。鉴于神经排序器是基于查询与其相关文档的嵌入表示之间的相似度来运行的，困难查询表现不佳的原因可能是由于学习到了次优的表示。因此，本文工作的目标是同时学习文档排序并转换查询表示，使得查询的表示被转换成更接近其相关文档的形式。这样，我们的方法将有机会满足大量原本无法得到解决的困难查询。为了同时学习文档排序和转换查询，我们提出在神经排序器中集成两种形式的三元组损失函数，确保每个查询通过其嵌入表示的转换而在嵌入空间中移动，从而靠近其相关文档。我们在MS MARCO段落排序任务上进行了实验，并表明我们提出的方法对于那些现有神经排序器难以处理的查询，能显著提高性能。平均而言，对于初始神经排序器中倒排等级为零的查询，我们的方法能够以10位时的均倒排等级(MRR@10) 0.21来满足277个查询。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>信息检索(IR)领域从大型语言模型(LLMs)，如BERT [9]，在提高即席检索(ad hoc retrieval)性能方面获得了巨大益处[21,27]。即席检索任务的性能有了显著提升，这主要是因为在稠密的嵌入空间内学习了术语、查询和文档的表示[16]。然而，尽管神经排序器的整体有效性至少提高了两倍，例如基于MS MARCO段落排序数据集[18]，但这些改进并没有在不同的查询子集上均匀体现[3]。</p><p>研究人员传统上理解到，并非所有查询都能通过不同的检索器得到相同程度的满足[11]；然而，考虑到神经排序器相当高的性能，那些完全无法被神经排序器满足的查询数量可能会令人惊讶[1,4]。最近一项关于神经排序器在MS MARCO段落数据集上的有效性研究显示，在其开发集中的6,980个查询中，至少有2,500个查询未能被任何最先进的神经排序器处理（即这些查询的倒数排名为零）。这表明神经排序器通过专注于特定一部分查询而牺牲另一部分查询来提高总体平均检索效果[3,5]。</p><p>根据观察，神经排序器（1）对于一部分查询能够非常有效地检索出高度相关的文档。根据[3]，这些查询在各种神经排序器中都很常见，通常被称为简单查询；并且（2）在处理另一大部分查询时效果不佳，甚至无法达到最低要求，我们将这部分查询称为困难查询。一个典型的神经排序器在处理简单查询时不需要任何辅助；然而，在有效处理困难查询方面则需要额外的机制。为此，我们假设困难查询是指那些其嵌入表示在嵌入空间中位置不佳的查询，即它们与不相关文档的距离更近，而与相关文档的距离更远。解决这个问题的一个可能方案是对查询的表示进行转换，使困难查询更接近于它们的相关文档，从而提高其检索效果。</p><p>本文的目标是通过转换查询的表示来提升处理困难查询的性能。为了实现这一目标，我们提出进行（1）查询表示转换，以及（2）段落排名任务的同时操作，其中查询的转换不是在其表面形式上发生，而是通过将查询表示翻译成嵌入空间中的一个位置，使该位置更接近其相关的段落并远离其他不相关的段落。我们在MS MARCO段落排名数据集上进行了实验，并涵盖了多种最先进的神经排序方法。根据我们的实验结果，我们展示了同时学习转换查询和排序文档的策略能显著提高检索有效性，尤其是在处理困难查询方面。</p><p>我们工作的主要贡献可以总结为：</p><ol><li>我们提出了一种同时学习排序文档和转换查询的方法；</li><li>我们证明了我们的方法能够持续提高各种神经排序器在处理最困难查询时的表现。</li></ol><p>此外，我们提出的训练策略的优点包括： (a) 它广泛适用于一系列神经排序器，因为它不需要改变神经排序方法的架构； (b) 它不需要额外的学习开销来转换查询，因为这与训练排序方法同时进行。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 检索策略 &amp; 查询性能预测论文汇总</title>
    <link href="/2024/07/30/%E8%AE%B0%E5%BD%95%20-%20%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5%20&amp;%20%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%A2%84%E6%B5%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%80%BB/"/>
    <url>/2024/07/30/%E8%AE%B0%E5%BD%95%20-%20%E6%A3%80%E7%B4%A2%E7%AD%96%E7%95%A5%20&amp;%20%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%A2%84%E6%B5%8B%E8%AE%BA%E6%96%87%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Retrieval-Strategy-Selection"><a href="#Retrieval-Strategy-Selection" class="headerlink" title="Retrieval-Strategy-Selection"></a>Retrieval-Strategy-Selection</h2><p>[[笔记 - CIKM2021 Predicting Efficiency Effectiveness Trade-offs for  Dense vs. Sparse Retrieval Strategy Selection]]</p><h2 id="Neural-Disentanglement-of-Query-Difficulty-and-Semantics"><a href="#Neural-Disentanglement-of-Query-Difficulty-and-Semantics" class="headerlink" title="Neural Disentanglement of Query Difficulty and Semantics"></a>Neural Disentanglement of Query Difficulty and Semantics</h2><p>[[笔记 - CIKM2023 Neural Disentanglement of Query Difficulty and Semantics]]</p><h2 id="Learning-to-Jointly-Transform-and-Rank-Difficult-Queries"><a href="#Learning-to-Jointly-Transform-and-Rank-Difficult-Queries" class="headerlink" title="Learning to Jointly Transform and Rank Difficult Queries"></a>Learning to Jointly Transform and Rank Difficult Queries</h2><p>[[笔记 - ECIR2023 Learning to Jointly Transform and Rank Difficult Queries]]</p><h2 id="BERT-QPP-Contextualized-Pre-trained-transformers-for-Query-Performance-Prediction"><a href="#BERT-QPP-Contextualized-Pre-trained-transformers-for-Query-Performance-Prediction" class="headerlink" title="BERT-QPP: Contextualized Pre-trained transformers for Query Performance Prediction"></a>BERT-QPP: Contextualized Pre-trained transformers for Query Performance Prediction</h2><p>[[笔记 - CIKM2021 BERT-QPP Contextualized Pre-trained transformers for Query Performance Prediction]]</p><h2 id="Query-Performance-Prediction-From-Ad-hoc-to-Conversational-Search"><a href="#Query-Performance-Prediction-From-Ad-hoc-to-Conversational-Search" class="headerlink" title="Query Performance Prediction - From Ad-hoc to Conversational Search"></a>Query Performance Prediction - From Ad-hoc to Conversational Search</h2><p>[[笔记 - SIGIR2023 Query Performance Prediction - From Ad-hoc to Conversational Search]]</p><h2 id="A-Geometric-Framework-for-Query-Performance-Prediction-in-Conversational-Search"><a href="#A-Geometric-Framework-for-Query-Performance-Prediction-in-Conversational-Search" class="headerlink" title="A Geometric Framework for Query Performance Prediction in Conversational Search"></a>A Geometric Framework for Query Performance Prediction in Conversational Search</h2><p><a href="https://dl.acm.org/doi/10.1145/3539618.3591625">A Geometric Framework for Query Performance Prediction in Conversational Search</a></p><h2 id="Context-Aware-Query-Term-Difficulty-Estimation-for-Performance-Prediction"><a href="#Context-Aware-Query-Term-Difficulty-Estimation-for-Performance-Prediction" class="headerlink" title="Context-Aware Query Term Difficulty Estimation for Performance Prediction"></a>Context-Aware Query Term Difficulty Estimation for Performance Prediction</h2><p><a href="https://link.springer.com/chapter/10.1007/978-3-031-56066-8_4">Context-Aware Query Term Difficulty Estimation for Performance Prediction</a></p><h2 id="WRIG-A-Relative-Information-Gain-based-Query-Performance-Prediction-Framework-with-Generated-Query-Variants"><a href="#WRIG-A-Relative-Information-Gain-based-Query-Performance-Prediction-Framework-with-Generated-Query-Variants" class="headerlink" title="[WRIG] A Relative Information Gain-based Query Performance Prediction Framework with Generated Query Variants"></a>[WRIG] A Relative Information Gain-based Query Performance Prediction Framework with Generated Query Variants</h2><p><a href="https://dl.acm.org/doi/10.1145/3545112">A Relative Information Gain-based Query Performance Prediction Framework with Generated Query Variants</a></p><h3 id="Injecting-the-score-of-the-first-stage-retriever-as-text-improves-BERT-based-re-rankers"><a href="#Injecting-the-score-of-the-first-stage-retriever-as-text-improves-BERT-based-re-rankers" class="headerlink" title="Injecting the score of the first-stage retriever as text improves BERT-based re-rankers"></a>Injecting the score of the first-stage retriever as text improves BERT-based re-rankers</h3><p><a href="https://link.springer.com/content/pdf/10.1007/s10791-024-09435-8.pdf">Injecting the score of the first-stage retriever as text improves BERT-based re-rankers</a></p><h1 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a>Survey</h1><h2 id="Towards-Query-Performance-Prediction-for-Neural-Information-Retrieval-Challenges-and-Opportunities"><a href="#Towards-Query-Performance-Prediction-for-Neural-Information-Retrieval-Challenges-and-Opportunities" class="headerlink" title="Towards Query Performance Prediction for Neural Information Retrieval: Challenges and Opportunities"></a>Towards Query Performance Prediction for Neural Information Retrieval: Challenges and Opportunities</h2><p><a href="https://dl.acm.org/doi/10.1145/3578337.3605142">Towards Query Performance Prediction for Neural Information Retrieval: Challenges and Opportunities</a></p><h1 id="Score-based"><a href="#Score-based" class="headerlink" title="Score-based"></a>Score-based</h1><h2 id="SMV-Query-Performance-Prediction-By-Considering-Score-Magnitude-and-Variance-Together"><a href="#SMV-Query-Performance-Prediction-By-Considering-Score-Magnitude-and-Variance-Together" class="headerlink" title="[SMV] Query Performance Prediction By Considering Score Magnitude and Variance Together"></a>[SMV] Query Performance Prediction By Considering Score Magnitude and Variance Together</h2><p>[[笔记 - CIKM2014 Query Performance Prediction By Considering Score Magnitude and Variance Together]]</p><h2 id="Using-statistical-decision-theory-and-relevance-models-for-query-performance-prediction"><a href="#Using-statistical-decision-theory-and-relevance-models-for-query-performance-prediction" class="headerlink" title="Using statistical decision theory and relevance models for query-performance prediction"></a>Using statistical decision theory and relevance models for query-performance prediction</h2><p>[[笔记 - SIGIR2010 Using statistical decision theory and relevance models for query-performance prediction]]</p><h2 id="NQC-Predicting-Query-Performance-by-Query-Drift-Estimation"><a href="#NQC-Predicting-Query-Performance-by-Query-Drift-Estimation" class="headerlink" title="[NQC]Predicting Query Performance by Query-Drift Estimation"></a>[NQC]Predicting Query Performance by Query-Drift Estimation</h2><p>[[笔记 - TOIS2022 Predicting Query Performance by Query-Drift Estimation]]</p><h2 id="Neural-Query-Performance-Prediction-using-Weak-Supervision-from-Multiple-Signals"><a href="#Neural-Query-Performance-Prediction-using-Weak-Supervision-from-Multiple-Signals" class="headerlink" title="Neural Query Performance Prediction using Weak Supervision from Multiple Signals"></a>Neural Query Performance Prediction using Weak Supervision from Multiple Signals</h2>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 07.22-07.28（肌电图+入职串讲+科研反思）</title>
    <link href="/2024/07/28/%E5%91%A8%E8%AE%B0%20-%202024%2007.22-07.28%EF%BC%88%E8%82%8C%E7%94%B5%E5%9B%BE+%E5%85%A5%E8%81%8C%E4%B8%B2%E8%AE%B2+%E7%A7%91%E7%A0%94%E5%8F%8D%E6%80%9D%EF%BC%89/"/>
    <url>/2024/07/28/%E5%91%A8%E8%AE%B0%20-%202024%2007.22-07.28%EF%BC%88%E8%82%8C%E7%94%B5%E5%9B%BE+%E5%85%A5%E8%81%8C%E4%B8%B2%E8%AE%B2+%E7%A7%91%E7%A0%94%E5%8F%8D%E6%80%9D%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="07-22-周一-晴"><a href="#07-22-周一-晴" class="headerlink" title="07.22 周一 晴"></a>07.22 周一 晴</h2><p>下午2点多开始上班后，我就想着跟FS的one2one不是只有周三周五吗，就开始摸鱼了。<br>没想到14:55右上角的飞书弹出个会议📅提醒……<br>这下不得不光速挤出一些问题了，不然待会我和FS在会议室四目相对，没东西问大家都尴尬。</p><h2 id="07-23-周二-晴（肌电图-⚡️-🪡-麻痛）"><a href="#07-23-周二-晴（肌电图-⚡️-🪡-麻痛）" class="headerlink" title="07.23 周二 晴（肌电图&#x3D;⚡️+🪡&#x3D;麻痛）"></a>07.23 周二 晴（肌电图&#x3D;⚡️+🪡&#x3D;麻痛）</h2><p>早上8:54就到上财地铁站了。等我经过一番倒腾，到0号医技楼的时候已经9:47了，我早上到医院了才知道我是9:30的号。华山医院连个纸质预约单都没，数字化程度太高了，不利好我这种文盲了……<br>这一过号就害的我等了1个小时。</p><p>肌电图的形式感觉和针灸差不多，都是平躺在床上。<br>先是拿中学生物课上讲的，那种用来敲膝跳反射的小锤子，敲了敲我的四肢，有点吓人的是我的左手一开始咋都敲不出反射。<br>然后就是拿电极放在我的四肢上，各种电击。这又让我想起了生物课本上电击蛙肌肉神经的部分。只不过现在被电的是我了。电击还算是可以接受的，并且每次电击都会伴随不自主的肌肉抽动。<br>最后也是最难受的是针刺，拿针灸那种针在身上扎，然后需要绷紧被扎部位的肌肉，机器会发出可能是电流的响声。用力的时候还是很痛的。最后结束后发现被扎部位有几处还在流血，说明强度比针灸还是大不少的。</p><p>中午踩着饭点赶到公司，跟组里另外5人汇合干饭。</p><p>下午葛FS让我在TikTok-Rec-Core的飞书群里发一条新人串讲的会议链接。我把上一个人发的新人串讲的内容直接copy下来，改了改时间和串讲内容，就直接发了。没想到我多删了一个“是”字。<br>结果发出去的是这样的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">大家好，我内容冷启动的新人，将在本周五15点进行新人串讲，欢迎大家来听！<br></code></pre></td></tr></table></figure><p>大概一个小时之后我再回过头仔细看，才发现我少打了个“是”字。我读了下，我靠这人也太狂了吧！最骚的是还有群友点赞。哎反正鄙人也就是个实习生，一介草民，无所谓。</p><h2 id="07-24-周三-晴（被Python项目结构气晕）"><a href="#07-24-周三-晴（被Python项目结构气晕）" class="headerlink" title="07.24 周三 晴（被Python项目结构气晕）"></a>07.24 周三 晴（被Python项目结构气晕）</h2><p>我觉得是时候把qa-uplift-model整理一下了，具体来说就是把训练集、测试集的读取写成<code>.py</code>文件；把每个模型也写进一个单独的<code>.py</code>文件；绘制uplift曲线也得写成文件。<br>不然每次修改一下模型，改一下参数都得在好几个文件里同步。<br>然而我发现事情好像没那么简单……我意识到之前搞pyserini那些python项目的时候，都是先pip install，才能直接调用里面的文件+函数。可是我不想搞install，问通义问了半个多小时，也没整出来。</p><h2 id="07-25-周四-晴"><a href="#07-25-周四-晴" class="headerlink" title="07.25 周四 晴"></a>07.25 周四 晴</h2><h2 id="07-26-周五-晴转小雨（新人串讲）"><a href="#07-26-周五-晴转小雨（新人串讲）" class="headerlink" title="07.26 周五 晴转小雨（新人串讲）"></a>07.26 周五 晴转小雨（新人串讲）</h2><p>今天下午就要新人串讲了，搞得今早6点多开始来来回回醒了3次。</p><p>到公司之后我想到左边刚好有两个小包间，可以在那个地方模拟汇报一下。小包间的隔音效果还不错，有通风，有灯光还有电源🔌。要是中午能在这睡觉那该多好啊😋</p><p>16:00刚好汇报完成。有幸得到了葛FS和李BW两位mentor的高度评价：对于模型部分的掌握程度较好，讲的很详细。并且文档内容很新，包含了近期上线的策略。<br>我自己都觉得蚌埠住了。可能只有我自己清楚我在这上面花了多少时间……<br>我甚至连上线文档这种一手资料都没去点开看过几篇，全都是抄的James（算多手资料）的。<br>我自己都觉得过意不去，在汇报的最后，补充了Acknowledgement，表达了我对James和他文档的谢（歉）意。</p><p>串讲结束之后，我回到工位，以为串讲结束了就可以暂时解放了，没想到葛FS飞书问我去哪了。才想起原来还有跟葛FS的one2one。<br>葛FS交代了我的第一个任务：替换掉当前上线的多兴趣召回索引。就做了JSON文件比对。逻辑上完全听不懂他在说啥，反正一直说“嗯”“哦”“确实”就行了。</p><p>会议本该到17:00才结束，但是中途被李BW叫去有事。所以就提前10分钟。这次李BW居然是叫我到茶水间找他，那看来不是什么正式的事情。事实也确实不是工作上的事情，可是他和我说他08-08就要转base到圣何塞了，我也因此要换leader了。What can i say? 来着刚好一个月，换了4次工位，还要换一次leader……<br>不过李BW对我还是挺好的，特别是当时二面的时候，他没有特别刁难我，并且在我手撕算法题的时候夸我思路清晰，改变了他对”统计学专业学生“的刻板印象。最后他说：”我认为我把你招进来是一件很正确的决定“。泪目了。虽然我可能再过一两个月就想辞职了，但我还是会尽量配合葛FS安排的工作的。</p><p>晚上和孔LB一起到T4吃了棒约翰，咱俩互加了微信。</p><h2 id="07-27-周六-晴"><a href="#07-27-周六-晴" class="headerlink" title="07.27 周六 晴"></a>07.27 周六 晴</h2><p>晚上和杨M聊了聊，得知他也有走学术路线的意向。<br>他问我了不了解咱组的升学去向，我不是很了解，但也很想知道。据我所知好像就杨RJ学长申请了外面的phd。</p><h2 id="07-28-周日-晴"><a href="#07-28-周日-晴" class="headerlink" title="07.28 周日 晴"></a>07.28 周日 晴</h2><p>10:30正式开始调参，各种参数的组合，包括但不仅限于：学习率、隐藏层形状、交叉层层数、特征选择、特征预处理方法。</p><p>下午睡醒后，想着还漏了“特征预处理方法”。我从前天晚上加上log1p之后，一直都以为log1p会比raw要好，昨天上午和郑老师汇报说这是目前最大的发现。现在却发现</p><blockquote><p>2024-07-28 科研反思：</p><p>我认为自己的科研潜力没有被充分挖掘。</p><p>自己从2022年入坑以来，到现在为止到底看了多少篇论文，也只有自己清楚。每次基本都是郑老师让我汇报&#x2F;组会要讲，我才会去看。知识的输入基本都是被郑老师和学长灌输。<br>论文看的少，idea的游走和探索都只会局限在local optimum，并且还走了很多弯路，但凡SOTA了解接触的多了，很多方法实际上根本不需要花时间去试。<br>最难受的就是去年到今年年初做了几个月的Radius Filter，对于特征的处理完全就是noob，明显的分数偏布，也不会去想着用log1p这种规范化trick。预测的时候，也只是用MLP这种最最Naive的方法。<br>我认为我最大的优势在于缝合，把不同领域的东西融合起来。要发挥优势，必须了解更多领域，更多的工作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - 损失函数</title>
    <link href="/2024/07/22/%E7%AC%94%E8%AE%B0%20-%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <url>/2024/07/22/%E7%AC%94%E8%AE%B0%20-%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="NCE-损失"><a href="#NCE-损失" class="headerlink" title="NCE 损失"></a>NCE 损失</h2><p>NCE 损失（Noise Contrastive Estimation Loss）是一种用于训练语言模型的损失函数，主要用于处理大规模多类分类问题，诸如词嵌入和神经语言模型。</p><p>NCE 损失的主要优点是可以有效地处理类别数非常大（例如词汇表大小的词嵌入模型或语言模型）的分类问题。直接的 Softmax 分类需要计算所有可能输出的概率，这在类别数很大（例如语言模型中的词汇表）时计算成本会非常高。NCE：多类分类问题 &#x3D;&gt; 二元逻辑回归问题。</p><p>NCE 的工作原理是，对于一篇真实样本，随机抽取几个噪声样本，然后训练模型分辨真实样本和噪声样本的能力，这就把一个大规模多类分类问题转化为了一个二元分类问题。</p><p>理论上，当噪声样本的数量趋于无穷时，NCE 损失就会趋于正常的 Softmax 损失。但在实际应用中，噪声样本的数量通常远小于总类别数，而且可以有效地进行模型训练。常见的词嵌入模型 Word2Vec 中的Negative Sampling就是基于NCE损失。</p><h2 id="Focal-损失"><a href="#Focal-损失" class="headerlink" title="Focal 损失"></a>Focal 损失</h2><h2 id="Quantile-损失"><a href="#Quantile-损失" class="headerlink" title="Quantile 损失"></a>Quantile 损失</h2><p>回归损失函数，它最常用于预测中位数或其他分位数，覆盖范围可以从0至1。<br>Quantile Loss在预测值和实际值之间设定了非对称的罚分。<br>$$<br>L(y, f(x))&#x3D; Q * max(y - f(x), 0) + (1 - Q) * max(f(x) - y, 0)<br>$$</p><p>假设是你正在进行一项投资行为，你希望利用机器学习模型预测股票的价格，以便为你的投资决策提供依据。<br>如果模型预测的价格低于实际价格，你可能会因为低估了投资价值而错过了买入机会，但你实际上并未实际进行投资，所以你的真实损失相对较小。</p><p>然而，如果模型预测的价格高于实际价格，你可能会基于这个预测结果进行投资，然后发现实际的回报远远低于你的预期。<br>在这种情况下，你不仅错失了其他可能的投资机会，而且你已经投入的资金可能产生不如预期的回报，甚至可能会亏损。<br>因此，这种情况下的损失通常会被视为更大。</p><p>这就是为什么在某些情况下，我们可能希望模型的预测结果偏向更高的估值。通过在损失函数中使用Quantile Loss，可以使模型的预测结果具有更大的灵活性，更符合实际的业务需求和风险偏好。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 07.15-07.21</title>
    <link href="/2024/07/21/%E5%91%A8%E8%AE%B0%20-%202024%2007.15-07.21%EF%BC%88%E7%B2%89%E7%A2%8E%E4%BA%86LCJ3%E4%B8%AA%E6%9C%88%E5%8F%91%E6%96%87%E7%9A%84%E7%8B%82%E5%A6%84%E4%BC%81%E5%9B%BE%EF%BC%89/"/>
    <url>/2024/07/21/%E5%91%A8%E8%AE%B0%20-%202024%2007.15-07.21%EF%BC%88%E7%B2%89%E7%A2%8E%E4%BA%86LCJ3%E4%B8%AA%E6%9C%88%E5%8F%91%E6%96%87%E7%9A%84%E7%8B%82%E5%A6%84%E4%BC%81%E5%9B%BE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="07-15-周一-晴"><a href="#07-15-周一-晴" class="headerlink" title="07.15 周一 晴"></a>07.15 周一 晴</h2><p>昨晚比较晚才睡着，可能是想到今天一早又得上班就烦了。</p><p>早上起来又是满怀期待地开机，看看HNSW（M&#x3D;64）构建成功了没。结果肯定是不出意外地爆内存了。笑死，不知道多少次这样了：睡前挂进程，第二天一早爬起来看结果。哪次不是失败的，害……</p><p>208只有125GB内存，209～211也都是125GB。那只能想办法在100上构建了，于是我把raw_embedding传到100上，构建了3个小时左右，这才算把这个21Mx768维的HNSW弄出来。</p><p>9点35出宿舍，刚下楼想起没带Lightning的线，赶紧回去拿。一路走到财大门口，一辆小黄车都没，并且还发现Macbook的电源线又没带，这一路折腾到公司已经10点10分了。最近精神状态确实不是很好，科研和实习两边的压力确实得权衡一下了。</p><p>晚上下班回到宿舍，打开电脑，发现显示器不亮了。经过一番排查，鉴定为笔记本的HDMI接口坏了。这下好了，看番看VSCode的体验直线下滑。服了，屁事是真的多。看看后天去附近找找修电脑的店吧。明天还得准备跟葛FS开one2one……</p><p>考虑到这周就得把《算法导论》的期末论文给写完了，所以科研也得先放放了。</p><p>晚上把《secret base》上传到了网易云云盘，人声版的也好听啊。</p><h2 id="07-16-周二-晴（检索实验失败）"><a href="#07-16-周二-晴（检索实验失败）" class="headerlink" title="07.16 周二 晴（检索实验失败）"></a>07.16 周二 晴（检索实验失败）</h2><p>今天，我遭受了入坑Information-Retrieval以来的第二次失败，也是沉没成本最大的一次失败。虽然已经我早就料到不会这么顺利，毕竟5月初才正式入坑，但是一想到我这一个多月以来灌注的热血，很有可能因为今早的结果付之一炬，我就又不想干了。图个啥呢？我这些研究就算全发到CCF-A、CCF-B，真的就会对人类有贡献吗？或者退一步说，真的会有人引用吗？哎，失败总是贯穿人生的始终，想到我的处女座FSM虽然忝列VLDB的门墙，但也是属于那种充数的。我还能干啥呢？</p><p>总是要面对E2E的实验数据的，上周日我就大感不妙，给郑老师画的饼好像大过头了……<br>今天结果出来，发现的确如此。归根结底，是BM25检索太慢了，比我想象中慢太多了。再然后就是HNSW确实太快了，这也没办法，70+G的内存换来的极致性能。</p><p>晚上想到把HNSW换成IVFPQ试试，至少会比HNSW慢个几倍吧。如果还不行就开摆了。</p><h2 id="07-17-周三-晴"><a href="#07-17-周三-晴" class="headerlink" title="07.17 周三 晴"></a>07.17 周三 晴</h2><blockquote><p>发现有些emoji不会新建图片，好像是自带的。可以找个时间研究下这种通用的emoji，来丰富一下harbor。</p></blockquote><p>昨天下班忘记去北区驿站拿牛奶了，早上出门去拿。出门前发现校园卡不见了，这我很快就反应过来是昨晚洗澡忘记拔卡了……拿钥匙，又发现书包里钥匙🔑不见了。找遍了整个宿舍也没找到，不过很快就想起来昨天晚上在客厅的桌子上看到一串钥匙很像我的。一看确实是我的钥匙，已经有帕金森的迹象了……</p><p>早上开冷启动周会，这已经是我第三次参加了，可是我还是一头雾水。雾水就雾水吧，直接开摆。把meego对应页面打开，上面显示我在看就行。</p><p>最难蚌的是中午mentor李BW和我说我又得搬位置了，我真的服了。06-23入职以来，不到一个月时间，这<strong>已经是第4次搬位置了</strong>……</p><p>从这周一开始我感觉自己明显比之前累、困了很多。这几天还连续忘记事情，哎真的只想天天家里蹲。<br>晚上挂了07-19下午华山医院 营养-血液科。</p><h2 id="07-18-周四-晴"><a href="#07-18-周四-晴" class="headerlink" title="07.18 周四 晴"></a>07.18 周四 晴</h2><p>从我昨天下午搬过去新工位到我昨天下班，周围两排都没人。今天可算来人了，不知道的还以为字节的强度很低（笑</p><p>由于明天下午挂了华山医院的贫血号，今早8点半让李BW把明天下午的one2one改到今天下午了。</p><h2 id="07-19-周五-晴"><a href="#07-19-周五-晴" class="headerlink" title="07.19 周五 晴"></a>07.19 周五 晴</h2><p>早上到公司，到12楼一出电梯，就看到茶水间摆了3张长桌子。看到旁边还摆了一堆大箱子，桌子上有个二维码，原来是Tiktok Swag，周年礼包哇。问了问旁边的工作人员小姐姐实习生能不能领，我靠她直接翻了个白眼说不可以……</p><p>刚回工位我就问同为实习生的孔LB，他说5月份发了个调查问卷，填衣服的尺寸，我没填就应该领不了。<br>可实际上不久我就收到飞书消息，说可以“感谢您这一年的付出”，说我领Tiktok Swag礼包。中午直接去1208现场登记颜色尺寸把礼包给领了，羊毛+1！</p><p>早上在工位依旧是搞检索实验，用字节的GPT平台狂薅GPT4的羊毛。体验确实好，给我写Pytorch也是杠杠的。有GPT4的加持，今天就把 Deep Cross Network跑通了。<br>说到Pytorch，想到之前在知乎上刷到一条帖子<a href="https://www.zhihu.com/question/661322236/answer/3562764903">深度学习论文什么效果才能发论文?</a>。发CCFA连Pytorch都不需要会，直接全部丢给GPT就行，过于真实。</p><p>中午在工位上坐了一会就赶着去去华山医院了。医生问我有没有做血常规，感觉我应该做过吧、hub毕业体检 + fdu入学体检这不都抽了两次血了吗？但是也没收到反馈啊，fdu甚至连体检结果都查不到……<br>我和医生说我只做了微量元素和维生素，她就给我开了硫酸亚铁 + 叶酸 + 复合维生素。还算满意，希望吃了有用吧。</p><p>血常规确实还得做，打算9-10月份再来吧。按理来说铁缺20% + 叶酸缺33%大差不差会有点贫血。回去在地铁上刷xhs，好像刷到个说法，说这种入学体检、毕业体检主要看有没有传染病……</p><h2 id="07-20-周六-晴（实验接连失败-注册Google-Scholar）"><a href="#07-20-周六-晴（实验接连失败-注册Google-Scholar）" class="headerlink" title="07.20 周六 晴（实验接连失败&amp;注册Google Scholar）"></a>07.20 周六 晴（实验接连失败&amp;注册Google Scholar）</h2><p>今天一个上午都在修DCN。</p><p>下午到晚上一直都在调参，<strong>开启大炼丹时代！</strong></p><p>睡前更新：大抵是寄了。根本打不过query文本直接作为特征的BERT。<br>想想看确实啊，文本包含的信息量明显比分数特征高啊。时间序列，股票价格这种肯定比NLP效果差得多。<br>可以遗憾地宣布：<strong>Channing又要开始沉淀了！</strong></p><p><strong>这两次接连的实验失败，彻底粉碎了 LCJ 3个月零基础发检索顶会的狂妄企图</strong></p><p><strong>史称 07-20 QA-Uplift事变</strong></p><p>前5行还在说大炼丹时代，现在就粉碎狂妄企图了。着实令人难蚌，一周之内，一日之间，而気持不齐。</p><p>晚上由于宿舍停电，被迫去工位了。上次去工位得是2个月前了。这次实验室又没人，舒服了。<br>在工位上把22号DDL的《算法导论》期末论文写了写，然后就开始摸鱼了。<br>刷到彭P老师的google scholar，发现MPC那篇论文具有有3篇引用了。于是我赶紧注册了一个google scholar账号，相当于注册成为英雄协会会员了，只不过是C级最后顺位的英雄（悲）。<br>不管接下来走不走学术的路线，2024-07-20这一天可以载入史册了。</p><h2 id="07-21-周日-晴"><a href="#07-21-周日-晴" class="headerlink" title="07.21 周日 晴"></a>07.21 周日 晴</h2><p>早上又得向zwg交差，只能硬吹了。刘氏对比法，让他觉得我这个项目还能继续投资。<br>otherwise，我就又要掉进横向地狱了。</p><p>中午翻看浏览器，发现之前打开的一个知乎页面还没关<a href="https://zhuanlan.zhihu.com/p/683509519">CNN+Transformer:66.8%的二分类预测准确度</a>。<br>花了一个下午，用白嫖的gpt4把他复现了，并且和现在的实验框架接通了。效果甚至不如DCN……<br>主要训练成本还贼高，transformer encoder太耗显存了。双2080ti 数据并行，batch_size都只能开到2048。<br>这调参调起来是有多痛苦，我都不敢想。</p><p>晚上风扇持续性地哀嚎了，我真的是*了。</p><blockquote><p>本周的周度音乐是《secret base》<br>歌词太应景了，“<strong>10年后的8月</strong>”。马上就是十年前的“10年后的8月”了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - EMNLP2020 Dense Passage Retrieval for Open-Domain Question Answering</title>
    <link href="/2024/07/18/%E7%AC%94%E8%AE%B0%20-%20EMNLP2020%20Dense%20Passage%20Retrieval%20for%20Open-Domain%20Question%20Answering/"/>
    <url>/2024/07/18/%E7%AC%94%E8%AE%B0%20-%20EMNLP2020%20Dense%20Passage%20Retrieval%20for%20Open-Domain%20Question%20Answering/</url>
    
    <content type="html"><![CDATA[<p>原文链接：</p><ol><li><a href="https://arxiv.org/abs/2004.04906">arxiv</a></li><li><a href="https://aclanthology.org/2020.emnlp-main.550/">EMNLP</a><br>代码链接：<br>提出算法：DPR</li></ol><blockquote><p>陈丹琦力作，DR之父，万恶之源（bushi）。接下来很长一段时间都要靠它吃饭了🙏</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h3 id="3-2-Training"><a href="#3-2-Training" class="headerlink" title="3.2 Training"></a>3.2 Training</h3><p><strong>Positive and negative passages</strong></p><p>通常情况下正面的例子是明确可用的，而负面的例子需要从一个极大的池子中选择。例如，与问题相关的段落可能在QA数据集中给出，或者可以使用答案找到（can be found using the answer）。集合中的所有其他段落，虽然没有明确指定，但默认情况下可以视为不相关的。在实践中，如何选择负面例子经常被忽视，但可能对学习高质量的编码器至关重要。我们考虑三种不同类型的负面例子：<br>（1）随机：从语料库中选择任意随机段落；<br>（2）BM25：由BM25返回的顶部段落，它们不包含答案，但匹配问题的大多数tokens（match most question tokens）；<br>（3）Gold：与训练集中出现的其他问题配对的正面段落。<br>我们将在第5.2节讨论不同类型的负面例子和训练方案的影响。我们的最佳模型使用来自同一小批次的金牌段落和一个BM25负面段落。特别地，重复使用来自同一批次的金牌段落作为负面例子可以使计算效率高并实现出色的性能。我们在下面讨论这种方法。</p><p><strong>In-batch negatives</strong></p><p>假设我们有一个大小为B的小批量中的B个问题，每个问题都与一个相关的段落相关联。令Q和P为问题和段落嵌入的(B×d)矩阵，其中S &#x3D; QPT是一个(B×B)的相似度得分矩阵，其中每行对应于一个问题，与B个段落配对。通过这种方式，我们可以重复使用计算并在每个批次中有效地训练B2(qi，pj)个问题&#x2F;段落对。当i &#x3D; j时，任何(qi，pj)对都是正例，否则为负例。这在每个批次中创建了B个训练实例，其中每个问题有B-1个负段落。批内负例的技巧已经在全批次设置中使用（Yih等人，2011年），并且最近也用于小批量（Henderson等人，2017年；Gillick等人，2019年）。已经证明这是一种有效的策略，可以学习双编码器模型，从而提高训练示例的数量。</p><h3 id="4-2-Question-Answering-Datasets"><a href="#4-2-Question-Answering-Datasets" class="headerlink" title="4.2 Question Answering Datasets"></a>4.2 Question Answering Datasets</h3><p><strong>Selection of positive passages</strong></p><p>由于TREC、WebQuestions和TriviaQA6仅提供问题和答案对，因此我们使用包含答案的BM25排名最高的段落（the highest-ranked passage from BM25 that contains the answer）作为正面段落。如果前100个检索到的段落中没有答案，则该问题将被丢弃。对于SQuAD和NaturalQ，由于原始段落已经被分割并以不同于我们的候选段落池的方式进行处理，因此我们将每个黄金段落与候选池中相应的段落进行匹配和替换。当匹配失败时，由于不同的维基百科版本或预处理，我们将丢弃问题。表1显示了所有数据集的训练&#x2F;开发&#x2F;测试集中的问题数量以及用于训练检索器的实际问题。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - NIPS2022 EHI End-to-end Learning of Hierarchical Index for Efficient Dense Retrieval</title>
    <link href="/2024/07/18/%E7%AC%94%E8%AE%B0%20-%20NIPS2022%20ELIAS%20End-to-End%20Learning%20to%20Index%20and%20Search%20in%20Large%20Output%20Spaces/"/>
    <url>/2024/07/18/%E7%AC%94%E8%AE%B0%20-%20NIPS2022%20ELIAS%20End-to-End%20Learning%20to%20Index%20and%20Search%20in%20Large%20Output%20Spaces/</url>
    
    <content type="html"><![CDATA[<p>原文链接：</p><ol><li><a href="https://arxiv.org/abs/2310.08891">arxiv</a></li><li><a href="https://proceedings.neurips.cc/paper_files/paper/2022/hash/7d4f98f916494121aca3da02e36a4d18-Abstract-Conference.html">NIPS2022</a><br>代码链接：<a href="https://github.com/nilesh2797/ELIAS">ELIAS</a><br>提出算法：ELIAS</li></ol><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 阿里云算法岗笔试+面经</title>
    <link href="/2024/07/18/%E8%AE%B0%E5%BD%95%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E7%AE%97%E6%B3%95%E5%B2%97%E7%AC%94%E8%AF%95+%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/07/18/%E8%AE%B0%E5%BD%95%20-%20%E9%98%BF%E9%87%8C%E4%BA%91%E7%AE%97%E6%B3%95%E5%B2%97%E7%AC%94%E8%AF%95+%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一面（电话）04-01"><a href="#一面（电话）04-01" class="headerlink" title="一面（电话）04-01"></a>一面（电话）04-01</h2><p>网页上显示阿里云（阿里云智能下的日志存储部门），但是电话面试的时候说是通义实验室（代码生成相关落地业务）</p><p>面试官开始就说他不是专门研究新算法的，而是更加注重于落地、面向客户。</p><p>(1) 自我介绍</p><p>(2) 聊项目，问简历上的。 我在简历上只放出了已录用的论文，但是没有放机器学习、NLP相关的项目。<br>面试官问了我最熟悉的项目。我简要讲了讲已录用的论文项目，随后将重心转到没放简历的机器学习、NLP项目上。</p><p>(3) 根据项目问问题。我提到了向量数据库的IVF算法，以及如何用神经网络优化其性能。</p><p>项目中IVF算法用到了K-Means聚类，它为什么要用K-Means聚类，而不用DBSCAN聚类。他们的区别是什么？</p><blockquote><p>K-Means是划分类的聚类，DBSCAN是密度聚类。<br>K-Means需要指定聚类个数，而DBSCAN不需要。<br>K-Means对异常值敏感，而DBSCAN对异常值不敏感。<br>K-Means可以通过采样来加速，而DBSCAN无法加速。这对于1B级别的向量检索来说非常重要。</p></blockquote><p>除了简历上写的CPP、python之外，还会其他语言吗？</p><blockquote><p>简历上只放了我认为比较熟练的语言。我还用过JavaScript，是在《数据可视化》这门课上学的。</p></blockquote><p>有没有多人合作开发的经历？</p><blockquote><p>有，我们是通过github的private repository来合作开发的。</p></blockquote><p>git merge有多少种方法？</p><blockquote><p>不清楚。我是用vscode的可视化界面来merge的。</p></blockquote><p>简单介绍下MapReduce？</p><blockquote><p>我不是特别了解，但我还是说说我的认识。<br>MapReduce是一种分布式计算框架，用于处理大规模数据。它将数据分成多个部分，并使用多个节点来并行处理这些部分。<br>每台机器都会用map函数对数据进行处理，并将结果发送给reduce函数进行合并。</p></blockquote><p>如果某个函数有非常多的if else，应该用哪种设计模式来优化？</p><blockquote><p>我对设计模式没有了解。</p></blockquote><p>为什么python适合做数据处理，AI？</p><blockquote><p>python适合的语法天然适合做数据处理，比如列表的切片操作。<br>python开发较快，并且python不需要编译，能够快速验证结果。<br>python适合做AI，因为python有很多库，能够方便地实现各种算法。python的库管理系统pip非常方便，能够快速安装和升级库。比如<code>pip install transformers</code>。</p></blockquote><p>静态语言 动态语言都有哪些？区别？</p><blockquote><p>静态语言：C、C++、Java；动态语言：JavaScript和python<br>静态语言：编译时确定类型，比如声明变量需要显式地指定类型；动态语言：运行时确定类型。<br>静态语言能够在编译时发现一些错误，比如类型错误，能够减少低级错误的影响；动态语言在运行时才确定类型，因此可能会出现一些运行时错误。</p></blockquote><p>python带有返回值的函数？</p><blockquote><p>没有了解过。<br>（面试官补充）这是python在某个版本之后新增的功能。<br>是不是函数后面带箭头，注明返回值类型的？</p></blockquote><p>（面试官回答）是的。</p><p>有没有关注近期关于大模型、AIGC的新闻？</p><blockquote><p>有, 但是得你说一个，我可能会知道。</p></blockquote><p>（面试官说）比如devin、sora</p><blockquote><p>我知道sora，最近北大开源了sora的复现项目。我在github上也关注了。</p></blockquote><p>(4) 反问环节。</p><p>我的笔试成绩怎么样，我没有提前复习，所以笔试成绩可能比较差。</p><blockquote><p>这个不好意思透露，但是你的笔试成绩还不错</p></blockquote><p>实习工作内容是否跟NLP、ML相关？</p><p>你们这是暑期实习。但是我日常就可以实习。能否提前入职？</p><blockquote><p>可以提前入职，也欢迎提前入职。</p></blockquote><h2 id="二面（电话）04-18"><a href="#二面（电话）04-18" class="headerlink" title="二面（电话）04-18"></a>二面（电话）04-18</h2><p>(1) 自我介绍</p><p>(2) 聊项目，问RAG + AI4DB的项目。</p><p>(3) 问问题。</p><p>本科期间绩点排名还行，研究生期间呢？怎么没有展示？</p><blockquote><p>因为目前系统上没有空开排名。</p></blockquote><p>有没有参与过开源项目的开发？</p><blockquote><p>没有。但是我参加过组内闭源项目的协作开发。组里之前组队参加了NIPS的向量检索比赛，我通过git进行团队项目的开发。</p></blockquote><p>工程能力怎么样？</p><blockquote><p>我的工程技术栈集中在cpp。<br>我VLDB那篇是数据库相关的工作，要求高性能，因此我使用了CMake和Google的三件套进行开发。<br>我AI4DB的工作也是用cpp从零手搓了一个IVF-PQ的索引。</p></blockquote><p>有没有用过代码生成的工具？你觉得现有的工具存在什么问题？</p><blockquote><p>有。我经常使用codegeex。<br>我觉得有两个比较严重的问题：</p><ol><li>在上下文非常长的时候就没办法补全了。</li><li>在某些情况下回产生死循环。指从某处开始，一直循环某一语句。</li></ol></blockquote><p>(4) 反问</p><p>你们一周要到位几天？</p><blockquote><p>一般一周四天。</p></blockquote><h2 id="三面（视频）04-22"><a href="#三面（视频）04-22" class="headerlink" title="三面（视频）04-22"></a>三面（视频）04-22</h2><p>最紧张的时刻</p><p>大模型的应用？</p><p>职业规划？</p><p>base所在地是杭州，这一点很坑，官网投递时我投的岗位base地包含上海。</p><p>反问：周围同事的学历背景。<br>回答：普遍很优秀，有复交的同学。</p><h2 id="结果与后续"><a href="#结果与后续" class="headerlink" title="结果与后续"></a>结果与后续</h2><p>04-27（收到offer）：中午13:56来电，让我确认offer。问了我是哪里人，有无女朋友，还有关于base地的看法。<br>因为需要从广州&#x2F;上海transfer到杭州。我表示无所谓并且愿意接受offer。</p><p>04-28（发现我不是25届毕业生）：中午11:38来电。询问我真实的毕业年份，我意识到自己只在投递信息上改成25届，而简历上忘记修改。只好承认。对方表示暑期实习只招25届毕业生，故无法发放offer。</p><p>《阿里云25届暑期实习面试》全剧终</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求职</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux - Linux Cheatsheet</title>
    <link href="/2024/07/17/Linux%20-%20Linux%20cheatsheet/"/>
    <url>/2024/07/17/Linux%20-%20Linux%20cheatsheet/</url>
    
    <content type="html"><![CDATA[<h2 id="查看内存情况"><a href="#查看内存情况" class="headerlink" title="查看内存情况"></a>查看内存情况</h2><p>用<code>top</code>指令能看到kb形式的内存情况;</p><p>用<code>free -m</code>可以看到mb形式, <code>free -g</code>是gb形式</p><h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p><code>cat /proc/cpuinfo</code></p><h2 id="查看端口情况"><a href="#查看端口情况" class="headerlink" title="查看端口情况"></a>查看端口情况</h2><p><code>netstat -anp | grep -w 10208</code>: 查看port&#x3D;10208的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcp        0      0 0.0.0.0:10208           0.0.0.0:*               LISTEN      6602/docker-proxy   <br>tcp        0      0 10.28.5.208:34098       10.28.5.208:10208       ESTABLISHED 6874/ssh            <br>tcp        0      0 10.28.5.208:46100       10.28.5.208:10208       TIME_WAIT   -                   <br>tcp6       0      0 :::10208                :::*                    LISTEN      6609/docker-proxy<br></code></pre></td></tr></table></figure><p>可以发现pid&#x3D;6602, 6609等进程和port&#x3D;10208有关</p><h2 id="根据pid查看对应进程"><a href="#根据pid查看对应进程" class="headerlink" title="根据pid查看对应进程"></a>根据pid查看对应进程</h2><p><code>ps aux | grep 189034</code>: 查看pid&#x3D;189034 对应具体的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>root      189034 96.9 32.8 82106736 75961368 ?   Rsl  13:02 258:29 /root/miniconda3/envs/rag/bin/python -m ipykernel_launcher -f /tmp/tmprlj5afqh.json --HistoryManager.hist_file=:memory:<br>root      197169  0.0  0.0   3304   660 pts/9    S+   17:29   0:00 grep --color=auto 189034<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>USER</th><th>PID</th><th>%CPU</th><th>%MEM</th><th>VSZ</th><th>RSS</th><th>TTY</th><th>STAT</th><th>START</th><th>TIME</th><th>COMMAND</th></tr></thead><tbody><tr><td>root</td><td>189034</td><td>96.9</td><td>32.8</td><td>82106736</td><td>75961368</td><td>?</td><td>Rsl</td><td>13:02</td><td>258:29</td><td></td></tr></tbody></table><ul><li>USER：该进程的拥有者的用户名</li><li>PID：进程 ID</li><li>%CPU：该进程从启动开始消耗 cpu 时间的百分比</li><li>%MEM：该进程使用的物理内存的百分比</li><li>VSZ：该进程使用的虚拟内存大小，以KB为单位</li><li>RSS：该进程在物理内存中的大小，以KB为单位</li><li>TTY：该进程在哪个终端启动的，”?” 代表非终端启动</li><li>STAT：该进程的状态，比如：S (睡眠中) 、R (运行中) 、Z (变为僵尸进程)、s代表是会话的领导进程，l显示了多线程的进程</li><li>START：该进程启动的时间。258:29指258分钟29秒</li><li>TIME：该进程实际的CPU运行时间</li><li>COMMAND：启动该进程使用的命令行命令</li></ul><h2 id="查看占用内存最高的10个进程"><a href="#查看占用内存最高的10个进程" class="headerlink" title="查看占用内存最高的10个进程"></a>查看占用内存最高的10个进程</h2><p><code>ps aux --sort=-%mem | head -n10</code></p><h2 id="创建软链接-快捷方式"><a href="#创建软链接-快捷方式" class="headerlink" title="创建软链接(快捷方式)"></a>创建软链接(快捷方式)</h2><p>给&#x2F;var&#x2F;lib&#x2F;docker目录创建快捷方式&#x2F;dk</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /var/lib/docker /dk<br></code></pre></td></tr></table></figure><h2 id="连接主机后显示System-restart-required"><a href="#连接主机后显示System-restart-required" class="headerlink" title="连接主机后显示System restart required"></a>连接主机后显示System restart required</h2><p>此时应该重启系统，但是重启仍然报错：<code>Failed to activate service &#39;org.freedesktop.systemd1&#39;: timed out</code></p><p>此时可以使用强制重启：<code>reboot -f</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - ICLR2021 Approximate Nearest Neighbor Negative Contrastive Learning for Dense Text Retrieval</title>
    <link href="/2024/07/16/%E7%AC%94%E8%AE%B0%20-%20ICLR2021%20Approximate%20Nearest%20Neighbor%20Negative%20Contrastive%20Learning%20for%20Dense%20Text%20Retrieval/"/>
    <url>/2024/07/16/%E7%AC%94%E8%AE%B0%20-%20ICLR2021%20Approximate%20Nearest%20Neighbor%20Negative%20Contrastive%20Learning%20for%20Dense%20Text%20Retrieval/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://openreview.net/pdf?id=zeFrfgyZln">pdf</a><br>代码链接：<br>提出算法：ANCE</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在学习的密集表示空间中进行文本检索具有许多有趣的优点。然而，密集检索（DR）通常表现不如基于单词的稀疏检索。在本文中，我们首先从理论上证明了密集检索的瓶颈是在小批量训练中采样的无信息负样本的支配，这导致梯度范数减小、梯度方差增大和收敛缓慢。然后，我们提出了近似最近邻负对比学习（ANCE），它从整个语料库中全局选择难训练的负样本。我们的实验表明，ANCE 在网络搜索、问答和商业搜索引擎中的有效性，显示 ANCE 点积检索几乎与基于 BERT 的级联 IR 管道的准确性相匹配。我们还从经验上验证了我们的理论，即使用 ANCE 进行负采样更好地近似了正样本的重要性采样过程，并提高了学习收敛性。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>许多语言系统依赖于文本检索作为查找相关信息的第一步。例如，搜索排名（Nogueira＆Cho，2019），开放领域问答（OpenQA）（Chen等，2017）和事实验证（Thorne等，2018）都首先检索相关文档以进行后续的重新排名，机器阅读和推理模型。所有这些后期模型都享受深度学习技术的进步（Rajpurkar等，2016; Wang等，2019），而第一阶段的检索仍然主要依赖于匹配离散的词袋，例如BM25，这已成为许多系统的痛点（Nogueira＆Cho，2019; Luan等，2020; Zhao等，2020）。 </p><p>稠密检索（DR）旨在通过在通过神经网络学习的连续表示空间中进行匹配来克服稀疏检索瓶颈（Lee等，2019; Karpukhin等，2020; Luan等，2020）。它具有许多期望的属性：完全可学习的表示，易于与预训练集成以及来自近似最近邻居（ANN）搜索的效率支持（Johnson等，2017）。这些使得稠密检索具有根本性地克服稀疏检索的一些固有限制的有趣潜力，例如词汇不匹配（Croft等，2009）。 </p><p>稠密检索中的一个挑战是在学习表示空间时构建适当的负实例（Karpukhin等，2020）。与重新排名（Liu，2009）中的训练和测试负面文档都是来自先前检索阶段的无关文档不同，在第一阶段检索中，DR模型需要区分数百万或数十亿文档库中的所有无关文档。如图1所示，这些负面影响与稀疏模型检索到的负面影响非常不同。</p><p>最近的研究探索了各种构建稠密检索负训练实例的方法（Karpukhin等，2020），例如使用对比学习（Oord等，2018; He等，2020; 。 Chen等人（2020a）选择当前或最近的小批量中的难负样本。<br>然而，正如最近的研究所观察到的（Karpukhin等人，2020），虽然批内局部负样本在学习单词或视觉表示方面很有效，但在密集检索的表示学习中并不比稀疏检索的负样本显着更好。此外，密集检索模型的准确性通常低于BM25，特别是在文档上（Gao等人，2020b; Luan等人，2020）。</p><p>在本文中，我们首先从理论上分析了使用负采样的密集检索训练的收敛性。利用方差减少框架（Alain等人，2015；Katharopoulos＆Fleuret，2018），我们表明，在密集检索中常见的条件下，局部批次负样本会导致梯度范数减小，从而导致高随机梯度方差和缓慢的训练收敛 - 局部负采样是密集检索有效性的瓶颈。 </p><p>基于我们的分析，我们提出了近似最近邻负对比估计（ANCE），这是一种新的密集检索对比表示学习机制。与随机或批内局部负样本不同，ANCE使用正在优化的DR模型构建全局负样本来检索整个语料库。这从根本上对齐了训练中负样本的分布和测试中不相关文档的分离。从方差减少的角度来看，这些ANCE负样本提高了每个实例梯度范数的上限，减少了随机梯度估计的方差，并导致更快的学习收敛。 </p><p>我们使用异步更新的语料库表示的ANN索引实现了ANCE。类似于Guu等人（2020），我们维护一个Inferencer，该Inferencer使用最近优化的DR模型的最新检查点并行计算文档编码，并在完成后刷新用于负采样的ANN索引，以跟上模型训练。我们的实验证明了ANCE在三种文本检索场景中的优势：标准Web搜索（Craswell等人，2020），OpenQA（Rajpurkar等人，2016；Kwiatkowski等人，2019）以及商业搜索引擎的检索系统。我们还从经验上验证了我们的理论，即ANCE采样的负样本的梯度范数比局部负样本大得多，从而改善了密集检索模型的收敛性。1 。</p><h2 id="5-EXPERIMENTAL-METHODOLOGIES"><a href="#5-EXPERIMENTAL-METHODOLOGIES" class="headerlink" title="5 EXPERIMENTAL METHODOLOGIES"></a>5 EXPERIMENTAL METHODOLOGIES</h2><p>本节描述了我们的实验设置。更多细节可以在附录A.1和A.2中找到。 </p><p><strong>基准测试</strong>：网络搜索实验使用TREC 2019深度学习（DL）轨迹（Craswell等人，2020）。这是一个标准的自适应检索基准测试：给定来自Bing的网络查询，检索来自MS MARCO语料库（Bajaj等人，2016）的段落或文档。我们使用官方设置并专注于第一阶段检索，但也展示了在重新排名前100个BM25候选项时的结果。 </p><p>OpenQA实验使用自然问题（NQ）（Kwiatkowski等人，2019）和TriviaQA（TQA）（Joshi等人，2017），遵循Karpukhin等人（2020）的确切设置。指标是Coverage@20&#x2F;100，评估Top-20&#x2F;100检索到的段落是否包含答案。 </p><p>我们还评估了ANCE更好的检索是否能够传播到更好的答案准确性，通过在ANCE检索的基础上运行最先进的系统的读者。读者是NQ上的RAG-Token（Lewis等人，2020b）和TQA上的DPR Reader，使用它们建议的设置。<br>我们还研究了ANCE在商业搜索引擎的生产系统的第一阶段检索中的有效性。我们将生产质量的DR模型的训练更改为ANCE，并评估各种语料库大小，编码维度和精确&#x2F;近似搜索的离线收益。</p><p><strong>基线</strong>：在TREC DL中，我们包括相关类别中的最佳运行，并参考Craswell等人的基线分数（2020年）。我们使用相同的BERT-Siamese（Eqn. 2）实现各种DR基线，但使用不同的训练负构造：批量随机采样（Rand Neg），从BM25前100个中随机采样（BM25 Neg）（Lee等人，2019; Gao等人，2020b），以及BM25和随机负面的1:1组合（BM25 + Rand Neg）（Karpukhin等人，2020; Luan等人，2020）。我们还与对比学习&#x2F;噪声对比估计进行比较，该方法使用批次中最难的负面（NCE Neg）（Gutmann＆Hyvärinen，2010; Oord等人，2018; Chen等人，2020a）。在OpenQA中，我们与DPR，BM25及其组合进行比较（Karpukhin等人，2020）。</p><p><strong>实现细节</strong>：在TREC DL中，最近的研究发现MARCO段落训练标签更干净（Yan等，2019年），BM25负面可以帮助训练密集检索（Karpukhin等，2020年；Luan等，2020年）。因此，我们包括了一个“BM25热身”设置<code>（BM25 → *）</code>，其中DR模型首先使用MARCO官方BM25负面进行训练。ANCE也通过BM25负面进行热身。TREC DL中的所有DR模型都是从RoBERTa基础未大小写（Liu等，2019年）微调而来的。在OpenQA中，我们使用发布的DPR检查点（Karpukhin等，2020年）对ANCE进行热身。为了适应BERT-Siamese中的长文档，ANCE使用Dai＆Callan（2019b）的两个设置，即FirstP使用文档的前512个标记，MaxP将文档分成512个标记的段落（最多4个），并且段落级别的分数是最大池化的。最大池化操作在ANN中本地支持。ANN搜索使用Faiss IndexFlatIP Index（Johnson等，2017年）。我们在4个V100 32GB GPU上使用批量大小8和梯度累积步骤2。对于每个正面，我们从ANN前200个中均匀采样一个负面（加权采样和&#x2F;或从前100个中也很好）。我们使用一个32GB V100 GPU，Intel（R）Xeon（R）Platinum 8168 CPU和650GB RAM内存来测量ANCE效率。 在异步训练中，我们将相等数量的GPU分配给Trainer和Inferencer，通常每个都有四个或八个。 Trainer每5k或10k个训练批次生成一个模型检查点。 Inferencer加载最近的模型检查点并并行计算语料库的嵌入。一旦嵌入计算完成，就会构建一个新的ANN索引，并且Trainer会切换到该索引以进行负面构建。他们所有的通信都通过共享文件系统进行。在MS MARCO上，ANN负面索引大约每10K个训练步骤刷新一次。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - CIKM2021 Predicting Efficiency Effectiveness Trade-offs for  Dense vs. Sparse Retrieval Strategy Selection</title>
    <link href="/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20CIKM2021%20Predicting%20Efficiency%20Effectiveness%20Trade-offs%20for%20%20Dense%20vs.%20Sparse%20Retrieval%20Strategy%20Selection/"/>
    <url>/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20CIKM2021%20Predicting%20Efficiency%20Effectiveness%20Trade-offs%20for%20%20Dense%20vs.%20Sparse%20Retrieval%20Strategy%20Selection/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://arxiv.org/abs/2109.10739">arXiv:2109.10739</a><br>代码链接：<a href="https://github.com/Narabzad/Retrieval-Strategy-Selection">Retrieval-Strategy-Selection</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">@inproceedings&#123;DBLP:conf/cikm/ArabzadehYC21,<br>  author       = &#123;Negar Arabzadeh and<br>                  Xinyi Yan and<br>                  Charles L. A. Clarke&#125;,<br>  title        = &#123;Predicting Efficiency/Effectiveness Trade-offs for Dense vs. Sparse<br>                  Retrieval Strategy Selection&#125;,<br>  booktitle    = &#123;&#123;CIKM&#125;&#125;,<br>  pages        = &#123;2862--2866&#125;,<br>  publisher    = &#123;&#123;ACM&#125;&#125;,<br>  year         = &#123;2021&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在过去的几年里，上下文化预训练的Transformer模型，如BERT，在信息检索任务上通过在嵌入空间中微调查询和文档的密集低维上下文化表示，提供了实质性的改进。另一方面，传统的稀疏检索方法，如BM25，依赖于高维、稀疏、词袋式的查询表示来检索文档。尽管密集检索器在检索效果上与稀疏检索器相比有显著提升，但它们计算密集，需要大量的GPU资源，且密集检索器在时间和资源消耗上更为昂贵。此外，稀疏检索器已被证明能检索到相对于密集检索器的互补信息，这导致了混合检索器的提议。这些混合检索器利用低成本、基于精确匹配的稀疏检索器以及密集检索器来弥合查询与文档之间的语义差距。在这项工作中，我们通过提出一个分类器来选择适合的检索策略（即，稀疏、密集或混合）来解决稀疏与密集检索器的成本与效用之间的权衡问题，针对每个查询进行选择。对于可以通过稀疏检索器回答的查询，利用稀疏检索器可以减少调用GPU的次数。因此，虽然效用得以保持，查询延迟却减少了。尽管我们使用了更少的计算资源和时间，但我们仍然取得了改进的表现。我们的分类器可以根据查询本身选择稀疏或密集检索策略。我们在MS MARCO段落数据集上进行了实验，展示了纯稀疏、纯密集或混合检索策略之间效率&#x2F;效果权衡的改善范围，允许根据目标延迟和资源预算选择合适的策略。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>信息检索（IR）系统已被神经排名方法彻底改变。几年前，最先进的排名堆栈（ranking stack）会采用第一阶段的稀疏检索器，如BM25，它依赖于确切的词条匹配来检索初始的项目池，供后续阶段重新排序[10, 14, 22]。倒排索引使整个语料库能够被高效扫描，延迟极低。这种类型的第一阶段检索器自最早的商业和学术系统以来一直是IR的标准配置。</p><p>最近的进展提供了一种基于经典倒排索引的第一阶段检索器的替代方案。上下文预训练的转换器模型，例如BERT [2]，使得一种新型的第一阶段检索器能够将查询和文档映射到低维密集向量，并利用最大内积搜索方法来查找与查询向量最相似的文档向量[4、11、24、26]。虽然这些检索器与传统方法相比具有显着的检索效果改进，但它们仍然存在缺点，包括增加的GPU资源和潜在的更高延迟。虽然这些密集检索器在检索效果上平均优于传统的稀疏检索器，但仍然存在查询，稀疏检索器提供更优秀的性能。没有一种单一的检索方法可以有效和高效地回答所有查询，选择合适的检索策略是维护系统效率和效果之间的平衡的关键问题。传统的初始检索器，例如BM25 [10]，在信息检索中有着悠久的历史。在现代排名堆栈中，BM25通常与WAND查询处理策略配对，以最大化第一阶段检索的效率[1]。这些第一阶段排名器可以称为“稀疏检索器”，因为它们主要利用稀疏的高维度词袋表示。 在给定查询时，检索器使用评分函数对文档进行排序。由于稀疏检索器通过查询和文档术语之间的精确匹配进行操作，因此当查询和语料库语言之间存在语义差距时，它们不足以解决词汇不匹配问题。然而，它们非常具有成本效益并且易于扩展，即使在廉价硬件上也是如此。大多数第一阶段稀疏检索器的更稀疏排名方法通常使用BM25作为多级排名堆栈的第一阶段[5、6、18 20]。排名阶段的后续阶段使用更高成本的基于神经网络的重新排名器来重新排名初始低成本的稀疏检索器检索到的文档。虽然这种初始稀疏检索步骤与多个重新排名步骤的组合已经表现出优异的性能，但通过用密集检索器替换初始检索步骤可以进一步提高性能。这些密集检索器使用上下文化的预训练变压器模型将查询和文档映射到嵌入空间[4、11、12、24、26]。在这个密集的低维嵌入空间中，查询和文档之间的关联（例如点积）提供了相关性得分。通过用密集检索器替换稀疏检索器所做的改进已经在许多核心检索任务和排行榜上得到了证明，例如MS MARCO。MS MARCO是一个大规模的集合，重点是为信息检索的深度学习方法提供应用。提供相对较大的训练数据使MS MARCO成为比较SOTA检索方法的合适测试平台。</p><p>在撰写本文时，MS MARCO段落检索排行榜上的最高得分者是RocketQA [3]，它是一种密集检索器，使用双编码器（dual encoder）和交叉编码器（cross encoder）架构来学习查询和段落的密集表示。同样，文档检索排行榜上表现最好的模型是ANCE [24]，它是一种学习机制，可以在孪生神经网络（siamese network）中学习查询和文档表示，并使用点积来排名文档。文档可以离线编码以节省时间，而查找与查询最相似的文档是密集检索器（Dense Retriever）中一个耗时的阶段，应该在查询到达时即时完成。最近，最近邻搜索算法（如FAISS）支持这些密集检索器，在毫秒级别内扫描数百万个候选项[9]。但即使使用最有效的最近邻算法，密集检索器的延迟仍可能无法与稀疏检索器相比（本人的试验结果可不是这样的<code>(^_^;)</code>）。<br>此外，需要大量GPU资源使得密集检索器运行成本高昂，并可能限制它们在高容量、实际应用中的使用，资源限制始终是一个关键问题。因此，相对于稀疏检索器，密集检索器可能会产生更高的成本和影响延迟。此外，密集检索器无法产生token-level的匹配信号，这对于需要精确匹配的命名实体和其他术语可能是至关重要的。一些研究人员提出了“混合检索器”，将稀疏和密集检索器结合起来，希望获得两种方法的一些优势。一些最近的方法在训练过程中利用稀疏检索器的词汇信息。例如，Gao等人[4]通过语义级信息训练密集检索器来补充稀疏检索器。其他研究人员通过插值（interpolating，但是我觉得Reciprocal Rank Fusion好些）来组合稀疏和密集检索器的排名[4, 13, 15, 16]。然而，据我们所知，目前还没有针对个别查询选择适当检索策略的工作。</p><p>在本文中，我们研究了基于查询选择第一阶段检索策略的策略。选择适当的策略提供了效率和效果之间的权衡。我们从三种可能的策略中选择：1）仅稀疏，2）仅密集，和3）混合，其中稀疏和密集检索器都在运行，并将它们的结果合并成一个单一的池进行重新排序。通过在每个查询基础上选择适当的策略，我们可以利用稀疏和密集检索器的优点。对于某些查询，使用密集检索器可能避免词汇不匹配问题。对于其他查询，使用稀疏检索器可能提供必要的精确术语匹配。对于某些查询，两者都可能是理想的。当一个查询可以用更低成本、更低延迟的稀疏检索器单独回答时，通过避免使用密集检索方法可以降低成本。我们利用上下文预训练嵌入查询的表示来训练交叉编码器架构中的分类器，目的是选择可以最好回答查询的检索器。此外，我们在MS MARCO段落集上进行实验，训练两个分类器，即在每个查询基础上选择“稀疏 vs. 密集”或“稀疏 vs. 混合”。我们的实验提供了一个设置，可以根据查询延迟和资源限制选择最佳的检索策略。</p><h2 id="2-METHOD"><a href="#2-METHOD" class="headerlink" title="2 METHOD"></a>2 METHOD</h2><p>在选择检索策略时，我们旨在利用稀疏检索器的效率和简洁性，尽可能地优先选择它，而不是密集检索器。然而，如果我们的分类器预测稀疏检索器在查询𝑞上的表现相对较差，我们会更倾向于利用更强大和资源密集的密集检索策略。对于某些查询，我们还考虑采用混合方法，通过运行两个检索器并将稀疏和密集检索器检索到的项目池合并为单个池进行重新排序。在这种混合策略下，我们始终运行稀疏检索器，然后根据结果决定是否运行密集检索器。我们研究了这种检索策略选择过程对MS MARCO段落集合[17]的影响。该集合包括880万个段落，配有超过500k个查询和判断相关段落的对于训练目的。对于每个查询𝑞，都有一组相关的判断段落𝑅𝑞，其中对于超过90％的查询|𝑅𝑞|&#x3D;1，即每个查询都有一个判断相关段落。此外，还有6980个开发和验证查询（“MS MARCO开发集”）。最后，还有一个私有相关性判断的测试集，我们无法获得。在我们的实验中，我们使用许多顶级重新排序堆栈[7、8、19]中广泛使用的BM25作为我们的稀疏检索器，该算法由滑铁卢大学的开源Anserini系统[25]实现，提供了最先进的稀疏检索器性能。作为我们的密集检索器，我们采用了ANCE，它是目前从效率和效果两方面来看都是最先进的第一阶段密集检索器。ANCE已经显示比其他密集检索器快100倍以上[24]。此外，我们还用其他代表性的DR重复了我们的实验，例如RepBERT [26]和ColBERT [12]。对于我们的混合型检索器，我们简单地通过稀疏（BM25）和密集（ANCE）两种方式检索文档，并将它们合并成一个池。接下来，我们将讨论如何训练我们提出的分类器，以在每个查询基础上决定“稀疏 vs. 密集”或“稀疏 vs. 混合”作为检索策略。</p><h2 id="3-EXPERIMENTS"><a href="#3-EXPERIMENTS" class="headerlink" title="3 EXPERIMENTS"></a>3 EXPERIMENTS</h2><h3 id="3-1-Experimental-Setup"><a href="#3-1-Experimental-Setup" class="headerlink" title="3.1 Experimental Setup"></a>3.1 Experimental Setup</h3><p>为了训练分类器，我们遵循第2.1和2.2节中描述的标注方案。我们为训练集中的查询分配标签。对于稀疏与密集分类器，我们使用批量大小为8的BERT基础模型进行1个时期的微调。在RTX 2080 GPU上训练不到1小时。对于稀疏与混合分类器，我们使用相同的预训练模型，使用稀疏检索器检索的查询和顶部文档进行微调。我们输入查询，后跟分隔符令牌、第一个检索到的文档和分配的类别，使用相同的实验设置微调BERT基础模型。我们代码公开在 <a href="https://github.com/Narabzad/Retrieval-Strategy-Selection">https://github.com/Narabzad/Retrieval-Strategy-Selection</a> </p><h3 id="3-2-Results-and-Findings"><a href="#3-2-Results-and-Findings" class="headerlink" title="3.2 Results and Findings"></a>3.2 Results and Findings</h3><p>如图1所示，分类器产生每个类别的查询概率。为了指定策略，我们选择0.0到1.0之间的阈值。通过选择不同的阈值，我们可以在稀疏策略的效率和资源节约以及密集和混合策略的改进效果之间进行权衡。为了衡量效果，我们报告召回率@1000，但在其他召回水平上的整体结果类似。我们使用召回率，因为第一阶段检索的输出将被额外的阶段重新排序。第一阶段的目标是构建包含相关段落的池，而后续阶段的目标是将这些相关段落置于排名的顶部。 图2显示了稀疏与密集检索器之间的权衡。随着阈值从0.0到1.0的变化，越来越多的查询选择密集检索策略。x轴显示了在MS MARCO开发集的所有6980个查询中分配密集检索器的查询分数。我们可以将此分数视为分配给密集检索策略的“预算”，我们将其分配以提高效果。对于预算为0的情况，始终使用稀疏检索器。对于预算为1的情况，始终使用另一种（密集或混合）检索器。在左下角，两个蓝色曲线相交的地方，密集检索器预算为0，这意味着所有查询都使用了稀疏检索器。在右上角的蓝色点处，蓝色曲线再次相交，显示了密集检索器预算为1时的性能，这意味着所有查询都使用了密集检索器。作为基线，我们随机分配检索器，其速率由预算给出，如虚线所示。两个分类器都显著优于此基线。例如，在密集检索器预算为0.5时，当50％的查询（3490个查询）使用密集检索器时，其余的查询使用其他检索器。 这些查询（3490个查询）使用了稀疏检索器（蓝线），随机检索策略选择器获得了0.91的召回率，而我们的分类器获得了0.95的召回率，召回率提高了0.04。</p><p>第二个分类器，稀疏与混合，的表现如图2所示，用实心粉色线表示。左下角的点显示了在使用稀疏检索器执行所有6980个MS MARCO开发集中的查询时的性能，而右上角的粉色点则说明了在使用混合检索器（即稀疏和密集检索器）执行所有查询时的性能。我们还展示了将一部分查询随机分配给混合检索器的性能，用虚线粉色线表示。例如，在混合预算为50％的情况下，我们只能使用混合策略执行50％的查询时，随机基线获得了0.91的召回率，而我们的分类器获得了0.96的召回率，召回率提高了0.05以上。在这个50％的水平上，稀疏与混合策略的召回率超过了100％水平的密集检索策略，同时仅使用密集检索器处理一半的查询。图2还说明了完整的密集策略和完整的混合策略之间的差距。为了达到0.98的召回率@1000，必须使用两个检索器。虽然密集检索器优于传统的稀疏检索，但它仍然会错过稀疏检索器发现的相关段落。虽然BM25已经被证明是最先进的稀疏检索方法，但我们可以使用其他密集检索器作为密集检索器。为了测试我们结果的鲁棒性，我们使用其他最先进的密集检索器Repbert（基于表示的密集检索器）[26]和Colbert（基于后期交互的密集检索器）[12]重复实验。图3显示了我们使用这三个密集检索器的稀疏与密集检索策略的结果。如图所示，密集检索器的类型不会影响我们的结论，我们的检索策略对密集检索器的类型具有鲁棒性。最后，我们考虑使用我们的检索策略的效果。 在端到端检索框架中的选择器。在Lin等人的[15]中，将BM25作为稀疏检索器和ANCE作为密集检索器在MS MARCO段落集合上报告查询延迟时间为55ms和103ms。当我们将预算从0％到100％转移到密集检索时，我们的提议方法可以优先考虑需要使用密集检索器检索的查询。图4显示了随着预算变化而出现的延迟和效果之间的权衡。随着延迟和召回率的增加，Pareto前沿在检索策略之间转移。例如，稀疏与密集策略提供了召回率超过0.94且延迟低于80ms，而稀疏与混合策略提供了召回率超过0.96且延迟低于106ms。</p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4 Conclusion"></a>4 Conclusion</h2><p>密集型检索器与传统的稀疏型检索器（如BM25）相比，提供了显著的性能改进。然而，密集型检索器引入了性能和资源成本，这些成本与稀疏型检索器不相关，包括对大量GPU资源的需求。此外，密集型检索器仍可能错过稀疏型检索器发现的相关项目。考虑到效率与效果之间的权衡，我们提出了一种基于每个查询选择适当检索策略的方法，将密集型检索器分配给最有可能受益的查询。利用我们提出的检索策略选择，即使在计算资源或时间限制下，也可以实现改进的性能。利用先前报告的性能特征，我们说明了策略之间的权衡，首选策略取决于延迟。其他性能特征将产生不同的权衡。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
      <tag>Information-Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - CIKM2023 Neural Disentanglement of Query Difficulty and Semantics</title>
    <link href="/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20CIKM2023%20Neural%20Disentanglement%20of%20Query%20Difficulty%20and%20Semantics/"/>
    <url>/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20CIKM2023%20Neural%20Disentanglement%20of%20Query%20Difficulty%20and%20Semantics/</url>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://doi.org/10.1145/3583780.3615189">https://doi.org/10.1145/3583780.3615189</a><br>代码链接：</p><p>Disentanglement：解耦</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>研究人员已经表明，查询的检索有效性不仅取决于查询的语义，还可能受到其他因素的影响。换句话说，几个表达相同意图甚至使用重叠关键词的查询可能会显示出完全不同的检索有效性程度。因此，在本文中我们的工作目标是提出一种神经解耦（Neural Disentanglement）方法，该方法能够将查询语义与查询难度解耦。解耦后的查询语义表示提供了确定查询之间语义关联的手段，而解耦后的查询难度表示则允许估计查询的有效性。我们通过在查询性能预测和查询相似度计算任务上的实验表明，我们提出的解耦方法相比于现有技术能够展现出更好的性能。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1 INTRODUCTION"></a>1 INTRODUCTION</h2><p>深度神经网络在信息检索的各种任务中得到了越来越多的应用，并且相较于传统的检索方法展现出了显著的性能提升 [5, 26, 28, 34, 37]。这主要是由于它们能够通过密集表示学习数据的潜在分布。例如，在临时检索(ad hoc retrieval)的背景下，密集神经排序器学习到的表示能有效地将查询空间与文档空间连接起来，从而促进对输入查询相关文档的检索 [21, 35, 41]。研究者们已经证明，学习得到的表示编码了一系列的信息，只要最终表示对当前任务有效，这些信息并不会被区分对待 [12, 45]。在很多情况下，并不清楚表示中的每个子部分代表什么含义，以及它们是否独立携带了语义。正如早期的工作所示，查询和文档的表示很可能混合了不同的属性，如风格、内容语义、时态等，而没有将它们区分开来 [19, 20, 43]。</p><p>现有的研究探索了如何将神经表示中交织在一起的属性分离的方法。这一过程被称为解耦(disentanglement)，并且已经在诸如可控文本生成 [18] 和风格迁移 [46] 等领域找到了应用。神经解耦的过程对于临时检索的任务来说似乎特别相关，尤其是在如何使用查询的神经表示方面 [17, 25, 30]。已有多个研究表明，相似的查询即使携带相似的语义，甚至有时使用了重叠的术语，但由于不同的顺序或语气，可能会导致完全不同的检索结果，因此它们的检索效果也大相径庭。例如，Matches Made in Heaven (MMH) 数据集表明，在MS MARCO段落检索数据集的50万查询中，有超过18万的查询，其中查询的小幅变化可以使大量查询的检索效果从平均精确率为0.139降至1 [1]。虽然查询和文档的语义是检索过程中的关键因素，但查询的有效性还取决于决定检索方法满足查询难度的其他因素。本研究的动机源自于MMH数据集中至少18万条查询的证据，这些查询的语义相似，但它们的检索有效性却有着显著的差异。我们感兴趣的是将查询表示分解为两个独立的表示：一个捕获查询语义，另一个可能捕获查询难度。理想情况下，一旦查询表示被解耦，相似查询的解耦表示中的语义成分应该也是相似的。<br>此外，人们期望解耦表示中的难度成分能够让我们区分出哪些查询对于检索方法来说更难以满足，无论比较的查询是否具有相似的语义。这种提出的查询解耦方法的好处在于，它使我们能够在检索之前执行预检索查询性能预测（QPP）任务，即在实际检索之前确定查询的检索有效性。大多数QPP方法 [2, 3, 6–8, 11, 14, 22, 23, 31, 36, 38] 要么依赖于查询词与文档语料库之间的统计关系，要么依赖于神经嵌入模型产生的几何空间中查询词之间的关系。然而，在我们的工作中，我们通过解耦过程产生了一个明确的查询难度表示，可以直接用于执行QPP。</p><p>通过对四个广泛使用的数据集进行实验，包括MS MARCO开发集、TREC DL 2019、TREC DL 2020以及TREC DL-Hard，并基于三种评估指标——Kendall和Spearman相关系数以及缩放后的平均绝对排名误差（sMARE）指标 [13]，我们证明了所提出的解耦方法能够有效地独立捕获查询难度。此外，为了证明所提出的方法也能独立隔离查询语义，我们评估了解耦表示在计算由Nogueira和Lin [33]发布的语义相似查询对之间的关联方面的表现。我们展示了内容的解耦表示在捕捉查询语义方面比各种最先进的大型语言模型更有效。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - VSCode &amp; Jupyter实验踩坑记录</title>
    <link href="/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20VSCode%20&amp;%20Jupyter%20&amp;%20%E7%82%BC%E4%B8%B9%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/07/15/%E7%AC%94%E8%AE%B0%20-%20VSCode%20&amp;%20Jupyter%20&amp;%20%E7%82%BC%E4%B8%B9%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="Jupyter的环境变量设置"><a href="#Jupyter的环境变量设置" class="headerlink" title="Jupyter的环境变量设置"></a>Jupyter的环境变量设置</h3><p>要在pyserini这个虚拟环境中设置环境变量，要在<code>~/miniconda3/envs/pyserini/etc/conda/activate.d</code>中创建一个<code>add_path.sh</code>文件。<br>在里面加入例如如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PYTHONPATH=&quot;$PYTHONPATH:/dk/lcj_rag/&quot;<br>export PYTHONPATH=&quot;$PYTHONPATH:/dk/lcj_rag/Retriever-Feedback-QA&quot;<br>export PYSERINI_CACHE=/dk/rag-dataset/<br>echo $PYTHONPATH<br></code></pre></td></tr></table></figure><h2 id="VScode上Jupyter插件无法安装"><a href="#VScode上Jupyter插件无法安装" class="headerlink" title="VScode上Jupyter插件无法安装"></a>VScode上Jupyter插件无法安装</h2><p>VSCode输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2024-07-29 14:04:09.143 [error] Error: Unable to read file &#x27;/root/.vscode-server/extensions/ms-toolsai.jupyter-2024.5.0-linux-x64/package.json&#x27; (Error: Unable to resolve nonexistent file &#x27;/root/.vscode-server/extensions/ms-toolsai.jupyter-2024.5.0-linux-x64/package.json&#x27;)<br></code></pre></td></tr></table></figure><p>只需要把<code>/root/.vscode-server/extensions/ms-toolsai.jupyter-2024.5.0-linux-x64/</code>这个文件夹删了，重新在服务器安装Jupyter插件就OK了。</p><h2 id="Error-while-fetching-extensions-XHR-failed"><a href="#Error-while-fetching-extensions-XHR-failed" class="headerlink" title="Error while fetching extensions : XHR failed"></a>Error while fetching extensions : XHR failed</h2><p>VSCode安装插件时，显示XHR failed。</p><p><code>ping update.code.visualstudio.com</code><br>此时大概率无法ping通。</p><p>找到<code>host文件</code><br>Win：<code>C:\Windows\System32\drivers\etc\hosts</code><br>Mac&#x2F;Linux（sudo）：<code>/etc/hosts</code></p><p>追加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">VSCode</span><br>20.43.132.130  update.code.visualstudio.com   # Visual Studio Code download and update server<br>13.69.68.34  code.visualstudio.com   # Visual Studio Code documentation<br>104.119.90.120  go.microsoft.com    #  Microsoft link forwarding service<br>20.150.83.4  vscode.blob.core.windows.net    # Visual Studio Code blob storage, used for remote server<br>13.107.42.18 marketplace.visualstudio.com    # Visual Studio Marketplace<br>191.238.172.191 *.gallery.vsassets.io    # Visual Studio Marketplace<br>191.238.172.191 *.gallerycdn.vsassets.io     # Visual Studio Marketplace<br>40.70.164.17 rink.hockeyapp.net      # Crash reporting service<br>13.75.34.168 bingsettingssearch.trafficmanager.net   # In-product settings search<br>138.91.148.66 vscode.search.windows.net    # In-product settings search<br>raw.githubusercontent.com       # GitHub repository raw file access<br>50.17.211.206 vsmarketplacebadge.apphb.com    # Visual Studio Marketplace badge service<br>117.18.232.200 az764295.vo.msecnd.net    # Visual Studio Code download CDN<br>42.80.217.156 download.visualstudio.microsoft.com  # Visual Studio download server, provides dependencies for some VS Code extensions (C++, C#)<br>13.67.9.5 vscode-sync.trafficmanager.net     # Visual Studio Code Settings Sync service<br>13.69.68.64  vscode-sync-insiders.trafficmanager.net  # Visual Studio Code Settings Sync service (Insiders)<br>13.107.5.93 default.exp-tas.com     #  Visual Studio Code Experiment Service, used to provide experimental user experiences<br></code></pre></td></tr></table></figure><p>保存并使其生效：<br>Win：<code>ipconfig /flushdns</code><br>Mac：<code>sudo killall -HUP mDNSResponder</code> <code>sudo dscacheutil -flushcache</code></p><p>此时再次<code>ping update.code.visualstudio.com</code>，发现可以ping通。<br>再次安装插件，问题解决。</p><h2 id="更改Notebook文件名会kill掉进行的python进程"><a href="#更改Notebook文件名会kill掉进行的python进程" class="headerlink" title="更改Notebook文件名会kill掉进行的python进程"></a>更改Notebook文件名会kill掉进行的python进程</h2><p><code>wikihop_val_bm25.ipynb</code> &#x3D;&gt; <code>wikihop_val_100r_bm25.ipynb</code>会造成在跑的<code>wikihop_val_bm25.ipynb</code>实验被kill。</p><h2 id="VSCode服务器上使用Jupyter显示请选择内核源"><a href="#VSCode服务器上使用Jupyter显示请选择内核源" class="headerlink" title="VSCode服务器上使用Jupyter显示请选择内核源"></a>VSCode服务器上使用Jupyter显示请选择内核源</h2><p>请在VSCode的扩展栏中检查Jupyter插件，出现这个问题，此时Jupyter的图标大概率已经变灰了。可以通过更新版本 or 切换回预览版解决。</p><h2 id="nohup-jupyter-execute实现挂机"><a href="#nohup-jupyter-execute实现挂机" class="headerlink" title="nohup + jupyter-execute实现挂机"></a>nohup + jupyter-execute实现挂机</h2><p>在screen的session里面，conda activate进到虚拟环境，然后执行<code>nohup jupyter-execute a.ipynb &gt; a.log &amp;</code>就可以了。<br>你说得对但是<code>jupyter-execute command not found</code>。<code>apt install jupyter-execute</code>说找不到这个东西。<br>应该先conda activate 到一个虚拟环境，然后再<code>pip install jupyter</code></p><h2 id="Pytorch-Assertion-input-val-zero-input-val"><a href="#Pytorch-Assertion-input-val-zero-input-val" class="headerlink" title="[Pytorch] Assertion input_val &gt;= zero &amp;&amp; input_val &lt;= one failed."></a>[Pytorch] Assertion <code>input_val &gt;= zero &amp;&amp; input_val &lt;= one</code> failed.</h2><p>这个错误信息来源于PyTorch的CUDA后端，通常发生在使用某些损失函数（如二元交叉熵损失，<code>BCELoss</code> 或者 <code>BCEWithLogitsLoss</code>）时。错误信息中的断言 <code>input_val &gt;= zero &amp;&amp; input_val &lt;= one</code> 表明模型的输出（通常是最后一层的激活函数的输出）中有值超出了0到1的范围。</p><p>在使用二元交叉熵损失时，模型的输出通常需要被视为概率，因此它们应该被限制在0和1之间。<br>这意味着最后一层的激活函数通常应该是sigmoid函数（对于二分类问题）或softmax函数（对于多分类问题），以确保输出满足这个条件。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 07.08-07.14</title>
    <link href="/2024/07/14/%E5%91%A8%E8%AE%B0%20-%202024%2007.08-07.14/"/>
    <url>/2024/07/14/%E5%91%A8%E8%AE%B0%20-%202024%2007.08-07.14/</url>
    
    <content type="html"><![CDATA[<h2 id="07-08-周一-晴"><a href="#07-08-周一-晴" class="headerlink" title="07.08 周一 晴"></a>07.08 周一 晴</h2><p>今天中午休息的时候，右边的空位上来了个人。原来我右边的位置没人坐，早知道我就坐过去了。希望她是来这边出差的吧。等她走了我就坐过去，这样就不用往右边打嗝尴尬了……</p><p>下午吃饭前，赶着把SearchQA-val的结果跑出来了，</p><p>晚上7点多跑实验的时候，貌似没注意内存，把208跑崩了。<br>等到20:57，终于能重连上了。我刚启动进程，<code>free -g</code>看到内存占用是100%。<br>可是我从htop上看了看，没有看到内存占用高的内存啊。<br>高度怀疑又中了挖矿病毒……</p><p>求求各位大哥们放过吧，208一没显卡，二少cpu cores，三缺内存。现在光是跟实验室的同学争计算资源都天天爆内存（悲。<br>现在真的有种创业之初的感觉，用着破旧的设备，整出顶会的工作。respect！</p><p>从昨天开始就感觉手臂麻麻的。<br>尤其是昨天中午晚上躺在床上的时候，现在也感觉左手比较麻，但是又没有麻痹的那种感觉。<br>希望只是睡觉侧着睡压到手臂了。</p><h2 id="07-09-周二-晴"><a href="#07-09-周二-晴" class="headerlink" title="07.09 周二 晴"></a>07.09 周二 晴</h2><p>昨晚做了个噩梦。梦见世界末日了，不知道啥原因地球会在8月23号这天被无尽的巨浪吞噬。<br>梦里刚好是只剩几天就到末日了。<br>那会还在学校暑假上课，很难蚌得住。我得知这个消息就马上跑路了。<br>后面不知道咋回事，到了一个没有水的地方，好像也活下来了。</p><p>夏促12号就结束了，今天打算就先买一部分。晚上回宿舍尝试着用B站上的方法折上折买冰原DLC：先原价买20周年包里除了冰原之外，且我还缺少的游戏A。然后再买20周年纪念包。最后再把A退掉，最后冰原到手价45.42。鉴定为《古希腊掌管steam的神》。虽然但是，这也不能怪我吧，当时我入怪猎世界光是本体就123块了，现在本体+冰原总共才不到100（气</p><h2 id="07-10-周三-阴-雨"><a href="#07-10-周三-阴-雨" class="headerlink" title="07.10 周三 阴-雨"></a>07.10 周三 阴-雨</h2><p>早上出门的时候就感觉天阴沉沉的，不过好在骑车的时候没有下雨。</p><p>下午葛FS和架构那边的苏HT、张JZ拉了一个冷启预估的会，把我也叫上了。4个人在小小的12F-6会议室挤着，我全程都在干着自己的科研，他们那些听不懂一点。不是很懂为啥把文档都还没看完的我叫上……</p><p>经过三天的努力看文档（摸鱼），总算是对粗排精排有些许理解了。下午我在跟葛FS one2one的会上，讲了讲大致的理解。他纠正了一些，顺便讲了讲冷启动的一些业务逻辑。他的文档写的也挺不错的，打算接下来也看看他的，把LTR之类的补上。</p><p>下午看精排的时候留意了下，发现他有一个叫做MMCN（multi-head multi-layer cross network），是用来做特征交叉的。不知道他跟DCN-m这些比起来孰强孰弱，但是看起来bytedance内部已经有很多个项目都用上，并且涨点了。<br>我在网上搜了搜，却又没找到发表的论文。看起来应该是内部技术了。虽然但是，他这种特征交叉的方法如果用在我的uplift检索上，应该会算侵权吧。</p><p>下午就启动了AdversarialQA-train 的进程。但是却一直被kill。最后一次成功启动已经是快6点了。要等他跑完才能开始BM25和DPR的两个get_cache，可是等跑完得到晚上12点半之后了。<br>所以我研究了下，可以用at 指令来定时执行进程。跑了个<code>echo &quot;test at&quot; &gt; test | at now</code> 看起来没毛病。希望它会在12点半执行吧。</p><h2 id="07-11-周四-雨"><a href="#07-11-周四-雨" class="headerlink" title="07.11 周四 雨"></a>07.11 周四 雨</h2><p>一早起来整个天都是阴沉沉的，大概率我骑车的时候又要栉风沐雨了……</p><p>八点钟打开电脑，第一件事就是看昨晚的两个<code>get_cache</code>的定时进程启动了没。一看发现没启动，蚌埠住了，整个晚上就浪费了。<br>舍友张YF昨晚两点多回到宿舍，早上9点钟就出发去实验室了。高情商：天才+勤奋，低情商：耐卷王。</p><p>中午下午都在看James陈的新人串讲文档，但是看不进一点。所以又摸鱼搞学校这边的事了。我把DROP数据集接上框架，并且接上预测了，结果比HotpotQA还要烂……</p><p>晚上想去steam上领夏促的贴纸，却发现贴纸和每天的卡片都领不了了，因为夏促今晚就截止了。<br>想起来极限竞速地平线4因为版权到期的原因，今年12月15号就要下架了。<br>这次夏促它新史低了，只不过不知道秋促和圣诞促销会不会再来一个新史低，或者直接干脆不打折了。<br>犹豫良久，最后还是忍痛入了终极版66.6。</p><p>10点半左右想挂个WikiHop-Val上的实验。理想情况是睡前跑完，然后再开个新的跑一整晚。<br>只是计划赶不上变化，跑了一会208又挂了……</p><h2 id="07-12-周五-雨"><a href="#07-12-周五-雨" class="headerlink" title="07.12 周五 雨"></a>07.12 周五 雨</h2><p>九点二十刚想出门去公司，发现雨下的比昨天还要大。<br>本来想批个雨衣顶把伞，找辆小黄车直接冲了。</p><p>晚餐alone。本来想吃昨天中午的鲜虾鱼籽馄饨，却发现菜谱换掉了，虽然但是，按理来说应该是一周一换的吧。点餐的时候遇到昨天下午一起开会的苏HT，就是那位操着广普口音的同学。跟他聊了几句得知他确实是广东的，是东莞人从中大毕业，而且<strong>会说粤语</strong>。终于在公司找到同样沪漂的同学了，泪目。</p><h2 id="07-13-周六-雨"><a href="#07-13-周六-雨" class="headerlink" title="07.13 周六 雨"></a>07.13 周六 雨</h2><p>本来想看看周六日去公司打卡算不算加班之类的，再不济当成普通的工天也行吧。可一看这雨，顿时就不想去了。</p><p>晚上听张YF说他实验室那位专硕的字节同学说字节是没有打卡的。虽然我mentor李BW同学也这么说，但每天坐电梯不都是要刷门禁吗？<br>不打卡不算工天也好，以后也不用考虑了。还好今天下雨，不然冤大头就又得白跑一趟，公司压抑的氛围太难顶了。</p><h2 id="07-14-周日-小雨"><a href="#07-14-周日-小雨" class="headerlink" title="07.14 周日 小雨"></a>07.14 周日 小雨</h2><p>早上又得去参加检索小组会，组会我把“60%的成本达到99.5%的纯rrf召回率”这句话说了出来。ZWG一听完马上就让我准备投稿了……我个人是想往检索领域上投，梦中情会自然是SIGIR啦。可是郑老师却说得等到2月份，太晚了，让我准备8月中旬的AAAI，还说投完稿就让我放假休息一会，说实话我是十分拒绝的。</p><p>实际上这个60%成本并不等价于60%的时间，我觉得时间其实不会改善太多，因为目前的DR用的还是暴力检索，到时候肯定是要换成图索引比如HNSW之类的。再加上目前推理成本，实际上的加速效果其实也不会有太多……<br><br>由于担心俺的uplift框架已经被人捷足先登了，所以下午又<strong>在ACM Library上找引用了CIKM2021的那些论文，发现确实没找到类似的工作</strong>。“我们安全了，暂时”。只是safe for now，因为arxiv上肯定还有很多工作，Information Retrieval可比之前做的图挖掘卷多了……</p><p>晚饭之后刷网易云音乐，无意间点开了自己的动态，那是自己2020-03-17发的：内容是湖大毕业MV，自己文字是“曲线救国”。回忆起4年前，那大概就属于《Channing豪杰物语》的《立志篇》吧（《Channing豪杰物语》的本科篇已经鸽了好久了，事情确实多，先做个milestone的图文记录吧）。虽然那会因为疫情很快就开摆了，但好在能及时醒悟。想想看直到今天2024-07-14，虽然也没做出什么大成就，看到当时的自己还是感慨不已：驽马十驾功在不舍，大抵是千年学府学子特有的“登高自卑”吧（骄傲</p><p>还刷了刷好友的歌单，发现林LX、邓YJ和谭SY的ACG歌单挺多我听过的歌的，只不过我听的大部分都是piano cover。就去研究了下怎么把外部音乐导入到网易云云盘，让他识别。日语歌没有歌词翻译那属于是完全不行，而且有些评论还挺有意思的。整了2个小时，github上也找了工具，但都是不行。最后发现在属性里面修改一下艺术家和唱片名称，成功率有50%左右。</p><p>晚上10点后着手于把那61G的faiss index弄成HNSW，这一搞就搞到12点多，这125G的内存，咋可能建的下21Mx768维的HNSW索引呢？这光是裸的向量本身都61G了啊我靠，越想越烦，不过睡前还是挂了个ipynb试试。希望明早出现奇迹吧。</p><blockquote><p>本周的周度音乐是ryo（supercell）的《さよならメモリーズ》<br>于2024-06-14，从<a href="https://www.bilibili.com/video/BV1Xs41127Bp/?share_source=copy_web&vd_source=f1eb5a7dfcbdaec7154372672e90acbc">【Animenz】50万订阅特典！！！ 再见，回忆（Supercell）钢琴版</a>知道这首歌</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - IR &amp; ODQA Wiki</title>
    <link href="/2024/07/14/%E7%AC%94%E8%AE%B0%20-%20IR%20&amp;%20ODQA%20Wiki/"/>
    <url>/2024/07/14/%E7%AC%94%E8%AE%B0%20-%20IR%20&amp;%20ODQA%20Wiki/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2024.05.09 17:18 入坑纪念</p><p>Information Retrieval !</p><p>A brand new start, but i still hope</p><p>能在这条路上走下去</p><p>留下一些足迹~</p></blockquote><h2 id="Pyserini使用指南"><a href="#Pyserini使用指南" class="headerlink" title="Pyserini使用指南"></a>Pyserini使用指南</h2><h3 id="初步安装"><a href="#初步安装" class="headerlink" title="初步安装"></a>初步安装</h3><p>首先创建python虚拟环境pyserini：</p><p><code>conda create -n pyserini python=3.8.18</code></p><p>然后激活虚拟环境：</p><p><code>conda activate pyserini</code></p><p>安装pyserini：</p><p><code>pip install -r requirement</code></p><p>安装faiss（用于dense retrieval）：</p><p><code>pip install faiss-cpu==1.8.0</code></p><p>注意这里只能安装cpu版本的faiss，无法安装gpu版本的。</p><p>下载tools，并放到<code>pyserini-autofusion/pyserini/tools</code>下。</p><p>接下来将分别测试sparse retrieval和dense retrieval。</p><h3 id="测试sparse-retrieval"><a href="#测试sparse-retrieval" class="headerlink" title="测试sparse retrieval"></a>测试sparse retrieval</h3><p>由于anserini是基于java的，所以还需要jdk21：</p><p>下载并解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">aria2c -s 16 -x 16 https://download.oracle.com/java/21/latest/jdk-21_linux-x64_bin.tar.gz<br>tar -zxvf jdk-21_linux-x64_bin.tar.gz<br></code></pre></td></tr></table></figure><p>接下来下载anserini的jar包，并将anserini的jar包链接到项目的pyserini&#x2F;resources&#x2F;jars目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://repo1.maven.org/maven2/io/anserini/anserini/0.35.1/anserini-0.35.1-fatjar.jar<br>mv anserini/anserini-0.35.0-fatjar.jar pyserini-autofusion/pyserini/resources/jars/anserini-0.35.1-fatjar.jar<br></code></pre></td></tr></table></figure><h3 id="测试dense-retrieval"><a href="#测试dense-retrieval" class="headerlink" title="测试dense retrieval"></a>测试dense retrieval</h3><p>新建jupyter notebook，在其中运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyserini.search.faiss <span class="hljs-keyword">import</span> FaissSearcher, TctColBertQueryEncoder<br><br>encoder = TctColBertQueryEncoder(<span class="hljs-string">&#x27;castorini/tct_colbert-msmarco&#x27;</span>)<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">timeout: timed out<br>...<br>    447 except EntryNotFoundError as e:<br>    448     if not _raise_exceptions_for_missing_entries:<br><br>OSError: We couldn&#x27;t connect to &#x27;https://huggingface.co&#x27; to load this file, couldn&#x27;t find it in the cached files and it looks like castorini/tct_colbert-msmarco is not the path to a directory containing a file named config.json.<br>Checkout your internet connection or see how to run the library in offline mode at &#x27;https://huggingface.co/docs/transformers/installation#offline-mode&#x27;.<br></code></pre></td></tr></table></figure><p>这实际上是<code>pyserini/search/faiss/_search.py</code>中class TctColBertQueryEncoder(QueryEncoder)<br>的构造函数中，self.model &#x3D; BertModel.from_pretrained(encoder_dir)的问题。</p><p>使用以下脚本下载模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>os.environ[<span class="hljs-string">&#x27;HF_ENDPOINT&#x27;</span>] = <span class="hljs-string">&#x27;https://hf-mirror.com&#x27;</span><br><br>model = <span class="hljs-string">&#x27;castorini/tct_colbert-msmarco&#x27;</span><br>local_dir = <span class="hljs-string">&#x27;/remote-home/share/lcj_pyserini/encoder/tct_colbert-msmarco&#x27;</span><br>os.system(<span class="hljs-string">f&#x27;huggingface-cli download --resume-download <span class="hljs-subst">&#123;model&#125;</span> --local-dir <span class="hljs-subst">&#123;local_dir&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此时再运行from_pretrained(encoder_dir)仍然报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">OSError: Error no file named pytorch_model.bin, tf_model.h5, model.ckpt.index or flax_model.msgpack found in directory /remote-home/share/lcj_pyserini/encoder/tct_colbert-msmarco/.<br></code></pre></td></tr></table></figure><p>因此查看存放模型的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(pyserini) root@303b7c05f88b:/remote-home/share/lcj_pyserini/encoder/tct_colbert-msmarco# ls -lh<br>total 236K<br>-rw-r--r-- 1 root root  446 Apr 24 15:34 README.md<br>-rw-r--r-- 1 root root  313 Apr 24 15:34 config.json<br>lrwxrwxrwx 1 root root  149 Apr 24 15:37 pytorch_model.bin -&gt; ../../../../root/.cache/huggingface/hub/models--castorini--tct_colbert-msmarco/blobs/938c6367f910ac55073b58413577da148f5f1104e247379e4241917282ad15a0<br>-rw-r--r-- 1 root root 227K Apr 24 15:34 vocab.txt<br></code></pre></td></tr></table></figure><p>注意qas问题答案文件中，必须要确保问题、答案都<code>strip()</code>一次。</p><h3 id="加入新的语料topics"><a href="#加入新的语料topics" class="headerlink" title="加入新的语料topics"></a>加入新的语料topics</h3><p>先下载qas文件，大概长这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">head topics.dpr.wq.train.txt <br>&#123;&quot;answer&quot;: [&quot;Jazmyn Bieber&quot;, &quot;Jaxon Bieber&quot;], &quot;question&quot;: &quot;what is the name of justin bieber brother?&quot;&#125;<br>&#123;&quot;answer&quot;: [&quot;Padm\u00e9 Amidala&quot;], &quot;question&quot;: &quot;what character did natalie portman play in star wars?&quot;&#125;<br>&#123;&quot;answer&quot;: [&quot;New York City&quot;], &quot;question&quot;: &quot;what state does selena gomez?&quot;&#125;<br></code></pre></td></tr></table></figure><p>接下来需要让anserini读取到这个新qas文件的路径，修改<code>anserini/src/main/java/io/anserini/search/topicreader/Topics.java</code>：<br>添加这样一行<code>DPR_WQ_TRAIN(DprJsonlTopicReader.class, &quot;topics.dpr.wq.train.txt&quot;),</code><br>然后重新编译：<code>./bin/qbuild.sh</code><br>还需要把新的jar包加进pyserini的路径。</p><p>在pyserini中，也需要在<code>pyserini-autofusion/pyserini/encoded_query_info.py</code>添加新语料对应的信息：<br>其中md5码要求的是qas生成的embedding的md5码。所以需要先生成embedding。</p><p>还需要再<code>/root/miniconda3/envs/pyserini/lib/python3.10/site-packages/pyserini/search/_base.py</code>中添加一行：<br><code>&#39;dpr-wq-train&#39;: &#39;DPR_WQ_TRAIN&#39;,</code></p><p>准备工作完成了。随后就是生成embedding：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>embedding_path = <span class="hljs-string">&#x27;/dk/pyserini-dataset/queries/query-embedding-dpr_multi-wq-train-20240504-9323ec&#x27;</span><br>os.makedirs(embedding_path, exist_ok=<span class="hljs-literal">True</span>)<br>cmd0 = <span class="hljs-string">f&#x27;python /dk/lcj_pyserini/pyserini-autofusion/scripts/dpr/encode_queries.py \</span><br><span class="hljs-string">      --encoder /dk/pyserini-dataset/encoder/dpr-question_encoder-multiset-base/ \</span><br><span class="hljs-string">      --input ~/.cache/anserini/topics-and-qrels/topics.dpr.wq.train.txt \</span><br><span class="hljs-string">      --format json \</span><br><span class="hljs-string">      --output <span class="hljs-subst">&#123;embedding_path&#125;</span>/embedding.pkl&#x27;</span><br>os.system(cmd0)<br><br><span class="hljs-comment"># row: [&#x27;&#123;&quot;question&quot;: &quot;what is the name of justin bieber brother?&quot;, &quot;answer&quot;: [&quot;Jazmyn Bieber&quot;, &quot;Jaxon Bieber&quot;]&#125;&#x27;]</span><br><span class="hljs-comment"># use --format json instead</span><br></code></pre></td></tr></table></figure><p>生成md5码并改名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>command = <span class="hljs-string">&#x27;md5sum &#x27;</span> + embedding_path + <span class="hljs-string">&#x27;/embedding.pkl&#x27;</span><br><br>output = os.popen(command).read()<br>md5sum = output.split()[<span class="hljs-number">0</span>]<br><br>os.system(<span class="hljs-string">f&#x27;mv <span class="hljs-subst">&#123;embedding_path&#125;</span> <span class="hljs-subst">&#123;embedding_path&#125;</span>.<span class="hljs-subst">&#123;md5sum&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>同时把新的md5码加进<code>pyserini-autofusion/pyserini/encoded_query_info.py</code></p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>执行BM25检索的时候报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">resultPath: /root/.cache/pyserini/topics-and-qrels/topics.dpr.adversarial.val.txt<br><br>Traceback (most recent call last): File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/runpy.py&quot;, line 196, in _run_module_as_main return _run_code(code, main_globals, None, File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/runpy.py&quot;, line 86, in _run_code exec(code, run_globals) File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/site-packages/pyserini/search/lucene/__main__.py&quot;, line 148, in &lt;module&gt; query_iterator = get_query_iterator(args.topics, TopicsFormat(args.topics_format)) File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/site-packages/pyserini/query_iterator.py&quot;, line 187, in get_query_iterator return mapping[topics_format].from_topics(topics_path) File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/site-packages/pyserini/query_iterator.py&quot;, line 104, in from_topics topics = get_topics(topics_path) File &quot;/root/miniconda3/envs/pyserini/lib/python3.10/site-packages/pyserini/search/_base.py&quot;, line 598, in get_topics topics = JTopicReader.getTopicsWithStringIds(topics_mapping[collection_name]) File &quot;jnius/jnius_export_class.pxi&quot;, line 876, in jnius.JavaMethod.__call__ File &quot;jnius/jnius_export_class.pxi&quot;, line 1042, in jnius.JavaMethod.call_staticmethod File &quot;jnius/jnius_utils.pxi&quot;, line 79, in jnius.check_exception jnius.JavaException: JVM exception occurred: Unable to read topics: DPR_ADVERSARIAL_VAL java.io.IOException<br></code></pre></td></tr></table></figure><p>原因：准备的数据集格式出错了，可能的错误有：<code>&#123;&quot;question&quot;: &quot;Which actors are honorary freemen?&quot;, &quot;answers&quot;: [&quot;the Royal Shakespeare Company&quot;]&#125;</code>中的<code>answers</code>应该为<code>answer</code>，即多了个<code>s</code>。</p><h2 id="QA数据集"><a href="#QA数据集" class="headerlink" title="QA数据集"></a>QA数据集</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><table><thead><tr><th align="center">Data</th><th align="center">In-DPR?</th><th># Train QAs</th><th># Test QAs</th><th># Val QAs</th><th># Eval QAs</th><th># Dev QAs</th></tr></thead><tbody><tr><td align="center">AdversarialQA</td><td align="center">No</td><td>30,000</td><td></td><td>3,000</td><td></td><td></td></tr><tr><td align="center">AmbigQA</td><td align="center"></td><td></td><td></td><td>2,002</td><td></td><td></td></tr><tr><td align="center">ComQA</td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">CuratedTrec</td><td align="center">Yes</td><td>1,121</td><td>694</td><td></td><td></td><td></td></tr><tr><td align="center">DROP</td><td align="center"></td><td></td><td></td><td>9,535</td><td></td><td></td></tr><tr><td align="center">DuoRC</td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">FreeBase</td><td align="center"></td><td>20,358</td><td></td><td></td><td>3,996</td><td></td></tr><tr><td align="center">HarvestQA</td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">HotpotQA</td><td align="center">No</td><td>90,447</td><td></td><td></td><td></td><td>7405</td></tr><tr><td align="center">SearchQA</td><td align="center">No</td><td>117,384</td><td></td><td>16,980</td><td></td><td></td></tr><tr><td align="center">SQuAD</td><td align="center">No</td><td>87,599</td><td>10,570</td><td></td><td></td><td></td></tr><tr><td align="center">NarrativeQA</td><td align="center">No</td><td>32,747</td><td>10,557</td><td></td><td></td><td></td></tr><tr><td align="center">NaturalQ</td><td align="center">Yes</td><td>79,168</td><td>3,610</td><td></td><td></td><td></td></tr><tr><td align="center">WebQ</td><td align="center">Yes</td><td>3,778</td><td>2,032</td><td></td><td></td><td></td></tr><tr><td align="center">TriviaQA</td><td align="center">Yes</td><td>78,785</td><td>11,313</td><td></td><td></td><td></td></tr><tr><td align="center">WikiHop-100r</td><td align="center"></td><td>39,348</td><td></td><td>4,641</td><td></td><td></td></tr><tr><td align="center">WikiQA</td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="AdversarialQA"><a href="#AdversarialQA" class="headerlink" title="AdversarialQA"></a>AdversarialQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/UCLNLP/adversarial_qa">hugging-face</a></p><p>论文原文：<a href="https://arxiv.org/abs/2002.00293">Beat the AI: Investigating Adversarial Human Annotation for Reading Comprehension</a></p><h3 id="AmbigQA"><a href="#AmbigQA" class="headerlink" title="AmbigQA"></a>AmbigQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/sewon/ambig_qa">hugging-face</a></p><p>论文原文：<a href="https://arxiv.org/pdf/2004.10645.pdf">AmbigQA: Answering Ambiguous Open-domain Questions</a></p><p>模糊性是开放域问答所固有的;尤其是在探索新话题时，很难提出一个只有一个明确答案的问题。我们引入了一种新的开放域问答任务，它涉及预测一组问答对，其中每个合理的答案都与原始问题的消歧重写配对。</p><p>为了研究这个任务，我们构建了AmbigNQ，这是一个数据集，涵盖了来自NQ-open的14042个问题，NQ-open是一个现有的开放域QA基准。我们发现NQ-open中超过一半的问题是模棱两可的。歧义的类型是多种多样的，有时是微妙的，其中许多只有在检查非常大的文本语料库提供的证据后才会明显。访问Data Explorer查看示例!</p><h3 id="ComQA"><a href="#ComQA" class="headerlink" title="ComQA"></a>ComQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/iamrishiraj/com_qa">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/N19-1027/">ComQA: A Community-sourced Dataset for Complex Factoid Question Answering with Paraphrase Clusters</a></p><p>answer大部分都只给出了Wikipedia对应的链接，而没有给explicit的答案。</p><h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/ucinlp/drop">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/N19-1246.pdf">DROP: A Reading Comprehension Benchmark Requiring Discrete Reasoning Over Paragraphs</a></p><h3 id="DuoRC"><a href="#DuoRC" class="headerlink" title="DuoRC"></a>DuoRC</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/ibm/duorc">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/P18-1156/">DuoRC: Towards Complex Language Understanding with Paraphrased Reading Comprehension</a></p><p>SelfRC：</p><p>ParaPhraseRC：</p><h3 id="FreeBaseQA"><a href="#FreeBaseQA" class="headerlink" title="FreeBaseQA"></a>FreeBaseQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/KelvinJiang/freebase_qa">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/N19-1028.pdf">FreebaseQA: A New Factoid QA Data Set Matching Trivia-Style Question-Answer Pairs with Freebase</a></p><p>例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>&#x27;Parses&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     &#x27;Answers&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>         &#x27;AnswersMid&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;m<span class="hljs-number">.01</span>npcx&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>         &#x27;AnswersName&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&#x27;goldeneye&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>&#x27;AnswersMid&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;m<span class="hljs-number">.01</span>npcx&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>&#x27;AnswersName&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">[</span>&#x27;goldeneye&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>&#x27;InferentialChain&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;film.film_character.portrayed_in_films..film.performance.film&#x27;<span class="hljs-punctuation">,</span> &#x27;film.actor.film..film.performance.film&#x27;<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;Parse-Id&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;FreebaseQA-train<span class="hljs-number">-0.</span>P0&#x27;<span class="hljs-punctuation">,</span> &#x27;FreebaseQA-train<span class="hljs-number">-0.</span>P1&#x27;<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;PotentialTopicEntityMention&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;<span class="hljs-number">007</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;pierce brosnan&#x27;<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;TopicEntityMid&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;m<span class="hljs-number">.0</span>clpml&#x27;<span class="hljs-punctuation">,</span> &#x27;m<span class="hljs-number">.018</span>p4y&#x27;<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> &#x27;TopicEntityName&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;james bond&#x27;<span class="hljs-punctuation">,</span> &#x27;pierce brosnan&#x27;<br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>    &#x27;ProcessedQuestion&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;what was pierce brosnan&#x27;s first outing as 007&quot;</span><span class="hljs-punctuation">,</span> <br>    &#x27;Question-ID&#x27;<span class="hljs-punctuation">:</span> &#x27;FreebaseQA-train<span class="hljs-number">-0</span>&#x27;<span class="hljs-punctuation">,</span> <br>    &#x27;RawQuestion&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;What was Pierce Brosnan&#x27;s first outing as 007?&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Harvest-QA-Harvesting-From-Wikipedia"><a href="#Harvest-QA-Harvesting-From-Wikipedia" class="headerlink" title="Harvest (QA Harvesting From Wikipedia)"></a>Harvest (QA Harvesting From Wikipedia)</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/lmqg/qa_harvesting_from_wikipedia">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/P18-1177">Harvesting Paragraph-level Question-Answer Pairs from Wikipedia</a></p><h3 id="HotpotQA"><a href="#HotpotQA" class="headerlink" title="HotpotQA"></a>HotpotQA</h3><p>处理和基准设置：</p><table><thead><tr><th>Split</th><th>Desc.</th><th>Usage</th><th># Examples</th></tr></thead><tbody><tr><td>train-easy</td><td>single-hop</td><td>train</td><td>18,089</td></tr><tr><td>train-medium</td><td>multi-hop</td><td>train</td><td>56,814</td></tr><tr><td>train-hard</td><td>hard multi-hop</td><td>train</td><td>15,661</td></tr><tr><td>dev</td><td>hard multi-hop</td><td>dev</td><td>7,405</td></tr><tr><td>test-distractor</td><td>hard multi-hop</td><td>test</td><td>7,405</td></tr><tr><td>test-fullwiki</td><td>hard multi-hop</td><td>test</td><td>7,405</td></tr><tr><td>Total</td><td></td><td></td><td>112,779</td></tr></tbody></table><p>把单跳问题列入train-easy，基准模型可以正确回答的列入train-medium，无法正确回答的列入train-hard等4类中。</p><p>其中test-distractor挑战模型存在噪声时找到真实支持事实，test-fullwiki通过要求它回答所有维基百科文章的第一段没有指定黄金段落的问题，来充分测试模型找到相关事实以及推理相关事实的能力。</p><h3 id="NaturalQ"><a href="#NaturalQ" class="headerlink" title="NaturalQ"></a>NaturalQ</h3><h3 id="SearchQA"><a href="#SearchQA" class="headerlink" title="SearchQA"></a>SearchQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/lucadiliello/searchqa">hugging-face</a></p><p>论文原文：<a href="https://arxiv.org/abs/1704.05179">SearchQA: A New Q&amp;A Dataset Augmented with Context from a Search Engine</a></p><h3 id="SQuAD"><a href="#SQuAD" class="headerlink" title="SQuAD"></a>SQuAD</h3><h3 id="WikiHop"><a href="#WikiHop" class="headerlink" title="WikiHop"></a>WikiHop</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/MoE-UNC/wikihop">hugging-face</a></p><p>论文原文：<a href="https://arxiv.org/abs/1710.06481">Constructing Datasets for Multi-hop Reading Comprehension Across Documents</a></p><h3 id="WikiQA"><a href="#WikiQA" class="headerlink" title="WikiQA"></a>WikiQA</h3><p>下载链接：<a href="https://hf-mirror.com/datasets/microsoft/wiki_qa">hugging-face</a></p><p>论文原文：<a href="https://aclanthology.org/D15-1237.pdf">WikiQA: A Challenge Dataset for Open-Domain Question Answering</a>]</p><table><thead><tr><th>question_id</th><th>question</th><th>document_title</th><th>answer</th><th>label</th></tr></thead><tbody><tr><td>Q1</td><td>how are glacier caves formed?</td><td>Glacier cave</td><td>A partly submerged glacier cave on Perito Moreno Glacier .</td><td>0</td></tr><tr><td>Q1</td><td>how are glacier caves formed?</td><td>Glacier cave</td><td>The ice facade is approximately 60 m high</td><td>0</td></tr><tr><td>Q1</td><td>how are glacier caves formed?</td><td>Glacier cave</td><td>Ice formations in the Titlis glacier cave</td><td>0</td></tr><tr><td>Q1</td><td>how are glacier caves formed?</td><td>Glacier cave</td><td>A glacier cave is a cave formed within the ice of a glacier .</td><td>1</td></tr><tr><td>Q1</td><td>how are glacier caves formed?</td><td>Glacier cave</td><td>Glacier caves are often called ice caves , but this term is properly used to describe bedrock caves that contain year-round ice.</td><td>0</td></tr></tbody></table><h3 id="BM25空结果情况"><a href="#BM25空结果情况" class="headerlink" title="BM25空结果情况"></a>BM25空结果情况</h3><table><thead><tr><th>Data</th><th>Split</th><th># qas</th><th># result&lt;1</th><th># result&lt;20</th><th># result&lt;100</th><th># min result</th></tr></thead><tbody><tr><td>AdversarialQA</td><td>train</td><td>30000</td><td>1</td><td>1</td><td>6</td><td>61</td></tr><tr><td></td><td>val</td><td>3000</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>DROP</td><td>train-slim</td><td>1000</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>FreeBase</td><td>eval</td><td>3996</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>Harvest</td><td>train-slim</td><td>1000</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>HotpotQA</td><td>dev</td><td>7405</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>NarrativeQA</td><td>test</td><td>10557</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>SearchQA</td><td>dev</td><td>16980</td><td>7</td><td>10</td><td>19</td><td>2</td></tr><tr><td>SelfRC</td><td>train-slim</td><td>986</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>SQuAD</td><td>test</td><td>10570</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td>WikiHop</td><td>train</td><td>43738</td><td>282</td><td>2584</td><td>4390</td><td>1</td></tr><tr><td></td><td>train-slim</td><td>1000</td><td>6</td><td>53</td><td>90</td><td>1</td></tr><tr><td></td><td>val</td><td>5129</td><td>34</td><td>313</td><td>488</td><td>1</td></tr><tr><td>WikiQA</td><td>test</td><td>633</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="yes-no-问题占比"><a href="#yes-no-问题占比" class="headerlink" title="yes &#x2F; no 问题占比"></a>yes &#x2F; no 问题占比</h3><table><thead><tr><th align="center">Data</th><th>Split</th><th># yes</th><th># no</th><th># Total</th><th># Ratio</th></tr></thead><tbody><tr><td align="center">HotpotQA</td><td>train</td><td>2748</td><td>2733</td><td>5481</td><td>5481&#x2F;90,447</td></tr><tr><td align="center">HotpotQA</td><td>dev</td><td>225</td><td>233</td><td>458</td><td>458&#x2F;7,405</td></tr><tr><td align="center">SearchQA</td><td>train</td><td>3</td><td>5</td><td>8</td><td>8&#x2F;117,384</td></tr><tr><td align="center">SearchQA</td><td>val</td><td>1</td><td>0</td><td>1</td><td>1&#x2F;16,980</td></tr><tr><td align="center">NaturalQ</td><td>train</td><td>1</td><td>1</td><td>2</td><td>2&#x2F;79,168</td></tr><tr><td align="center">NaturalQ</td><td>test</td><td>0</td><td>1</td><td>1</td><td>1&#x2F;3,610</td></tr></tbody></table><h3 id="Wikipedia上的抽取式问答"><a href="#Wikipedia上的抽取式问答" class="headerlink" title="Wikipedia上的抽取式问答"></a>Wikipedia上的抽取式问答</h3><table><thead><tr><th>Dataset</th><th>Split</th><th># qas</th><th>SR R@100</th><th>DR R@100</th><th>HR R@100</th><th>bonus</th></tr></thead><tbody><tr><td>AdversarialQA</td><td>val</td><td>3000</td><td>0.5933</td><td>0.506</td><td>0.6213</td><td></td></tr><tr><td>Ambig</td><td>val</td><td>2002</td><td>0.7617</td><td></td><td></td><td></td></tr><tr><td>BioASQ</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>DROP</td><td>val</td><td>9535</td><td>0.6853</td><td>0.6258</td><td>0.6926</td><td></td></tr><tr><td>FreeBase</td><td>train-slim</td><td>1000</td><td>0.9520（WFT？）</td><td></td><td></td><td></td></tr><tr><td></td><td>eval</td><td>3996</td><td></td><td></td><td></td><td></td></tr><tr><td>Harvest</td><td>train-slim</td><td>1000</td><td>0.6000</td><td></td><td></td><td></td></tr><tr><td>NarrativeQA</td><td>train</td><td>32747</td><td></td><td></td><td>0.3973</td><td></td></tr><tr><td>&#x3D;&#x3D;SearchQA&#x3D;&#x3D;</td><td>val</td><td>16980</td><td>0.8100</td><td>0.8067</td><td>0.8518</td><td></td></tr><tr><td>SelfRC</td><td>train-slim</td><td>986</td><td>0.4533</td><td></td><td></td><td></td></tr><tr><td>WikiHop</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>train-slim (去除#result&lt;1)</td><td>994</td><td>0.6469</td><td>0.5785</td><td>0.6881</td><td></td></tr><tr><td></td><td>val</td><td>5125</td><td>0.6126</td><td>0.5286</td><td>0.6510</td><td></td></tr><tr><td></td><td>val-100r (去除#result&lt;100)</td><td>4641</td><td>0.6100</td><td>0.5538</td><td>0.6524</td><td></td></tr><tr><td>WikiMovies</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>WikiQA</td><td>test</td><td>633</td><td>0.2401</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><p>DR：Dense Retriever，即密集检索器。常见的Dense Retriever包括DPR、ANCE。</p><p>SR：Sparse Retriever，即稀疏检索器。最常用的SR是BM25、SPLADE。</p><p>HR：Hybrid Retriever，即混合检索器。通常由一个稀疏检索器+一个稠密检索器构成，对两个召回通道做<strong>RRF &#x2F; 分数加权</strong>得到最终结果。在目前的实验版本中，HR是BM25 + DPR + RRF</p><p>gt：ground truth，在本文context下指的是一条query的正确答案，为若干个字符串。检索器返回的所有候选doc中至少需要有1个doc包含gt，才能算命中hit</p><p>RRF：Reciprocal Rank Fusion，倒数平均聚合。<br>来自论文<a href="https://doi.org/10.1145/1571941.1572114"># Reciprocal rank fusion outperforms condorcet and individual rank learning methods</a></p><p>ODQA：Open-Domain Question Answering，即开放域问答。ODQA系统的目标是从庞大的语料库中检索并提取出能够回答给定问题的信息。为了实现这一目标，系统通常需要执行以下步骤：</p><ol><li><strong>信息检索</strong>：从语料库中找出可能包含答案的文档或段落。</li><li><strong>阅读理解</strong>：对检索到的文档进行深入分析，理解其内容，以定位具体答案。</li><li><strong>答案生成</strong>：根据理解的内容生成或抽取答案。</li></ol><p>corpus：即ODQA任务中的语料库，通常包含大量的文档，这些文档可以是网页、书籍、文章、维基百科条目等各种来源的文本数据。</p><p>doc：document，即corpus中的文档。在ODQA任务中，语料库</p><p>R@10、R@100：Recall at 10、100的简称。含义为检索系统在前10个或前100个检索结果中找到至少一个相关文档的能力的指标。<br>这个指标关注的是检索结果的“召回率”方面，却并<strong>不考虑检索结果的排序</strong>，也就是说，只要在前10或前100的文档中有至少一个相关文档，该指标就算作成功。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Information-Retrieval</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/13/hello-world/"/>
    <url>/2024/07/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 07.01-07.07</title>
    <link href="/2024/07/06/%E5%91%A8%E8%AE%B0%20-%202024%2007.01-07.07/"/>
    <url>/2024/07/06/%E5%91%A8%E8%AE%B0%20-%202024%2007.01-07.07/</url>
    
    <content type="html"><![CDATA[<h2 id="07-01-周一-阴-小雨"><a href="#07-01-周一-阴-小雨" class="headerlink" title="07.01 周一 阴-小雨"></a>07.01 周一 阴-小雨</h2><p>早上来到公司，坐我后面位置的那位“饱经风霜”的同学，和我说我坐的位置明天就会有出差的人过来坐了。</p><p>下午5点多快下班了我才把东西收拾到张H的位置。毕竟能远离同事，就能摸鱼了（bushi）。</p><p>晚上看基金的收益，发现博时跌了10+块钱。心里大感不妙，果然，9点多一看，直接亏了36块，属于是新史低了（悲）。<br>睡前刷视频，刷到央行的“借入”操作。<br>那没办法，只能明天盘算下怎么把债基出仓一些了。<br>直觉告诉我这回调可能会持续几天。<br>所以明天3点前至少要把博时给清掉。</p><h2 id="07-02-周二-阴-小雨"><a href="#07-02-周二-阴-小雨" class="headerlink" title="07.02 周二 阴-小雨"></a>07.02 周二 阴-小雨</h2><p>今天中午吃饭得知mentor李BW同学，下个月就要转base到US了。<br>这不得好好摸清US那边码农的工作情况？（我觉得这就是一种自信<br>他还说等他走了，他的工位可以给我坐。<br>他人还怪好的。正好我一直找不到长期能坐的工位。</p><h2 id="07-03-周三-晴-雨-（入职满一周）"><a href="#07-03-周三-晴-雨-（入职满一周）" class="headerlink" title="07.03 周三 晴-雨 （入职满一周）"></a>07.03 周三 晴-雨 （入职满一周）</h2><p>下午5点10分，找孔LB同学，一起去5楼的健身房兜一圈。发现居然还有洗澡间。</p><p>晚上突然被zwg call了，说VLDB参会注册只需要学生会员就可以了。<br>让我去把我之前注册的professional会员改成student会员，也就是说要退钱，重新注册。<br>我晚上断断续续花了1个小时才在官网找到：要给他们发邮件。<br>网站上全是又臭又长的英文，各种条款，非常恶心。</p><p>傍晚我吃过晚饭骑车刚回宿舍，就开始下暴雨了。</p><h2 id="07-04-周四-晴（极热）"><a href="#07-04-周四-晴（极热）" class="headerlink" title="07.04 周四 晴（极热）"></a>07.04 周四 晴（极热）</h2><p>一早起来就是打开复旦邮箱，看看VLDB那帮人回了没。<br>原来他们昨晚在收到我邮件之后几分钟就回了我。</p><p>10点钟被zwg拉去参加一个讲座，结果11点20我才从子彬院出发，骑车去公司。<br>大中午的太阳 + 骑车，让我感受到了上海的热情。<br>中午吃饭的时候我才从妈妈那知道天河区（31°C）都比上海（37°C）凉快。</p><p>下午突然想起余t和卞wr都有内推的需要，所以中午睡醒之后我就在工位上摸鱼，在people内推系统里找。<br>看到了NLP的实习岗位，写着NLP，但实际也是推荐相关，也是我们Tiktok-Rec-Core的。<br>哎还是眼馋NLP的岗位啊。</p><p>这几天一直有想把我之前博客上的所有日记、笔记都用类似飞书那种方式弄成知识库。<br>这一周下来天天用飞书，感觉它的各种链接，比如术语词典之类的功能真的挺好用的。<br>只不过我不是很想用飞书来搞，毕竟它不是开源的。<br>有空了琢磨一下obsidian能不能搞成那种效果。</p><h2 id="07-05-周五-晴"><a href="#07-05-周五-晴" class="headerlink" title="07.05 周五 晴"></a>07.05 周五 晴</h2><p>不知道为啥最近早上总是会早醒，昨天早上5点多就醒了，今早是6点半……<br>7点多没等闹钟响就下床了，刷B站的时候心血来潮，看了看一些GAL Game的夏促资讯。<br>发现steampy上价格不是很给力，于是就又想去倒余额了。</p><p>上午在公司工位上，我想试试用MLP替换掉Lightgbm试试分类效果。</p><p>下午五点多去一楼大厅换工牌，本来还期待一下领一条Tiktok狗牌的带子。<br>结果领到的带子甚至连bytedance的logo都没有……</p><p>临近6点下班的时候，终于是把HotpotQA的训练数据 + 模型给整出来了。<br>可是上了HotpotQA的dev上测了下，发现效果就是一坨。<br>这下头大了。</p><p>这时候孔LB飞书过来问我去不去吃饭，我就赶紧收东西跑路了。<br>晚上我、LB和陈XP一起到4楼吃了本周在公司的最后一顿晚餐。<br>我们边吃边聊到转base的事情，得知mentor 李BW转base到圣何塞之后，年薪可能会翻2倍不止。</p><h2 id="07-06-周六-晴"><a href="#07-06-周六-晴" class="headerlink" title="07.06 周六 晴"></a>07.06 周六 晴</h2><p>今天打算把到目前为止所有的代码都整理一遍，代码用git备份一下。<br>也得包括之前在各种数据集上跑的各种cache、trec、json，打算在100服务器上的docker上也备份一下。</p><p>打算得挺好的，可是整个早上 + 中午我都在对着HotpotQA的结果纳闷。<br>我认为这是训练数据不好导致的。<br>之前SQuAD的数据就很nice，从Lightgbm改用128x64的MLP之后，甚至在WQ-test（跨数据集）的召回率都能超过纯rrf。</p><p>初步猜测是HotpotQA训练数据中，rrf、dense和sparse能回答问题的重合度太高了。<br>于是我算了算他们两两之间的 jacard 相似度，发现他们三者的相似度都比之前SQuAD要高。<br>因此改进的策略是：对三者都能回答的样本进行下采样，来调整训练数据中<br>rrf、dense和sparse的分布。</p><p>下午我重新翻了翻HotpotQA-train的QA文本，发现里面有很多样本的answer都只是简单的yes、no。<br>我觉得对于抽取式问答来说，这种样本的answer质量太差了，应该被筛掉。</p><p>我还心血来潮，又重新捣鼓起Notion了。这次我用复旦的教育邮箱注册了个新号，没想到可以直接升级成教育计划。但是用了用发现这种无法本地化的软件可能还不是很适合我……<br>于是到了晚上我又抄起Obsidian，搜了搜B站，发现Obsidian好像也是可以做成个人网站的。<br>我把我的blog导入到Obsidian，惊喜地发现博文头上的那些tag、category之类的它也能用好看的UI显示。</p><h2 id="07-07-周日-晴"><a href="#07-07-周日-晴" class="headerlink" title="07.07 周日 晴"></a>07.07 周日 晴</h2><p>早上七点出头就被热醒了，原来是没电费了，群里半夜两点交的电费……</p><p>醒来之后我开始准备待会汇报的内容。<br>首先要解决的问题就是把图片放到图床上，我打算以后都放picgo了。<br>然后就是研究用Obsidian + git实现MSI和MacBookPro同步了。<br>出于时间考虑，我就没来得及捣鼓Obsidian的git插件了，直接用vscode+git同步了再说。<br>最后成果就是MacBook上也能同步上了，以后出门就不用带MSI了，起飞！</p><p>热热热！10点得去子彬院开小组会，在线下的同学只有我、陈YZ、施JY和蔡YZ4个人……就连郑老师也线上参加。明显感觉到组会的节奏比较拖，整到中午12点多才下会。</p><p>下午先是整理了一下现在做QA实验的pyserini那个git库。<br>整得差不多了就开始把HotpotQA-dev里的485条<code>yes-no questions</code>全部去掉，再用分类器重新跑一次recall vs budget。<br>不出所料的，效果还是很差，主要体现在高budget下，分类器的表现不如随机。<br>原因看起来也不是单纯的<code>yes-no questions</code>了。主要是HotpotQA的multi-hop问题难度太高了。</p><p>虽然已经预料到了，但还是给了我不小的打击。现在只有一个SQuAD，说服力太差了。<br>现在也只能寄希望于接下来的SearchQA他们了。</p><p>祈祷下周能出奇迹！</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 06.24-06.30</title>
    <link href="/2024/06/30/%E5%91%A8%E8%AE%B0%20-%202024%2006.24-06.30%EF%BC%88Tiktok%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%89/"/>
    <url>/2024/06/30/%E5%91%A8%E8%AE%B0%20-%202024%2006.24-06.30%EF%BC%88Tiktok%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="06-24-周一-雨"><a href="#06-24-周一-雨" class="headerlink" title="06.24 周一 雨"></a>06.24 周一 雨</h2><p>不出意外的话，今天就要开始正式的实习生活了。<br>但是不出意外地出意外了……</p><p>早上我早早地起了床，想着入职第一天早点去，说不定要交代很多事项，还得发配笔记本之类的。<br>我8点多一点就到了三门路的抖音集团，问前台得知需要我和我的HR对接。<br>我就vx给HR发了无数条消息，拨了无数条语音电话，结果硬是等到10点才回我。</p><p>HR问说我没有在系统填入职信息，所以今天之内没办法入职。<br>我再三确认了我的gmail，只收到了一个确认offer的邮件，HR道歉说他们忘了给我发后续的系统填写邮件。<br>我直接开怼，要她赔偿，他妈的硬是在T3大厅坐了2个小时。</p><p>下午在宿舍干着学校这边的活，主要就是把SQuAD也给接到pyserini框架上。<br>先是把之前就接上的SQuAD-test数据集拿出来测了一下所谓的OOD。</p><p>基本思路是直接在SQuAD-test的10570条QA数据上做train-test split。<br>只不过这次的label跟之前不一样，下面是所有可能的label情况。</p><table><thead><tr><th>class_name</th><th>Dense_hit</th><th>Hybrid_hit (rrf)</th><th>Sparse_hit</th><th>count</th></tr></thead><tbody><tr><td>class0</td><td>0</td><td>0</td><td>1</td><td>158</td></tr><tr><td>class1</td><td>0</td><td>1</td><td>0</td><td>8</td></tr><tr><td>class2</td><td>1</td><td>0</td><td>0</td><td>83</td></tr><tr><td>class3</td><td>1</td><td>1</td><td>0</td><td>420</td></tr><tr><td>class4</td><td>0</td><td>1</td><td>1</td><td>1836</td></tr><tr><td>class5</td><td>1</td><td>0</td><td>1</td><td>25</td></tr><tr><td>class6</td><td>1</td><td>1</td><td>1</td><td>6631</td></tr><tr><td>fail</td><td></td><td></td><td></td><td>1409</td></tr><tr><td>total</td><td></td><td></td><td></td><td>10570</td></tr></tbody></table><h2 id="06-25-周二-雨"><a href="#06-25-周二-雨" class="headerlink" title="06.25 周二 雨"></a>06.25 周二 雨</h2><p>还没到入职的日子，所以今天还是家里（宿舍）蹲。</p><p>不记得啥时候，突然灵光一闪，觉得我现在在做的事情：<code>根据top-k候选的距离，去判断一个query是否是OOD</code> 这件事情用的特征处理方法好像不是很好。目前的直觉是：</p><ol><li>给定一个query，计算它与top-k召回的距离</li><li>如果距离小于某个阈值，则判定为OOD</li></ol><p>这样属于一种无监督的判断方法。效率和落地性自然是很可以，但是效果就是一坨。<br>其实这个top-k的距离特征，我能不能把它当成一种时间序列（TimeSeries）呢？</p><p>目前对dist特征（维度为k）的处理方法比较naive，都是把dist当成一个k维的特征：</p><ol><li>NN版本：丢到MLP，然后接上一个 BCEWithLogitsLoss；</li><li>ML版本：直接扔给lightgbm，做二分类任务。</li></ol><p>这样的话其实我更改dist特征的内部顺序，比如让他变得不再是非升序，模型效果应该也是差不多的。<br>而如果用TS模型去考虑，就会考虑到这些顺序。<br>如果用TS模型来考虑，那么我们的任务就变成TS的 二分类任务 &#x2F; 异常检测任务</p><p>中午晚上我刷了一些帖子，发现还有TS大模型这种东西。<br>只不过不知道能不能用来做分类任务，因为它们好像都是decoder-only的，直觉上感觉做分类任务会没encoder-only那种容易。</p><p>回过头看华科郑博龙老师的那篇ICDE2023论文，就是预测搜索多少个簇的。<br>他对于dist特征就用到了1D-CNN还有Pooling，这些方法都属于TS特征提取的方法。</p><p>如果TS分类的算法真的对于我的OOD任务有效，那么至少可以水出两篇论文了。</p><ol><li>用kNN距离阈值做无监督OOD检测的论文，换成用整个top-kNN的距离序列来做；</li><li>目前在做的QA混合检索策略选择的工作也可以用TS来加强效果；</li><li>之前做的RF，说不定也可以通过这个模块复活。</li></ol><h2 id="06-26-周三-雨-（入职第一天）"><a href="#06-26-周三-雨-（入职第一天）" class="headerlink" title="06.26 周三 雨 （入职第一天）"></a>06.26 周三 雨 （入职第一天）</h2><p>这几天天天下雨，早上还得去字节新江湾工区报到。我选择右手美团单车 + 左手打伞。<br>一路栉风沐雨，花了20+分钟到新江湾。可是我等我找到新人入职培训的入口，已经10点20了。</p><p>听HR在上面逼逼赖赖了半天，她提醒我们要签到。我发现我的飞书APP怎么都签不上，联系HR才得知我又没有签署blabla文件……<br>不过这次的确是我的问题，发了邮件到我这我没留意到。</p><p>坐我旁边的是一个THU的女生，她是搞AIGC的实习生。<br>想到我之前投的实习全都是nlp、大模型相关的，却全都石沉大海了……<br>如果让我选，那我肯定愿意选大模型，而不是现在这个推荐算法。<br>再不济我也愿意选LLM + 推荐的算法。</p><p>先是领临时门禁工牌，然后就是领电脑。我本来没报太大期待，因为我周一在系统里填办公电脑的时候，没得选，只有一栏MacBookPro I7版本。<br>没想到领到的却是23年11月的M3pro版本的MacBookPro，喜出望外！</p><h2 id="06-27-周四-雨"><a href="#06-27-周四-雨" class="headerlink" title="06.27 周四 雨"></a>06.27 周四 雨</h2><p>明晚是《社交网络分析》期末报告的DDL。<br>所以今天得开始收尾了。<br>说实话这门课的期末PJ已经算轻松的了，我直接复用了VLDB2024的图划分工作，强行跟阳DQ讲的“社区划分”扯上关系。</p><h2 id="06-28-周五-雨"><a href="#06-28-周五-雨" class="headerlink" title="06.28 周五 雨"></a>06.28 周五 雨</h2><p>今天周五了，下午跟GFS有个one2one。<br>可是我这几天都在搞SQuAD，还在搞社交网络分析期末PJ的报告。<br>所以早上到公司就创了个文档，用来记录我看文档遇到的问题。</p><p>我照着 新人串讲-ZCR 一点点推进度。看到多路召回merge的部分，有一个算法叫做snake-merge。<br>每个召回通道都会有权重 $w_i$ 和当前召回到的数量 $dice_i$。</p><ol><li>每路召回结果需要有序，都从第一名开始召回</li><li>依次遍历每条通道，如果dice_i&#x2F;total_dice &lt;&#x3D; w_i&#x2F;total_weight，则继续在此路召回，否则召回下一路，直到召回量达到quota or 所有队列没有候选。</li><li>当某一个召回队列已经没有可用候选，则total_weight -&#x3D; weight_i且total_dice   -&#x3D; dice_i</li></ol><p>实际上就是郑老师上上周提到的half_tops算法在双通道且$w_i &#x3D; 0.5$的特殊情况。</p><h2 id="06-29-周六-阴-晴"><a href="#06-29-周六-阴-晴" class="headerlink" title="06.29 周六 阴-晴"></a>06.29 周六 阴-晴</h2><p>早上起来就去计算中心工位把昨天收到的 VLDB参会费发票 给打印了。<br>本来想着只带MacBook Pro去打印，比MSI轻便一点。突然就想起来工位那台打印机好像只能用USB连接。<br>而这台MacBook Pro是USB-C接口，所以就把MSI也带上了。<br>打算去到那边看看可不可以用网络连接打印机。<br>结论是垃圾打印机好像只能用USB……</p><h2 id="06-30-周日-雨"><a href="#06-30-周日-雨" class="headerlink" title="06.30 周日 雨"></a>06.30 周日 雨</h2><p>早上约了zls，检索例会会前半小时过去找他。和他讲了我周一周二的想法之后，他似乎还挺满意的。<br>不过zls看起来更喜欢 “kNN指导查询重写” 的那个idea。</p><p>睡醒之后我调了下top-k的k这个参数，试了50、100和200。发现100效果是最好的。<br>我看了看label的规则，才发现我的label选择规则和我的策略没对应。<br>这次我试着把sparse会失败的全部样本都当成label&#x3D;1了，发现效果和之前差不多。</p><p>候选的ood测试集：</p><ol><li>SQuAD （test：10570）</li><li>HotpotQA （test：7405）</li><li>msmarco</li></ol><p>现在暂时放在这记一下，打算把ODQA的整个探索过程汇总起来，弄一篇单独的post。 </p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - BERT面试题目总结</title>
    <link href="/2024/05/23/%E7%AC%94%E8%AE%B0%20-%20BERT%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/23/%E7%AC%94%E8%AE%B0%20-%20BERT%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="3-1-BERT用字粒度、词粒度和子词粒度的优缺点有哪些？"><a href="#3-1-BERT用字粒度、词粒度和子词粒度的优缺点有哪些？" class="headerlink" title="3.1 BERT用字粒度、词粒度和子词粒度的优缺点有哪些？"></a>3.1 BERT用字粒度、词粒度和子词粒度的优缺点有哪些？</h2><p>BERT可以使用字粒度（character-level）和词粒度（word-level）两种方式来进行文本表示，它们各自有优缺点：</p><p>字粒度（Character-level）：</p><ul><li><strong>优点</strong>：处理未登录词（Out-of-Vocabulary，OOV）：字粒度可以处理任意字符串，包括未登录词，不需要像词粒度那样遇到未登录词就忽略或使用特殊标记。对于少见词和低频词，字粒度可以学习更丰富的字符级别表示，使得模型能够更好地捕捉词汇的细粒度信息。词表会大大减小，26个字母基本就能够覆盖所有词，5000多个中文基本也能组合覆盖的词汇。</li><li><strong>缺点</strong>：计算复杂度高：使用字粒度会导致输入序列的长度大大增加，进而增加模型的计算复杂度和内存消耗。需要更多的训练数据：字粒度模型对于少见词和低频词需要更多的训练数据来学习有效的字符级别表示，否则可能会导致过拟合。</li></ul><p>词粒度（Word-level）：</p><ul><li><strong>优点</strong>：计算效率高：使用词粒度可以大大减少输入序列的长度，从而降低模型的计算复杂度和内存消耗。学习到更加稳定的词级别表示：词粒度模型可以学习到更加稳定的词级别表示，特别是对于高频词和常见词，有更好的表示能力。</li><li><strong>缺点</strong>：处理未登录词（OOV）：词粒度模型无法处理未登录词，遇到未登录词时需要采用特殊处理（如使用未登录词的特殊标记或直接忽略）；对于多音字等形态复杂的词汇，可能无法准确捕捉其细粒度的信息；词表中的低频词&#x2F;稀疏词在模型训练过程中无法得到充分训练，进而模型不能充分理解这些词的语义</li></ul><p>子词粒度（Subword-level）：</p><p>对于未见单词，既不把它存为单独词表，也不按字母分词，而是把它拆分成有意义的子词单元<br>例如：unfriendly -&gt; un &#x2F; friend &#x2F; ly</p><ul><li><strong>优点</strong>：融合了字粒度和词粒度的优点。处理未登录词（OOV）：子词粒度模型可以处理未登录词，因为可以将其拆分为多个子词，从而学习到更加准确的子词级别表示。对于多音字等形态复杂的词汇，可以更好地捕捉其细粒度信息。</li><li><strong>缺点</strong>：只适用于英文等拉丁语系的语言，对于中文来讲，由于不能将某一个字拆分为偏旁部首和字根，没有意义。</li></ul><h2 id="3-BERT的三个embedding为什么可以直接相加？"><a href="#3-BERT的三个embedding为什么可以直接相加？" class="headerlink" title="3. BERT的三个embedding为什么可以直接相加？"></a>3. BERT的三个embedding为什么可以直接相加？</h2><p>三个embedding分别是：</p><ol><li>词嵌入（Word Embedding）：表示输入文本中每个词语的嵌入向量。这些嵌入向量可以通过预训练的词向量模型（如Word2Vec或GloVe）得到，也可以在BERT的训练过程中进行学习。</li><li>位置嵌入（Positional Embedding）：用于表示输入序列中每个词语的位置信息。由于BERT是基于Transformer的模型，并没有显式地编码位置信息，因此需要通过位置嵌入来提供序列中每个位置的特定表示。</li><li>分段嵌入（Segment Embedding）：用于区分不同句子或文本段落之间的嵌入。在处理包含多个句子的输入时，为了区分它们，BERT引入了分段嵌入。</li></ol><p>解释1：embedding的本质是one-hot向量经过全连接网络得到的向量。<br>三个 embedding 相加等价于三个原始 one-hot 的拼接再经过一个全连接网络。和拼接相比，相加可以节约模型参数。<a href="https://www.zhihu.com/question/374835153/answer/2108264167">从网络角度理解</a></p><p>解释2：在实际场景中，叠加是一个更为常态的操作。比如声音、图像等信号。一个时序的波可以用多个不司频率的正弦波善加来表示。只要着加的波的频率不同，我们就可以通过傅里叶变换进行逆向转换。<br>一串文本也可以看作是一些时序信号，也可以有很多信号进行叠加，只要频率不同都可以在后面的复杂神经网络中得到解耦(但也不一定真的要得到解耦)。在BERT这个设定中，符号，片段，位置明显可以对应三种非常不同的频率。<a href="https://www.zhihu.com/question/374835153/answer/1080315948">从信号角度理解</a></p><h2 id="3-2-BERT的Encoder与Decoder掩码有什么区别？"><a href="#3-2-BERT的Encoder与Decoder掩码有什么区别？" class="headerlink" title="3.2 BERT的Encoder与Decoder掩码有什么区别？"></a>3.2 BERT的Encoder与Decoder掩码有什么区别？</h2><p>Encoder主要使用自注意力掩码和填充掩码，而Decoder除了自注意力掩码外，还需要使用编码器-解码器注意力掩码来避免未来位置信息的泄露。这些掩码操作保证了Transformer在处理自然语言序列时能够准确、有效地进行计算，从而获得更好的表现。</p><h2 id="3-3-BERT用的是transformer里面的encoder还是decoder？"><a href="#3-3-BERT用的是transformer里面的encoder还是decoder？" class="headerlink" title="3.3 BERT用的是transformer里面的encoder还是decoder？"></a>3.3 BERT用的是transformer里面的encoder还是decoder？</h2><p>BERT使用的是Transformer中的<strong>Encoder部分</strong>，而不是Decoder部分。</p><p>Transformer模型由Encoder和Decoder两个部分组成。Encoder用于将输入序列编码为一系列高级表示，而Decoder用于基于这些表示生成输出序列。</p><p>在BERT模型中，只使用了Transformer的Encoder部分，并且对其进行了一些修改和自定义的预训练任务，而没有使用Transformer的Decoder部分。</p><h2 id="3-4-为什么BERT选择mask掉15-这个比例的词，可以是其他的比例吗？"><a href="#3-4-为什么BERT选择mask掉15-这个比例的词，可以是其他的比例吗？" class="headerlink" title="3.4 为什么BERT选择mask掉15%这个比例的词，可以是其他的比例吗？"></a>3.4 为什么BERT选择mask掉15%这个比例的词，可以是其他的比例吗？</h2><p>BERT采用的Masked LM，会选取语料中所有词的15%进行随机mask，论文中表示是受到完形填空任务的启发，但其实与CBOW也有异曲同工之妙。</p><p>从CBOW的角度，这里 有一个比较好的解释是：在一个大小为 数学公式: $1 &#x2F; p&#x3D;100 &#x2F; 15 \approx 7$ 的窗口中随机选一个词，类似CBOW中滑动窗口的中心词，区别是这里的滑动窗口是非重叠的。</p><p>那从CBOW的滑动窗口角度，10%~20%都是还ok的比例。</p><p>15%是一种经验性的选择，是原论文中的一种选择，并没有一个固定的理论依据，实际中当然可以尝试不同的比例，15%的比例是由BERT的作者在原始论文中提出，并在实验中发现对于BERT的训练效果是有效的。</p><h2 id="3-在BERT中，token分3种情况做mask，分别是什么？作用是什么？"><a href="#3-在BERT中，token分3种情况做mask，分别是什么？作用是什么？" class="headerlink" title="3. 在BERT中，token分3种情况做mask，分别是什么？作用是什么？"></a>3. 在BERT中，token分3种情况做mask，分别是什么？作用是什么？</h2><p>15%token做mask；其中80%用[MASK]替换，10%用random token替换，10%不变。</p><ul><li>80%的概率替换成[MASK]，比如my dog is hairy → my dog is [MASK]</li><li>10%的概率替换成随机的一个词，比如my dog is hairy → my dog is apple</li><li>10%的概率替换成它本身，比如my dog is hairy → my dog is hairy</li></ul><p>其实这个就是典型的Denosing Autoencoder的思路，那些被Mask掉的单词就是在输入侧加入的所谓噪音。主要原因是：</p><p>(1) 在后续finetune任务中语句中并不会出现 [MASK] 标记，“不总是用实际的[MASK]标记替换被掩码的词”能减少预训练和微调之间的不匹配，使模型更好地适应微调任务的特定上下文；<br>(2) 预测一个词汇时，模型并不知道输入对应位置的词汇是否为正确的词汇（ 10% 概率），这就迫使模型更多地依赖于上下文信息去预测词汇，并且赋予了模型一定的纠错能力。</p><h2 id="3-5-为什么BERT在第一句前会加一个-CLS-标志"><a href="#3-5-为什么BERT在第一句前会加一个-CLS-标志" class="headerlink" title="3.5 为什么BERT在第一句前会加一个[CLS] 标志?"></a>3.5 为什么BERT在第一句前会加一个[CLS] 标志?</h2><p>BERT在第一句前会加一个 [CLS] 标志，<strong>最后一层该位对应向量可以作为整句话的语义表示，从而用于下游的分类任务等</strong>。为什么选它？因为与文本中已有的其它词相比，这个无明显语义信息的符号会更“公平”地融合文本中各个词的语义信息，从而更好的表示整句话的语义。</p><p>具体来说，self-attention是用文本中的其它词来增强目标词的语义表示，但是目标词本身的语义还是会占主要部分的，因此，经过BERT的12层，每次词的embedding融合了所有词的信息，可以去更好的表示自己的语义。而 [CLS] 位<strong>本身没有语义，经过12层，得到的是attention后所有词的加权平均，相比其他正常词，可以更好的表征句子语义</strong>。</p><h2 id="3-6-BERT非线性的来源在哪里？"><a href="#3-6-BERT非线性的来源在哪里？" class="headerlink" title="3.6 BERT非线性的来源在哪里？"></a>3.6 BERT非线性的来源在哪里？</h2><p>主要来自两个地方：<strong>前馈层的gelu激活函数</strong>和<strong>self-attention</strong>。</p><p><strong>前馈神经网络层</strong>：在BERT的Encoder中，每个自注意力层之后都跟着一个前馈神经网络层。前馈神经网络层是全连接的神经网络，通常包括一个线性变换和一个非线性的激活函数，如gelu。这样的非线性激活函数引入了非线性变换，使得模型能够学习更加复杂的特征表示。</p><p><strong>self-attention layer</strong>：在自注意力层中，查询（Query）、键（Key）、值（Value）之间的点积得分会经过softmax操作，形成注意力权重，然后将这些权重与值向量相乘得到每个位置的自注意输出。这个过程中涉及了softmax操作，使得模型的计算是非线性的。</p><h2 id="3-7-BERT训练时使用的学习率warm-up和decay-策略是怎样的？为什么要这么做？"><a href="#3-7-BERT训练时使用的学习率warm-up和decay-策略是怎样的？为什么要这么做？" class="headerlink" title="3.7 BERT训练时使用的学习率warm-up和decay 策略是怎样的？为什么要这么做？"></a>3.7 BERT训练时使用的学习率warm-up和decay 策略是怎样的？为什么要这么做？</h2><p>在BERT的训练中，使用了学习率warm-up策略，这是<strong>为了在训练的早期阶段增加学习率，以提高训练的稳定性和加快模型收敛</strong>。</p><p>学习率warm-up策略的具体做法是，在训练开始的若干个步骤（通常是一小部分训练数据的迭代次数）内，<strong>将学习率逐渐从一个较小的初始值增加到预定的最大学习率，最后再decay到比较小的值</strong>。在这个过程中，学习率的变化是线性的，即学习率在warm-up阶段的每个步骤按固定的步幅逐渐增加。学习率warm-up的目的是为了解决BERT在训练初期的两个问题：</p><ul><li><strong>不稳定性</strong>：在训练初期，由于模型参数的随机初始化以及模型的复杂性，模型可能处于一个较不稳定的状态。此时使用较大的学习率可能导致模型的参数变动太大，使得模型很难收敛，学习率warm-up可以在这个阶段将学习率保持较小，提高模型训练的稳定性。</li><li><strong>避免过拟合</strong>：BERT模型往往需要较长的训练时间来获得高质量的表示。如果在训练的早期阶段就使用较大的学习率，可能会导致模型在训练初期就过度拟合训练数据，降低模型的泛化能力。通过学习率warm-up，在训练初期使用较小的学习率，可以避免过度拟合，等模型逐渐稳定后再使用较大的学习率进行更快的收敛。</li><li><strong>后期decay</strong>：当模型训到一定阶段后（比如十个epoch），模型的分布就已经比较固定了，或者说能学到的新东西就比较少了。如果还沿用较大的学习率，就会破坏这种稳定性，用我们通常的话说，就是已经接近loss的local optimal了，为了靠近这个point，我们就要降低学习率让模型在训练的后期细致地调整参数。</li></ul><h2 id="3-8-在BERT应用中，如何解决长文本问题？"><a href="#3-8-在BERT应用中，如何解决长文本问题？" class="headerlink" title="3.8 在BERT应用中，如何解决长文本问题？"></a>3.8 在BERT应用中，如何解决长文本问题？</h2><p>在BERT应用中，处理长文本问题有以下几种常见的解决方案：</p><ul><li><strong>截断与填充</strong>：将长文本截断为固定长度或者进行填充。BERT模型的输入是一个固定长度的序列，因此当输入的文本长度超过模型的最大输入长度时，需要进行截断或者填充。通常，可以根据任务的要求，选择适当的最大长度，并对文本进行截断或者填充，使其满足模型输入的要求。</li><li><strong>Sliding Window</strong>：将长文本分成多个短文本，然后分别输入BERT模型。这种方法被称为Sliding Window技术。具体来说，将长文本按照固定的步长切分成多个片段，然后分别输入BERT模型进行处理。每个片段的输出可以进行进一步的汇总或者融合，得到最终的表示。</li><li><strong>Hierarchical Model</strong>：使用分层模型来处理长文本，其中底层模型用于处理短文本片段，然后将不同片段的表示进行汇总或者融合得到整个长文本的表示。这样的分层模型可以充分利用BERT模型的表示能力，同时处理长文本。</li><li><strong>Longformer、BigBird等模型</strong>：使用专门针对长文本的模型，如Longformer和BigBird。这些模型采用了不同的注意力机制，以处理超长序列，并且通常在处理长文本时具有更高的效率。</li><li><strong>Document-Level Model</strong>：将文本看作是一个整体，而不是将其拆分成句子或段落，然后输入BERT模型进行处理。这样的文档级模型可以更好地捕捉整个文档的上下文信息，但需要更多的计算资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
      <tag>BERT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 04.22-04.28</title>
    <link href="/2024/04/22/%E5%91%A8%E8%AE%B0%20-%202024%2004.22-04.28/"/>
    <url>/2024/04/22/%E5%91%A8%E8%AE%B0%20-%202024%2004.22-04.28/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="544533425fa74a8439d8265132c3eec2112f85068293313d2bc0945dd1818767">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7411f3730728d3ad157eef2e34d25c79e6618b753a874ea2785fddbf12b56b8517e01c9a85969d5e37e238753fd0cd22b83e73c0371715178d7eaac5b0e8ba1c94d2fac7cbbed0eeeb68f0001724d28338136941f82da59396c69510a81b741a8fad8349f2479c8e20ec9d30f47a8d4362d166e862e419f900d053d329021582d9dd707b92d8592b708c681ba32fd1d056ce1615fe8ea7c84724d3bf4bb6772cdd3943fa0c8e0d74255397207b5b59295931f08912c88a9ab17a0d42bc60560c05bc9f0e3d0dc599cdf9bb348e6feb2235c93ff4e048f539cc03204d3d53b12875557485d6e4cb7179d454d2b96cea0de54f8acaf86ed5eb9b800f8e3f26a20ce8ae52772fb94bb20999c7900a0fbdacba0d7a5bf2978a532ca6bc11db1ecb3a47f34a3ab0f4a40ae66c197889b308ee3908a7f1cabfcb6eebfbd40769341a34eef55dcf343ae4fdac92a24f9c613f187cfdbfb3d9d652064f7657bd3a1546c4d1a4d2fce54c323fed2856535bff96c6dbca2cfb4ff31cef7eec43472afe0613990f0fb54333a4a68ba8aa87ecba4819b1ec5d40732e2ae636e7a7c1e5e861ebf451a155c4d54cc2d42dd4305b0360f7a033393748309ff08b775a2c8e872c90a05f790ef071328634f2907f0e609920d09e22c1fe237829a86b9b930403767f90ad80b39b8651c23a8c6dd4673feb8be480f19b960ee8d90045d39c73819e5063aa43053d6b03e3bef37d9f7503b331dc5051b530df47d1912daccafc74c1a642998b9bc02c5649ace36c35d3f542942b2fab621163be4dd28d12732378f915e532a894dfa965b740a850c85b299097617d4adc7f9325d4e0b1a48592bd2a54f47a24931ffa5035bf91aeed925284e1c528347ce049c4b26d8239df9d8722bba5f6338042a5f2799d144859a935af577cb58a20f2f347d8f6126f66937f2e303ed628c163691a308f204e02c8bc82d7287380175f8d243af38d3e009d346bc9036ccacf310a3633c4fb4816ad6e6eb5a1f370a9f1cea5dfba07a41277a762bcf710dcb756fe56c691a52a5b724c554d08f46fd61776ca1665a685d8cfaacb69c4740940b6585b2b4a108a0f48fa935a3ec6d4f5943bb7e6d7f7543372aa9deb182109ee1f4eebf899f37f778e35661b5f66bdebe161292c438f82ac9a5b9a3721f0a29c71593302196c7ea08defb666ddd80d59b78d34f7394f33ff4185fb5c05c27e22fcf0b142bdbf614be3d02bd169a1381130601267381a28a2eab38f096afcfa3423493ba06581616059c6ee54f825f15dea963911a91d2a9f8c8a75366b1d8c5ecfb4a2d50eb8ed2ba8bedff6fb55b074e9bb6974a00415343f2778f80a7867a32af46d8f68211ad6e767329375634823d1c66e922c5835eab5a040dcf9d98bbfdf5bee556457b18e8aecd75b8b109ebb8d5133a89983eccfb84cd4bb302dbe50cb893ada448913ad0525e61dd7984c4fd10bff249c3a51cebbe7d0c12670a9926006f963dd2f9b17c8f4d59bc7a849d59cf756c35d6eb246585d6c35ca7da75544f512940741c3871670c95c38ba9ba8769684df369b6ff032d7b15052d46dce5704ce1febd95e46726b9d2582b1d0ed3976a952808ad53fd5f10c5e12643aa26b3020cb2097146bd6fc8e2c82de6fe8e46434ae5198990256fcb44713c172f031ce2a14b7498c74de7cb8aae43e60b2fdc330c84919ea6848be85524c4465de40e4210b50c0f19ad6dd02cd9eeb03acc6d48884966ef80222726a76b58df735b7e87c6a09b6a47a933f80c39af3cf10ff5dfd5b420d682cd3ee776f9041a6dfa84e022dd7eddd9df1be5b57a8c1c1e49b7af025e494b6a289231a5bc0ce0b2576df7c9bb6f27b45ca4b174015d6c5a1cbe5435db73af156392696c5da6bab196d86ab0ae1ed8a4f56e2f927deacbed50b1a8a1bb4b122ba218c4fc401d97b74716e13d0b832a23cd8aaf20da1a59ccf71e57e1a4b8b6caf509bf599b9cd88d8c096fdd087ef28bfc6fa03272ba9997b76d28d6ff1f699d406ea036d6e18b5f0f4f83a594ed9549cfdbb4c30873ec62e3c2f3eb7faa69f9cea713e8dad5308943f4d56c308f7a371e4425960fd2f22cefab85fdb3c7a5cdb6bcb1465d85e89cd97122c3a3681e0665387aa82537c254287ecddc6008f1a0d153406a401f0c7e8fee40b0353b233b5e24d3d579976a088fbc37af19da719986020ffd73fb237851dc4f52d5f09c611f20fdfa1ac66fa7bd14b5f9a7a06c39b1ee523dcba50688f74030a8ec597162bf6932591b3f16ead19821294a3f4bf5ca470e57c1182c848fdd0a6a8d19e3bc18c09cfc3b0807f0beb97855a17dcb619bb1a0300311d5d062f6ecad08e2ea1040e5c5acda73cbe6fa641e12575a0f61b7c653fd6351b80dab3b7e55db4dc9c7aa8b6324803ae1742a606ab1b64976bd4ba2358b41efd489b85da8278a58650dc494faa05d820366466a651e5ee37c783e0eb3efc738ead27be02eb92c7e71a46b49d5adf631e94a5d1065a41eea39c1a0805c3fc61a8856096cab5e911b8230ada0c6c4fc3a4e79532afa5e826b31af47ce0fe295eb2682e90cb8862cea1bed58fde8fb08f6ff28e8a8bc189f89fac0aff8ba4240bb19476682e4bee4648e11ac23e545ea24624552e769cac6968d119fdf5fb8f5a451e36fb89e9d398fad2a5a21d4f1175bccdb912a4c2fb96cf18d1c351e16340b2244e37428b1b6d6bac421f533e1fae5bcc89965cb4a0f1e5e7efdbb58bc57468bf6d5eb74f3617015ab502660a4118b9cc80a3e311d3bb1295bbf41312f4d9d9d5c509bf679d39bea87aeee7a88e3e5a77a894b0f01893750ccbf9e4416639e0f5dc73cfcb73e954dd296d06ed302d125ce08d933a4a694daa544c796fffa7c886aee8bf2d51194ea508dfef666edb73050d0b7f24a327d2519cd2528a17a3d0538375750de90a7ed3106ede1aab87809e9718b228e27ea3574d9e82521ec4226aceb33b53cf6443325c425b65ef069e7d43f8f8d51d20a1fe2aaa595623ab66b519f3dcaa78cce4b7cae7ebadcf6af926db83f830c5a2dd2e255f7a33dd7085f886da8d5042eb999a05e72da4367281b33798569e8d369727f1a7650c92e0acc2f4c2195e9ed2294c47beb70ac08b435193cae6b7874585960ba5647d7226dafad3f252f405e4a76217a511d7d2176bd122a68dcfc2a02ae0b6a03f5e0a823159877b47fbcc40b9302890e66605047ab2bf9efee793aa622455b2bb8ba5567c92e719f0f93f777fc3554edab90fc9ed85ea0030f121f18ed0134fb1f47f5b51e3167aa336d1147905026219521293acf0afd0d8c358b3fd2e37b0bf14ff107cb94e04c74e4f2f7b05d1dbd6f710d5d71f1d5fb02104bd838e610f79103bf7d2ea775f7ba590653c54e98686089740f83a65f2df8e6348d845292934fa99d4050e404f1e520b39fea38224bbfdd2b4e4f5d1493f74df41ae6c000c5efb92d5e57ac64d269403bf1667d25b8dd794e85d32e56626cbc831badabb02cb4692197cd85cf9850298de64c9ad710dcd9e977fa1a0f182cd9bbccc9de5ea189ed808f955f7dffc124d1d71983c2e5149ff25afb2c43445fb09875261d91ba0a40b73e0cda0f6437d5b60389bf60eadd8eb3e9102d9fe6c7ba0c504f0bdbf052d57ac95830ac09f069f788ba8e9794fc7520caee4393f6a5d4ef2a155d9d101e4c9f0636389a014b495bc2614b27d7e5ead84bde9394d9f108c8d5ef49635ecf44189e0662d575b2480f39751d121f11eebf1c74c3021e9b805b2281103c7619b2dc1cca24b1997704ffdbeefbefef220375957fab1b1963a1cf7cb8ff2691e827a819da88ce6c4d6ce5c05333e276be8ce179917f59056ba8a26d84a53b7537bf6f894175d4ff0155606aadefc2b96bcfd1416a1f6f79be215d343e75765b52324562e92810be9228b10d188a75ab25ee3c7a6b6f89109e7fd613bca2cafd7f1ea211d1982b90f176af3fbce28ce704a3ea8fe0d4fae31db0f47edb6d5fcf09d067b27c4a8e46e90f4c7ac59c556992ab0314e3eb31e45e5177bffadc45b430753fdd67e7a6fe3878c9579856a077ea5c68a4acf59f4a268fc79895a8173d9e9af72490ed7916d8cefd9d7881cc5a38509ae49ecddd4a626c71bfca64d840fc1aea55718f67c592c784a1bb012fc2010559326feb1a4a4cb27148a08c22df4cab0501324b2bf68018973da4ea4c0778543999bcdcaa222a101a0cb83d2b0d335c8621fa78f0b9f7d530926e066ea1cd5a84bb017466b7b812c1573a216a4c609cfc1fd388483dc6ba1ce32aaa9f7cf644e6b43bc1efc2352cfb33801d9a7a64bf6c6b95307534ffd2214224edc3d63a21e60987f9020ff416d7c022d8ff58efd2f08d0d619db51ae1422c088a7b74edf1b419617dac0403fd413f879778eaeccc3b96a04b385c6e3f96c8d754a3ac5e424310cb4bc75409129ca0a384c3e780614d29a7c7d41e8a8fe6b5cbab745b5c176b6037cddf21bd80ba522dd02e7f0e502e809a11bf67c4370dc5fe0151ae90f08d52a1ef53ca899703914a8767769b50391fc272fa69ce50d6b8f484de4a1bc199859cbb576c0403ed7a2cf23e3f2056dedbdea53c4e06ee1e9a8ab754eb3400e0c677def3ab0b354b9bd4f643c375471b1edb934fc78e40d0145776e9663aefc60f10227637526308f249d591e09817e88d58a6dfca448f9cde33bce38bd10edc1907c88d587f05e5ad046cd1b62f00a9050de122aa77461edcb88a32cd4a47b8181a02e8fb2523236f47f15d0aeb2cfec37c75686b1d33c8c64f977236de79bf0d8b060896757edddb3ae19d807ad318950d10cf5b2cd46c0bab4ed2420dd5678b5c5a367a32014d67b29fcd3678ac71e5b90cbab9b4f5a939431679ecb8c7f7a0676963033f06899c1180f8b0e776d3e660fe79cacf0344520c83201d61a951fd5b04a89c1adf7c5cb4b8ebcad3d3aaa2b22dfcff267dc6331e52a413e401c837fb91d7fc65e9936984cc52d3af4b6308ab3c88d7d21c06fa527d428d7e3411a965a570dd09d01b889e9253de2f24846dcbfc1200436a57dceca951f999947321db15d9ceea69e6470a6d78c81af57ae83dfd8d2720d9fd4bb72837db8cf266b504f14426dcb48cb738db6cdd46340571d5b12c5a2591f00d8d22d86ab080cf32294c38750dd85173ae76186de0a6439d18c2b1829a2b4a652060742f65f490f780ba5fc63b286ffe8834b20bcb8a46a09b35a8f9db4cad6893d0a4e3a2990ef11422611a19d0f1da03c0dcc1bf66aa6309b0d7e27746443d8c031ca6b1d9085fe7c1f84e4428b5c2400ff54fc8a9a630933f88ce6bfacbb1674bb69c7ea0afb49caffd10cd878ae85ea7b9713bd711901afbcfaab6c9c263ab6b1574c37cae42f029bfe529e0afc116e697c33959709881230f0bf74d4ab06d40d71fd4858bec8b42051057e47ed8444bbaa26ebf5d401d2e39f41a5948007e7bbdf861baa2f42e7115e7ada7dc67a0299aa9997f6e092d538350348e27a70ad0ba8339eb0233984198d07aa69f0054d76b63c3ab4565e4e605469f1c3b1a0f107a2a9767712687e03dde7f26b5cd0d3cf071bb2f9f358e1a6326c2f19463bed30557ad847786a68ed8fb9e26702d9295e16b178cbc89af792453a8515c07d6b2964c498f0b2bdde28e978ca50b4818ccd83e66e917a16b8dcccf7889dc1c77ad352338d632a575e5555899034e7cfcba39ea17f4b9447f6b784e9ca08d07011f1439ba445cd2c1693e42b522b1e079aec47a4ad9778d23dc986b48cd8e431435ce51b71ed41ca1e5f0bf83daa70e8cc4238812b038471da2448a9fded1c349901a5310e2f6119fe975ec2d4c00ed101fe18565fbc0f3c4354f981ad619b156c8bbdf17ae9eaed69cda999f5bfa516b1d7cfb3fc24cd423c671441a1d5a4374720dcfe7cd77edfcf9fc60250ffa43c9f142343c8d4d5893b35cf88c6b7441f66479a02c99c9267048748eb1b51eb0c6a4bdfbf104371f8cafd2b53c388156143e935db94f024ab6fb2774021c1da057a6cca15f748f856746c916397fd23f7f1d3485ab10e070f7b5330d2ff3548b559706042d707e9782533df6e912e2c9c662afc457333b53a29639a4b5c2bbdbdb5b2287f818099645a13c97a39b4fbd170a80fdd9e21bf493cee803a9113818d58b7604e4d424a2d548bf673e52f7d42b4e1f2568148e19ad83df35a7432d4f4074fe1cc38c1d6ec5891321fd79cbe8b9245e64e28503b0278268e5a36e48b92ce00dbb07ebb538ad32532f1362f75c373d1cfd1e48d16d20ba1576492ebcc003d4360c6f8456e2635ae04ed11d0720cd47167803feb83cb81f942ca0db091f63e1d18eb5bcd87b7cd9e736e50b611012688f9b361c8cf9974a7663826c7a04bf0f6b9ccd79057a4bcaa14f28e7c51d2fabff40c1d35af09ad0adf596d98ad730121f98e8469b98db9feecb87491e6bde99c96b63a23507640ffaa829a97e90430880d1fc958d9ca6d10ab7fef1c73c976023c03e0c563a5db7dbb66d83816ebec8e3ec3ddce9be0bfe42c91d0e2e3c0e9e81afcd29266d82726455d81113c4a28cf10d503fbc83e950114e9d396148765d96517960eadd48c5904bdb677f1592cf08de3665fb6214a694e6dfe2c582bd4452e00326689020f8dbb039e0b84788782cf5ce0f54eb5300ea9ba4759165d2b301c4c85577e9de40cb547af0060ded38ac2c83404435d3dab15b3e4526b7a79dba4706cd1d511c8f34cf009eebbdfff6f8decf5c5fae4e9b803dac4f9c4fb7d88edf831df3819838633eee7460417b14a0f272ab91c8e9cfcba2196f233ea122c2508a887f02884900adc4864605d3218ac460cdd6fe544da6f6a647f85793b921644b1af628b245f8617a7650085bae6c1c690c54005013a577960f4f67e57a30449ca1ea72b64256aa7809985584d1eaf48109270925a2a854b5284f0f56afa818d787f3815c84623d08d8b191f6e6062fe6bcfec35a0f3db3349d1d0ebad04a48730ec83d0496eefd40b1f854d9bdb59fcf011a299b85f8c979a2c61b0dea4de7cee61a05ee7e8846976a7829bf573000ba47a237ffb3b67bcb4c79531ee693b697777d7413c732549955dc084aaf637eedc6a71568600592b5f26c4269ddbfbae0835111aac6290e915f3af46bc6b80d97142613927fb14914e9f46819c86ca5d3d59f3c5fdb2218cf72e420b14ce583274f7daf107f5cadade190e13e91ae303d6466c9b1c9720401d5c57ea8586dbad0d2fab21ef184b22e69450656edab7f8e0a2554a101abe19bfb1569618da1b7c3fccd8bda1211a9977ad28907789b242d55fb5d637cb2e337e8c929e6c152999c609b40ddc2432cdcc6546e337921e8686e584516f5316e676ed9b02ba6b8d70ec1da9955476dbf6820baa22dc061a3715e67613c97d40ef18665289a087c33f99a0cf8364018cd6307b7f38bae1985fe08a4b47e1b713f7eaf6651d0a33fa839695b1abb77375513ff26643aaaf6847e5d6f80eca6b00ad3d9985b6cedc3beeacbccfd0bccf5c138d0a7da10567c4a4608133542c821d139ac496613e437bc4c5e6e27a6686b3761f43b8a5a7c8d1d431faf5e5e6ba16ed10447df6da87779e9091666813ed555de45e68c9782919d4f973443c9d3e2ce905117128e4d9e211658197bc7e4de4248b793b06ef567dd58b43e0952ae95429996f059ecef68a3364c1172b1841a9f692322b73edd4e0d7309aafcb076e3044bef416ddaac8808a12d1076e588a30932bb80cbf2353268ccaa3dc5c0b071f9af13e1d09b25d1dc8f0a35b03e7c18ac1a8c42da72e43bfc6ed429a734cf85cc3ca38147638edcce6e1b9730bb48e1a94f338a5d8934707ff926bc7c7e6fb05f0cbe4a7bce4add2c5b2121eb18d6ef39e2551138c99e9be41cdbe75d649799c8831fc7f0a705bb1f143ee596da9a93eb6f2bf85d1f79f56fbacc6ba8c8286a4a031faad291ba4d2be94b7c9afb78f88be3bea781e0f5f3dce918b495afaccbeed3f93d55c7569dd4a881bc61581bddaafb41737eaf74ac7d1ef8df147ced98119083fc626b1a4260afb85bf6858f436741287110c67c26e715fcdcfcb8043e7f290fcb688a66f0d699b20d3e07edf65a1be50f29d2b257b69215091b1dc81b39be1c957e80654d1bf408e95eac39e67a8a7fce2863113b9f164e31632cc00f9e7b7465591d6ec5f721cf302af3b41a50450ffd6ad9250a609e28bfef718ae9722343dd28f3c31734e00e58c77d54ab2d2eb2ceb40b4f3607ec0839e42d013e65d79db6bdeeb95c1cdc6b906a5ca260256c4feaeeed6db2567019886b91eb1ec777f86543c81f94171287a7e0c1c84b36e93a4a15295063f84ed728e9aaf26a3a796bb13cfdca3b95767a6afdb9f53b13865a85a07bdebc5841aa26c0b358b738002bdd5a323f8ee99839565af5f444c4822204f92f1923be46f6044f9c65bf5c9ada0c8eb8c6c90aa98cb3ebdf2c622e0a4cdd0f8c49caaf639747bd22cf88a6fba74b2db435df63a3a9e1383db2a3401592f626d1b43bcba0816d876832487786d5d9f16a7ae4774e8ed716a049bfb225aaab3a6186446a34e343913580793de6b22c9bb75b6445e389103089661633d28d577631c08628ee3d516aa46f9dbf5d53326e3c7d7df6ce9ca10a9bb86c1993206638958fc56e5bd7a551dfb808377ccd72e0ff21af57100543f43d261f5e2f702f4f818174ca1963a8af3a89a5df63da85df8dbd49b06192e5129447dc5e4b1d37e49b8a72171dc5557f0b721e4ed3c48a2aa1885772be441402f10d1b5468a8ab4a4cc6a2e9d6e1918a0f637b41ae3e5d253edcc3c60a6fa130e74db63fd7afc8e8bbf5ee1842ba7b9dedc84274639afd703a5c5350a9e77c1e01efba0e7f6b75a6cb588bba8b426e42af356caec030dda6618f4406b851b8f1f5318be2a3205c13c6491f060aba3ed575b611a2eb2038e78105057304a7a18e77012e975673c1863a2328edf701ec6dab08fd6cb075436d2d6ff83065144c91fe5da28b3a785c8093f52359617edafbfd48ffe5579fede6aedcba3e029905d755105a2081b26176c7c688b7f4313b05dbe35a023e36ca6db0075f00731f63b1f0742e11b7a6e8f3cafb31a477e00957c41e0214677c9accf7e8195172e990b4cf855e56a20f6e78c1947e9ff44f8d1b58c5c1ec7763faece9082d6a55e26486e474df3197cd9fd3c5ac9335bd16806dbfe19b398f9239a72d5165a408c6461bf9e8a6b0ff43b1813223060d38a54b025e1c3b2b6aec0c3a7edaa9f21a87a87ea1cb3721b005fd9210bc65b4109fe42af2c1a5cfe450ccba8cdf45787a0a4403595911303bf22d3975a8cd28b2b5e5f523f6dccd88d9a7a2c9d3bec2b23da77c9d42193a298d1643cc1541b4a18407213dc390c7bb9e5e940022ebe1ef4bcd5d8add35ce4a4f265857607df07f1d3f730f1d3069cbf59c03c5a5fea10709fde23a3d38f521f6ae20baa15fe6a89904e438ac5e664e92903eeadf1049a4d8057ae8d0622e612b06c0fe1282777042104684c53992daca9ab3379d587f63ae719a98c0ee554e21beb2a13c82c36f69bcb2bb7d61149159ca6b307ca306fb310e5c4dc930e493cd63006faedb195345faac4ca72f7ec86ca2aab08c913b4e1c360610ebbf112e80a66bc358508b6f9efa1c7d79482609c41f449e0a99b9271c15483fe8c9b495e3508db0d477a100eab09db2b2a74b5234851181e94966640842542da6b6864b5c049f54660b6db8ec9defb6f4507a65514270edd3d98b767c072d7d3b9ebd0ff7284e4f21eed52d37f986cf500acee92cd4c2094784c1d846c1d513017dfc5ce1b0f72babe14a9366bf9ae20cfb3a9f7718b92ec273e497e5d0b115bcfd04ec25ca6c12ae5ea3d0659fb826f23e7230c25f42c5250cca439d092e5966d42d686923892c492ab0e21da20ebeddeb7d926c31858aa4b8f5945f38e8f59abf93c4360e76175a8f94f8fe3c862d65a15d896383ecff240fe201fe804c06a0a1085970a7bd281ef150cc8e3edaf0a8037acc071c3d427e54b7d5af4f578328fde81055d260983826e04fa9971b15b97f76e938b57b4a038d25ae17b99e09c6e04a8943a21a4469e80dea829fea02d73deb435e5fd1e5932a0af55217b4caa3239a1b8d63c1447360513aff6573bbbfd67b990753f1cfcc669147e569ac4bbac37da7cff195bc688cc1ae7d735efd9ab0a16dc4618e5cd688983d36ee4d65e02ef4f0f10af875854341fc7234141ec8ebc5dabac6897773098a98bbd57f2ea57eaf393d559571cc1b6dc78a6d19817f406a451118a37d75311f988e1ead4bb74c4e094bdf96f5f445619ac4c43ef302e698cc898863e38baf1be4ec25c32e64531207d5186bcc451d319f92de07310aa27f5306927eae57df019dc7fe6eb1744d7b3a1d78f931b138f9153bfe1e47ff4e0a78994d396256295e30ce10ee41c0f9df075aba3069913d246d39ef6c92b67ae031d7f03e86c52acc2159de5e2a2a32a206291592649165cd25f84c36843ec8ff0bd12bcef4e11b53a8b17a529caca0d7083e1b4176ffdfe7bfc6e5df4c65de17a463fc6094d39975434ef970032ce46c5f72978b1a4b9cafd0d9f5e624fa4fa41e222a1ae041f52cb534489cff6e1ad555f9d207c71438a95b956b9bd6d3b2a1c9ac7072ce8f5d06a8c99dc309cc945b990ab43b629f690aac0acb9ddb7f4f8f571e8f8c538f311278a4886fcbc05a04dc4834036e4160f4a46cfb10dd493f66f2e3754e1bb2c4d564761cb6ffdab9eb03ba847361bd6ecfbc8ac5d161d53509dc221f500ea53984ae3dc60aa66178954802a452237f64e95a66042e8f9b8fa493a74f240c143a79b880d716d4bf12f384c2f14d4e85ba44df669c9c027dfab094d521c5337e98dfb2608c50eff74b553fbbd0a83802f17c442238e7d0709cf6baa015c9cc3153864fbb635283b317ae0e38e8d4c39a708a3be626faa8358f69c874caf2219c6b8a17bc0944d073f1d90d3d07d47dd0d5ef7473db2b87f27fcf0f3fb5379e0e464e6e484b27f95a22fb0e990410bf8235e1d85552</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 04.29-05.05</title>
    <link href="/2024/04/22/%E5%91%A8%E8%AE%B0%20-%202024%2004.29-05.05/"/>
    <url>/2024/04/22/%E5%91%A8%E8%AE%B0%20-%202024%2004.29-05.05/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e33f4f348b851ccf651d60e087e434da159ae3618419ec974b35ce03145457e7">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7e154df9b866f1267f3c5f425fa7b1923b5cde0251672d03538793e9b09d5bffa064a6ac16be110d0f7c5925d75400c49e816575ee85e794573da24e91bd899e7034b5359b5b57c3767835a15056d8c43db5949da5a2b9f5e7616270371e84ebd37c4016c47283bd01dffdfa15517637e108a1a918a3b5413574653e470fa887955dd87763c31c1bf2668fe01f3befe8c5f97dfb47ccaaef9f9d7c4496221f34314734b2ccb233d53670eb85a10e82399153de5380a13ee58db6c52327d5a094cdc083d2a84a5a85dd4fe6f04fff12a1660c3c13de9fef3e12a133c67136a8bf122892791d6ac847727caec69cdbab645853666d24a83bc9007c6d451b1a2e4650f2f4b819e8ea9714705c9f0ca204627a9b79526a59267bbc72b80f5de2afde18ebc9b813ad5076abd1df02e17c0a654eb224ccc3ae39b4bbfd66ad28ef5894fbd29bf85acd17a778f64a514400826f8f7ebf83560f4bde70a8879ea292c53fd34eb66e4e0b4f1c4c618488fa2fc428878e9b15af977ce204426b91f37dc680915eaa13f93a25d7b6430d9653d9f1ee31482408421808f009320fb24905cd239e127cf3dad45935b91f2d19de553a078e95d691af406c37af1e78483ec643a86b22d48b3b899fc2ea21e163d608ef23eb6a71087eb0e20861ed17d8e704256a2c4b20fa943c0ad2e50cab4bf8f9d2226c1d30c4a94e4341e930dbc4f31cb7aa65028bb8ef14fcc6a059e89f8b027d13fb7766d390d543e34100ee56475b04a9fa72c9fbdd39cd479be67d14254ea7e7e54c3a4195ddefe0e9769041dea5cb90cf31832f2a9b1dcb9ef8106dc862d7c76d44f27d1768bbc36c00a6035e124ea1a87ce416ecfc143a32b2f6b0ca0d1a4e1859ce066092fa621974b797f458bbf631d6eac0992b4c9d6d839b58ad86f50ee2e9eb78223555c7f360aafb10295909fd9633bb22e35c859e042d1434c6483c6ec7b2d3af2aa3d96c92d4daf968c7effd9ff5cf992ee5cfabba90a0395ba8d8510fa94e0e356b59079760013cde32611238525ea82cb15f1797af2916741bc644973aaae7bbe84140f11e5f3e669fde4e3beb4fa53388065d5f7afbf23d085841677a8d80b917846080a22b7177dc802dde9c9983d7b917ba60f68056e8587aafd1547608a680fac3d20e98a93eb228e1ce5ff8cb316d96a7c08120833b63f6623d59080a9f858b829a62ead7022ebf85831c676acf832496c1e862526e3136995b90b1105ca9b654ee2e04dd47302c2c387fe37bae9775511098f1ef3f843c6c6d6747dc939fe10d44a00c307f1ccc9a8181997b86c189c016673f437cf916f767dbdd08fa78f77ae554c40dc434a1c5c8927f60d9725d4f6f0b627e8cc54704361535fdccfd2b6f1c257c572134332cb88dec4070dd339b0b56a2dfae4adf70dcb599966208d5977272d12a50f1b0c1bd491d36d9a0e4d5fef755ff9eff1cffed9cb16dbe64dcd2a21d1668b73a4a4076ae5e2a7de580a4fbe05b4364b75e0024968a0a7d00f71cdf8ffd6a543e5f683dbe9f29700b58761155bb3a8d3c32f7edac61fd479bfd4c131f12c14d0aa37f713a6d0d8d7eb652e3d334b55181785003f85d79ef516a4ae0511c3fa31ca8172d733d96dae1d901006a332ac25997d46fb4618bfb6e7b7461724ea35d593bdc36d3309facec8d8bd0c01a22ec345e4a3b17c3c68f2ae794ded2c15927e426591f2a5e8082019423955eb9a5a207bcd5852158dadafb378e5660f46ced797723586bc0278b4403da2c284fa56ac9536bfe7895fe84f59769a49f792e234a75f2c95bbff5cb0f273254a438bb60179e456c377eda5414d976c699c09521c035a7e59c75582b10c55cc4bba0004a1963ef4161a6f910b13dbd5a6fcb6784e4796f287b0cdea690c0f2dab92418bc62423c902d6b8daa0b2a9160ecd15f4f7b5358ceb2aa5415f6e4d6eaad4fcd534afaf5adb7090b0b02847cfdf86d1db85b0834bc5265c2e343866343eb76f3dc23c65a98d96b6c63e37b0b90236636a0a983387e6e317e65d5969bc3109033b4118602d1a44931c83ce15740b53ced63d37a2a3a5fc6a129fd13c1d24fdec5b223709637a63bd8e40ab0968171e55dd37c136103605ada6aae98ede84995bdccb42daaddf876c5b10c99fa808ea71b339a6f1c0b637767d351d5b27d147947e8bb627e3a0570aa9670cffee09fb43c37796d3030096e3f7107e18112c37c9b4a0b08ec0026a93a2278e49487e52df3a6d387bf3aeb135f55df9181fbd6bd8f9d2d8ad75acdf09883d20328634843a1883b717b6be343e81910bfff4f6ff64c21f41b3cef838f74baae9a88c247a7290ec155072c650e585a5a3ec9e9dbb580ecf97496eb0b7d948d69c0a2f7e7ca49c95e7b36f930ae991f28cc65e7776b0e1ae05d5c00fdd607e82a613a64776973a04bb931bb95c8d656ac5082853f894a0871d2c7a22388d473e10084aefb60424a42cdbf574746e0524d6da40fd2ccc36dac19ff1cbca5fafbd39f7707305fcf6763ede075d218398be7217f42829f2ce378c037a5bc39319c21344eeb658c506a0f64dd9aa07d30a078896bdc9839cfcde5fabf7d128c259a5e6df8389097d888a26cf203ae23c68720221352a0e7eab9a60d726de395feb89fd6c9eb9e611fd2939bb4206512a49e9075536e7d782c8c12d8bf436a2751f8494788522b8c0ba58fa56b0ff0f36bf4ada45269a810fe165cf481766f98e3684232bb334851e22d00b259f8497f52ce266f0e60f976d2031aa6d8d4a4284f650909cc6cea2c6d65bc741090285b4e88650f8a1a1cd198c2aaa048429c551ee0a1422020a6b8ceeea92928afba09df8b844e3e6ac5a81890e44ef6c1b44dd2be02a9f40f53c58496718bf91a25aefa07f52a80c3b82398d587670</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 04.15-04.21</title>
    <link href="/2024/04/21/%E5%91%A8%E8%AE%B0%20-%202024%2004.15-04.21/"/>
    <url>/2024/04/21/%E5%91%A8%E8%AE%B0%20-%202024%2004.15-04.21/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="096e08b575c3b66f2bc519a77e539af8d04c773c105c3f1b726e7fd92f235c92">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a79793475ebe0172ce3931a5f8c0e367b30ed20440b70f486cd38a358e3a53135135e779e600b7884480e40936b6915f0a55006f5f3698871204e00779f618407cdd6e46d2e5a774e2a2e6a7625fc5dacd3cfc0259a8bda32d0c33f106a0cbe123725542d4c3352807106d7233f23ebcb1459c141e47752b3f1f692a5232ddf6b0deb1750e4601291a3a9040aa19372b8de56be7eaeec919532b8a6bfbf5a28c44c854620947279dc363c043450a13e9eabc99c7d1e93ab07840cc0ed419a36f4e2796ffffec6d74eeb4b21dff683475fa93dbae08655f103143953afd0cde9805621de9fd8b4741947ee127eda2146faa7c65aebb98ddaee0190104b3a55ef344a3742cce334d7db1d4b8ba44b7eca89837260d64de74428eb24213a30498cb10dcb125ed01c758a8a24bef3666853ca724093a31d4802eba5801e4fddbdb608c33d6d4586e189c640e6cf3ea400a9b820f137fbf3fc605571e7ff4afac51fd1d1534885380533503fe393d7c2575e27d39c3fcdc5273f05fda176b3f91d8c3f90ef9d8893d47b68e80477fd2919d4f35c9e09a412b557d31749b25af8014a920f266aee2cfcc754850d65d4237f0c9f8b0c2b6b1dc174188ae30209b9a37dd0623d3a5b0674787cfa290c9453cfe35340f4614385dbc4697c524fa4374cd38cfb525a8265b01f3191e8b59a86172a53bfc297e0f25c25429ff9da770b93e85871f1160260562a1e886ac04f8b0b59e5a5d5a47775d129cd803b4bb0e3c8c5a3b67b59675eb475124cbae2097de0b1c173e9e568d542454be40321e2f28d014697145c2aa5fe0bc63f088368cd460f8b59c741cc3ff87547e540fd0721ad1a38f03af7df58b86b77196d2507d45e0c397e07afe8e9599b9b3175b9c51a03da073d8d2866c70e67cac9ca08c6739436b668f7eb55c656c70f5e75208b6e624e6ad8d85ca1220be7132c759208b7a45c2b19fe725316cb9455f6b5ffc8401ef38d49312a3c8d5065506952991616c656b1d1b796d9a9766458698403d82f1a2c70c4504a3e00efe8d156cb6a724d88882aed0b244a3fccc0b77da27fa4cb96c10e118c0d669fe8122855c9e4accf250462b6711286edc51536a0a83d66da7d8b4227329caf2d7be05ff3fafbf647d0349c135c0ab03595e6794a1714289d17e2854ea4f88f6e18ffe06be71c031afe56d52a439f66cfa464d3c19cdc2d0896ab67cee89d97d72ef1df2d49fa7fd9ebc0f08735e39e1ab71ee192f17fae788aa0958d7880340ada6a8de85845205078363eb417f18805d5f16508954bf543041e4ea467835f65edb682f3bcd80640f9ab1be64ce0ebf11dfd973a0479b1833074d7f0dca9e8595fe45a70acac49013fbfabf62cef5ba8422204b2872908f0fde910c4a069111c83a70834d4f8b793a8fad398cc4f42bd4031d80cd76b0af4a70e34f4e19412ae2a90896f5a0244a1c73ec3e58fca463c7b0bb22803a16db84bc52232b45fbc85389844e21829980f0bec73a72e95238dd5ddfac932a957c005fecefa550f8eae3a766c1e9e51124e991e31575f861f728205a2a3b80e68440b38ec58692afc26aace9551fe3a8768f197ef1acd99c69c5983aa074858f3b63f7ceaa36c768b131b7322be27bb0df1afe007777da68c1a8ef723bcc478ea3026c8da152373cca899c9ef555d08e1520796c49bff2a3d6d95c3f136a948a1bdd1fde3b7d54c43ea8a56879902720649fe9921c1135d541173eee41a6070d1c29ae02aedb200640830d58898be85f542dcd9303857c561a8a1df80ea5f182c703c97337ec2d94276fc350abd7e6705857b5ecea8b3e8b8b37f2ecfd3781692a14c3e9cd1c33ca141c97c4315c4dba68b4bb58ddf42bd8bacc8edc28e565988fc73236f938ecfe04d1da23e60929453fe6b92a47903d26d26c1a93a35d733b69d9aad3b52355c6108b33efb1be890727d63977a563984854fe1c1e0a4718fc872d1307890f8cd2045713bec37cd70c49d09dd132c7cb67efe869bfef24b688242a2c80e29c53863475520bcab8aec456c58869d03ba0b90496d19465345435ce01f21b9144b301fb937cc59aed2ca3d1ceb4c3d373e39e2afe4ef11bb0fa4470c7da3ec2aa0daedb0399716acbccea52fff41e77c0cf2760823120388584d386ef88c41c71119f56a6c192fb0fa3c658fb0109970fce53df55e5f81938389b354b313b06df3793436c1136fef8fbd777075a28771161aeff1289b09b8dae8e8ea65455822237122f0be54969f8aeecadde6761005fbc5818894a1f88edf8a5817f23b7a879c38469b3e2bd5548b33b106190cfe4330e850f33ea6ab298064811bc38595204d3d56c11840d9bdf1820cb3c0756b6fbc2036fe17152491a0211ab2ec43d2c334be0a6a9e7a9fc9980efda2d512ebd88b89b7840df315ae1739987386d10599871d2016b670fc80736223e4d085902c21e88b647ecb8e7c9c745e0afad4a42b757fb5709df28b94d216eafb3a20862b7b53eac973851f115ea58ba7f22cf415de4bb4f1d218b9660b7f8f22be4f47e7689ca7e1b2675c4e2a0f2a3c189ad0c3acd4f022a6a494ad549ccdf95f3f1793d1aca864a69073a3e9dd4bc56407c875c5746b928b7003c5f77aad49d978b503d84982f4d9eba630359f5c02df50d55e01638e6da269b2da99725cbe37537bdf1cce9ffb77a52ea45f1987a52774f2f7c93743f148b2b639a4f44c4d15f6342373631960d9a91c9a3f3c805070af489b330554924f5d35f4fefdeb56232ceadd20998fbc2ddefd97a2ebd1bde27fa822b74aacea2c3b51812dd4737eade3d3749d72330126bf5e4792364b9cb2075fedc3e9aae56191026c8033796bd80d2261da5f2ca336c18450b1601a2de17c21424e9a4decc9458db5d0e7f87e37bd0e2421c161a57096ff7adc2f94c4947ed169ca37c097e6f31f79def60d39fa585391ce6c78244f920a0b882a7922832d0631cdba279c51a82dddfa6d23588ec4062430257ad148a3f1d3802ae6323ddd29406cb92bd7ced0f026c2499375b4959ee096ff9253faa03ddeeb98d5544a6952fb510b6f72e83a9eefb0d7055803586525ea12abb35edcee73e7b95630dffb41acd22800407c906c9b200484440f6399fa6b9d7ec226dc0455cef315fd0f3e6913cd54650ce4ae487cbaec86f3c0b5a5dbf3aa84cd46dd39faa14977616eb274107deac7c762ea46f56cd334ba16b04ba13c9ff424489b620569055e658791cbcc3fd6ea7700b4f7cfd048740f8361ed557c2b0e21614fb968145607d2337dbaafba5211bcc22628a6d5f9e761085d2d64aeec14b206de5eb90540ff9bfde20fe55754ad702dd68ff21c1d2f0e4f4b8f3374e601fdf83c373fb2ce77f9db8bed1ae363f8237b0353a6ddcf8bb04e377dc452b25e9f4155a3d42b34101a0cc600a7bb4c3ed5eb870e854373598411307b8ff45f5c30d5d69ccbf064f9e5a94e1a87c1e71cceaba30b6627565d91fe8751058c423aae0985280f9f8c517bbaf08ba6d9723a7443c357da3c65e5d0a2ccdbdc9e9f0af979b20d87fc5949620e527e85154a7f650da01913f0c4d5982ac9f92f76efb21545895cffd9778e8ebb1436c7e23ac8ab2f1cbe333999fd355ecbb7c56f392fe4de5807c698cbfc670c8f5b051e88385828b2d275180232ac2721e0c7fe2383ca30bf7fde98765057cc8909fdd778621ae1e62e4260842e8520ace98e5ed5bc0e439afdb75f751643b80740d1ba02c907ec7107b94dbfe01c5c4174af9c1b9ab0b74b8845d834e086a122ea938c9bb9d01419348c32a23ac21f85c86131612a36b2461ae54f2ad4c2be36e54ec45b5d7873535f6115462e1305259c97f93d99abd8d99562e27ff512f728dad067ee675615c215d9d5e14f626d74903bae317ceddd1d025f31fb4f5f2a149da214252a88f5658a13de83b7abf748a7c1dec256c4d7e5c0b47150bbb311fe20aaebfc6b0a99fd1c208b2ec37eaaacc945862dd23e858a32af90c111709e565cb84b58e8ac501c6d4fac96ca18f1d40bd8b7ce1bf0cc44ec9acb62d0e111eb611c4b7281f2535572f9704f3d01ed4878436c8692f201df41d13a94bb022284ce0e5af8f3308db9a08b0b795566ccec33bf92674ea27a04b3105fecce014d1ca90b64f456ba7796d499652d1dd4f78c775eb62ffbab638c3e1628cf3cc461bfe498a803246eb2989d2a37549018239f7bb7ab74e5825629638724dc5ff5c07e975ad6efe76a21948952a16c0c90ba5b85402e414b72b98044ac787021e0ba54314ac20df8e45ae25a597b4e087de21a40b07db93d0e54d2057c95db5d4b55aa79b4791d177382ddfdfb73ed023f1bc7eb6d5aa7fdd081488a07a92ccf5067e62abdf116cfce19330cbbf69257b011179fc9d36369a4b567ddc8775a9667c4261be8757d1c1e36cfb22b782f7edd51935cb0ee66c6026c14500919e71bd07307ae8293c1fc108a4d6b27a714171a7f79e88ae087c44314ae0176ccefd1ffbbce72c1054b0bd6f830d507c4ebeb8a7ebcd106a84093088b800066fb1de09705567ef021b329f3518c0ff9ae4bd27497ea1c269b2a743dceb8ff9befaaa1c7bfffdd4e1a1c1574da99c3d27663b7e732736547d4fe22ad4eef23ea55e3d9edd0f16dacf05bc118f3d661b062a4ce94db87d4cfb687c86ab3a2bedbc3fe576f02e255aadc8e4c81119e59e3a3b624203618e225a46821976a99c94fb2bb5b4d6b88433ec66ea53c953d2be73d85f53f54acd297fc118c92300f84a49a59842f107168b8dafb2812d5b6f23a84cb1cbdc1584ab97bc7ecf3e3f830c31ddb09c343812470d1e5e067550e5f5aa6f7b54544ede09892132055d5f0612c22c262811324de91c6c8bcd6cba921db253d2c730b763ea7823774d9e0c3b7c9aa050718b1f3bc2025716805cc520f09881f05957ec5c3372f1fad31c7352a472a26364d8837e87daae9efd838b703f9f2a354deb4f95645dccca5c7a38b2455fc4716051f16d9ad6875e1a72255f01cea2d380125462dcd33b0767d9e5663faf92f4b70b5ae03080b5d2c5aab5b5ca4fd52a371e0043b734746e9f6692398e10bb3e0f7fd1fe9f2cd5ec74f20647d619fe65f1da71ca6832d2ca2132431ec4a1f6f8215f49d14ddd18592921d0b9998cccce0d94b0120d2b2bd3ace3a40d73dc8d7f08118a9892f898c84ec750cd56ba8988b10b0c452c19ba041214777f502d1915134051110ef5db23bf1c3fe14bd2a16d291d39ffdd64239ecc202d53acaa2ba8c75ae9cc2463cb0dd232ae28ddc9ca08762a9774de94297736a4f343afd1cbae2cbd310eacbc21a355ac5c06e0510f988d139a832292ca03b0e3b3f20a1cc3b74e45e3f93c5fa7a8c2458b6d3a50c44e31d2c370a9e21fa1dfb21b62375ed155163d628fdedae4ea4fab46c03c46fb0e130f4d207284afbfb4cfe289a6ff75e06117abded4dbb661d89710cfccd95540f05198e01aa8357fc325c1f15228627f64700914ce403f7de19a2a81459f17f89d090937f6aff21836795f04eef60b03360aee3897b9fd58d76f1327ebaca8333640acb87d3e96b1cce3bcab05e25d4637660cbc37be1ea24ad76835cb69d3106525dff3ef5386e8511993b646a19bf0df0afeff5fb47ac4a2dae531298b3a8dad257f923fd328ac095ca680717fda3e3df3cb6755792bda9e4bd5d0a4f4e989c764687a0d75b5bce7d417fcb8322cb595c43d518fc4ee7f433bde9f8b358b58eebc7f49e88fa9af227ecc60a2af0e106a69bd373f7d8abe00a0b2142eb9711acad9fa38a6956096ef6906ad1d4ae8c931784015b1e42a7a57e9fd3e90511cd7112231f165d5a6f17afdcd1cff869c08f7e76c311c8afd04df2e6b8822a0f56a9c293d51f6d70a2ccdd65a990171af2a62dd16579016a427d60f583253da7c8f6ed8aa0803354f8003ec8510e612a05706482ed23e2f39646de8654a293ef31383efbd7982b19d8b9208e2b945068a6cdaff094891a293e749c37b5b0e2ec0bdcb94829b49cf0d74b9bfa9f9f1b619d66738bb2c8873b915c29fa14bedead9a0963976903b905507b8741c410a9c08d26dee30cd644de407abd343c974a23335feaee5f0f43a576a31cd34e39969e4db9b567f735517bc6f7a96c9fe4a904796505e59fdf5ceed14a70cd84db9c6c603c1b7c852e06606e1d94a870a5ef9de2acd484750f67dac291585fde4ec3e9afbd69b86510f660700206f702868c04d0a307d38152a353111cab6dd98db2cc5b2f92c23c05f1a13833a4454f9d67c947ea9c271a00f2d206ce5d03d09b87671d54f1893153c5128992ff07bb2a43dacc6086a0ec9c9ecf8e6c70cb04a850b2f36184ea5b8d9a40e3cacde7dea964400ba7c6fe27aebcea16a080b454d9babb864d7b78d0590313788c4d6f058d3817b3183e34c71b953ea179fde51072247cff4408dfe2056901866734877ba96acdd42923c80289aae72b399fa59512fea8cf360690ac6a5ef6274b9a70793f366eeda3f449378f7c030e467cbaf5affb7acaaae5df49e080bed640647c83ce5d97b885abe3008135dfcb8ec77cc83057862363f4a94812541ec9cf18ec4095824b459c93ad6705e6d7ad35338cdcb67133ae4b9c601c5e863aab141db9bee4fa9e766e48939f35443c7ea4b3fb0b4e5d486cda2aff688151fc856079550cb370f388dfdaa7d4e8145adfa0ddf3522196a810238c7cd76e36585ae39e81a0726a7f37117e0b7227711fde48509cbab5e08787769a59dd60fec0dcb18996f50ebbe4450a68af72581d9c1f820f50749d46c00755dce5669e018e502cb334df2c1180d67e721a1338a9e553173e3f67b614118c95b1a3bba85d03244cad650787c2d228bead8ec95fabb608d07c73cf3db6b3fbf545ecba04f09548f2981a6f836d4a8cf7c7e9932f10332a338330605542b96cf44e6d3af3ec20e303d080bbe76a482fc18462f0cc490f54e1e3bbd8809066060b1b4ce4dd12057fd8ca0782482c0a898cfec6aae6dc0e2a5959df50304f4fe1b8ae3595fe5dd921b99c13e0aa2ba9581b8238ab1888ce652a05746d06aa1fb8101b9172dce8dda2c5649b8a4b8dbd2d24ce2ac677f1a0336c39ffe5219d3c960e28830a2304e3986641a3eb92920ad4f75b4789ed84cc181f9775b21267e6de3e48fbfd592c84a3086147dafb1150f7f2e485fa4ae604a3dec84d0580e293e9f7c80de875c9f9c656e0261f8391cc7433f3e720c5ddf4246f726a4b1e6baab57e582e355fd86e2c229edab0c359709a734107b13838279efabf0d3a791500dc23448a51c8176356c702309c273a63642fe42f3c5b7b9faafb0185f4c0fb4b81bc201775874b9324be40bca71965f9980095bb603d5a7ed09975dbd031f3fa0fc21418a452d28c44d00f879ee8c582f281bad9d386a38a011c0a46dd3412c5aef92b0ddbc4210664e8596eff225ff1aebe1d3199fd14790317b2606d72bd0c6c43ced0c7051de14c1c820a7db5973efccefd45790fbb5b0e302ae3098c747a729f2316c9ef4609bad4a7f8dba88d6e68d1069cc44ce325cf627d11f3db17fc09b94e459aa15bfafc8c68de8b40acc7fcb6cc00212ca52f8edf533bccd861c038d4eaaf5ba5fec12a53a624e6d601cb3108c6a91202427eba0e0260ae5623c2a354c2bbe73c77077efb91e41bd5b71270c79b10e5e64558e92f2cd7f4b6fe58fb17e44ce4eabffedaa4babfaf283bdc16cfbf2a7bb0b14ff2bc62c1ef6179de3d45633ef9a6b0007e1ba3b89fb00d90ee5a5df8b3085ce59c0a72b10dbee1462c14c6fc91c41d96512907ed466155a4566db52935712aee57432114cabe842ef17fec9b253228f646e575765f69a80fa94ab25b533477a84d1d0d05e48c32b0c5e7873d441e65c627ca9fe4988889fc69288e0cf78d317845d53b31d208a3b1d92feb2a7d5f8723275d7dd01c385625f08261c70bebfb9f79864314790572492c8c3465c41acabe59d2aa26028d6204f6222d890780b5e25fdcb2239843796a99a17c68dca870cd4c8d1a002bc81400addf3e28e5535a372e01c14c95bc5f87542ed30a0777890cfae90841cd39c9a6d1ef4a5c071f60a4d0c8fca458ba8fda48e05ad8a1e48423e78231db080073140725e87ca5c7847a2936486c66d9643b61193604d6aab950385649179c19b02fadca4bfa67e04e5eeb63f1b1e6486bd61a0c0b25dabc9684eed3fc6594ce9602e3265345b2b1b201bf360ab6b0edf1dbed3feba86a150f8eb5a724c1023cffed0d4a05322e4d351d9bfafcfdf1bc98882495c03d5103f03caf3360bc962eb42f4986671cda8916078b8830bf05edea14374f5ca7873b5ee111ed5124d630640ea5e49c110a24633ed5fd98e2ce85fc765b53b900890912d184469fbc27bdd718c6735980814263272ac903703c7aaf531a4071c74f5e81dc99b9356b69e0a2f8f135dad7f5cc5184d2bbb940f2926734774dcb055d83eceeaf0339438720b9553f02ebeb58a1bda5e09c8f6454e52893d7df71dd13efa9ceaf9291148fcfeb792e84427116a26b769044f1bf9f72833a53d74cadeafb1187d21d8d5fdf0f559abe4916f8bfccf6801f7de739eb72b137212d8fe676456acdb0853d125ef642db57249a3240e71eb25af298c89e8011fd10e6224a932f16f5e71e2265a697def30c2d0fa09107891d24539912437558c8d10df6259c142d0e846337f74c30f6b145d6356ae006e16a9e98ccba33e23175efad22254fc45701c35d2fa75c6213ce96aeb8341d3ca554c130cb2a63d65dd83b77d9fed9bd59b32bab147cefd15fd4e9d2c4709ca1829d2c71dbdf52c054de06527bb81f88785c09719b07847abf059ed1af48cdf0a10f6129f748524dbfa36e8efb627da7470b4f40b3e8971025a3253debc2e0b896f0449fea63f5972ee1687db4549affb6adb5166e49db32a1b3c31de81b4885066aa84dc2e508667a4c1e08e4991d30c6c588f3bec88db620de1deff6a0ba8058437302ed09edfdf6c49098357f92f5e4735e7f81ae890be11e5876a37771be8e68552b224a11bae7ef5658b57be79263c65e785de804cb275f0d1c4b12dc5e83753436b805c28455d4ad0495658c0b8015f34646408b77841dea94cdb4fa9a0011b7f1c147d301beb790e10bf68484832e1e0a71af15922557ec29552b5f1049356c235fe607d29d8ca674f247945ff3781712c67a7bdd959a216f3f68236a22c1519ee3c065227a3294f2be4fbcddb676cc75e661e13230bfa09a4de409e3fb780ba3a126328f6e0864a5fcb2a1f4e32e629dfe64d720e9a50981b9cec378636e64bae6c8a546c5033042e6453b1915613e795dbb13375c2419f7e552f9d9321e3d3062ad6527dd801162d4fe4f05d3882ee2d4c13db3bca85cc2e02c820ffc7663d686db93676fccd6d7262d8ceae0aec67e47deb32745bb2e59d73e9aee4e7d50a94da8a88cf8b5f8309c5904ae8f8400e0d2e245f4078cfdfe7548001ee213de470953543d22c070cb19e7ad18b46a21ca8f744a07eb1e90da125b1763b253910fcece0a4d34976a0f30ef3f0072d8b7bcfb3dd337d2c0fb22dffad707c823732731026496b5a7a57c39a1cac1e919146c9f3877f22ebfc5351d904c689b9ec606e1f71200f90e0ff1a5ba60c83a769b2e660bc1f5aaadedef4fc1d3138ef1f8c2dce668d179daf42e9bfc6bdb6d949557b2c425b44e2619f41ab47a239eba0b94abd208a067e0985eafb4a5077374505da862981703e28a016f171f59e8bf10d15333bfef8951cf5f58c2e6ca20d4b9005e52e2a930218b4793817bcb1aaad6c81b7e0734aecbe1616698fc6f85958c9f08394955732445cf89db6c25aae1133a2f2eab2a3c833b484d0152862d56ecb83e3b048c3bb8dc138c1d8bc9224ae85240d3d6bec851d2a802885a296dac446c44fc0c0a1bdc81b9f75305e47c5c9fbd9b38bcb0d2fafc9236fadaa5b97d4cc19b1339193d669f33c19358c1592b3383a809e4fee308143b8dc98415045234073bd41c170f52f4dd6ee945344d426ac1bae421fa5b8292bbff1625b2367a23b8e98aab1c19f3d9454e9898cc4e42f2eac4769c5b134624020cdb6ef6413d5b37ea4f561fc942506ebee6ce0dd443e21a2be482f4a1d01ed6ff656b9abe061659fc2dc0ae14d211ddbba0d84ead5b9b9a4534d67541d7ed33b5f3ab9fc20dbb7825ea93c5295bc6fc780e98257a32de509d1cc55a98120d0bf878ce88ebc816e0e8f9db5065bd025c7cf3808313c5b18fb1297f92b2778db70d6ea9e9912879215733a850abaea401a99fbc46c1623cbfd683ddfe5824fe7a72d7aad05c80d0f21b6dd7e4baee49dd71d58d0f9a8ea0d0ee2306de5fa894ecda4cd0e15abc87139f476013edbdad11846e29187b7a63bf7446061ae500b893419293d4aeafb452f17303d04a2638e0f204d37666d38c156f513ecab92459c632dab7f339f06262a12a50dffd81a82d68c3ec0cea77f38b5b2274a1ffd6b6623a9a89ff02060516288be25eda4867030eab3e2300313b16a9751985bdf6c8f81e290eb602bc0692cfad7eaa3e3d47063fd5b8bbe47d7a700bb132d94ecbe6bfbbf55e7176c3158c09af6578d01aa0414eb1534af3a06972cbf4871a6b87f4d0b470d7fd68269015dbee7967e6a1f272e0045216863508121187f3c86e7c810ca2a668d5b1bcaa48ffc1f8e787d7ce85cdbb90814d7f9551e201bf6d0452d445a24507cfd8c14b95d786139dbcb4f7242bce1f929baae972063d1359039072f90071afd7771e76fbe6253946dbd5d8da67f7b20ae15ce9acb12f2954f1e16f3328d2585a6cd1d7cdd51872c41e6d7e0beeb347c34fc076c47112ea313d13d9ae3d7a69a37ba2c547dcc974ddbb5bfc8c74d2e4c741535f8c7e046f64425ba0b2902ef7f2f08dc40d9b388079c8865a804a987cf66a0f0eb935d6b480840de07ff52be75787d3c6998186070d51bf0b53ac2f8c7e0202ccc953249cde9bc2a4e9cb66cb72ba45fe01cad6886aeba7942c10c25ee404a101d78aee9ed99e2a339498ed45536f80ef1891caf8c6f56bbe3d9b6d5f818b8c11669625a4afc2361f720aca3b11d877c5825b76c5d20190bcb52744a175c5667268682f8052f787683489052dac484de6aa10983e12ba8c417b5966e43e201042ad0e98c20ed3c65089eea7a48f5694af9d79d5b22054c8590b51bc4341357310dbd63e2b3bc5cf96ce672d2722697fd904ac4f9dd94382a37e8594187974563440ce151dc62ee0b87b65909cf85767aa2f409919af6e4bffe152ddbc59b73540c8f2aad58fee33ca9227886da07996b6145edf7e26fc0199c5643b3a71ddfec329730383855514a0f87432551b469fe2cbcf11cad85fe2c1a59eaffbb124587b72d05484b5bfa1ab4cbc0abcf196ce8f7862a44224fe2ba2f1c57f3ad17cd813d71d4997f2887c9c651f105cc21a4ddb306523473518ed714352ed2e98e24221431157f862950b060db735ff20553255e6e98d52b560790661431198dc0aa6734695c4fcfed2b52e935ea83b9c3c8cd828a38263daecc4e1ff694ca0fa86ad6548c5c7787aa21278d5c4b81a898af01e9b4cde39053b3b6e91c6322a3efd275863b3e325c860a6ea2b161554b3a44189cc3ce6a3f24e8f480999ad5d3774b5a272c1079d7ad06d9fa24a85dd1bb76537767b92ca27db18f12a1cc0f0be52d762efa72097d900fb1fa0c9dda3bda6fe4ec40646137157c08ef64d1afc40bae78e5a2eef78d52fc0aafddc46bd4cefa0c538905d114d7b6abc89ed8f02a8c505150c8df2f2c0e9978a6f103f55efec24d2e1e56b03bc7ef3c98fc07fe58a2641a3d961d92a7473f11d42b75b48a7e37dd2b8d29843e10f815109493d201731e222b15f3322318bd49c8c0ca2e663add107c54116dba9b8125ea1db24931f1c8e5d036441f0f851c5d296e7fd348c3db357da917afb9d1979bb1a1f45f6b13f44746a7ce0d700463e506026536778007572cd57e94fced71aa952f72ffc70b304269f25cbb36718d2685f558db44839effa4cb04ad2363d5f95a0b4755e3058245b89f58573048fc92c2d70f27b03c0dbb2681159ec2e5d62fcf35fc16e25b3f5ee1d9322f88720038340b1f6685a9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 文远知行算法岗笔试+面经</title>
    <link href="/2024/04/18/%E8%AE%B0%E5%BD%95%20-%20%E6%96%87%E8%BF%9C%E7%9F%A5%E8%A1%8C%E7%AE%97%E6%B3%95%E5%B2%97%E7%AC%94%E8%AF%95+%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/04/18/%E8%AE%B0%E5%BD%95%20-%20%E6%96%87%E8%BF%9C%E7%9F%A5%E8%A1%8C%E7%AE%97%E6%B3%95%E5%B2%97%E7%AC%94%E8%AF%95+%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一面（视频会议）04-01-50min"><a href="#一面（视频会议）04-01-50min" class="headerlink" title="一面（视频会议）04-01 50min"></a>一面（视频会议）04-01 50min</h2><p>(1) 自我介绍</p><p>(2) 聊项目，问简历上的。</p><p>面试官对我的VLDB很感兴趣，于是就让我详细展开。</p><p>(3) 算法题。</p><p>第一题：给定一个长度为n的double数组，求最大连乘之积。<br>[1, 2, 0, 2.5, 4, 0 -2, 3, -2] &#x3D;&gt; 12</p><p>我思索1分钟：</p><blockquote><p>可以根据0的位置进行分段，然后在每一个段内进行dp，需要考虑负数的个数</p></blockquote><p>面试官：</p><blockquote><p>有点复杂，能不能直接dp？</p></blockquote><p>我思考5分钟：</p><blockquote><p><code>dp[N][2]</code>表示以第i个数结尾的，所有连续子数组的最大乘积。其中第二维[0, 1]表示对应的子数组内负数的个数。<br>（突然意识到应该是“连续子数组的最大乘积的<strong>绝对值</strong>”）于是赶紧纠正<br>如果a[i]是负数，选上<code>a[i]</code>，<code>dp[i][b]</code>就得从<code>dp[i - 1][b ^ 1]</code>转移。如果不跟a[i - 1]连接的话，那就直接是<code>dp[i][1] = a[i]</code><br>如果a[i]是正数，同理。只不过不需要考虑b的翻转。</p><p>最后答案就是所有<code>dp[i][0]</code>和<code>-dp[i][1]</code>的最大值。</p></blockquote><p>面试官思索了一会：</p><blockquote><p>听上去好像没问题，挺好的。</p></blockquote><p>第二题：给定一个二维<code>n * m</code>网格，网格上有一些障碍，障碍无法通过，同时给k把铲子，每把铲子可以铲掉一个障碍物。求从左上角到右下角的最短路径。</p><p>我思索了1分钟：</p><blockquote><p>如果<code>n * m * k</code>不大的话，比如在1e7之内，就可以直接暴力dp了。<br><code>dp[i][j][k]</code>表示从起点到(i, j)的最短路径长度，k表示当前用了的铲子数量。<br>如果(i, j)是障碍物，那么<code>dp[i][j][k] = min(dp[i - 1][j][k - 1], dp[i][j - 1][k - 1]) + 1</code>。<br>如果(i, j)不是障碍物，那么<code>dp[i][j][k] = min(dp[i - 1][j][k], dp[i][j - 1][k]) + 1</code></p><p>答案就是<code>dp[n - 1][m - 1][0~k]</code></p></blockquote><p>面试官：</p><blockquote><p>不错，挺熟练的。</p></blockquote><p>(4) 反问环节。</p><p>如果我能通过这次一面，是不是还有二面？如果能二面我需要准备些什么知识呢？</p><blockquote><p>是的。需要着重准备一下MDP的相关知识，你统计学专业应该也有学吧。我说目前我还没学到，不过我会去学习一下的。</p></blockquote><h2 id="二面（视频会议）04-15-50min"><a href="#二面（视频会议）04-15-50min" class="headerlink" title="二面（视频会议）04-15 50min"></a>二面（视频会议）04-15 50min</h2><p>(1)(2) 自我介绍 + 聊项目。同一面</p><p>(3) 算法题。</p><p>第一题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 按从小到大对数组排序的最少元素交换次数</span><br><span class="hljs-comment">// 可以先不考虑存在重复元素</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MinimalSwapNums</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 1 5 4 3 2</span><br>  <span class="hljs-comment">// 1 2 4 3 5</span><br>  <span class="hljs-comment">// 1 2 3 4 5</span><br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alls</span><span class="hljs-params">(nums)</span></span>;<br>  <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());<br>  alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : nums) &#123;<br>    x = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), x) - alls.<span class="hljs-built_in">begin</span>();<br>  &#125;<br><br>  <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    pos[nums[i]] = i;<br>  &#125;<br>  <br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-type">int</span> rings = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (st[i]) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> c = nums[i];<br>    st[c] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (c != i) &#123;<br>      c = nums[c];<br>      st[c] = <span class="hljs-number">1</span>;<br>    &#125;<br>    ++rings;<br>  &#125;<br>  cnt = n - rings;<br>  <span class="hljs-comment">//输入答案</span><br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//打印出长度为2n的所有合法括号，比如n=3时答案有5个，分别为((())), (()()), (())(), ()(()), ()()()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;  <br>  <span class="hljs-keyword">auto</span> check = [&amp;](string s) -&gt; <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-type">int</span> cumu = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>        cumu++;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cumu--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cumu &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (cumu == <span class="hljs-number">0</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// O(n 2^n)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; val &lt; (<span class="hljs-number">1ll</span> &lt;&lt; n); ++val) &#123;<br>    string s;<br>    <span class="hljs-comment">// O(n)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; n; ++b) &#123;<br>      <span class="hljs-keyword">if</span> (val &gt;&gt; b &amp; <span class="hljs-number">1</span>) &#123;<br>        s += <span class="hljs-string">&quot;(&quot;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        s += <span class="hljs-string">&quot;)&quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// O(n)</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(s)) &#123;<br>      cout &lt;&lt; s &lt;&lt; endl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// cout &lt;&lt; &quot;!!!\n&quot;;</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>补充：可以用check函数的逻辑做dfs剪枝，效率是O(n)的。</p><p>(4) 反问环节。</p><p>如果我这面试通过了，还有三面吗？</p><blockquote><p>一般都是三面的。可以跟HR联系下，约三面的时间。</p></blockquote><p>实习待遇怎么样</p><blockquote><p>之前我来那会是400一天，但是现在据说好像降到300了。</p></blockquote><h2 id="三面（视频会议）04-18"><a href="#三面（视频会议）04-18" class="headerlink" title="三面（视频会议）04-18"></a>三面（视频会议）04-18</h2><p>(1) 自我介绍 + 聊项目。同一面</p><p>(2) 算法题。</p><p>第一题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  你必须定义一个 `main()` 函数入口。</span><br><span class="hljs-comment">  you must define a `main()` function entry.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  You are a stock trader want to know your maximum possible return rate during a certain period in the past, if you always make the optimal trade.</span><br><span class="hljs-comment">Several restrictions:</span><br><span class="hljs-comment">1. You can buy any portion of a stock, like 0.2 stock or 1/3 stock, but you cannot short(做空) a stock(you cannot benefit when stock price goes down).</span><br><span class="hljs-comment">2. The stock market use a special &quot;T+1&quot; rule, which means after you sell a stock at day T, you will receive the cash at T+1, which you can use to buy another stock</span><br><span class="hljs-comment">The input is N-day historical price of K stocks. We assume stock price does not change within a day.</span><br><span class="hljs-comment">The output is the maximum possible return rate of your portfolio. (To make it easier to understand, assume you start with 1 thousand dollars, output should be x thousand dollars which you end with)</span><br><span class="hljs-comment">Sample Input:</span><br><span class="hljs-comment">&#123;&#123;100, 200, 300, 400, 500, 600, 700&#125;,</span><br><span class="hljs-comment"> &#123;200, 200, 200, 200, 200, 400, 400&#125;&#125; (2 stocks 7 days)</span><br><span class="hljs-comment">Sample Output:</span><br><span class="hljs-comment">8.0 (Buy s1 at d1, sell s1 at d4, buy s2 at d5, sell s2 at d7, (400/100)*(400/200)=8.0)</span><br><span class="hljs-comment">Sample Input:</span><br><span class="hljs-comment">&#123;&#123;100, 200, 150, 100, 200&#125;&#125; (1 stock 5 days)</span><br><span class="hljs-comment">Sample Output:</span><br><span class="hljs-comment">4.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 100 400 300 400</span><br>  <span class="hljs-comment">// 100 200 300 600</span><br>  <span class="hljs-comment">// 4 * 2</span><br>  <span class="hljs-comment">// 6</span><br>  <span class="hljs-comment">// dp[i][j][2]: 前i天, 当前持股j, 并且当前卖出 or 买入</span><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a = &#123;&#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">600</span>, <span class="hljs-number">700</span>&#125;,<br> &#123;<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>&#125;&#125;;<br>  <span class="hljs-comment">// a = &#123;&#123;100, 200, 150, 100, 200&#125;&#125;;</span><br>  a = &#123;&#123;<span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">600</span>&#125;&#125;;<br>  <span class="hljs-type">int</span> K = a.<span class="hljs-built_in">size</span>(), n = a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>  vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(K, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; K; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>         mx = <span class="hljs-built_in">max</span>(mx, dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; K; ++j) &#123;<br>      dp[i][j][<span class="hljs-number">1</span>] = mx;<br>      dp[i][j][<span class="hljs-number">0</span>] = mx;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; K; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i; ++k) &#123;<br>        <span class="hljs-comment">// cout &lt;&lt; a[j][i] / a[j][k] &lt;&lt; endl;</span><br>        dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>], dp[k][j][<span class="hljs-number">1</span>] * a[j][i] / a[j][k]);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; K; ++j) &#123;<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[n - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>  &#125;<br>  <br>  cout &lt;&lt; <span class="hljs-string">&quot;Talk is cheap. Show me the code.&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的评价：这题一开始就看的不是很明白。dp也只是过了2个他给的样例 + 自己的1个样例而已。dp貌似最后一维<code>[2]</code>可以省去。</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求职</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - Transformer图解</title>
    <link href="/2024/04/16/%E7%AC%94%E8%AE%B0%20-%20Transformer%E5%9B%BE%E8%A7%A3/"/>
    <url>/2024/04/16/%E7%AC%94%E8%AE%B0%20-%20Transformer%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Transformer是谷歌在2017年的论文《Attention Is All You Need》中提出的，用于NLP的各项任务，现在是谷歌云TPU推荐的参考模型。网上有关Transformer原理的介绍很多，在本文中我们将尽量模型简化，让普通读者也能轻松理解。</p><h2 id="1-Transformer整体结构"><a href="#1-Transformer整体结构" class="headerlink" title="1.Transformer整体结构"></a>1.Transformer整体结构</h2><p>在机器翻译中，Transformer可以将一种语言翻译成另一种语言，如果把Transformer看成一个黑盒，那么其结构如下图所示：</p><p><img src="https://pic1.zhimg.com/v2-8caa4fff3ca2ce5dc5a29b03fd617ac4_b.webp?consumer=ZHI_MENG" alt="blackbox"></p><p>将法语翻译成英语</p><p>那么拆开这个黑盒，那么可以看到Transformer由若干个编码器和解码器组成，如下图所示：</p><p><img src="https://pic3.zhimg.com/v2-73b11f65411c0cdfecca80585b7a31b2_b.webp?consumer=ZHI_MENG" alt="en-decoder"></p><p>继续将Encoder和Decoder拆开，可以看到完整的结构，如下图所示：</p><p><img src="https://pic4.zhimg.com/v2-fc13ed90487a03daad57497e8028a093_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Transformer整体结构（引自谷歌论文）</p><p>可以看到Encoder包含一个Muti-Head Attention模块，是由多个Self-Attention组成，而Decoder包含两个Muti-Head Attention。Muti-Head Attention上方还包括一个 Add &amp; Norm 层，Add 表示残差连接 (Residual Connection) 用于防止网络退化，Norm 表示 Layer Normalization，用于对每一层的激活值进行归一化。</p><p>假设我们的输入包含两个单词，我们看一下Transformer的整体结构：</p><p>Transformer整体结构（输入两个单词的例子）</p><p>为了能够对Transformer的流程有个大致的了解，我们举一个简单的例子，还是以之前的为例，将法语”Je suis etudiant”翻译成英文。</p><ul><li><p><strong>第一步</strong>：获取输入句子的每一个单词的表示向量  ，  由单词的Embedding和单词位置的Embedding 相加得到。</p><p>  <img src="https://pic1.zhimg.com/v2-1745b50be609efad5090fa5801954f6c_b.webp?consumer=ZHI_MENG" alt="img"></p></li></ul><p>Transformer输入表示</p><ul><li><p><strong>第二步</strong>：将单词向量矩阵传入Encoder模块，经过N个Encoder后得到句子所有单词的编码信息矩阵  ，如下图。输入句子的单词向量矩阵用  表示，其中  是单词个数，  表示向量的维度（论文中  ）。每一个Encoder输出的矩阵维度与输入完全一致。</p><p>  <img src="https://pic2.zhimg.com/v2-750502dbcc93b061723262afdabd5a39_b.webp?consumer=ZHI_MENG" alt="img"></p></li></ul><p>输入X经过Encoder输出编码矩阵C</p><ul><li><p><strong>第三步</strong>：将Encoder输出的编码矩阵  传递到Decoder中，Decoder会根据当前翻译过的单词  翻译下一个单词  ，如下图所示。</p><p>  <img src="https://pic1.zhimg.com/v2-1c19890bfb2738610a595a55f473492c_b.webp?consumer=ZHI_MENG" alt="img"></p></li></ul><p>Transformer Decoder预测</p><p>上图Decoder接收了Encoder的编码矩阵，然后首先输入一个开始符 “<code>&lt;Begin&gt;</code>“，预测第一个单词，输出为”I”；然后输入翻译开始符 “<code>&lt;Begin&gt;</code>“ 和单词 “I”，预测第二个单词，输出为”am”，以此类推。这是Transformer的大致流程，接下来介绍里面各个部分的细节。</p><h2 id="2-Transformer的输入表示"><a href="#2-Transformer的输入表示" class="headerlink" title="2. Transformer的输入表示"></a>2. Transformer的输入表示</h2><p>Transformer中单词的输入表示由<strong>单词Embedding</strong>和<strong>位置Embedding</strong>（Positional Encoding）相加得到。</p><p><img src="https://pic1.zhimg.com/v2-1745b50be609efad5090fa5801954f6c_b.webp?consumer=ZHI_MENG" alt="Transformer输入表示"></p><h3 id="2-1-单词Embedding"><a href="#2-1-单词Embedding" class="headerlink" title="2.1 单词Embedding"></a>2.1 单词Embedding</h3><p>单词的Embedding可以通过Word2vec等模型预训练得到，可以在Transformer中加入Embedding层。</p><h3 id="2-2-位置Embedding"><a href="#2-2-位置Embedding" class="headerlink" title="2.2 位置Embedding"></a>2.2 位置Embedding</h3><p>Transformer 中除了单词的Embedding，还需要使用位置Embedding 表示单词出现在句子中的位置。<strong>因为 Transformer不采用RNN结构，而是使用全局信息，不能利用单词的顺序信息，而这部分信息对于NLP来说非常重要。</strong>所以Transformer中使用位置Embedding保存单词在序列中的相对或绝对位置。</p><p>位置Embedding用 表示， 的维度与单词Embedding相同。 可以通过训练得到，也可以使用某种公式计算得到。在Transformer中采用了后者，计算公式如下：</p><p> 其中，  表示单词在句子中的位置，  表示  的维度。</p><h2 id="3-Multi-Head-Attention（多头注意力机制）"><a href="#3-Multi-Head-Attention（多头注意力机制）" class="headerlink" title="3. Multi-Head Attention（多头注意力机制）"></a>3. Multi-Head Attention（多头注意力机制）</h2><p><img src="https://pic1.zhimg.com/v2-fe6a25d5b50af58a9419d8496e5574fc_b.webp?consumer=ZHI_MENG" alt="Transformer内部结构"></p><p>上图是Transformer的内部结构，其中红色方框内为<strong>Multi-Head Attention</strong>，是由多个<strong>Self-Attention</strong>组成，具体结构如下图：</p><p><img src="https://pic3.zhimg.com/v2-c0f64bb363bc16ce1bc091c76399564e_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Self-Attention和Multi-Head Attention</p><p>因为<strong>Self-Attention</strong>是Transformer的重点，所以我们重点关注 Multi-Head Attention 以及 Self-Attention，首先介绍下Self-Attention的内部逻辑。</p><h3 id="3-1-Self-Attention结构"><a href="#3-1-Self-Attention结构" class="headerlink" title="3.1 Self-Attention结构"></a>3.1 Self-Attention结构</h3><p>Self-Attention结构</p><p>上图是Self-Attention结构，最下面是  (查询)、  (键值)、  (值)矩阵，是通过输入矩阵  和权重矩阵  相乘得到的。</p><p><img src="https://pic4.zhimg.com/v2-47ae22cfc369bb8ada48e8cd87e6a40b_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Q,K,V的计算</p><p>得到  之后就可以计算出Self-Attention的输出，如下图所示：</p><p><img src="https://pic3.zhimg.com/v2-26cf164e2ce740a7cc6afc1e237d88be_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Self-Attention输出</p><h3 id="3-2-Multi-Head-Attention输出"><a href="#3-2-Multi-Head-Attention输出" class="headerlink" title="3.2 Multi-Head Attention输出"></a>3.2 Multi-Head Attention输出</h3><p>在上一步，我们已经知道怎么通过Self-Attention计算得到输出矩阵  ，而Multi-Head Attention是由多个Self-Attention组合形成的，下图是论文中Multi-Head Attention的结构图。</p><p><img src="https://pic2.zhimg.com/v2-c4e7695fdbf5c46bd45f9428b342a755_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Multi-Head Attention</p><p>从上图可以看到Multi-Head Attention包含多个Self-Attention层，首先将输入  分别传递到  个不同的Self-Attention中，计算得到  个输出矩阵  。下图是  的情况，此时会得到 8 个输出矩阵  。</p><p><img src="https://pic4.zhimg.com/v2-19ffed2e3c0a93608b7837f369e6eed7_b.webp?consumer=ZHI_MENG" alt="img"></p><p>多个Self-Attention</p><p>得到8个输出矩阵  后，Multi-Head Attention将它们拼接在一起（Concat），然后传入一个Linear层，得到Multi-Head Attention最终的输出矩阵  。</p><p><img src="https://pic2.zhimg.com/v2-dad82b6bd8c4a0dc849e58a706049be1_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Multi-Head Attention输出</p><h2 id="4-编码器Encoder结构"><a href="#4-编码器Encoder结构" class="headerlink" title="4. 编码器Encoder结构"></a>4. 编码器Encoder结构</h2><p><img src="https://pic2.zhimg.com/v2-cefd3fb99de81b635ff3b6aca1af67cd_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Transformer Encoder模块</p><p>上图红色部分是Transformer的Encoder结构，  表示Encoder的个数，可以看到是由Multi-Head Attention、Add &amp; Norm、Feed Forward、Add &amp; Norm组成的。前面已经介绍了Multi-Head Attention的计算过程，现在了解一下Add &amp; Norm和 Feed Forward部分。</p><h3 id="4-1-单个Encoder输出"><a href="#4-1-单个Encoder输出" class="headerlink" title="4.1 单个Encoder输出"></a>4.1 单个Encoder输出</h3><p><strong>Add &amp; Norm</strong>是指残差连接后使用LayerNorm，表示如下：</p><p> 其Sublayer表示经过的变换，比如第一个Add &amp; Norm中Sublayer表示Multi-Head Attention。</p><p><strong>Feed Forward</strong>是指全连接层，表示如下：</p><p> 因此输入矩阵  经过一个Encoder后，输出表示如下：</p><h3 id="4-2-多个Encoder输出"><a href="#4-2-多个Encoder输出" class="headerlink" title="4.2 多个Encoder输出"></a>4.2 多个Encoder输出</h3><p>通过上面的单个Encoder，输入矩阵  ，最后输出矩阵  。通过多个Encoder叠加，最后便是编码器Encoder的输出。</p><h2 id="5-解码器Decoder结构"><a href="#5-解码器Decoder结构" class="headerlink" title="5. 解码器Decoder结构"></a>5. 解码器Decoder结构</h2><p><img src="https://pic3.zhimg.com/v2-7b3d618fa051cc60576154b949b613c6_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Transformer Decoder模块</p><p>上图红色部分为Transformer的Decoder结构，与Encoder相似，但是存在一些区别：</p><ul><li>包含两个Multi-Head Attention</li><li>第一个Multi-Head Attention采用了Masked操作</li><li>第二个Multi-Head Attention的  矩阵使用Encoder的<strong>编码信息矩阵</strong>  进行计算，而  使用上一个 Decoder的输出计算</li><li>最后有一个Softmax层计算下一个翻译单词的概率</li></ul><h3 id="5-1-第一个Multi-Head-Attention"><a href="#5-1-第一个Multi-Head-Attention" class="headerlink" title="5.1 第一个Multi-Head Attention"></a>5.1 第一个Multi-Head Attention</h3><p>Decoder的第一个Multi-Head Attention采用了Masked操作，因为在翻译的过程中是顺序翻译的，即翻译完第  个单词，才可以翻译第  个单词。通过 Masked 操作可以防止第  个单词知道  个单词之后的信息。下面以法语”Je suis etudiant”翻译成英文”I am a student”为例，了解一下 Masked 操作。</p><p>在Decoder的时候，需要根据之前翻译的单词，预测当前最有可能翻译的单词，如下图所示。首先根据输入”<code>&lt;Begin&gt;</code>“预测出第一个单词为”I”，然后根据输入”<code>&lt;Begin&gt;</code> I” 预测下一个单词 “am”。</p><p><img src="https://pic1.zhimg.com/v2-d381d89dc81313a26717bf72dbda4294_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Decoder预测（右图有问题，应该是Decoder 1）</p><p>Decoder在预测第  个输出时，需要将第  之后的单词掩盖住，<strong>Mask操作是在Self-Attention的Softmax之前使用的，</strong>下面以前面的”I am a student”为例。</p><p><strong>第一步：</strong>是Decoder的输入矩阵和<strong>Mask</strong>矩阵，输入矩阵包含”<code>&lt;Begin&gt;</code> I am a student”4个单词的表示向量，<strong>Mask</strong>是一个  的矩阵。在<strong>Mask</strong>可以发现单词”<code>&lt;Begin&gt;</code>“只能使用单词”<code>&lt;Begin&gt;</code>“的信息，而单词”I”可以使用单词”<code>&lt;Begin&gt;</code> I”的信息，即只能使用之前的信息。</p><p><img src="https://pic2.zhimg.com/v2-a52bc9153f72664214753253acbaa3e9_b.webp?consumer=ZHI_MENG" alt="img"></p><p>输入矩阵与Mask矩阵</p><p><strong>第二步</strong>：接下来的操作和之前Encoder中的Self-Attention一样，只是在Softmax之前需要进行Mask操作。</p><p><img src="https://pic4.zhimg.com/v2-aa7b81c5ef8e153affd45d78c484f0e3_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Mask Self-Attention输出</p><p><strong>第三步</strong>：通过上述步骤就可以得到一个Mask Self-Attention的输出矩阵，然后和Encoder类似，通过Multi-Head Attention拼接多个输出然后计算得到第一个Multi-Head Attention的输出  ，  与输入  维度一样。</p><h3 id="5-2-第二个Multi-Head-Attention"><a href="#5-2-第二个Multi-Head-Attention" class="headerlink" title="5.2 第二个Multi-Head Attention"></a>5.2 第二个Multi-Head Attention</h3><p>Decoder的第二个Multi-Head Attention变化不大， 主要的区别在于其中Self-Attention的  矩阵不是使用上一个Multi-Head Attention的输出，而是使用<strong>Encoder的编码信息矩阵</strong>  计算的。根据Encoder的输出  计算得到  ，根据上一个Multi-Head Attention的输出  计算 。这样做的好处是在Decoder的时候，每一位单词（这里是指”I am a student”）都可以利用到Encoder所有单词的信息（这里是指”Je suis etudiant”）。</p><h2 id="6-Softmax预测输出"><a href="#6-Softmax预测输出" class="headerlink" title="6. Softmax预测输出"></a>6. Softmax预测输出</h2><p><img src="https://pic2.zhimg.com/v2-7f93a08d8b68fda543bb93ef4fa5d045_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Softmax预测输出</p><p>编码器Decoder最后的部分是利用 Softmax 预测下一个单词，在Softmax之前，会经过Linear变换，将维度转换为词表的个数。</p><p>假设我们的词表只有6个单词，表示如下：</p><p><img src="https://pic1.zhimg.com/v2-a42a9f12991d9e57c8e3b7c484211f24_b.webp?consumer=ZHI_MENG" alt="img"></p><p>词表</p><p>因此，最后的输出可以表示如下：</p><p><img src="https://pic3.zhimg.com/v2-b47a5cdc84b9d3fa78db9ff5bf51909e_b.webp?consumer=ZHI_MENG" alt="img"></p><p>Softmax预测输出示例</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Transformer由于可并行、效果好等特点，如今已经成为机器翻译、特征抽取等任务的基础模块，目前ChatGPT特征抽取的模块用的就是Transformer，这对于后面理解ChatGPT的原理做了好的铺垫。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://zhuanlan.zhihu.com/p/603243890">绝密伏击：OPenAI ChatGPT（一）：Tensorflow实现Transformer</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/338817680">初识CV：Transformer模型详解（图解最完整版）</a></p><p><a href="https://zhuanlan.zhihu.com/p/54356280">数据汪：BERT大火却不懂Transformer？读这一篇就够了</a></p><p><a href="https://link.zhihu.com/?target=https://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></p><p><a href="https://zhuanlan.zhihu.com/p/48731949">忆臻：搞懂Transformer结构，看这篇PyTorch实现就够了（上）</a></p><p><a href="https://link.zhihu.com/?target=https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformer</a></p><p><a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1706.03762.pdf">https://arxiv.org/pdf/1706.03762.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/69973607">青空栀浅：图解Transformer</a></p><p><a href="https://zhuanlan.zhihu.com/p/69290203">Ph0en1x：Transformer结构及其应用详解–GPT、BERT、MT-DNN、GPT-2</a></p><p><a href="https://zhuanlan.zhihu.com/p/590311003">大师兄：ChatGPT&#x2F;InstructGPT详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/589533490">张俊林：ChatGPT会取代搜索引擎吗</a></p><p><a href="https://zhuanlan.zhihu.com/p/54743941">张俊林：放弃幻想，全面拥抱Transformer：自然语言处理三大特征抽取器（CNN&#x2F;RNN&#x2F;TF）比较</a></p><p>来源: <a href="https://www.zhihu.com/tardis/bd/art/600773858">https://www.zhihu.com/tardis/bd/art/600773858</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - Transformer面试题目总结</title>
    <link href="/2024/04/16/%E7%AC%94%E8%AE%B0%20-%20Transformer%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/16/%E7%AC%94%E8%AE%B0%20-%20Transformer%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Attention"><a href="#1-Attention" class="headerlink" title="1.Attention"></a>1.Attention</h2><h3 id="1-1-讲讲对Attention的理解？"><a href="#1-1-讲讲对Attention的理解？" class="headerlink" title="1.1 讲讲对Attention的理解？"></a>1.1 讲讲对Attention的理解？</h3><p>Attention机制是一种在处理时序相关问题的时候常用的技术，主要用于处理序列数据。</p><p>核心思想是在处理序列数据时，网络应该更关注输入中的重要部分，而忽略不重要的部分，它通过学习不同部分的权重，将输入的序列中的重要部分显式地加权，从而使得模型可以更好地关注与输出有关的信息。</p><p>在序列建模任务中，比如机器翻译、文本摘要、语言理解等，输入序列的不同部分可能具有不同的重要性。传统的循环神经网络（RNN）或卷积神经网络（CNN）在处理整个序列时，难以捕捉到序列中不同位置的重要程度，可能导致信息传递不够高效，特别是在处理长序列时表现更明显。</p><p>Attention机制的关键是引入一种机制来动态地计算输入序列中各个位置的权重，从而在每个时间步上，对输入序列的不同部分进行加权求和，得到当前时间步的输出。这样就实现了模型对输入中不同部分的关注度的自适应调整。</p><h3 id="1-2-Attention的计算步骤是什么？"><a href="#1-2-Attention的计算步骤是什么？" class="headerlink" title="1.2 Attention的计算步骤是什么？"></a>1.2 Attention的计算步骤是什么？</h3><p>具体的计算步骤如下：</p><ul><li><strong>计算查询（Query）</strong>：查询是当前时间步的输入，用于和序列中其他位置的信息进行比较。</li><li><strong>计算键（Key）和值（Value）</strong>：键表示序列中其他位置的信息，值是对应位置的表示。键和值用来和查询进行比较。对于一个句子，对每个词汇进行线性变换，得到变换后的查询（q）、键（k）和值（v）向量表示。</li><li><strong>计算注意力权重</strong>：通过将查询和键进行内积运算，然后应用softmax函数，得到注意力权重。这些权重表示了在当前时间步，模型应该关注序列中其他位置的重要程度。</li><li><strong>加权求和</strong>：根据注意力权重将值进行加权求和，得到当前时间步的输出。</li></ul><p>在Transformer中，Self-Attention 被称为”Scaled Dot-Product Attention”，其计算过程如下：</p><ol><li>对于输入序列中的每个位置，通过计算其与所有其他位置之间的相似度得分（通常通过点积计算）。</li><li>对得分进行缩放处理（除以$\sqrt{d_k}$），以防止梯度爆炸。</li><li>将得分用softmax函数转换为注意力权重，以便计算每个位置的加权和。</li><li>使用注意力权重对输入序列中的所有位置进行加权求和，得到每个位置的自注意输出。</li></ol><p>$$<br>Attention(Q,K,V)&#x3D;softmax(\frac{QK^T}{\sqrt{d_k}})V<br>$$</p><h3 id="1-3-Attention机制和传统的Seq2Seq模型有什么区别？"><a href="#1-3-Attention机制和传统的Seq2Seq模型有什么区别？" class="headerlink" title="1.3 Attention机制和传统的Seq2Seq模型有什么区别？"></a>1.3 Attention机制和传统的Seq2Seq模型有什么区别？</h3><p>Seq2Seq模型是一种基于编码器-解码器结构的模型，主要用于处理序列到序列的任务，例如机器翻译、语音识别等。</p><p>传统的Seq2Seq模型<strong>只使用编码器来捕捉输入序列的信息，而解码器只从编码器的最后状态中获取信息，并将其用于生成输出序列</strong>。</p><p>而Attention机制则允许<strong>解码器在生成每个输出时，根据输入序列的不同部分给予不同的注意力，从而使得模型更好地关注到输入序列中的重要信息</strong>。</p><h3 id="1-4-self-attention-和-target-attention的区别？"><a href="#1-4-self-attention-和-target-attention的区别？" class="headerlink" title="1.4 self-attention 和 target-attention的区别？"></a>1.4 self-attention 和 target-attention的区别？</h3><p>self-attention是指在序列数据中，<strong>将当前位置与其他位置之间的关系建模</strong>。它通过计算每个位置与其他所有位置之间的相关性得分，从而<strong>为每个位置分配一个权重</strong>。这使得模型能够根据输入序列的不同部分的重要性，自适应地选择要关注的信息。</p><p>target-attention则是指将<strong>注意力机制应用于目标（或查询）和一组相关对象之间的关系</strong>。它用于将目标与其他相关对象进行比较，并将注意力分配给与目标最相关的对象。这种类型的注意力通常用于任务如机器翻译中的编码-解码模型，其中需要将源语言的信息对齐到目标语言。</p><p>因此，<strong>自注意力主要关注序列内部的关系，而目标注意力则关注目标与其他对象之间的关系</strong>。这两种注意力机制在不同的上下文中起着重要的作用，帮助模型有效地处理序列数据和相关任务。</p><h3 id="1-5-在常规attention中，一般有k-v，那self-attention-可以吗"><a href="#1-5-在常规attention中，一般有k-v，那self-attention-可以吗" class="headerlink" title="1.5 在常规attention中，一般有k&#x3D;v，那self-attention 可以吗?"></a>1.5 在常规attention中，一般有k&#x3D;v，那self-attention 可以吗?</h3><p>self-attention实际只是attention中的一种特殊情况，因此k&#x3D;v是没有问题的，也即K，V参数矩阵相同。</p><p>实际上，在Transformer模型中，Self-Attention的典型实现就是k等于v的情况。<br>k和v共享相同的参数矩阵$W_k$和$W_v$。这样做的好处是可以减少模型的参数量，并且在计算上更加高效。</p><p>Transformer中的Self-Attention被称为”Scaled Dot-Product Attention”，其中<strong>通过将词向量进行线性变换来得到Q、K、V，并且这三者是相等的</strong>。</p><h3 id="1-6-目前主流的attention方法有哪些？"><a href="#1-6-目前主流的attention方法有哪些？" class="headerlink" title="1.6 目前主流的attention方法有哪些？"></a>1.6 目前主流的attention方法有哪些？</h3><p>讲自己熟悉的就可：</p><ul><li><strong>Scaled Dot-Product Attention</strong>: 这是Transformer模型中最常用的Attention机制，用于计算查询向量（Q）与键向量（K）之间的相似度得分，然后使用注意力权重对值向量（V）进行加权求和。</li><li><strong>Multi-Head Attention</strong>: 这是Transformer中的一个改进，通过同时使用多组独立的注意力头（多个QKV三元组），并在输出时将它们拼接在一起。这样的做法<strong>允许模型在不同的表示空间上学习不同类型的注意力模式</strong>。</li><li><strong>Relative Positional Encoding</strong>: 传统的Self-Attention机制在处理序列时并未直接考虑位置信息，而相对位置编码引入了位置信息，使得模型能够更好地处理序列中不同位置之间的关系。</li><li><strong>Transformer-XL</strong>: 一种改进的Transformer模型，通过使用循环机制来扩展Self-Attention的上下文窗口，从而处理更长的序列依赖性。</li></ul><h3 id="1-7-self-attention-在计算的过程中，如何对padding位做mask？"><a href="#1-7-self-attention-在计算的过程中，如何对padding位做mask？" class="headerlink" title="1.7 self-attention 在计算的过程中，如何对padding位做mask？"></a>1.7 self-attention 在计算的过程中，如何对padding位做mask？</h3><p>在 Attention 机制中，同样需要忽略 padding 部分的影响。</p><p>这里以transformer encoder中的self-attention为例：self-attention中，Q和K在点积之后，需要先经过mask再进行softmax，因此，<strong>对于要屏蔽的部分，mask之后的输出需要为负无穷</strong>，这样softmax之后输出才为0。</p><h3 id="1-8-深度学习中attention与全连接层的区别何在？"><a href="#1-8-深度学习中attention与全连接层的区别何在？" class="headerlink" title="1.8 深度学习中attention与全连接层的区别何在？"></a>1.8 深度学习中attention与全连接层的区别何在？</h3><p>这是个非常有意思的问题，要回答这个问题，我们必须重新定义一下Attention。</p><p>Transformer Paper里重新用QKV定义了Attention。所谓的QKV就是Query，Key，Value。如果我们用这个机制来研究传统的RNN attention，就会发现这个过程其实是这样的：RNN最后一步的output是Q，这个Q query了每一个中间步骤的K。Q和K共同产生了Attention Score，最后Attention Score乘以V加权求和得到context。那如果我们不用Attention，单纯用全连接层呢？很简单，全连接层可没有什么Query和Key的概念，只有一个Value，也就是说给每个V加一个权重再加到一起（如果是Self Attention，加权这个过程都免了，因为V就直接是从raw input加权得到的。）</p><p><strong>可见Attention和全连接最大的区别就是Query和Key</strong>，而这两者也恰好产生了Attention Score这个Attention中最核心的机制。<strong>而在Query和Key中，我认为Query又相对更重要，因为Query是一个锚点，Attention Score便是从过计算与这个锚点的距离算出来的</strong>。任何Attention based algorithm里都会有Query这个概念，但全连接显然没有。</p><p>最后来一个比较形象的比喻吧。如果一个神经网络的任务是从一堆白色小球中找到一个略微发灰的，那么全连接就是在里面随便乱抓然后凭记忆和感觉找，而attention则是左手拿一个白色小球，右手从袋子里一个一个抓出来，两两对比颜色，你左手抓的那个白色小球就是Query。</p><h2 id="2-Transformer"><a href="#2-Transformer" class="headerlink" title="2.Transformer"></a>2.Transformer</h2><h3 id="2-1-transformer中multi-head-attention中每个head为什么要进行降维？"><a href="#2-1-transformer中multi-head-attention中每个head为什么要进行降维？" class="headerlink" title="2.1 transformer中multi-head attention中每个head为什么要进行降维？"></a>2.1 transformer中multi-head attention中每个head为什么要进行降维？</h3><p>在Transformer的Multi-Head Attention中，对每个head进行降维是<strong>为了增加模型的表达能力和效率。</strong></p><p>每个head是独立的注意力机制，它们可以学习不同类型的特征和关系。通过使用多个注意力头，Transformer可以<strong>并行地学习多种不同的特征表示</strong>，从而增强了模型的表示能力。</p><p>然而，在使用多个注意力头的同时，注意力机制的计算复杂度也会增加。原始的Scaled Dot-Product Attention的计算复杂度为$O(d^2)$，其中d是输入向量的维度。如果使用h个注意力头，计算复杂度将增加到 $O(hd^2)$。这可能会导致Transformer在处理大规模输入时变得非常耗时。</p><p>为了缓解计算复杂度的问题，Transformer中在每个head上进行降维。在每个注意力头中，输入向量通过线性变换被映射到一个较低维度的空间。这个降维过程使用两个矩阵：一个是查询（Q）和键（K）的降维矩阵$W_q$和$W_k$​，另一个是值（V）的降维矩阵$W_v$​。</p><p>通过降低每个head的维度，Transformer可以在<strong>保持较高的表达能力的同时，大大减少计算复杂度</strong>。降维后的计算复杂度为$O(h\hat d ^ 2)$，其中$\hat d$是降维后的维度。通常情况下，$\hat d$会远小于原始维度d，这样就可以显著提高模型的计算效率。</p><h3 id="2-2-transformer在哪里做了权重共享，为什么可以做权重共享？"><a href="#2-2-transformer在哪里做了权重共享，为什么可以做权重共享？" class="headerlink" title="2.2 transformer在哪里做了权重共享，为什么可以做权重共享？"></a>2.2 transformer在哪里做了权重共享，为什么可以做权重共享？</h3><p>Transformer在Encoder和Decoder中都进行了权重共享。</p><p>在Transformer中，Encoder和Decoder是由多层的Self-Attention Layer和前馈神经网络层交叉堆叠而成。<strong>权重共享是指在这些堆叠的层中，相同位置的层共用相同的参数</strong>。</p><p>在Encoder中，所有的自注意力层和前馈神经网络层都共享相同的参数。这意味着每一层的自注意力机制和前馈神经网络都使用相同的权重矩阵来进行计算。这种共享保证了每一层都执行相同的计算过程，使得模型能够更好地捕捉输入序列的不同位置之间的关联性。</p><p>在Decoder中，除了和Encoder相同的权重共享方式外，还存在另一种特殊的权重共享：<strong>Decoder的自注意力层和Encoder的自注意力层之间也进行了共享</strong>。这种共享方式被称为”masked self-attention”，因为在解码过程中，当前位置的注意力不能关注到未来的位置（后续位置），以避免信息泄漏。通过这种共享方式，Decoder可以利用Encoder的表示来理解输入序列并生成输出序列。</p><p>权重共享的好处是大大减少了模型的参数数量，使得Transformer可以更有效地训练，并且更容易进行推理。此外，共享参数还有助于加快训练速度和提高模型的泛化能力，因为模型可以在不同位置共享并学习通用的特征表示。</p><h3 id="2-3-transformer的点积模型做缩放的原因是什么？"><a href="#2-3-transformer的点积模型做缩放的原因是什么？" class="headerlink" title="2.3 transformer的点积模型做缩放的原因是什么？"></a>2.3 transformer的点积模型做缩放的原因是什么？</h3><p>使用缩放的原因是为了控制注意力权重的尺度，以避免在计算过程中出现梯度爆炸的问题。</p><p>Attention的计算是在内积之后进行softmax，主要涉及的运算是$e^{q \cdot k}$，可以大致认为内积之后、softmax之前的数值在$-3\sqrt{d}$到$3\sqrt{d}$这个范围内，由于d通常都至少是64，所以$e^{3\sqrt{d}}$比较大而 $e^{-3\sqrt{d}}$比较小，因此经过softmax之后，Attention的分布非常接近一个one hot分布了，这带来严重的梯度消失问题，导致训练效果差。（例如y&#x3D;softmax(x)在|x|较大时进入了饱和区，x继续变化y值也几乎不变，即饱和区梯度消失）</p><p>相应地，解决方法就有两个:</p><ol><li>像NTK参数化那样，在内积之后除以 $\sqrt{d}$，使$q\cdot k$的方差变为1，对应$e^3,e^{−3}$都不至于过大过小，这样softmax之后也不至于变成one hot而梯度消失了，这也是常规的Transformer如BERT里边的Self Attention的做法</li><li>另外就是不除以 $\sqrt{d}$，但是初始化q,k的全连接层的时候，其初始化方差要多除以一个d，这同样能使得使$q\cdot k$的初始方差变为1，T5采用了这样的做法。</li></ol><h3 id="2-4-transformer-为什么使用-layer-normalization？batch-normalization-为什么不能用？"><a href="#2-4-transformer-为什么使用-layer-normalization？batch-normalization-为什么不能用？" class="headerlink" title="2.4 transformer 为什么使用 layer normalization？batch normalization 为什么不能用？"></a>2.4 transformer 为什么使用 layer normalization？batch normalization 为什么不能用？</h3><p>首先通过一个例子来说明layer norm和batch norm（只考虑均值归一化）是什么：</p><table><thead><tr><th>样本index</th><th>x1</th><th>x2</th><th>标签</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>10</td><td>True</td></tr><tr><td>2</td><td>2</td><td>0</td><td>False</td></tr></tbody></table><table><thead><tr><th>样本index</th><th>x1 (BN)</th><th>x2 (BN)</th><th>标签</th></tr></thead><tbody><tr><td>1</td><td>0 - 1 &#x3D; -1</td><td>10 - 5 &#x3D; 5</td><td>True</td></tr><tr><td>2</td><td>2 - 1 &#x3D; 1</td><td>0 - 5 &#x3D; -5</td><td>False</td></tr></tbody></table><table><thead><tr><th>样本index</th><th>x1 (LN)</th><th>x2 (LN)</th><th>标签</th></tr></thead><tbody><tr><td>1</td><td>0 - 5 &#x3D; -5</td><td>10 - 5 &#x3D; 5</td><td>True</td></tr><tr><td>2</td><td>2 - 1 &#x3D; 1</td><td>0 - 1 &#x3D; -1</td><td>False</td></tr></tbody></table><p>不同正则化方法的区别只是操作的信息维度不同，即选择损失信息的维度不同。</p><p>在CV中常常使用BN，它是在N、HW维度进行了归一化，而Channel维度的信息原封不动，因为可以认为在CV应用场景中，数据在不同channel中的信息很重要，如果对其进行归一化将会损失不同channel的差异信息。</p><p>而NLP中<strong>不同batch样本的信息关联性不大</strong>，而且由于<strong>不同的句子长度不同</strong>，强行归一化会损失不同样本间的差异信息，所以就没在batch维度进行归一化，而是选择LN，只考虑的句子内部维度的归一化。 可以认为NLP应用场景中一个样本内部维度间是有关联的，所以在信息归一化时，对样本内部差异信息进行一些损失，反而能降低方差。</p><h2 id="4-MHA-MQA-MGA"><a href="#4-MHA-MQA-MGA" class="headerlink" title="4.MHA &amp; MQA &amp; MGA"></a>4.MHA &amp; MQA &amp; MGA</h2><h3 id="（1）MHA"><a href="#（1）MHA" class="headerlink" title="（1）MHA"></a>（1）MHA</h3><p>从多头注意力的结构图中，貌似这个所谓的<strong>多个头就是指多组线性变换层</strong>，其实并不是，只有使用了一组线性变化层，即三个变换张量对Q，K，V分别进行线性变换，<strong>这些变换不会改变原有张量的尺寸</strong>，因此每个变换矩阵都是方阵，得到输出结果后，多头的作用才开始显现，每个头开始从词义层面分割输出的张量，也就是每个头都想获得一组Q，K，V进行注意力机制的计算，但是句子中的每个词的表示只获得一部分，也就是只分割了最后一维的词嵌入向量。这就是所谓的多头，将每个头的获得的输入送到注意力机制中, 就形成多头注意力机制.</p><p>Multi-head attention允许模型<strong>共同关注来自不同位置的不同表示子空间的信息</strong>，如果只有一个attention head，它的平均值会削弱这个信息。</p><p>$MultiHead(Q,K,V)&#x3D;Concat(head_1,…,head_h)W^O \ where ~ head_i &#x3D; Attention(QW_i^Q, KW_i^K, VW_i^V) $</p><p>其中映射由权重矩阵完成：<br>$W^Q_i \in \mathbb{R}^{d_ \times d_k}$<br>$W^K_i \in \mathbb{R}^{d_{\text{model}} \times d_k}$<br>$W^V_i \in \mathbb{R}^{d_{\text{model}} \times d_v}$<br>​和$W^O_i \in \mathbb{R}^{hd_v \times d_{\text{model}} }$</p><p><img src="https://dongnian.icu/media/image.png"></p><p><img src="https://dongnian.icu/media/image_1.png"></p><p><strong>多头注意力作用</strong>？</p><p>这种结构设计能<strong>让每个注意力机制去优化每个词汇的不同特征部分</strong>，从而均衡同一种注意力机制可能产生的偏差，让词义拥有来自更多元的表达，实验表明可以从而提升模型效果.</p><p><strong>为什么要做多头注意力机制呢</strong>？</p><ul><li>一个 dot product 的注意力里面，没有什么可以学的参数。具体函数就是内积，为了识别不一样的模式，希望有不一样的计算相似度的办法。加性 attention 有一个权重可学，也许能学到一些内容。</li><li>multi-head attention 给 h 次机会去学习 不一样的投影的方法，使得在投影进去的度量空间里面能够去匹配不同模式需要的一些相似函数，然后把 h 个 heads 拼接起来，最后再做一次投影。</li><li>每一个头 hi 是把 Q,K,V 通过 可以学习的 Wq, Wk, Wv 投影到 dv 上，再通过注意力函数，得到 headi。</li></ul><h3 id="（2）MQA"><a href="#（2）MQA" class="headerlink" title="（2）MQA"></a>（2）MQA</h3><p>MQA（Multi Query Attention）最早是出现在2019年谷歌的一篇论文 《Fast Transformer Decoding: One Write-Head is All You Need》。</p><p>MQA的思想其实比较简单，MQA 与 MHA 不同的是，<strong>MQA 让所有的头之间共享同一份 Key 和 Value 矩阵，每个头正常的只单独保留了一份 Query 参数，从而大大减少 Key 和 Value 矩阵的参数量</strong>。</p><blockquote><p>Multi-query attention is identical except that the different heads share a single set of keys and values.</p></blockquote><p><img src="https://dongnian.icu/media/image_2.png"></p><p>在 Multi-Query Attention 方法中只会保留一个单独的key-value头，这样<strong>虽然可以提升推理的速度，但是会带来精度上的损失</strong>。《Multi-Head Attention:Collaborate Instead of Concatenate 》这篇论文的第一个思路是<strong>基于多个 MQA 的 checkpoint 进行 finetuning，来得到了一个质量更高的 MQA 模型</strong>。这个过程也被称为 Uptraining。</p><p>具体分为两步：</p><ol><li>对多个 MQA 的 checkpoint 文件进行融合，融合的方法是: 通过对 key 和 value 的 head 头进行 mean pooling 操作，如下图。</li><li>对融合后的模型使用少量数据进行 finetune 训练，重训后的模型大小跟之前一样，但是效果会更好</li></ol><p><img src="https://dongnian.icu/media/image_3.png"></p><h3 id="（3）GQA"><a href="#（3）GQA" class="headerlink" title="（3）GQA"></a>（3）GQA</h3><p>Google 在 2023 年发表的一篇 <a href="https://arxiv.org/pdf/2305.13245.pdf">《GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints》</a>的论文</p><p>如下图所示，</p><ul><li>在 <strong>MHA(Multi Head Attention)</strong> 中，每个头有自己单独的 key-value 对；</li><li>在 <strong>MQA(Multi Query Attention)</strong> 中只会有一组 key-value 对；</li><li>在 <strong>GQA(Grouped Query Attention)</strong> 中，会对 attention 进行分组操作，query 被分为 N 组，每个组共享一个 Key 和 Value 矩阵。</li></ul><p><img src="https://dongnian.icu/media/image_4.png"></p><p>GQA-N 是指具有 N 组的 Grouped Query Attention。GQA-1具有单个组，因此具有单个Key 和 Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p><p>在基于 Multi-head 多头结构变为 Grouped-query 分组结构的时候，也是采用跟上图一样的方法，对每一组的 key-value 对进行 mean pool 的操作进行参数融合。<strong>融合后的模型能力更综合，精度比 Multi-query 好，同时速度比 Multi-head 快</strong>。</p><p><img src="https://dongnian.icu/media/image_5.png"></p><h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p>MHA（Multi-head Attention）是标准的多头注意力机制，h个Query、Key 和 Value 矩阵。</p><p>MQA（Multi-Query Attention）是多查询注意力的一种变体，也是用于自回归解码的一种注意力机制。与MHA不同的是，<strong>MQA 让所有的头之间共享同一份 Key 和 Value 矩阵，每个头只单独保留了一份 Query 参数，从而大大减少 Key 和 Value 矩阵的参数量</strong>。</p><p>GQA（Grouped-Query Attention）是分组查询注意力，<strong>GQA将查询头分成G组，每个组共享一个Key 和 Value 矩阵</strong>。GQA-G是指具有G组的grouped-query attention。GQA-1具有单个组，因此具有单个Key 和 Value，等效于MQA。而GQA-H具有与头数相等的组，等效于MHA。</p><p>GQA介于MHA和MQA之间。GQA 综合 MHA 和 MQA ，既不损失太多性能，又能利用 MQA 的推理加速。不是所有 Q 头共享一组 KV，而是分组一定头数 Q 共享一组 KV，比如上图中就是两组 Q 共享一组 KV。</p><p><img src="https://dongnian.icu/media/image_6.png"></p><h2 id="5-Flash-Attention"><a href="#5-Flash-Attention" class="headerlink" title="5.Flash Attention"></a>5.Flash Attention</h2><p>论文名称：<a href="https://arxiv.org/abs/2205.14135">FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness</a></p><p>Flash Attention的主要目的是加速和节省内存，主要贡献包括：</p><ul><li>计算softmax时候不需要全量input数据，可以分段计算；</li><li>反向传播的时候，不存储attention matrix (N^2的矩阵)，而是只存储softmax归一化的系数。</li></ul><h3 id="5-1-动机"><a href="#5-1-动机" class="headerlink" title="5.1 动机"></a>5.1 动机</h3><p>不同硬件模块之间的带宽和存储空间有明显差异，例如下图中左边的三角图，最顶端的是GPU种的<code>SRAM</code>，它的容量非常小但是带宽非常大，以A100 GPU为例，它有108个流式多核处理器，每个处理器上的片上SRAM大小只有192KB，因此A100总共的SRAM大小是192KB×108&#x3D;20MB192KB\times 108 &#x3D; 20MB192KB×108&#x3D;20MB，但是其吞吐量能高达19TB&#x2F;s。而A100 GPU <code>HBM</code>（High Bandwidth Memory也就是我们常说的GPU显存大小）大小在40GB~80GB左右，但是带宽只与1.5TB&#x2F;s。</p><p><img src="https://dongnian.icu/media/image_7.png"></p><p>下图给出了标准的注意力机制的实现流程，可以看到因为<code>HBM</code>的大小更大，<strong>我们平时写pytorch代码的时候最常用到的就是HBM，所以对于HBM的读写操作非常频繁，而SRAM利用率反而不高</strong>。</p><p><img src="https://dongnian.icu/media/image_8.png"></p><p>FlashAttention的主要动机就是<strong>希望把SRAM利用起来</strong>，但是难点就在于SRAM太小了，一个普通的矩阵乘法都放不下去。FlashAttention的解决思路就是将计算模块进行分解，拆成一个个小的计算任务。</p><h3 id="5-2-Softmax-Tiling"><a href="#5-2-Softmax-Tiling" class="headerlink" title="5.2 Softmax Tiling"></a>5.2 Softmax Tiling</h3><p>在介绍具体的计算算法前，我们首先需要了解一下Softmax Tiling。</p><p>（1）数值稳定</p><p>Softmax包含指数函数，所以为了避免数值溢出问题，可以将每个元素都减去最大值，如下图示，最后计算结果和原来的Softmax是一致的。</p><p>$m(x):&#x3D;\max <em>{i} ~ x</em>{i} \ f(x):\left[\begin{array}{llll}e^{x_{1}-m(x)} &amp; \ldots &amp; e^{x_{B}-m(x)}\end{array}\right] \ \ell(x):&#x3D;\sum <em>{i} f(x)</em>{i} \ \operatorname{softmax}(x):&#x3D;\frac{f(x)}{\ell(x)}$</p><p>（2）分块计算softmax</p><p>因为Softmax都是按行计算的，所以我们考虑一行切分成两部分的情况，即原本的一行数据$x \in \mathbb{R}^{2 B}&#x3D;\left[x^{(1)}, x^{(2)}\right]$</p><p><img src="https://dongnian.icu/media/image_9.png"></p><p>可以看到计算不同块的f(x)值时，乘上的系数是不同的，但是最后化简后的结果都是指数函数减去了整行的最大值。以$x^{(1)}$ 为例，</p><p>$<br>\begin{aligned} m^{m\left(x^{(1)}\right)-m(x)} f\left(x^{(1)}\right) &amp; &#x3D;e^{m\left(x^{(1)}\right)-m(x)}\left[e^{x_{1}^{(1)}-m\left(x^{(1)}\right)}, \ldots, e^{x_{B}^{(1)}-m\left(x^{(1)}\right)}\right] \ &amp; &#x3D;\left[e^{x_{1}^{(1)}-m(x)}, \ldots, e^{x_{B}^{(1)}-m(x)}\right]\end{aligned}​​​​​<br>​$</p><h3 id="5-3-算法流程"><a href="#5-3-算法流程" class="headerlink" title="5.3 算法流程"></a>5.3 算法流程</h3><p>FlashAttention旨在避免从 HBM（High Bandwidth Memory）中读取和写入注意力矩阵，这需要做到：</p><ol><li>目标一：在不访问整个输入的情况下计算softmax函数的缩减；<strong>将输入分割成块，并在输入块上进行多次传递，从而以增量方式执行softmax缩减</strong>。</li><li>目标二：在后向传播中不能存储中间注意力矩阵。标准Attention算法的实现需要将计算过程中的S、P写入到HBM中，而这些中间矩阵的大小与输入的序列长度有关且为二次型，因此<strong>Flash Attention就提出了不使用中间注意力矩阵，通过存储归一化因子来减少HBM内存的消耗。</strong></li></ol><p>FlashAttention算法流程如下图所示：</p><p><img src="https://dongnian.icu/media/image_10.png"></p><p>为方便理解，下图将FlashAttention的计算流程可视化出来了，简单理解就是每一次只计算一个block的值，通过多轮的双for循环完成整个注意力的计算。</p><p><img src="https://dongnian.icu/media/image_11.png"></p><h2 id="6-Transformer常见问题"><a href="#6-Transformer常见问题" class="headerlink" title="6.Transformer常见问题"></a>6.Transformer常见问题</h2><h3 id="6-1-Transformer和RNN"><a href="#6-1-Transformer和RNN" class="headerlink" title="6.1 Transformer和RNN"></a>6.1 Transformer和RNN</h3><p>最简单情况：没有残差连接、没有 layernorm、 attention 单头、没有投影。看和 RNN 区别</p><ul><li>attention 对输入做一个加权和，加权和 进入 point-wise MLP。（画了多个红色方块 MLP， 是一个权重相同的 MLP）</li><li>point-wise MLP 对 每个输入的点 做计算，得到输出。</li><li>attention 作用：把整个序列里面的信息抓取出来，做一次汇聚 aggregation</li></ul><p><img src="https://dongnian.icu/media/image_12.png"></p><p>RNN 跟 transformer <strong>异：如何传递序列的信</strong>息</p><p>RNN 是把上一个时刻的信息输出传入下一个时候做输入。Transformer 通过一个 attention 层，去全局的拿到整个序列里面信息，再用 MLP 做语义的转换。</p><p>RNN 跟 transformer <strong>同：语义空间的转换 + 关注点</strong></p><p>用一个线性层 or 一个 MLP 来做语义空间的转换。</p><p><strong>关注点</strong>：怎么有效的去使用序列的信息。</p><h3 id="6-2-一些细节"><a href="#6-2-一些细节" class="headerlink" title="6.2 一些细节"></a>6.2 一些细节</h3><p><strong>Transformer为何使用多头注意力机制？</strong>（为什么不使用一个头）</p><ul><li>多头保证了transformer可以注意到不同子空间的信息，捕捉到更加丰富的特征信息。可以类比CNN中同时使用<strong>多个滤波器</strong>的作用，直观上讲，多头的注意力<strong>有助于网络捕捉到更丰富的特征&#x2F;信息。</strong></li></ul><p><strong>Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？</strong> （注意和第一个问题的区别）</p><ul><li>使用Q&#x2F;K&#x2F;V不相同可以保证在不同空间进行投影，增强了表达能力，提高了泛化能力。</li><li>同时，由softmax函数的性质决定，实质做的是一个soft版本的arg max操作，得到的向量接近一个one-hot向量（接近程度根据这组数的数量级有所不同）。如果令Q&#x3D;K，那么得到的模型大概率会得到一个类似单位矩阵的attention矩阵，<strong>这样self-attention就退化成一个point-wise线性映射</strong>。这样至少是违反了设计的初衷。</li></ul><p><strong>Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？</strong></p><ul><li>K和Q的点乘是为了得到一个attention score 矩阵，用来对V进行提纯。K和Q使用了不同的$W_k, W_Q$来计算，可以理解为是在不同空间上的投影。正因为有了这种不同空间的投影，增加了表达能力，这样计算得到的attention score矩阵的泛化能力更高。</li><li>为了计算更快。矩阵加法在加法这一块的计算量确实简单，但是作为一个整体计算attention的时候相当于一个隐层，整体计算量和点积相似。在效果上来说，从实验分析，两者的效果和dk相关，dk越大，加法的效果越显著。</li></ul><p><strong>为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根）</strong>，并使用公式推导进行讲解</p><ul><li>这取决于softmax函数的特性，如果softmax内计算的数数量级太大，会输出近似one-hot编码的形式，导致梯度消失的问题，所以需要scale</li><li>那么至于为什么需要用维度开根号，假设向量q，k满足各分量独立同分布，均值为0，方差为1，那么qk点积均值为0，方差为dk，从统计学计算，若果让qk点积的方差控制在1，需要将其除以dk的平方根，是的softmax更加平滑</li></ul><p><strong>在计算attention score的时候如何对padding做mask操作？</strong></p><ul><li>padding位置置为负无穷(一般来说-1000就可以)，再对attention score进行相加。对于这一点，涉及到batch_size之类的，具体的大家可以看一下实现的源代码，位置在这里：<a href="https://link.zhihu.com/?target=https://github.com/huggingface/transformers/blob/aa6a29bc25b663e1311c5c4fb96b004cf8a6d2b6/src/transformers/modeling_bert.py#L720">https://github.com/huggingface/transformers/blob/aa6a29bc25b663e1311c5c4fb96b004cf8a6d2b6/src/transformers/modeling_bert.py#L720</a></li><li>padding位置置为负无穷而不是0，是因为后续在softmax时，$e^0&#x3D;1$，不是0，计算会出现错误；而$e^{-\infty} &#x3D; 0$，所以取负无穷</li></ul><p><strong>为什么在进行多头注意力的时候需要对每个head进行降维？</strong>（可以参考上面一个问题）</p><ul><li>将原有的<strong>高维空间转化为多个低维空间</strong>并再最后进行拼接，形成同样维度的输出，借此丰富特性信息<ul><li>基本结构：Embedding + Position Embedding，Self-Attention，Add + LN，FN，Add + LN</li></ul></li></ul><p><strong>为何在获取输入词向量之后需要对矩阵乘以embedding size的开方？意义是什么？</strong></p><ul><li>embedding matrix的初始化方式是xavier init，这种方式的方差是1&#x2F;embedding size，因此乘以embedding size的开方使得embedding matrix的方差是1，在这个scale下可能更有利于embedding matrix的收敛。</li></ul><p><strong>简单介绍一下Transformer的位置编码？有什么意义和优缺点？</strong></p><ul><li>因为self-attention是位置无关的，无论句子的顺序是什么样的，通过self-attention计算的token的hidden embedding都是一样的，这显然不符合人类的思维。因此要有一个办法能够在模型中表达出一个token的位置信息，transformer使用了固定的positional encoding来表示token在句子中的绝对位置信息。</li></ul><p><strong>你还了解哪些关于位置编码的技术，各自的优缺点是什么？</strong>（参考上一题）</p><ul><li>相对位置编码（RPE）1.在计算attention score和weighted value时各加入一个可训练的表示相对位置的参数。2.在生成多头注意力时，把对key来说将绝对位置转换为相对query的位置3.复数域函数，已知一个词在某个位置的词向量表示，可以计算出它在任何位置的词向量表示。前两个方法是词向量+位置编码，属于亡羊补牢，复数域是生成词向量的时候即生成对应的位置信息。</li></ul><p><strong>简单讲一下Transformer中的残差结构以及意义。</strong></p><ul><li>就是ResNet的优点，解决梯度消失</li></ul><p><strong>为什么transformer块使用LayerNorm而不是BatchNorm？LayerNorm 在Transformer的位置是哪里？</strong></p><ul><li>LN：针对每个样本序列进行Norm，没有样本间的依赖。对一个序列的不同特征维度进行Norm</li><li>CV使用BN是认为channel维度的信息对cv方面有重要意义，如果对channel维度也归一化会造成不同通道信息一定的损失。而同理nlp领域认为<strong>句子长度不一致，并且各个batch的信息没什么关系</strong>，因此只考虑句子内信息的归一化，也就是LN。</li></ul><p><strong>简答讲一下BatchNorm技术，以及它的优缺点。</strong></p><ul><li>优点：<ul><li>第一个就是可以解决内部协变量偏移，简单来说训练过程中，各层分布不同，增大了学习难度，BN缓解了这个问题。当然后来也有论文证明BN有作用和这个没关系，而是可以使<strong>损失平面更加的平滑</strong>，从而加快的收敛速度。<ul><li>第二个优点就是缓解了<strong>梯度饱和问题</strong>（如果使用sigmoid激活函数的话），加快收敛。</li></ul></li></ul></li><li>缺点：<ul><li>第一个，batch_size较小的时候，效果差。这一点很容易理解。BN的过程，使用 整个batch中样本的均值和方差来模拟全部数据的均值和方差，在batch_size 较小的时候，效果肯定不好。</li><li>第二个缺点就是 BN 在RNN中效果比较差。</li></ul></li></ul><p><strong>简单描述一下Transformer中的前馈神经网络？使用了什么激活函数？相关优缺点？</strong></p><ul><li>ReLU</li></ul><p>$FFN(x)&#x3D;max(0,~ xW_1+b_1)W_2+b_2$</p><p><strong>Encoder端和Decoder端是如何进行交互的？</strong>（在这里可以问一下关于seq2seq的attention知识）</p><ul><li>Cross Self-Attention，Decoder提供Q，Encoder提供K，V</li></ul><p><strong>Decoder阶段的多头自注意力和encoder的多头自注意力有什么区别？</strong>（为什么需要decoder自注意力需要进行 sequence mask）</p><ul><li>让输入序列只看到过去的信息，不能让他看到未来的信息</li></ul><p><strong>Transformer的并行化提现在哪个地方？Decoder端可以做并行化吗？</strong></p><ul><li>Encoder侧：模块之间是串行的，一个模块计算的结果做为下一个模块的输入，互相之前有依赖关系。从每个模块的角度来说，注意力层和前馈神经层这两个子模块单独来看都是可以并行的，不同单词之间是没有依赖关系的。</li><li>Decode引入sequence mask就是为了并行化训练，Decoder推理过程没有并行，只能一个一个的解码，很类似于RNN，这个时刻的输入依赖于上一个时刻的输出。</li></ul><p><strong>简单描述一下wordpiece model 和 byte pair encoding，有实际应用过吗？</strong></p><ul><li>传统词表示方法无法很好的处理未知或罕见的词汇（OOV问题），传统词tokenization方法不利于模型学习词缀之间的关系”</li><li>BPE（字节对编码）或二元编码是一种简单的数据压缩形式，其中最常见的一对连续字节数据被替换为该数据中不存在的字节。后期使用时需要一个替换表来重建原始数据。</li><li>优点：可以有效地平衡词汇表大小和步数（编码句子所需的token次数）。</li><li>缺点：基于贪婪和确定的符号替换，不能提供带概率的多个分片结果。</li></ul><p><strong>Transformer训练的时候学习率是如何设定的？Dropout是如何设定的，位置在哪里？Dropout 在测试的需要有什么需要注意的吗？</strong></p><ul><li>Dropout测试的时候记得对输入整体呈上dropout的比率</li></ul><p><strong>引申一个关于bert问题，bert的mask为何不学习transformer在attention处进行屏蔽score的技巧？</strong></p><ul><li>BERT和transformer的目标不一致，bert是语言的预训练模型，需要充分考虑上下文的关系，而transformer主要考虑句子中第i个元素与前i-1个元素的关系。</li></ul><p>本文转自 <a href="https://dongnian.icu/note/llm/llm_concept/02.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/1.attention/1.attention.html">https://dongnian.icu/note/llm/llm_concept&#x2F;02.%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80&#x2F;1.attention&#x2F;1.attention.html</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - 通用面试手稿</title>
    <link href="/2024/04/14/%E7%AC%94%E8%AE%B0%20-%20%E9%80%9A%E7%94%A8%E9%9D%A2%E8%AF%95%E6%89%8B%E7%A8%BF/"/>
    <url>/2024/04/14/%E7%AC%94%E8%AE%B0%20-%20%E9%80%9A%E7%94%A8%E9%9D%A2%E8%AF%95%E6%89%8B%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="613e3fce99246b1a0658c9c7a1378cab7460861b6db9d433da5f505a857192fb">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7437d92210b9370f7ae48cb0d3b75ff2b9888802021482e0c58aa88f3153b740f2ab74ef2628a722d5e96d0133e6fe347a1d9f766b022497641375c3c307f34fb4f99961f117633bb1ce6d259dff8d4bbf71c92979f5f5d2fd03e77939a4438bbe8fde18ef4f28b06a1dd3219490f00e07c916f672dbc848b69e5fc927ff5d2ec1a6fb92e2e58b629031db5818e909070bfeacfcfb82fad7a6b3c4ba49c9f6e1b1ac248351af17ab9fd9ad024ac4df590b88c6febdae35e985a1c25cdb0586b56c5ea49ef53561bfdd5926762bf240b35569f69aebe84e80bd19efdf24ce0a8a754202e90424846ed235764b4a6292eed674f814b10279457215ef3aaa0e60608dec097d1cd6c1186b0f20ddcecbc8fd3e94b6289803e76f37c9abfc0dc4e944f1b88f396931cb9b9a06a123a30d009276d0f93ef59d8ed6dd010f7e82b447db02fd17618ac655d9eaa2c3764dd3ab146494f53299f63d97e95a08a737e81d1ba07f90a12b73e3f3d5caf256484ca75152ea508fd3e643e57efd00f5aacbf80d3e87624ae75d7635edb5c8898ae42da8a7ab8630379000f743e0a1ba0497ae2c574eb3800f05a535897bdcbfefb7711f93576536ca3209722b3497b4bfc7efc796ba631427eea6769acf00243c06f2eb6ca58f427e1764a7ad79847ff65c9fae5fa285ba6e9a242fc542294b9a7e49ba3bb912e64a682e7ae34d205e9acd25180095d2d60fb83f921ad71fd58a24f021f56905b97be42c43bd0b02a250d04101496c427305c8a57802df9992b24a0d3898201fcec24a2eb2c08d137909e246f1b602a6d0d3b1aba06bfdf57c61a4c88b4c20f41c32681176a19cc0c6ac5baab738eb94a1ad4baa2b1130f208787f0162bfd725d5f8bc7786d5bc10cdcf01f9b5e22344a26c6511c4ff603b6b9f3c9c1cef0c03cf51a3c449fb051d47ad75db832f5715f4ce82ff1a39b2adbd264b50c77e6f28c7255d8b3f47e9f5d26cd4c876bd8938d3d406f68845f38d19bf5929e61fc3dabbc191fa2f654671ca0f26c5d93c38aa50704ad49e418bb7e8b7f4882f25e2c487a5193242499c40d85b3f98857fd23ebc97023bc3d4951961ab268e532b51ba4a97458843c7aec51d37c8a10fb0d1472011d207c5369dd03847ce87f58c3054cefda9e60833fb03e8642c5c43958e11e18f2c263d8f9effa9b3064242633aecd2f43e34f03a56af886665343f81c2ee6e1c09c94127282d442f12ac71822d85bdf6fb78859456241e9da00c0c688a4a9f46de872a88f3e5f40566d25b2bf1924eeb9ef1e31d5cf215d178a86effa851d3ea17e1a0fd15281173ee98665075949a23ca46b14345d9646c3394267f4edcf246ddbc56d8f5dbc35ee97c15910045eadfd5ffd92728fca30cf010bdf4006dab20e156dabb26862cc04c7b8bac507a41d180612cd0965a46f624730e3b23de742821095b69a24097bc70d31345a2551ab47ee28f350e3ae962b0ca17760517789271fb7ad5c62a8607fa9e7282595bb10a80d7f436d98dab87c949f47c57490d29a931882eb1aaf380d475fc9cf63b1c10ba042a2d395bf53c037178eb2350c09ab14fb1b03015dfa37415b482762cb4be252212db1a983ae81e74c4df75f5bd0f705eb123c4348a860b30ab7e5d8c00c164205a344808fc1729d8afef37ea01a9f708a6cba52f0dbe9dda1237721d6c547a0b5c7ede7ebc5d4a1fbabc4b0b858ee560c48b4e01c24b55aa1c121484755f5f8a2b67204ecfd7604eade9662bce2042da4b94953edde3138feecdf9a4240863a9cf536d0ad84a36543062584df63b8fba90086b81dd4a0589f2546fd5ed6081d69bc3c2eec9f43e144e824c61fe79e583cb7b6aa9376fc371105d6f68387391766bdcf2ac631fd65454e32150b96e42f3fe7ed4fe36e33f7332f57487938d7a8868cc854baf53296a3c8f4e4844a14b3ae51a48d09136c49ca9f8aef580b39546116b261fa14a4623f8bf8c368fdca4fe8809120b096763ddcb41a988f37a765d16f9519c5c4ca3a1e9d540a86b1f983c6d1835309b22ca5ffb803296a9b86fd5db8e40d1e8b3a9f4239e23f205454fe5f4149dd4eb9108ba8489de95f114820d16f9aad546f62df999431a79007a3d3f29001b22b3e413dc757147fe2c1b1c99763973ec330c5a2b8e0be3bfc99598afd462415c4cf182c78bc24a2656cc31554090b67c78af21ae17ee58ff2a7085c504c1a96c37acf367e6a86a6c26eb9e202c69e9525ca8368001f1a23b7e8fd3d5a938dae64c4cdac3d7d765cb50665c42236dff4c4050cba4c4e6a62f1bdf8eb2e17cbf7c797f80db06c2f69495529264cd7fc1bac77ef69f4525a672262fedeba8bc1a28355fd5226763720f911d6720a157ca227318d286b6c0ec534e93cf79016d69367be6a908c373f1847391929954cffcd9cac376ff1df770d397e633963bd8b5fe94f8f965e3e7c0bfbe2deb14902f7deff3f8bed5458d8df7d11b1f081d1fe24cc3e93cef82eacb610845d6a07f706829d2e67a754d89c0b531c1bed38442fd58a96f36ca156fc3c234a204577643d7da5fb52399fb6450c8df5f6d69bf1c04a6f5358fcdcace4a13a1200f3f640ca5c892e5c75edadbb58affbd32eea0305c5db683241a0a270cf3620fcc039958d2ce222d8e9885c2958b70d41ec798419f61da67c9b09395bb84d340cfbe6d51df1aa235facf6d8ea9006a2269ffcdb05edb7f777eed601ea620f7160e2e4fee6e6c0dfb6ca0647e836705a370303e641d646410a3e3831b4fe4cbe3a11dd06e039765f95b440c8fb1803c0bbd8aa8dcd66a1b768e28fa8888cd4114b813f6533711920208019871762baeff36a41af90d21ff384b135e31b8d97a307bee4f717e45ea1016f0c9a89469a0a94db610527fa015c15469265e8747a4706bc9983643d127ed9cdd2a7a15a13cdc79bc8ceb8ad6863fb7b63f318671b78aa149b9470bb7c43f08a31e2ab7ad5beff046418663e8776b3feab1e355a76a3369078329196df366838b35002c7ab57955920a477effab78220bfe40f8b8199cf5950ed3e0ae99ecba9208bca9fd6030cb8a358c61fe4ed94bd89500b99dcb2c29503db9c1d031c6d37231bdc1e204f53bda5425f164c1333f6f174fcd8f48e7c58938b588233f64a884b97578403afe4d81ca59c1da371544b7280147bc9beebe2e12a825e2cded0f1d1ad6365b34963f3daf25bc83c8aea71f82c6b6cd8bd0260c73b4e4a8cd27d1456e4a7204133362d97e5b887289dc9f0bb570a348fc059def1dcc59acd2dae379b84faaa4395a3bc5fc087985c077b89ae7d8b6e9a40ca1fd06ef77c68e2386937d86f82e659af6bb7ca692f905621545225efd68bc8dd70218ab5665327a42fbf872f20d6fc55ebc9cf45ee2d9ba72aea2bb23a84c4ad20ae1e5744f3f859f8527dc22e0acba82ea28dc0d08b521939c9a8a218b1f02b441355b3fb114f2eaf70234af712e05d3d68b0245fda6ef81f6a062885403b7fdd64e5cfb8121d138bd64e88e9a322596270d9f5d433e2ba7ea33a4bb8a9f8774d84894e50349ce5390804e3253198d8598b48e2231feadf124f8b66a66583c6574a58929228d027cd48761b4f48c9a069040b16503a2d7cf2ad6470df09efc674c06d57670b34d019940f9e8670a035b367b52e3486f48f58b380bb722f4e5b6ceeaa1a0e0c8f503468d68d30501c7a4e39cf8cd855e920572953f535d95eccc410875e18025512779fdb26ce1456317bfc183574527e941483083e44175de7918e0e4d7fb1588452f86c6bad3988a76d52130ec6ea9ed125697583c96cbca2fde70a4a35d7601d62ae1b23007528ce99101d3f3b0dc8ba7098aa161ad29581c12ac9cb41f9f272e8a1dde8bc28261cd3899f99e90ae0a15749cc479c0876bf23158471c9de8a78026e0c9261b22975c4ab000fc32c54f977b7e756da3db2326332d989b36838eb78f4011806ab44f427b5af20dd2a33b5cd1be4780deeaa7beaaef29ff2a8723996c76e22058bdb33af17e37b10ff0e706b7ce1ded42485e30139a2b24c82942018908628d40bac12732dedcde62a42b1398d7136a01638729048d19c8cfd201dc762f09988557552fcdfe22e5b69ee628f672248c94fc7ede0e60da75cee2b08fafdfa1fd6832ff722a381421aa58c2614c70c8dccb9fd650c660e774349f64117866d777d7e1bb3ac8f8a5ee62f7bd290c471a8a50e21a95b7ff56137083702ddf77ad02d6b79f8b9fa1db5f05f87234055d1b84dbbda1f1d4c14008301043763e1f5851241c54424027f4e14c2cf745a43ed0e96839a0afb3ff58dfb56d36123beb18fd8d3be3fd9ce6ac33ccba694de72228ffef2b06b5308a81509280214c78e224f55f4afa911e6b28b7de35f46e9f0c1ce0b83f0032a3543b3ba187f10e65870a62a8482c741507aab573cb10b62622c7d1f72fbea82de6658c15b3d1780c779009795f4dffcd8195aded9be2995472ca9b9d981ff62b9b445dcc0a1611b83381809cff7c60eb2a1b3960c3f603b193f59e92ae4303ead8bd5b4ec1823ffba6ce4016bb5408780e7b30543c49804a83b403549aa800ef906d0d03ff6ccd70974f03e90a0a5a41d411ef4e80eb71fa440f6bb4ee3ea7b8ec7ac28cdd7fe122ee64e71cdf6322bab51a59769fd8ed9c3e609c7d3ef0a0cc294999618fc596b23c545096c318fc2a560f426a176dbfda9e7e541c27b32652ddad0decb053ed47c1afb6005f3530f59a6a7faa10e76717cec85640531c9e7638310a12991060b1e0f71ef8dccecfb71a193e9a7f3cf5544afed688d07603529b26c8b0fc1e58df08cee23a630170dc558efe320b01a08489071a26595bf45f1086e1a8ce3f976c6ef3f5267e12e1235f268365ff44974d793eb5323ffe6ff505f9ac7110300b63eea55ba3bbe6c8d8daed72bbef2ce12a5ffcbbfa8bf0190d24ae665a1f56b2d0c92c384c9368ecf9447dcf3e7e79bce81baa5fd36c3f3cb93a20e058ce274562b6d1b9a9680813254dd5f9637d42f673cec26d4bcab58196dfcd7dbf7238a6db32977e6fed87613ef6bd8a25b5614e940d9ca7bd9670e8c6fc416c223dab0c19f5b1b242d6040784b47d26521cb334e98698e73f92c98c5e37b5454411b87acc8aa426b077e0d8284be413d171ca14ba9e2c3ea6383f5522cc7b79641e17fc9d694812d7fc104636bb26e8487c098d8647ad8edf9a47c763af056c9e90b52edd2ab4b1a405ba9e85ef079a2c9f9537cb7488df2a1d3065e18082b6b46d0c19a11ee9ee4e4ca153323222620da53df80960d0014ebb30759ff9b6a034a4f1280907e408fb517d28727f4a70c499e2da12a8f5f8f029a2714dc1e5c69829956f7afcc32417fe96215f2d4a75383afb20973f0d1b987481fbea21cdd0b183a4583ab5df26a1162ec719a1bc9a3e9c61a6edbaebe6399d267b1e6f69e2c1461a7a47aefd0d656a55b34324bf1873c49369857874a7c464fda6ce06dee73682081c7b6a74247edff82ef47caded0540bfc126ce8b27d896e8a04abcb9f5cd7ed39f2d7446c4cb52a17224dd8347a1b58152325ee24983b3f91921d758735e8bdfffd09f6eecff49749bd247dd1472ee9b68d41cc200f741e79620e8698c4cbe1a34124257a5f63e0b376e607db32819da3532ea4d64d27b75e0ab271a571178d58dbf75955324d8403b8bc37ca3943f6357de316d8500eab9cce3e26e3d2005aaf28adb93c50d7b8a268dca1fcca90dad703ebb2b462b720e90ff77c13cd28bbe7499580d15b0627ae58f8d35187811c8b5189c2842d3f72703e7b8bc879d7451d024d69a581281ed67d6f6a66c6746fe7a261a84d2076841137ea4cb7c5793b37de6bb7a70591dee2e7fc900584f01939c8cf725ae2f573cc66e6d0cb543c21507a555181d92c176d97d30f3e53eda6a0b204442f58f45afcd66c5a767a5b587516ca0ab5f6f1d34fbaa5f17d8bdc2ae1c1b28123b2d73bae0902cf0d5e568287fea348524986e2d63021009b7754c15f051fab37ee4e00227b81a9077be02daee56ab828ff2c7e067c5a94f9bc499f9b67fe7c45fec3e72df29745e70b9f115a3c3f41785fc9ab56a602edfe9bd376e202e3a1135daf6584bd97e4dd507b2eaa602a3319b252adca9dc485caa989e4086f99eac05d476e2c962642330907b22068c719a2fee56c02baaa2316e223a6574977f36c79a5d570d1b9f491e9ca2778b1ca657954791d73c6be0235804ec826f7381a796372ceacb49f2049860f57474e08dcfe4d6bc1bb7f09757cdbb76d9f4754eae0e511cb4ec7312dd40ffa8c018a5c8564c6fcb3c747e577d035c062b59698de4bb5e0ea6efbc0225ec3857815c35c15456db9e56eee431f306968349cb65d0d1c19b1c698d236c0c8bc7ca588a5ea7adb0459110b9a702457a5eff99a616f56f741511180033c64a925c1559cfa4a15e348cd4fd9d72d24a4bdc364db70afc5620070a8b778cfac4a4b25a4d3beb1fbe7a00672c7cb277aa5f54177f728e10b2224e647d41385360007f6666d28537c5840812c7df41a48468fca6081a6d7e4d391c3d15881e088f3c18cb064d87099b2c6f12b532ac1847f3ba06d173bf6a42471b9f2a9166dc7a0059d83f4c1b09b357f8fbd8a8698de6a699235e8408c56603e02694a0b5be84aa983eebbdfd07e68368d001b1e75a703b9f266feb383c5a7039dcaf3f7b9d3b4c832ec6669359762ee909141e46b40f5ef01e6e36b84b5d800a65a85ab0ad9b4ec831e30d564a2e7655ef7b1463767a21cc2cbd54c9fd24bbf64010b10bdd692a68e403d348a03c51837550ef526424f15a076cee8822cc40620e47ce71b942b5770cbbc224fa38f093ceea94c9a46e04808b069989ed50bf0f5ce5e2625dea3627c0916208f26d6a28c0c6f842e69e10ae7319349f55cf53ea38d3edbad3f1c29e2771eae1371d4e34bc89f44e44c18eca6ee1fae8888f1291ee7b589f27892319e3ff1ba6b1c5304eaa669f0817aa8b7db440f104f7ae37de35a42f97671ffbee8259feace3e76af5325d5b31d1066881cc5abf4b6fa3402dc589a97ed0b0a71724c9f5d89d040af24fb91519642e5d615f01db640b8c4c9b57b028b4cb395a92428a6c27c21196211940e5718f76d8eef673541136446e4bdd1290ee6bb74de4a672abc2eb99f928f2b23c5cabaf6fe5099e39cf32182f1e97b9e3447137365385a124722032c4fe04ad2ee223046839cffa6829ebcda5214deccdfdfb73d55a800a69df96492fc52977f39d0d35af2d35992442421f9911e8a17cb68d310827cee0ce5f4e43c1a434ed3da1fe03be42b758d1e703485960b1c8a3271ed5bb3430ae3f0106f5eea28378a9e0aceb8765d53868875610700cab52b26a2884e848943e5e63a6b8d338652b4e8fc5a124f5f7eb63956e0dce88eec8cdbfeafa61b7a306245d84279c96e4e7de4e57c0402e6074d3cb000720f590aa990564c2107a756d233344fe707c1258f84ebe24c350dbc9667a3378bd22e12859a33b9f3eea82a98d514be5d26b2c46b2ad4abc0115f703960474d17f52d1cccbeaa8324d45642ab3ea4c7404014b6e3309f2e7abbf149fa769c22c2a06fbb4805a634bcad008da604b739a92ecd523ff2481db5f4e26c351b4ce60d778e847ce53a5ca5bb28294917dafbeac8ac002ebb6f0973733d819265e10b5bb5ef70fe149c46f6db5afc711a8cb864d53baeb8c11d6ce82c5413ed911d6992e4bfc567783365f8aa83d7a41f10abad218c424c6315807b9115c276415e3e264de71470dac77c5ac01bd8579588ddeec57b7b4f2a972ecb1efb4b2ef3b98b10b300d5aa2eb74557b580f72acf62caa7a8b36ebe0b9ec305932401c2080558317e33e5bb56944fcb821db78f703b3005e54134c69339bf1dc11625a527e866efcf144c763782307b886a5cd9d6272e53a5874130705995f91d7946368392aba6b17c72b9271047b386f27e4bd1f4df16a2ee2e4cd61cd7dc23690aff6581a8999e155def982623ed5d9431557db2644fc1ecd809213183a00c09b1d95c18b596fc2d6e2a2ada2cf450043b1aacee5fc4246e665280b26a23010d522e99ee90a3df2b677027a3b6cbb23a7dd9d66b2647985ddff10780ad1e04139e29b66e7a851e3dadc455a404193636c0c8afe35565d2c0d51737588313b219fd968ab058be4024ee0dcdf8b0ad7f011f621470f3fabb0b5b0e6c3d8b0834d4909b5e07b781e2e11a2145f7758d7f43909340bc25e150a949fda71f351b55a1e99f902c3b36a0b4afcde7c18c5d3aa9b75ab0ab4a4be7c9a5d742504fb46bba85aef71626103a0197a504153ab42c4d01df9d5a97cb977a63ffdaf71b9cad53c732a017cb3f757cd1ea723522314f5c28266ed4454e44aa1283b683524e3b7f53e78d2da6b79ebe0f0789c2963f88f3b7c9df8d6d3c270a555d592d5b7d799eb5398436d50967339b2fbd5b21bb0f1f5221e28a4217d4af4238b5be766a98fcb410ad0aa100cd9da3559ce18551d42d1e9a0db4375fd4349a856b5b89d21edaca5062fda8d48e75d768e17f7bd51be44f7724718df76f10b89a2b133f322f49c9e7a4263db392f5a889b3ad9f32689511cb936cc3b13b43500f6986ec5bbf67a97c38a8d7d7f00a0220f6fa7c920dae0535b896d4f13264d8137925ea866effe673ed07df3cff735a2ac4d3dc709cdefd4f2edab83fa97798bcf23765fe1b91e25bdc53d03b37172d4d2ae12c84cb91dbb59fbf89d12761da45c20be78aa47490e701a091dfb5d4d56bc34f2c0479fe95c671beb4d6f90e77a6bef0f9ecbf9e0b38ebe8e737b4a4fcbc5927bdce2a8e174f80ab879a9be5708e1b799926566fb2848e068353f666b66c62adc0ed1f6ad1c5e371f3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - 强化学习面试题目总结</title>
    <link href="/2024/04/14/%E7%AC%94%E8%AE%B0%20-%20%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/14/%E7%AC%94%E8%AE%B0%20-%20%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>(1) 什么是强化学习？</p><blockquote><p>强化学习（Reinforcement Learning, RL），又称增强学习，是机器学习的范式和方法论之一。<br>RL由<strong>环境、动作和奖励</strong>组成，强化学习的目标是使得作出的一系列决策得到的总的奖励的期望最大化。</p></blockquote><p>(2) 强化学习和监督学习、无监督学习的区别是什么？</p><blockquote><p>监督学习一般有标签信息，而且是单步决策问题，比如分类问题。<br>监督学习的样本一般是独立同分布的。无监督学习没有任何标签信息，一般对应的是聚类问题。<br>强化学习介于监督和无监督学习之间，每一步决策之后会有一个标量的反馈信号，即回报。通过最大化回报以获得一个最优策略。因此强化学习一般是多步决策，并且样本之间有强的相关性。</p></blockquote><p>(3) 强化学习适合解决什么样子的问题？</p><blockquote><p>强化学习适合于解决模型未知，且当前决策会影响环境状态的（序列）决策问题。Bandit问题可以看成是一种特殊的强化学习问题，序列长度为1，单步决策后就完事了，所以动作不影响状态。当然也有影响的bandit问题，叫做contextual bandit问题。</p></blockquote><p>(4) 强化学习的损失函数（loss function）是什么？和深度学习的损失函数有何关系？</p><blockquote><p>累积回报。依赖于不同的问题设定，累积回报具有不同的形式。比如对于有限长度的MDP问题直接用回报和作为优化目标。对于无限长的问题，为了保证求和是有意义的，需要使用折扣累积回报或者平均回报。深度学习的损失函数一般是多个独立同分布样本预测值和标签值的误差，需要最小化。强化学习 的损失函数是轨迹上的累积和，需要最大化。</p></blockquote><p>(5) POMDP是什么？马尔科夫过程是什么？马尔科夫决策过程是什么？里面的“马尔科夫”体现了什么性质？</p><blockquote><p>POMDP是部分可观测马尔科夫决策问题。<br>马尔科夫过程表示一个状态序列，每一个状态是一个随机变量，变量之间满足马尔科夫性，表示为<br>一个元组&lt;S, P&gt;，S是状态，P表示转移概率。<br>MDP表示为一个五元组&lt;S, A, P, R, $\gamma$&gt;，S是状态集合，A是动作集合，P表示转移概率，即模型，<br>R是回报函数，$\gamma$表示折扣因子。<br>马尔科夫体现了无后效性，也就是说未来的决策之和当前的状态有关，和历史状态无关。</p></blockquote><p>(6) 贝尔曼方程的具体数学表达式是什么？</p><blockquote><p>对于状态值函数V(s)的贝尔曼方程：<br>$V(s) &#x3D; \sum_{a \in A} \pi(a|s) \sum_{s’ \in S} P(s’|s, a) [R(s, a) + \gamma V(s’)]$</p><p>对于动作值函数Q(s, a)的贝尔曼方程：<br>$Q(s, a) &#x3D; \sum_{s’ \in S} P(s’|s, a) [R(s, a) + \gamma \sum_{a’}\pi(a’|s’) Q(s’, a’)]$</p></blockquote><p>(7) 最优值函数和最优策略为什么等价？</p><blockquote><p>最优值函数唯一的确定了状态s &#x2F; (s, a)相对比他s &#x2F; (s, a)对的利好。<br>可以依赖这个值唯一的确定当前的动作，他们是对应的，所以等价。</p></blockquote><p>(8) 值迭代和策略迭代的区别?</p><blockquote><p>值迭代算法则是一步到位，直接估计最优值函数，因此没有策略提升环节。</p><p>策略迭代。它每一次迭代都有两个循环：先计算当前值函数（根据当前策略计算），在进行策略评估（根据当前值函数选取最优动作作为策略）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">value_iteration</span>(<span class="hljs-params">self, env</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; VALUE iteration. &quot;&quot;&quot;</span><br>    values = &#123;s:<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br>    policy = &#123;s:<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">argmax</span>(<span class="hljs-params">state</span>):<br>        max_val = -<span class="hljs-number">1e9</span><br>        max_idx = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> idx, action <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(env.legal_actions(state)):<br>            res = env.transition(state, action)[<span class="hljs-number">0</span>]<br>            reward = res[<span class="hljs-number">2</span>]<br>            <span class="hljs-comment"># 在同一层的values上计算下一层new_values的分数</span><br>            <span class="hljs-comment"># 类似背包的dp[i][] &lt;- dp[i-1][]</span><br>            next_val = values[res[<span class="hljs-number">1</span>]]<br>            prob = res[<span class="hljs-number">3</span>]<br>            score = reward + self.gamma * next_val * prob<br>            <span class="hljs-keyword">if</span> score &gt; max_val:<br>                max_val = score<br>                max_idx = idx<br><br>        <span class="hljs-keyword">return</span> max_val, env.legal_actions(state)[max_idx]<br><br>    self.iteration_number = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        difference = <span class="hljs-number">.0</span><br>        self.iteration_number += <span class="hljs-number">1</span><br>        new_vals = &#123;s:<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br><br>        <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> env.legel_states:<br>            new_vals[state], policy[state] = argmax(state)<br>            difference += <span class="hljs-built_in">abs</span>(new_vals[state] - values[state])<br>        <br>        <span class="hljs-keyword">if</span> difference &lt; <span class="hljs-number">1e-4</span>: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>: <br>            values = new_vals<br><br>    <span class="hljs-keyword">return</span> values, policy<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">policy_evaluation</span>(<span class="hljs-params">self, env, values, policy</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_values = &#123;s:<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br>        difference = <span class="hljs-number">.0</span><br>        <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> env.legel_states:<br>            res = env.transition(state, policy[state])[<span class="hljs-number">0</span>]   <span class="hljs-comment"># [(1.0, next_state, reward, done)]</span><br>            reward = res[<span class="hljs-number">2</span>]<br>            prob = res[<span class="hljs-number">3</span>]<br>            new_values[state] = reward + self.gamma * values[res[<span class="hljs-number">1</span>]] * prob<br>            difference += (new_values[state] - values[state])<br>        <br>        <span class="hljs-keyword">if</span> difference &lt; <span class="hljs-number">1e-4</span>: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>: <br>            values = new_values<br>    <br>    <span class="hljs-keyword">return</span> new_values    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">policy_iteration</span>(<span class="hljs-params">self, env</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; POLICY iteration. &quot;&quot;&quot;</span><br>    values = &#123;s:<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br>    policy = &#123;s:random.choice(env.ACTIONS) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">argmax</span>(<span class="hljs-params">s,values</span>):<br>        max_val = -<span class="hljs-number">1e5</span><br>        max_idx = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> idx, action <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(env.legal_actions(s)):<br>            res = env.transition(s, action)   <span class="hljs-comment"># [(1.0, next_state, reward, done)]</span><br>            score = values[res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]]<br>            <span class="hljs-keyword">if</span> score &gt; max_val:<br>                max_val = score<br>                max_idx = idx<br>        <span class="hljs-keyword">return</span> env.legal_actions(s)[max_idx]<br><br>    self.iteration_number = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_policy = &#123;s:<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states&#125;<br>        self.iteration_number += <span class="hljs-number">1</span><br><br>        new_values = self.policy_evaluation(env, values, policy)<br>        unchanged = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> env.legel_states:<br>            new_policy[s] = argmax(s,new_values)<br>            <span class="hljs-keyword">if</span> new_policy[s] != policy[s]:<br>                unchanged = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> unchanged == <span class="hljs-literal">True</span>:<br>            values = new_values<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            policy = new_policy<br>            values = new_values<br><br>    <span class="hljs-keyword">return</span> values, policy<br></code></pre></td></tr></table></figure><p>(9) 如果不满足马尔科夫性怎么办？当前时刻的状态和它之前很多很多个状态都有关之间关系？</p><blockquote><p>如果不满足马尔科夫性，强行只用当前的状态来决策，势必导致决策的片面性，得到不好的策略。<br>为了解决这个问题，可以利用RNN对历史信息建模，获得包含历史信息的状态表征。表征过程可以<br>使用注意力机制等手段。最后在表征状态空间求解MDP问题。</p></blockquote><p>(10) 求解马尔科夫决策过程都有哪些方法？何时用这些方法？动态规划是怎么回事？</p><blockquote><p>方法有：动态规划DP，时序差分TD，蒙特卡洛MC。<br>有模型使用DP方法。<br>无模型使用TD, MC方法。<br>动态规划是指：将一个问题拆分成几个子问题，分别求解这些子问题，然后获得原问题的解。<br>贝尔曼方程中为了求解一个状态的值函数，利用了其他状态的值函数。</p></blockquote><p>(11) 简述动态规划(DP)算法？</p><blockquote><p>为了解决MDP问题的DP算法就是利用最优贝尔曼方程来更新值函数以求解策略的方法。最优贝尔曼方程如下：</p></blockquote><p>(12) 简述蒙特卡罗估计值函数(MC)算法。</p><blockquote><p>蒙特卡洛就死采样仿真，蒙特卡洛估计值函数就是根据采集的数据，利用值函数的定义来更新<br>值函数。这里假设是基于表格的问题，步骤如下：</p><p>初始化，这里为每一个状态初始化了一个 Return(s) 的列表。可以想象列表中每一个元素就是一次累积回报。</p><p>根据策略pi生成轨迹tau</p><p>利用轨迹，统计每个状态对应的后续累积回报，并将这个值加入对应状态的Return(s)列表</p><p>重复若干次，每次都会往对应出现的状态回报列表中加入新的值。最后根据定义，每个状态回报列表中数字的均值<br>就是他的值估计</p><p>参考<a href="https://zhuanlan.zhihu.com/p/55487868">MC值估计</a></p></blockquote><p>(13) 简述时间差分(TD)算法。</p><blockquote><p>TD,MC和DP算法都使用广义策略迭代来求解策略，区别仅仅在于值函数估计的方法不同。<br>DP使用的是贝尔曼方程，MC使用的是采样法，而TD方法的核心是使用自举（bootstrapping），即值函数的更新为：<br>$V(s_t) &#x3D; V(s_t) + \alpha (r_t + \gamma V(s_{t + 1}) - V(s_t))$，使用了下一个状态的值函数来估计当前状态的值。</p></blockquote><p>(14) 简述动态规划、蒙特卡洛和时间差分的对比（共同点和不同点）</p><p>形象图解：<br><img src="https://img.picgo.net/2024/04/15/interview-14c8a9d0f9f4df71a5.png" alt="interview-14c8a9d0f9f4df71a5.png"></p><blockquote><p>共同点：核心都是价值函数的计算，所有方法都是基于对未来事件的展望来计算一个回溯值。</p><p>不同点：</p><ol><li>DP算法是model-based，MC和TD都是model-free</li><li>DP是期望更新，MC和TD是采样更新</li><li>DP是planning，MC和TD是Learning</li><li>DP显示了所有的单步转移，MC是完整的一幕，TD采样不采集完整的一幕</li><li>MC是最小化训练集上均方误差的估计，批量TD是找出完全<strong>符合马尔可夫模型</strong>的最大似然参数</li><li>MC通过采样求均值求解；DP已知模型，直接计算期望，不用采样，仍然使用了自举；TD结合了采样和自举</li></ol></blockquote><p>(15) MC和TD分别是无偏估计吗？</p><blockquote><p>MC是无偏的，TD是有偏的</p></blockquote><p>(16) MC、TD谁的方差大，为什么？</p><blockquote><p>MC的方差大。<br>TD因为使用了自举，实现一种类似于平滑的效果，所以估计的值函数方差小。</p></blockquote><p>(17) 简述on-policy和off-policy的区别</p><blockquote><p>on-policy:行为策略和要优化的策略是一个策略，更新了策略后，就用该策略的最新版本采样数据。</p><p>off-policy：使用任意的一个行为策略来收集收据，利用收集的数据更新目标策略。</p></blockquote><p>(18) 简述Q-Learning，写出其Q(s,a)更新公式。它是on-policy还是off-policy，为什么？</p><blockquote><p>Q学习是通过计算最优动作值函数来求策略的一种算法，更新公式为：</p><p>$Q(s_t, a_t) &#x3D; Q(s_t, a_t) + \alpha [R_{t+1} + \gamma \max_a Q(s_{t+1}, a) - Q(s_t, a_t)]$</p><p>离策略，由于是值更新使用了下一个时刻的$argmax_a Q$，所以我们只关心哪个动作使得 $Q(s_{t+1}, a)$ 取得最大值，<br>而实际到底采取了哪个动作（行为策略），并不关心。<br>这表明优化策略并没有用到行为策略的数据，所以说它是离策略（off-policy）的。</p></blockquote><p>(19) 写出用第m步的值函数更新当前值函数的公式（1-step，2-step，m-step的意思）。当m的取值变大时，期望和方差分别变大、变小？</p><blockquote><p>m-step的更新目标：<br>m-step TD for SARSA: $y_t &#x3D; \sum^{m - 1}<em>{i &#x3D; 0}\gamma^i*r</em>{t+i} + \gamma^m<em>Q_{\pi}(s_{t+m}, a_{t+m})$<br>m-step TD for Q-Learning: $y_t &#x3D; \sum^{m - 1}_{i &#x3D; 0}\gamma^i</em>r_{t+i} + \gamma^m* \max_{a} Q^{*}(s_{t+m}, a)$<br>利用更细目标更新当前值函数，趋近于目标：</p><p>当<strong>m越大</strong>时，<strong>越接近于MC</strong>方法，因此方差越大，期望越接近于真实值，偏差越小。</p></blockquote><p>(20) TD($\lambda$)方法：当$\lambda &#x3D; 0$时实际上与哪种方法等价，$\lambda &#x3D; 1$呢？</p><blockquote><p>$\lambda &#x3D; 0$等价于TD(0)<br>$\lambda &#x3D; 1$等价于折扣形式的MC方法。参考<a href="https://zhuanlan.zhihu.com/p/72587762">文章</a>。</p></blockquote><p>(21) 写出蒙特卡洛、TD和TD（$\lambda$）这三种方法更新值函数的公式？</p><blockquote><p>MC更新公式参考问题14附图（左图公式），如果是单步的TD方法，更新公式参考问题14附图（中），<br>m步的更新参考问题19。TD(lambda)用lambda-return更新值函数，lambda-return是m-step<br>return的加权和，m-step回报的系数为\lmabda^{n-1}，所以lambda-return等于：</p><p><img src="https://github.com/roanhope/DeepRL/tree/master/DRL-Interviews/assets/interview-21-1.png"></p><p>所以TD(lambda)的更新公式只需要把问题19的更新公式中的G_{t:t+n}换成上图的G_t^lambda就行。<br>当然这种更新叫做前向视角，是离线的，因为要计算G_t^n，为了在线更新，需要用到资格迹。定义资格迹为：</p><p><img src="https://github.com/roanhope/DeepRL/tree/master/DRL-Interviews/assets/interview-21-2.png"></p><p>利用资格迹后，值函数可以在线更新为：</p><p><img src="https://github.com/roanhope/DeepRL/tree/master/DRL-Interviews/assets/interview-21-3.png"></p><p>更多的关于TD(lambda)细节参考<a href="https://amreis.github.io/ml/reinf-learn/2017/11/02/reinforcement-learning-eligibility-traces.html">文章</a></p></blockquote><p>(22) value-based和policy-based的区别是什么？</p><blockquote><p>value-based通过求解最优值函数<strong>间接地求解最优策略</strong>，典型算法是DQN（$Q(s, a; w)$输入当前状态s输出所有动作a的Q值）；<br>policy-based的方法直接将策略参数化$\pi(a | s; \theta)$，通过策略搜索，策略梯度policy gradient或者进化方法来更新策略的参数以最大化回报。</p><ol><li>处理的action space不同：value-based适合处理的action space低维离散的，policy-based适合处理连续的action space。</li><li>针对action的价值输出不同：value-based计算出每个action的价值，policy-based一般情况下只给出较价值较高的actions。</li><li>更新频率不同：value-based每个action执行都可以更新，policy-based 每个episode完成之后才能更新一次。</li></ol></blockquote><p>(23) DQN的两个关键trick分别是什么？</p><blockquote><p>使用目标网络(target network)来缓解训练不稳定的问题；经验回放</p></blockquote><p>(24) 阐述目标网络和experience replay的作用？</p><blockquote><p>在DQN中某个动作值函数的更新依赖于其他动作值函数（自举）。如果我们一直更新值网络的参数，会导致更新目标不断变化，也就是我们在追逐一个不断变化的目标，这样势必会不太稳定。<br>引入目标网络就是把更新目标中不断变化的值先稳定一段时间，更新参数，然后再更新目标网络。即：<br>目标网络的参数$\theta^-$，每隔C步才和普通网络的参数$\theta^-$同步一次。<br>这样在一定的阶段内目标是固定的，训练也更稳定。</p><p><code>Experience Replay</code>将系统探索环境得到的数据储存起来，然后随机采样样本更新深度神经网络的参数。通常用一个buffer存储1e5~1e6条$(s_t, a_t, r_t, s_{t+1}, a_{t+1})$<br>主要作用是克服经验数据的相关性和非平稳分布问题。它的做法是从以往的状态转移中随机采样进行训练。优点：</p><ol><li>数据利用率高，因为一个样本被多次使用。</li><li>连续样本的相关性会使参数更新的方差比较大，该机制可减少这种相关性。</li></ol></blockquote><p>(25) 手工推导策略梯度过程？</p><blockquote><p><img src="https://github.com/roanhope/DeepRL/tree/master/DRL-Interviews/assets/interview-25.png"></p></blockquote><p>参考<a href="https://spinningup.openai.com/en/latest/spinningup/rl_intro3.html">文章</a></p><p>(26) 描述随机策略和确定性策略的特点？</p><blockquote><p>随机策略：$\pi_{\theta}(a_t|s_t) &#x3D; P(a|s, \theta)$。P是概率函数<br>在某个状态s下动作a取值的分布。</p><p>确定性策略：$a &#x3D; \mu_{\theta}(s)$。$\mu$是一个确定的函数映射。<br>在每个状态只有一个确定的动作可以选。</p><p>从熵的角度来说，确定性策略的熵为0，没有任何随机性。</p><p>随机策略有利于我们进行适度的探索，确定性策略的探索问题更为严峻。</p></blockquote><p>(27) 不打破数据相关性，神经网络的训练效果为什么就不好？</p><blockquote><p>在神经网络中通常使用随机梯度下降法。随机的意思是我们随机选择一些样本来增量式的估计梯度，比如常用的采用batch训练。<br>如果样本是相关的，那就意味着前后两个batch的很可能也是相关的，那么估计的梯度也会呈现出某种相关性。如果不幸的情况下，后面的梯度估计可能会抵消掉前面的梯度量。从而使得训练难以收敛。</p></blockquote><p>(28) 画出DQN玩Flappy Bird的流程图。在这个游戏中，状态是什么，状态是怎么转移的？奖赏函数如何设计，有没有奖赏延迟问题？</p><p>(29) DQN都有哪些变种？引入状态奖励的是哪种？</p><blockquote><p>Double DQN, 优先经验回放， Dueling-DQN</p></blockquote><p>(30) 简述double DQN原理？</p><blockquote><p>DQN由于总是选择当前值函数最大的动作值函数来更新当前的动作值函数，因此存在着过估计问题（估计的值函数大于真实的值函数）。<br>为了解耦这两个过程，double DQN 使用了两个值网络，一个网络用来执行动作选择，然后用另一个值函数对一个的动作值更新当前网络。<br>比如要更新Q1， 在下一个状态使得Q1取得最大值的动作为a<em>，那么Q1的更新为 r + gamma Q2(s_, a</em>).二者交替训练。</p></blockquote><p>(31) 策略梯度（Policy Gradient）方法中基线baseline如何确定？</p><blockquote><p>基线只要不是动作a的函数就可以，常用的选择可以是状态值函数v(s)</p></blockquote><p>(32) 画出DDPG框架结构图？</p><p><img src="https://img.picgo.net/2024/04/15/2017110809035022984e772c0b6d628de.jpeg" alt="ddpg_total_arch"></p><p>(33) Actor-Critic两者的区别是什么？</p><blockquote><p>Actor是策略模块，输出动作a；<br>critic是判别器，用来计算(s, a)对应的效用函数。</p></blockquote><p>(34) actor-critic框架中的critic起了什么作用？</p><blockquote><p>critic表示了对于当前决策好坏的衡量。<br>结合策略模块，当critic判别某个动作的选择时有益的，策略就更新参数以增大该动作出现的概率，反之降低动作出现的概率。</p></blockquote><p>(35) DDPG是on-policy还是off-policy，为什么？</p><blockquote><p>off-policy。因为在DDPG为了保证一定的探索，对于输出动作加了一定的噪音，也就是说行为策略不再是优化的策略。</p></blockquote><p>(36) 是否了解过D4PG算法？简述其过程</p><blockquote><p><strong>Distributed Distributional DDPG (D4PG)</strong> 分布的分布式DDPG, 主要改进:</p><ol><li><strong>分布式 critic:</strong> 不再只估计Q值的期望值，而是去估计期望Q值的分布, 即将期望Q值作为一个随机变量来进行估计。</li><li><strong>N步累计回报:</strong> 当计算TD误差时，D4PG计算的是N步的TD目标值而不仅仅只有一步，这样就可以考虑未来更多步骤的回报。</li><li><strong>多个分布式并行演员：</strong>D4PG使用K个独立的演员并行收集训练样本并存储到同一个回访缓冲中。</li><li><strong>优先经验回放</strong>（<strong>Prioritized Experience Replay</strong>，<a href="https://arxiv.org/abs/1511.05952"><strong>PER</strong></a>）：最后一个改进是使用一个非均匀的概率 $\pi$ 从一个大小为 RR 的回放缓冲中进行采样。</li></ol><p>详见：<a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html#d4pg">Lil’Log</a></p></blockquote><p>(37) 简述A3C算法？A3C是on-policy还是off-policy，为什么？</p><blockquote><p><strong>异步优势演员-评论家方法</strong>: 评论家学习值函数，同时有多个演员并行训练并且不时与全局参数同步。A3C旨在用于并行训练。</p><p><strong>actor-critic类算法都属于on-policy</strong>.</p></blockquote><p>(38) A3C算法是如何异步更新的？是否能够阐述GA3C和A3C的区别？</p><blockquote><p>下面是算法大纲：</p><ol><li><p>定义全局参数 $\theta$ 和 $w$ 以及特定线程参数 $θ′$ 和 $w′$。</p></li><li><p>初始化时间步 $t&#x3D;1$。</p></li><li><p>当 $T&lt;&#x3D;T_{max}$：</p><ol><li><p>重置梯度：$dθ&#x3D;0$ 并且 $dw&#x3D;0$。</p></li><li><p>将特定于线程的参数与全局参数同步：$θ′&#x3D;θ$ 以及 $w′&#x3D;w$。</p></li><li><p>令 $t_{start} &#x3D;t$ 并且随机采样一个初始状态 $s_t$。</p></li><li><p>当 （$s_t!&#x3D;$ 终止状态）并$t−t_{start}&lt;&#x3D;t_{max}$：</p><ol><li>根据当前线程的策略选择当前执行的动作 $a_t∼π_{θ′}(a_t|s_t)$，执行动作后接收回报$r_t$然后转移到下一个状态st+1。</li><li>更新 t 以及 T：t&#x3D;t+1 并且 T&#x3D;T+1。</li></ol></li><li><p>初始化保存累积回报估计值的变量：r&#x3D;{0Vw′(st) 如果 st 是终止状态 否则r&#x3D;{0 如果 st 是终止状态Vw′(st) 否则</p></li><li><p>对于 i&#x3D;t−1,…,tstarti&#x3D;t−1,…,tstart：</p><ol><li><p>r←γr+rir←γr+ri；这里 rr 是 GiGi 的蒙特卡洛估计。</p></li><li><p>累积关于参数 θ′θ′ 的梯度：dθ←dθ+∇θ′logπθ′(ai|si)(r−Vw′(si))dθ←dθ+∇θ′log⁡πθ′(ai|si)(r−Vw′(si))；</p><p>累积关于参数 w′w′ 的梯度：dw←dw+2(r−Vw′(si))∇w′(r−Vw′(si))dw←dw+2(r−Vw′(si))∇w′(r−Vw′(si))。</p></li></ol></li><li><p>分别使用 dθdθ 以及 dwdw异步更新 θθ 以及 ww。</p></li></ol></li></ol></blockquote><p>(39) 简述A3C的优势函数？</p><blockquote><p>A(s,a)&#x3D;Q(s,a)-V(s)</p><p>是为了解决value-based方法具有高变异性。它代表着与该状态下采取的平均行动相比所取得的进步</p><p>如果 A(s,a)&gt;0: 梯度被推向了该方向</p><p>如果 A(s,a)&lt;0: (我们的action比该state下的平均值还差) 梯度被推向了反方向</p><p>但是这样就需要两套 value function</p><p>所以可以使用TD error 做估计：$A(s,a)&#x3D;r+\gamma V(s’)-V(s)$</p></blockquote><p>(40) 什么是重要性采样？</p><blockquote><p>期望：$E|f|&#x3D;\int_{x} p(x) f(x) d x&#x3D;\frac{1}{N} \sum_{i&#x3D;1}^{N} f\left(x_{i}\right)$ 按照 p(x)的分布来产生随机数进行采样</p><p>在采样分布未知的情况下，引入新的已知分布q(x)，将期望修正为</p><p>$E|f|&#x3D;\int_{x} q(x)\left(\frac{p(x)}{q(x)} f(x)\right) d x$</p><p>这样就可以针对q(x)来对 p(x)&#x2F;q(x)*f(x)进行采样了</p><p>$E|f|&#x3D;\frac{1}{N} \sum_{i&#x3D;1}^{N} \frac{p\left(x_{i}^{\prime}\right)}{q\left(x_{i}^{\prime}\right)} f\left(x_{i}^{\prime}\right)$</p><p>即为重要性采样。</p></blockquote><p>(41) 为什么TRPO能保证新策略的回报函数单调不减？</p><blockquote><p>在每次迭代时对策略更新的幅度强制施加KL散度约束来避免更新一步就使得策略发生剧烈变化.</p><p>将新策略所对应的回报函数分解成旧的策略所对应的回报函数+其他项</p><p>$\eta(\tilde{\pi})&#x3D;\eta(\pi)+E_{s_{0}, a_{0}, \cdots \tilde{\pi}}\left[\sum_{t&#x3D;0}^{\infty} \gamma^{t} A_{\pi}\left(s_{t}, a_{t}\right)\right]$</p><p>如果这个其他项大于等于0，那么就可以保证。</p></blockquote><p>(42) TRPO是如何通过优化方法使每个局部点找到让损失函数非增的最优步长来解决学习率的问题；</p><p>(43) 如何理解利用平均KL散度代替最大KL散度？</p><p>(44) 简述PPO算法？与TRPO算法有何关系？</p><blockquote><p>思想与TRPO相同，都是为了避免过大的策略更新, PPO把约束转换到loss函数中</p><p><img src="https://github.com/NeuronDance/DeepRL/blob/master/DRL-Interviews/drl-interview.assets/equation.svg" alt="公式"></p><p><img src="https://github.com/NeuronDance/DeepRL/blob/master/DRL-Interviews/drl-interview.assets/equation-1584541764589.svg" alt="公式"></p></blockquote><p>(45) 简述DPPO和PPO的关系？</p><blockquote><p>Deepmind在OpenAI的PPO基础上做的多线程版</p></blockquote><p>(46) 强化学习如何用在推荐系统中？</p><blockquote><p>可以把用户过去的点击购买的商品作为 State, 把推荐的商品作为 Action</p></blockquote><p>(47) 推荐场景中奖赏函数如何设计？</p><blockquote><p>点击率和下单率</p><p>$r &#x3D; w_c * \sum I_{click} + w_p * \sum I_{pay}$</p></blockquote><p>(48) 自动驾驶和机器人的场景如何建模成强化学习问题？MDP各元素对应真实场景中的哪些变量？</p><blockquote><p>状态（State）：状态是描述系统或环境的特征或条件。在自动驾驶中，状态可以包括车辆的位置、速度、方向、周围车辆的位置和行为，以及交通信号灯状态等。在机器人中，状态可以包括机器人的位置、姿态、周围物体的位置和状态等。<br>动作（Action）：动作是智能体或控制器可以执行的操作或决策。在自动驾驶中，动作可以是加速、刹车、转向等。在机器人中，动作可以是移动、旋转、抓取等。<br>奖励（Reward）：奖励是反映系统目标的信号，用于评估智能体行为的好坏。在自动驾驶中，奖励可以根据驾驶行为的安全性、效率或乘客舒适度来定义。在机器人中，奖励可以根据任务完成情况、与环境的交互效果或资源利用效率来定义。<br>状态转移概率（State Transition Probability）：状态转移概率描述在给定状态和执行动作后，从一个状态转移到另一个状态的概率分布。在自动驾驶中，状态转移概率可以基于车辆动力学、环境条件和其他车辆行为进行建模。在机器人中，状态转移概率可以基于机器人的运动模型和环境的物理特性进行建模。<br>折扣因子（Discount Factor）：折扣因子是用于平衡即时奖励和未来奖励的重要参数。它表示在计算累积奖励时对未来奖励的折扣程度。较高的折扣因子意味着更关注未来的奖励，而较低的折扣因子则更加重视即时奖励。在自动驾驶和机器人中，折扣因子可以根据任务的长期目标和时间尺度来确定。</p></blockquote><p>(49) 强化学习需要大量数据，如何生成或采集到这些数据？</p><blockquote><p>Simulator是个好东西，mujoco对真实环境模拟</p></blockquote><p>(50) 是否用某种DRL算法玩过Torcs游戏？具体怎么解决？</p><p>(51) 是否了解过奖励函数的设置(reward shaping)？</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/56425081">强化学习奖励函数塑形简介（The reward shaping of RL）</a></p></blockquote><h3 id="贡献致谢列表"><a href="#贡献致谢列表" class="headerlink" title="贡献致谢列表"></a>贡献致谢列表</h3><p>@<a href="https://github.com/huiwenzhang">huiwenzhang</a></p><p>@<a href="https://github.com/skylark0924">skylark0924</a></p><h4 id="参考及引用链接"><a href="#参考及引用链接" class="headerlink" title="参考及引用链接"></a>参考及引用链接</h4><p>[1]<a href="https://zhuanlan.zhihu.com/p/33133828">https://zhuanlan.zhihu.com/p/33133828</a><br>[2]<a href="https://aemah.github.io/2018/11/07/RL_interview/">https://aemah.github.io/2018/11/07/RL_interview/</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
      <tag>Reinforcement-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 - SDS求职经验交流会</title>
    <link href="/2024/04/13/%E8%AE%B0%E5%BD%95%20-%20SDS%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81%E4%BC%9A/"/>
    <url>/2024/04/13/%E8%AE%B0%E5%BD%95%20-%20SDS%E6%B1%82%E8%81%8C%E7%BB%8F%E9%AA%8C%E4%BA%A4%E6%B5%81%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>善于<strong>利用数字展示成果</strong></p><p>银行：学历 荣誉 技能<br>算法：学历 论文</p><p>泛体制内：<br>（1）实习对口：实习为了了解更多的领域，发掘自己兴趣与擅长<br>（2）兴趣爱好：体育、乐器爱好</p><h2 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h2><p>渠道：利用学校平台，比如宣讲会</p><p>注意泛体制内的专业代码限制</p><h2 id="考核"><a href="#考核" class="headerlink" title="考核"></a>考核</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>笔试（所有公司基本上都有，多数2小时）</p><ul><li>形式：客观选择题、填空题、算法题</li><li>内容：数学、机器学习、神经网络、数据结构、力扣算法题</li><li>备考建议：《机器学习》（西瓜书）《神经网络与深度学习》、反复刷力扣题（至少剑指Offer）</li></ul><p>面试（2-3轮技术面分钟小时）</p><ul><li>一面：mentor  二面：leader</li><li>考核内容：简历中的算法论文、算法实习、算法比赛等+算法基础知识+力扣题现答（1-2道）</li><li>备考建议：（1）熟悉简历中重点相关内容，提前准备Q&amp;A以备应答（2）复习专业知识（机器学习、深度学习、前沿技术Transformer、BERT以及各个衍生语言模型和ChatGPT等生成模型）</li></ul><h3 id="银行"><a href="#银行" class="headerlink" title="银行"></a>银行</h3><p>笔试（所有公司基本上都有，多数1-3小时）</p><ul><li>形式：客观选择题、填空题、编程题</li><li>内容：综合知识、图形测试、认知能力测试、性格测试、职业能力测试(EPI)、开发知识、计算机协议、<br>力扣算法题（兴业银行）、可能还有英语（中行、中信）和申论（中信）</li><li>备考建议：刷一点行测题</li></ul><p>面试（2-3轮5分钟~20分钟）</p><ul><li>考核内容：简历中的任何内容+开放性问题</li><li>备考建议：（1）熟悉简历中重点相关内容，提前准备Q&amp;A以备应答（2）开放性问题准备（3）注重面试礼仪（4）注意说话的思维逻辑，回答切题，有时候自信很重要</li></ul><p>总行 &gt; 分行 &gt; 支行  <strong>FinTech管培</strong> &gt; 技术岗</p><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><p>引导面试官问自己熟悉的问题</p><p>有更高工资的offer，可以和之前签订的HR凹价。</p><p>常见开放性问题：<br>（1）为什么来我们公司<br>（2）有几个offer</p>]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 牛客小白月赛90 C-F</title>
    <link href="/2024/04/05/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B90%20C-F/"/>
    <url>/2024/04/05/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B90%20C-F/</url>
    
    <content type="html"><![CDATA[<h2 id="C-小A的数字"><a href="#C-小A的数字" class="headerlink" title="C - 小A的数字"></a><a href="https://ac.nowcoder.com/acm/contest/78306/C">C - 小A的数字</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>小A给定一个数字 n ，请你帮她找出从低位对齐后任意一位均与 n 对应数位不同的最小正整数。</p><p>对于本题题面描述中的从低位对齐后任意一位均与 n 对应数位不同，你需要保证你所输出的答案的位数小于 n 的位数时，即使在添加前导零至与 n 的位数相同后，也不应有任意一位的数字两两相同。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>贪心。每一位都要么是0或1。</p><p>如果该位为0，那么只能选1。否则全选0。</p><p>去掉前导0，然后特判一下空串，置为1或2即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;  cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            ans += <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;idx &lt; ans.<span class="hljs-built_in">size</span>(); ++idx) &#123;<br>        <span class="hljs-keyword">if</span> (ans[idx] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    ans = ans.<span class="hljs-built_in">substr</span>(idx, ans.<span class="hljs-built_in">size</span>() - idx);<br>    <span class="hljs-keyword">if</span> (ans == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            ans = <span class="hljs-string">&quot;2&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-小A的线段（easy-version）"><a href="#D-小A的线段（easy-version）" class="headerlink" title="D - 小A的线段（easy version）"></a><a href="https://ac.nowcoder.com/acm/contest/78306/D">D - 小A的线段（easy version）</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>本题为 easy version ，与 hard version 的区别仅为 m 的数据范围$m \in [1, 10]$。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>二进制枚举每条线段选 or 不选</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">seg</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[l, r] : seg) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; val &lt; (<span class="hljs-number">1</span> &lt;&lt; m); ++val) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">10</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; m; ++b) &#123;<br>            <span class="hljs-keyword">if</span> (~val &gt;&gt; b &amp; <span class="hljs-number">1</span>)  <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">auto</span> [l, r] = seg[b];<br><br>            d[r + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>            d[l] += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            d[i] += d[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (d[i] &lt; <span class="hljs-number">2</span>) &#123;<br>                ok = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ok) ++ans;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-小A的任务"><a href="#E-小A的任务" class="headerlink" title="E - 小A的任务"></a><a href="https://ac.nowcoder.com/acm/contest/78306/E">E - 小A的任务</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>小A现在需要完成有序的 A 类任务和 B 类任务各 n 个，初始时只有第 1 个 A 类任务可以进行。进行第 i 个 A 类任务需在完成第i − 1 个 A 类任务之后，进行第 i 个 B 类任务需要在完成第 i 个 A 类任务之后。且在同一时刻只能进行 A 类和 B 类中的一类任务，同一类的任务只能同时进行一个，任何一个任务都至多完成一次。</p><p>总共有 q 次询问，每次询问你需要回答完成 k 个 B 类任务至少需要多长时间。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>每走到一个A的位置，都会对应一个 最小的选k个B任务的cost。</p><p>注意到每走到一个Ai位置，这个位置的A的cost都是固定的。也就是Ai的前缀和。</p><p>但是Bi的选择是可以变的，这时候我们只需要对Bi的选择做反悔贪心。</p><p>用大根堆维护Bi的选择，比较当前Bi和当前已选择的最大Bi。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, q;   cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : b)  cin &gt;&gt; x;<br>     <br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> k;  cin &gt;&gt; k;<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ans += a[i] + b[i];<br>            pq.<span class="hljs-built_in">push</span>(b[i]);<br>        &#125;<br> <br>        <span class="hljs-type">int</span> curr = ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; ++i) &#123;<br>            curr += a[i];<br>            <span class="hljs-keyword">auto</span> cc = pq.<span class="hljs-built_in">top</span>();<br> <br>            <span class="hljs-keyword">if</span> (b[i] &lt;= cc) &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                curr -= cc;<br>                pq.<span class="hljs-built_in">push</span>(b[i]);<br>                curr += b[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ;<br>            &#125;<br>            ans = <span class="hljs-built_in">min</span>(ans, curr);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-小A的线段（hard-version）"><a href="#F-小A的线段（hard-version）" class="headerlink" title="F - 小A的线段（hard version）"></a><a href="https://ac.nowcoder.com/acm/contest/78306/F">F - 小A的线段（hard version）</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>在一个标有 $1-n (n \in [2, 1e5])$ 的数轴上给定 $m (m \in [1, 200])$ 条线段，第 i 个线段的左右端点分别为 $st_i$ , $ed_i$</p><p>求有多少种线段的选择方案可以使得数轴上的每个整数点至少被覆盖两次。</p><p>​定义两种选择方案不同当且仅当至少有一个线段在两种方案中的状态（选&#x2F;不选）不同。</p><p>​由于方案数可能很多，所以你需要输出满足条件的方案数对 998244353 取模的结果。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>不难发现 $m \le 200$ 这个范围，很 O(m^3)</p><p>给了区间的问题, 一般都跟区间范围没关系, 离散化之后就只跟区间数量有关了。</p><p>将坐标点都离散化，最多只有 2m 个点，然后 l,r 就只有 O(m)。</p><p>有个很好想，但是又很关键的性质：</p><p>假设有某种方案，一段区间被覆盖了 $k \ge 1$ 次，那么显然这个区间的右端点，必然是题目中某个线段的右端点。</p><p>基于这种性质，我们进行状态定义：</p><p><code>dp[l][r]</code> 表示 <code>[0,l)</code> 这一段区间都被覆盖至少了 2 次，<code>[l,r)</code> 区间被覆盖了 1 次。<br>初始默认 0 这个坐标被覆盖了两次，即 <code>dp[0][0]=1</code>。</p><p>考虑状态转移，前 i-1 个线段的选择方案，得到了 <code>dp[l][r]</code>，然后选择第 i 个线段。</p><p>需要确保每次加入新的线段时，不能出现违反dp定义的情况。<br>比如：<code>a&lt;b&lt;c&lt;d</code> 如果依次考虑线段[1, n], [a, b], [c, d], [b, c]。<br>当枚举完[c, d]之后，此时[a, b],[c,d] 是覆盖了两次的区间，但是 (b,c) 是覆盖一次区间</p><p>所以需要保证，插入新的线段，左端点始终单调递增即可，而它的右端点则无所谓。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">segs</span>(m);<br> <br>    vector&lt;<span class="hljs-type">int</span>&gt; alls;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[l, r] : segs) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        r ++;<br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br> <br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> (alls[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> || alls.<span class="hljs-built_in">back</span>() != n + <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">shrink_to_fit</span>();<br> <br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[l, r] : segs) &#123;<br>        l = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), l) - alls.<span class="hljs-built_in">begin</span>();<br>        r = <span class="hljs-built_in">lower_bound</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>(), r) - alls.<span class="hljs-built_in">begin</span>();<br>    &#125;<br> <br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br> <br>    <span class="hljs-type">int</span> k = alls.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[l, r] : segs) &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">dp2</span><span class="hljs-params">(dp)</span></span>;<br> <br>        <span class="hljs-comment">// [i, j) 已经被覆盖1次</span><br>        <span class="hljs-comment">// i只能从l开始枚举, 因为必须保证[0, i) 都是覆盖2次的区间</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; k; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; k; ++j) &#123;<br>                <span class="hljs-type">int</span> i2, j2;<br>                <span class="hljs-keyword">if</span> (r &lt; i) &#123;<br>                    <span class="hljs-comment">// l, r, i, j</span><br>                    i2 = i;<br>                    j2 = j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt; j) &#123;<br>                    <span class="hljs-comment">// l, i, r, j</span><br>                    i2 = r;<br>                    j2 = j;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// l, i, j, r</span><br>                    i2 = j;<br>                    j2 = r;<br>                &#125;<br> <br>                dp2[i2][j2] += dp[i][j];<br>                dp2[i2][j2] %= mod;<br>            &#125;<br>        &#125;<br> <br>        dp.<span class="hljs-built_in">swap</span>(dp2);<br>    &#125;<br> <br>    cout &lt;&lt; dp[k - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 03.18-03.24</title>
    <link href="/2024/03/22/%E5%91%A8%E8%AE%B0%20-%202024%2003.18-03.24/"/>
    <url>/2024/03/22/%E5%91%A8%E8%AE%B0%20-%202024%2003.18-03.24/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fa048a8f84f736d61447b6251e07af3d09d0c347541d3e8ac3ef924bc6ff66ec">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a785689a11985da7512165fa422b00c9d6ae3616f28743d01998bfb36d7fabd6e30d780d604e9d36ee8a115effcc333a3f82f351f601536b59ea4514536194d760bea61f78f13a548348633b1a936b109e6e74d3a69e2837e01f7db68e52839890b1b2c64befcf114622324d2cdcc28104c75b0b30ae9f3342bdaff28d1a567fcbda388a4ccee1665184a7d35bb967cd36ac55edc9f3b2181ca8ad42259afb469728a54c2cc7b10d6440a3b4f7c13d8eab1e031aaeba1fdc2258092b39fa1d2805b0d0b49a2374e2564f27bd29a845e839fdad7255f11051c865504e5086feeaa5ff74fd146ca1bdee5294353cbebcf4fcfe70901eebc951a99a1aa8f4201470bcecd1b33cd1e5e17b785b030a8a6d331d544f100476a8742a80932ed83f6599dbf272a207c9f58526cfdd855f6110f404d732e2b6c96d932f7d4f483d99c4ac4feb5a4c7f1017d5b80f5c2c1ab60be48f6d602783c430a977bbee2c77f2437ee856094db413af017aa132fae324330fec4cea5b29a122a25f858d260a446c2e858ced288fd5c4fb268e995aa0ea011ca2cf024e54e3a3b20f209d7e4fe42e9e721b65ea06446b9bed9071e275ed26dd37ecdd65b814bdf487ad9800ecf35aac92e513b252c34c897e67787f36e790c61dd260133e85385df754ca68fe6cbffb9ebe9873e834d0751190d31abb8de740c8f54ec14c47a2b4ffc99f293718062b067004dadf3b8d37c278e58de15ac3e5d0198a4e855dae970267a0941ab4bf75844ccf1475749fe44b58dd1e29774092e56d92ca8f471bfe9b82030b543356b746a69e137adb5a1be5a45b316b841b473c097a7f2386891a5739f6439147809ef538ad6874e7021d3f258fa25844360f4a38540d019fe724ed26aaa2beeab1f06140b8d89a580e74bb2174b87a498a87ab1bdc9048c0e850f15a6281169ced1b8cedf90a76af058365106ebdf52ba53ea285c29c399071496711093f13d59c8b61dae6c5bd983405423cd0b1860eefd7c47b3bc7fc9aaf625603d553ebd37c3917b675c73ffeea32dcc8ab9dbb243f46ba8d836821ee7fb87abf817335fafaa30bfdb31db2f502ad592abf6ab47aa0d8acef30167f534f364da6b4b36e86230c1e0d4f3eabb2f830711ff123278e29f98a70226d55282a2a7f4703d814e2bf933a78f1c27fb9b5d94e80a110f3af4beb7c570a45b3ab43b65bb7758be209a6e12e6e6c7a3aad5bf0db2e009594f864da31d49e42081ed86953eb60a23cfcc965cf5b3dd63dc1ad7aa607054e240f30bc4c1168574bfb446e01088c66da73c46b7b87cf9c9f77e7190d840cad371a20372f839d7851b84a1d61f656d765e54a73df0518386f4dc4baa90292050485b6459830971ae74577f9849e111dfd34e07b7d58146ce9d44dc9b27b774027a71d0d9475147430f5406048f0f8b68369ad653df84f67056a1dfbf46cb8638645ea4797dee8dfbc891a97cca98a8ebcc96aa5803a414a7492189f383cf3953665d57cc96bf7ac88a0e7d37e1d02c56e051fdc7b63a517e6d6feb30c032f02f65239864a2dc68018c0ac72af5b134bcda4f1d9bd72c906d3fc4c7b2f1f6d07c71938ed8ff4dcf33d572715d47d73185c8e6b48c2592a5d41c014ece235ac8918fafdf13b99008c6feb7a22b75884c6aace44d7868404841abcdc81a0f9e9dc140a10c7a97186ec36e20c60974060cf734d6b75e28c2aeda4759075e999ab9339ba53a36432352f726ef20bc1c9e123a2c5a8a7927453af1747ff3a26b483d6080bf29b959f54a5e8bd8a8b2aa32de3c8675b339ac8273e22d9f49cccd40155b61b5d90ed791855b1caee5a6418cf5ad0c55425532debaf75e6a4e2129a4d3cf89e50aa3ab4007d2310d0a52f40c832d485d606373550388b5747470b5f498064da3b9304c05cd032407724faef4f4cb2c2c40ad9ed00fdccb0d4fd74547b6968a5a6417b5d3290a5318f7fbff808d042b2276c717f26229af6f07ac6ceffd5af255378ca3b3a716f57d4896acd468459c0b0bf437a2dc518fe255570a7fa08e1291381d5919751ab467c371181a92979f4f7f211e61c9a8a9085054042c25e20e67f37f15770d0f889ef131f52d11c5f4bdc2b9e6391877167b9629862e0183bbd8ab5bacbb10dc453efdf8e83925ade562ecd934e8f4b3f35da7cea9f507d27b6122f55971234191d5285b3e2287498c73fdee2d802f191230de706f6998864f4d477a368ccca9904d0a61006c9147b46eb72215447033f09b83b9753a97c591535ca278531464dfc8f85fe0bee9ed6fee3528f814eb4e3ee12e0469f3b41143d60d11f6f3f81071cecb8f16021369c3459787a9397d2146e607e988b2eeb0dd1e597981b8d02a597913b637104b775a30332dda2b0a103f2b9bfe5fc6a82d0e654649e70be3263a37d95cec69a44a9e9e86bde1e79d7f9877cbf6a11e4f1ef588dd8383c90244b924d90401783d53eccdff375f50c039526a397f5b49854dd967b57a000a6efd61ffbe1a1d5a02913838fd53c202e02c65115c79c90eb639a2b56699f1c34d9e91bcbf206fb2b87c55bb436294183dd929b76eaacb7523ab404a9da5abec6919fc21db35568381c866586ac620905780e06026bc7121e85b9bbc44fb35e13762d7a399285ed2ac48992508a71415cbf878cbce4a9d2abf36ea7db5c5e1b0e2acb2e262eef830fa28f2c75bd40e9462d319b3fa5427cd52cd2172c7ebafe9fe871c3f3553795e81f9b2a9a3bb9b86e362fadb1689d68df972a38dd9ff4e1534b838eb2cd69de500157de9d71722d43632ec711b4b0c0f3ad15469d91970f1c804dc3cc44fdb724c043e40a202d2b377f70e25840deaaea4bc5904a1b89b25ebe53b1c85960489bb177f2b228d152d8acafb82510ce528b3e508e2bb0c14076db72dacdbe7543ac5b40ab399e30c2c535251acb72ae7cd80099f60b873bf09652591c2474f0835a2f287993fb034dc132935ac82f034ccddd7c3a5fe55fbde1f48fd0f08e5ef22dcaa1948f1f60d25eedff5f4c15d7ae5ab2f9cc0293e565b70502e17407c1855b75dc41a306972c41897ea4e517ec37eaf3d74cb69a32308b5bc2061bc3a411f08f5141f26a090954bf38ad663e041b8c369782d198bdaf94e73a0f6e41ae24ee0d19bac7b0cdcbc3f8f1c59aa535241242099aa81be9f0f6048545a430a35b06b9d957e643ee4dad9bfdcb562005ca35f93e1fd50165d0119bcab08f51d500288084f2db27889a5b9f1ab6473c0ce1d807e5419c3b6e7e58db0a1ea79b42cbd30b90d8b228918cf76bb499a2e814cba644e146ffb75a1a11b53a2de1563afb086164f0a88148cd5de57bad4861a9d2c1073944644ab4ca7c791b752d332a5fc48bf913126dcae62bcd849fdb1ce73bee4293414815bbe8607ba6992653aa40603d248d320ee1d38c36345231ad494ce6ffda238d5a040a03d23bda98b6dadbea0e7894d720920de502ae0d716f8e02d4b956a31787cf4558a86101d67f6a65c5394b71268d83984c4a80b71b0fb58b87740ce46e1b176ff28d067fa9c2ecf4a1ac53c8606dfde8f968780133c21233d34aa9da7f04a3062bf2ff8bf5ac385b067db70182e05d6952aa27f94d8b0dcd1eda510f313f6bc74a9fcca34e1cf66ab0e3cbe248486869286c96de99c3ac8b0cd673071e6fe15bd3ec286d4bdb17f2efdaeac18482a3951c7136a012ca8399c46431c57bddd3e3b8966fe4c84e7cc97a04ef41bd07cfe7a218c077e767df4c3ecd1eaffcf4a2a3e2e17e6dfedb39529e7d964001bbd8f9507815705bb3a747cdc20546ceee365c08ee9db7382720439308726849f80cc9259c3a661ec9c27e161830364539f65c6dc61a55739e30ac7502e2e099b57e8b5de4185b045a323189bc38c9ea0856b41c8fd29cd3d4f3a4453c44f9b6a9884c0431e3c7602e465fd3c61915b0ef670ddcfc1f21afa89232460f86cfb57acbd357bc4c5ba4f2a67eb57c6ed57e6d98b91bad12a022a9746031af721bb33e1fad322be4af44768dd2bb011020f14d860df004ea5f57809be7d50c0af5badababc226737bc7866ecfc35a035c080a4a5e74edea4295157007bcef165c290e6101930699b769eaa662b9550168d17a50e09da5fb80c324395cc2111d23caa647861c9a0fdd7baf90a45d6ce82c0ff6840a3fd2b7fe63c0e64ac959b052b35afa82c52f9dd661fb3a1084431b87b2bcc0129381182219417703e3fbee5a51b64e47f42184b3ae63229d72ea498b507bb5065a5d275f1b7f35db3e627660f55122d2e34c84a10dcdce774fcd326395f71756ed2d825c50951652143f701f17998e28e8b735fbe0d07d3d988b8d06c0ae6fdfdaf9c37cff85cd8fa6148f7897282aef6b83246efe9ef4c750d41a7b97b0562beb829807798cc55508af70619bbcad6ed268207f0cc01ef9fb1d2612494d87672507e4b1dfc90c6efc617a44931977250249d8ce939b2ddefde14d38a7eb1cc31b0d087cd420bbb9b918ad53f4eaf30b9b1a1793f99298795f8307a2d4f0cc61d0d70ff64caafc96f8f52d5f6e997fa441b0a2b8dcd627991050179cba7c4b785a712a02d4b2aeb7e5d66f453a432b3eee5d5fb95dbaa0940f3d7cd4b83cd8249b1b3edea44fd61864af05d3234c5923f1725c9720d61f3717a8a6a948b1be12ee70097e70e361033b2cc47d68e2c093a23a7a0cba0bb0025add27061e0483628197a4d18a1966a051e89e667f0499a49ddd4b3675ed10c49e4d4257639e896179f7706b4505f292eac4ed88ac640e09468346b2c6c69b72b5ec05a749d6b5dfe5d683e485bb6d521c280b1e4bf324012b0f226d61e85870520a3c96dc71613ffe4971a8cd68288151b82fb53e7cf73e6afbbfbadd8be9df7016ffed67c40acaf97ca5fec67e93292c7141cbe3c2c2e9f28380d1ef010a53937878a17d816ff71eb43c7a0394b88b7fbe44c3b3de23cb4cde57bd002c3399294d7cba210be0f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 03.11-03.17</title>
    <link href="/2024/03/17/%E5%91%A8%E8%AE%B0%20-%202024%2003.11-03.17/"/>
    <url>/2024/03/17/%E5%91%A8%E8%AE%B0%20-%202024%2003.11-03.17/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ffcc6477888db319297069c35bdacda43a8a0dcff3d6d43a0b05d57f15f34793">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a71b926b3e455c5e8f2237838f8a0dfe7e73236311ca08276a46b0b3e3fccbb8a0a0a696c12f202792d20aea8d440da1141b91ebc101ca0dab75924733269140fe570a3e2cc4780c32daeaf792efb8bcae48e8ecf24a88284b13a35e7ddfe1db6b9756fa4b6197d0568741becc22769875a7d94dcd8191a649c14f6c44684f9cc25fb3d6fb0c9657a7b4445db9b25bf59c5d5099c74b69a006d49a322ef08a711308e248dc974ca8896828665733f81b910c4939495d8bdf9a86e5cdc3dc19bfc019421160f1b6c20a37d8b2a0d3b922ada345f66b4b7975eab102e78ec51f2f6270a61f32d7a3e0131dedb5e0f729229dc74b0203fced39db518e58732c49eb1ac4ce6c5cf2a120597c64cf632f2eb671682cb09df4ce0f3412fab67c6013f9e832a3525e9f9e6a7faa6cb8ef955345a9ec7aa619dcdb61f2638591841679790dadb0496afdc2cc02aec836552e238da13b22aa4a63d4a931aeec573233777d5e02b415b85746167beb5dc0bb3705d8eae8346bf4fa8ea58b9b9c0094d30a19bf13f39ea063a9909ee3a734ee5dcb3c5e37cbeb00fb06bbcd1bac2442617d16f5d102f18f00c59b28e3b3f32eba65ca48005c2f5ec16d36e4a2e1058baeade881a0f477f012e8816f9cca83b0d497612b29073f50d57c1202427d6bc863f715279d666acd7645e3bcc033156c6f51becf630086843befe449df894a63e299cf79a06d1c72a3f1c8444a82007deedbe9abe7b3a210616e3fe5168795f9580ef2fdcd1aa0bf030819afbc90ec4f7f93569046d342c23c4320ef1b5502086c914b5d8f62c5e68697f6aeefa07c3cfbdbc1e698185f3f5b3b75cf54c38fb1a2b02dae7ae8da6b46efd6e7663ec283f725939fea6ca853aadc8aadba9fdb61056ec6684edc76d1169d53f7096e45974a9c80d1da611ec12be7208d8c023ebd009f0382607b7918320538ba022e7ca6cf0cb21f6eb9a8f3362d3fcbdcbcb8ccf40f0cd58e0021e5853fe6e408f7f6339daa35003960c18abf03faf614e70a41b0fe925ba238b1db551fc1105629d411eb7b591104a90d7d561b7430c66ffb237b6d1541d85c922fb47600dc157f08f982b4a65abbf5b2751812787f355cab4f06118c326742a00549e0f00c706815c59144823da90c60c7cbfb49ec5d52ee2dfc74d3b100f78c7e554ba6d46fb599fb4bb34f3bd976c362dc264166a7037b3abefe74448f3f96046e93fe945b293e67d486247c42379b2f845b11bea797407b856222b968fa416a3473deb9cb3dd5b37f12ead7263e2b9cc77ed493596cfe2aac7616f6e6565748f4dda1ad1793663d8cb5ef03fc31b76fb1e623d81ae9f20ff856e59b4d57fbf43aa8e7f2833034ce400d106dec66354d041e43d9a43df22a465cedd4a2c3ba8deec6a55998fc94fe1a85aae8e4d80b789bc166660af92a06d0396727acaf2ccd1203b822139477097e174c0e8269d310ccd93487eff433bba1ac85c1492fef5e681bdedb6299631cd0b8b64cdbacd6bb9d52b5fb2424e48f0d48a40041c33c71f06cbb0b6d5968eaba737dbb1cc0365c01c761c66fb7ae6ab474b434f394dba87d9259643bd9bbf3c0b79cd07ab80b8c21cfb028ac861dcf0d72da3ce441bba25266af8fcdde77b64476bffc171b9082a3e3237cb7ee8ebf629b10be1c47683f9827a2da257bd85dfe03e1d1d25899ad0d77f168ea3a9d94ab1f19ca8ecb78e02b16177b8cf8937cbaa4deb00f0998804df351c6abedafbd463a610d4219ec7b22bc2831213354e0b6916acf9fe4f32320db205c5e1c02731aaa44a5bf23b1072d3a4e1823266d4989c7e0ea35ce4d18ac1aa6101ba54eb771ce7ed19333acaf5b331655c63f487ea9378e05c9f170685a196d5bbe43e62a7fb1fd3c346086c5ddc1550170d8303adf6b5934e868a4df84f7ba4ce81632d980ec6e05293ff01e2e73afd6350b3fa4bdbdb944d52cab25c4cdbc7a399b653194bd20e2d10e98c6c2945a0326fef24c929e44f999087662b585c773759c1677b06ee51474a5b0a11824ecfd957109fbd714373f1be01114a767633e78471dcd3242ea4a37455e42c19c5df0286ece028b009f4f5ca8beecb390fd7e6d9ee217882b3291d3100acc280616282021d64bb265a8f1c05415619931e49067410f02cf28c4c8b63f6d1e821d8d196cf528e82b6d929b925cb049c76553f2ab00f8290b52d86b43af0d68afa20a95c370bf3476b77bc2dbe60ac94c150d669ebad8e2920cd1f19462ad8b0637df2f0d51f5ffe6012171045a9fdd55dce5ac0436a9b77045f9615c8afa25f535b5d12f44b06f5255ae553432bd97a3433d3b72ff33e54e65e650177c1974641bfa38adf7c1784eef35aacc7bf5b5be3d0785a9ca05f3f3df2e00e9139fb588a8ec803a0ea78065d36f2b41b0d050a2f8fe76928ee2ac1d3f06f9cc541b3754b6005f43def70d73d6ac658a637e2d677f5805a4ab446863b8a6597df252ddbb69c2a6ac2d059359aca2fc5ab0550fe2362d62b1f9134fc5483fa347188c5604d9e0eaede219198a203a00131c5a2eb25b76471abd643f66256781d121902a53e0603a8eb95661d3f3639a125a0387a87128e975fe783d4501871289dc9954575837119ef28a46b2f85f2700c9ee18f330d0414c8379b98c25f4ed807f52e9c6fbe00239fc28632fafcec487bc370077556446e7ce1301b1b2ee2a882aa06f010ff1da86f04f4e07ce7659da3f218656cd9e0514e5f9ce778162d2ccb43985d2249cf26aacd3223ca9b451522ea7f9b06e2284498cd8017ab1c91d5db0048bc008a37317ec6fd2ddb3a7c186a94e97d6dd7b46dd4b62c7acb5eea94222a3996538e9e944449663ee15ad7e10045afa83c0f990c59ef88073b7da85fd3f8050251fba778e46bdcfead0fb8dc92e94b934a44bce1f3bba8e2bfafdecb4eba79b0d20d2825df663421b52fccf89b984270bd1b4e9d776cbc91ccfdbac150fdaad01d04cafbd2d9eb588ac95f5b5911b5b83e58a3ec858f287344aa6ad5d3db4f646d6b5f901acbd5fad714e64975c087a961d692d8b3ec6e1c93b40ac1ef7c4e31a6a192e93ec3bd6aa14c6ae7b836c9f889166089fece4f875117544859ca2ad70818cfa5189397ff018e2268c9781473af4345cbff004bc0bca9b333b9c317603e767947f262d2a2718aa9a056e75cc41835bbd76167c41fe271d65a937d6f965d9e260afc978f47402a3377ba0f84c36046cb6704974810624bf051d4887c060b03d4971993c7db6dc01024229e93a6ae263ef3fb4f887e5822a4e724d9385c29116ed9fae995bef56ad20485f372b41fb8b7a4986155858bb392736e4cdfad8207478e2a72629e2fa4b27e2f1a004de30f60d524349145b034d34269119a834a9ab6334ffd8fab06b54e207a94e6726eae78ee89c434f9920e56bd241de844ef9c770cedb813c38a17861ab7786aba3eb566d8ed32ef3949edd4a5204ae2e981ffd57afd4779a90561ae16191f813fb64fb374a2a78912f5401b7809cf95f5f401ce5da6cc2fd5e53989cd7377bf18bc27ef377a9f665b22d30fafbba6efc6ac88b9e7b589bbf1dd1a7514d36367871a2b62d301acbb37e71547eab70e444e04b219a35e9856aa1755516dc8fb83f9ceb22c7bc4a420b39108c6cc1cb568166e5717cda9cd48a1e42e55f91be5ae633962ac1c483459db738b9016b10c5c502495c5c096432533037acd0cb5052e0651eaeda66f4a1fccf5551978b673268a9db72149d14838f31ed7fc563577cbb09c9e8a8b614f116c6ec21b7547278727ffb6b90e106e4c31e5805cd31b3118317c0dd1d7b03ecf0c55705d1d408fddb4ce2f6fe79e872f26618cd0a8fee0982be199cbe254042508ffdcd86261d25e5bb142e6a935ded8f00df566f8ecbeaf72f7327519f256cc88f871fb1f0d769a12a7a8d1581456422586fc0fb068838155c2ab3f6718d12c21128bd4af03213bde629035ab53511aefa80772e645fa4e14e2144da283e68c44b1f1b5390e970f9943015a416becfcaee4a13afb70f5f5f9ba27d2c567669975deb61619fde3e537f45a7a87c56e3d5c0a0cca52da4a5ce6b94a5c27b2b0b50490bc2aacac729ef04c8c899219e6c385281524c9389dbf2afc7f79d067c1d375c606bbcc90b05dd75d7ec1afc3d5d35c756523909273a78e99dc112926e5cba02ad0a9ae60fc8eef25602dd6831f7780673967fd4b84a83f84b755c9533ffc744124875ff4526a62f39b07069fc3b478bcbc4f0a513282756b174fd9e851c95f5f9ef9819ac11e3dbd2186e8684ad2614a44d29e83125ddc789a83193be33d5e63812c07898664810a8ec8a2b45c873285c56c30907e1a04c2d454ca4035f031ace979a00d872b028a50bfc98798a204a13ce4506d1e37a12b80b3c752293effc2d25d288679983d9af1a268b1647c6a9c5a87db64c4c6eb009cdc28f10b8c20cba9e6300ad1a733a1c2c596dc5a4ced7b51ff8117196bf45404cd01c9d34c1344ddffa82540634281374043c24872f1c93cb2336edbcbc9fe41eccdcf3525f9ea67d1e2d91fd9810d52cd294019406ad10d3f7e39f2f12cad1a2ebbf1e1c243ad82508b125cf2b790c96959f66ecfc49f4a593b8e858fbe5e46795c4f2f4fbd37ad115620e0a8084445b7633f73877f2170ecb2f26bab175d5993aa9b3d78a2b071c504ab3ef279ea6d2cc1eaf737281dc35eaf01fcfb901648fd6b66672cd5200851c6a1f9609698ad4074058916edcb1722d7fbe4d52651e9598a1663c861849e02dbcef23a9b6fca4abf0c4308c9e583f33dfcab2fa76c5298e09503a54294c714d270f66625c2bb660d96165fc403c7cf68d16f0fee76fed0dca2d840b46d7be2ed01166fa5bf7aae05cb74b1b0f3b1998e4fc3798e84da5b7899c74c6e5815c0457ab1db78f51a3e9c436309cd33be6367d928396c657c5c5db02385c1916992866f9d6abe5cc22e4eba17d2e8b584ea42ec9ed256ab1b688fd657223be334bdea8978e3512f78494697e797e940e4a9f11004c6913ca61d8809a0a026756794e91f7ef11450ea3d7f69be5e27b1ee2e60aa963733d9f47a725fe71a6dccff7d63cae541be3ce2f0f53cf28202fd79b09ee7be92ee303cd28dd15727a4dfa258e2ae564a404edc4bd43e3358a60e46b242a86f47c5bea22885f78fef384344ce0cd5518f1deda62029accfbe4dced18764bbb5fffb7368463c55fe5f42eda9ab9d0ad8423cf77244f7657ff7008c1b678f7f033ac60d28f3ee93170f8550f8092a5dd531007c2bb8cc8d19042664655e5772b0c6fd6296eef74dc5ef3cd8c8f5ea595cfa99452c47ff01b20cb2a5b290011707e0feda037a3800f69af797fdc31eb02ffe77011867c68c5a5174586e67b014d7e510f0b36947ed4858831f066a294a800da8b58bbd97b871241cb4931eea36178f3bbf1bd2c2eab4b1913bb55d51e41ec018f8f9b9c06ff54e66d79cfe1947cbd3a47792fae06523f1db860bcbede925227e4057d96467289e1c185ad3cb1f2198afb3cf830d09c175535d7c629ca2f53b3a9e308d0a5e939b6660129cf3b462c5f971f5a1256fdb123fae6899642bee5419b36197580a3e821e7397977ce33a26bc46cca67442e59bad63ecd9238f10b05761022d4c9b4eb5b6b2e4f9547efc83b206fd852f9831bdc8dccd2e1069ec51594c97a6b5f148ca392a620c9215686262c7824a5c4fc421ab18ef1f3df465fc5f5a468a2110d6fded8368079d35b54d33a30cbaae5c5ea13788b6ccfc73efc1e4ab121bda97306c4658e03fc1136fc1df7d56b7b155dfb68e56ad66374c55569192fb3848bbfb5df4d1a119eb912391185db0f4aa8ae3782e4c101313f5f790094ffc7f1e2ef0b79a80c592981bef9706a2fa0d0c90180ff7e794f1d903175d03d6725204578365d19daa64cab9596de186b3cbfa88cc4f950cbcc7f53bd1649861305e62f5abc45dbffce4e2da91d5499a4f59fbaf1a777eea09dc559198ba4fbcd774fc7e3b1a43a47cd21e4e50b7d329da6c5f6272d1e8d9439464487d0c1fa35ce16b47bcdeab76574cfd34d3908cc8c1a1d5771baf98ef75df2ecaa036dc219822867d1351930ed3f1486470905c222fbd402a592bfed5157bba73f2fec21d867722fadce7c78b0f5d747ab99c39a53f9e18b01aa2479dacef2dc6061cf89e86f0b4897db53ca4bccfb7ce15d6c62bdcf54892255a6ab3790684f55aae2b27e2348ea4c0fd3c572d5464f6fed53de8cc50784f09ecaadab654196ac8ad88c58cfc09472b8ef1cc5b0443e9034bf34da2304e3b9df11fdabd5f1f95e5b05b71fdaf87d57eb33c6a676d0753a63034b03ca215654c90bffbe339f01e60a87e696ee9a400c1af7208a4dd77eb1b73c0faafbc0375fac5987c5d91852abe5fd052ba4f0bab3b20b9f857d72be89addcd80f95461cff4fe201c36341580f2a032f9ba407b68858725e6658e46726690af17aad7c06a22f845fc76ad7ab9e945072c1636a12306ebc77beac565e422be0cc081776ad0580a0ce6c661d3c6b7e3ad739ee6559be74d973c666a66fc907da4c4da4fd6d093ca28cbebc2361398168812ee042c3444c05032ea2f47e88da55efafaa0d1239b779de506797c7729eac0add906b8a36cb3fe31ac5858f732700c141b79e2a58415c7d9fac8838ab01d90693128d97b3d15f5876bad280df8f42a1d61abfe6a9fb261f5b34af4de122818e1cf93a035a812351f4b84e1d06cdce70a4586f0569a8b501fed40c702072a5f470718be45e6f35c0e70292eae6d34cb88a0f3a2646a0e5f93f672c31eab906a578895b979c44f4b5416c467bb69f37d7abdeee3d00fe608d20d6356f3b7a74bbbedce85d25f6d3f2a6940f84bd5e6d5d4cdaf9b7c4b16fa0d3bf621b51c58d19eb650fc8b4202ed0e197cb0f402c06fa68deea95887e9d52ad258e3c3b5d4c75a3cfca29ec7c00d916a7920fcca5ee71fc7a449a4be15b3f9a472fa86c22c3b87f5bc991a28e61141038b831a80749fc1a4dac7534d0af2eb5486908fa89a8589b0ca8cb08837ef29746e8244c1d791bc35c4ebafd6aaa2a5557907c0c9eb98726a4e292731f1bc560a7827dfdc0b563aa9bebe8a84b8f57b41db713103d9d53d23310f80d73edc2dd9ba4cff27a21dcd032c18f8794b8bd57665852437b57aebdeb06f22bd3b551dff6f058864d1269c63c0d940307ab6e12b41274d4b8d64a48410ed81a883333b73d3d7c4e8662243f1db84d99b614f1a199fcbc2932f60ecca2fbe414fbe0fe314c2676fa5cbd413a90c8877fe2d2cd435703f6bf1a7948ee0c1f6a15dc738b3e9bc00d2966c355bb198bedecdb2ca4150aca26e5b4c7e8972ddd0507ad658dc9410a9d7cbfa3cea204c1615699f81186a9f580feeac3eb216418d94e5e4dcacc7906cfbb6bf1aadd84ab330946162a19b86fd3a3b757934811bf138b539a817da0c1afe242ac3bd9c433799e4e4e256cec366f2e03e079640bf7a6547bc70a10ef24805409afeaf20e562a0b606baf990e3309c7fb9dea70f355f7e06d201197dfcba1703cde210913cdc42c8554126bd2fcf8ffaf2b490f82ee781c262e36eced07a45e32ed56629870be45ed3d53562b5836b07b91b69f9c26ca219f5e01c0b02b8b05ca122acb4566f0c566c283a255046171bb753973f6f63ea152af3b25d3aaad768129f986a7a05fb22f5a433b31c5b41307813c94c39690421783bed5fb097fed1a18ae57f409079a708fb156679c9b49ec19065be30276d2f67bcc5c94eb62d888582b0657a55574f50470dfbe31d008a010079fe14d942ced01cbb0998f04142e75ad93561012d27015ca0dba00a29e2d3fbb96670d93965801ffb1a3f05f95251b8303376c6d7d5fc9dc5c710cd086ee0a18e9c108916dd7f347dda81719227c6fec42782ee333447130664a5476a3e048f5de786c6016b5b8b9004e8282de569df324aa5978de43c609e4aa7266d98f996d989a78b2affdf36dc1c36a4fc1417792593cd26a84521ff910f40549f13c48ba4e8ff27709415c122e875cec329e15a5fd60afa6dccbb60ba860df67b7d38481b7fffc71dc9146d942a7e59bfde1a97cc01ef53d0e864be11fbc40e210ae3b0474c23401f61ed3d5e57d4304a3774024b193145b655d7c03b263e05f9b528518e2804e8415a31f262e89b971b25197ee4d45213cfc3d7585ca4d61b65756923f96630c26e3d408287802a22fbe667df1bfca503c68859563eb51be7ccb7fdf2e4d801ad62ceba37ebd071927dc5807e67a6a2cdf3d523e6255692b30830de26568c57720e2fa76def865e9005b1f1e5e78a621d60cce88e4cfc777d341428244adf483f6c5409780667d981d2850be72f615cdbf30f422d8d022ee618586b33ded9accf500500c10aebed591c8ca2e472f92db20b62378beb53d15b93f9e86bc425ab51e8273f21410e3266de61f495674fd226932edc655179ca31bf834d714bf8a7538d2713afb7f97ac40183d91389e45dbacb23428f2676544c0a7c2526da9a98f65515b8af1908209397d3b69cb5a6e0d517558d045b0e4bbf10d89f637f99ddb46487471622c8c96048aa325846d6000b2befe82e73f7978836f400b6f298efb9daf85f4423eced41fa5611fbf0ee97345ae974a42ce91ac81b49394a72012703a300e1f74be17ddd530bba6c443615b7a2451d02d0b4be2d2defe0387c3298f9a48fcc40f230c0a5ac6387f48d8bf0d2e5253d5c81801628c7981e1609d21796c98d754143390a4855f7f89d253faf3ee841dfd392599e64dd69c53ecadfb6cdad0bde4cf99c94e03fbd64de91d9edcdf6d5d4ecc5e9ab926bfdb0f3ca5e6d4a793299f4e8f671d5d1363d4571b79516b40adf312d5507e197aa978d7c21e24856081293ce8b8c7901f7575093e12a90ea59e3304a19c356f7deb95fb4f02a80e9ad50365e92c16fc54231261122c53a42b539ea7dfc07206c4b8ebe2b0bafc344b5cb4b7f4a67c40586dec9cca7ab0b7ac2a2b020e0ed59618e9830a98413410876307c9ba6ebb88bde93e5321d264279fd17bd9dd6f7d5836c22aae6ae772f69ecc4284dac146</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录 - 2024实习投递情况</title>
    <link href="/2024/03/17/%E8%AE%B0%E5%BD%95%20-%202024%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/03/17/%E8%AE%B0%E5%BD%95%20-%202024%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9306ce77f6625fadfbf33b7523ffccc4a8b15028ea980634c6d5878e9bde8fdc">6700a10771cde00a4b64b788d85e15b46fcea6ba0a4095c3d2d423aacacdb17636ded2844c28796ca862c9532f8c652e51b16911091ef17b47ab6cb795e686934bc5944cb2abbc75ec602cfef80f42b4eda68482afa8f5a2a1932d86cbfa22aba84fb2dd61c10950c558c386bade074c23254e2912d831ce43ee560e27ce4244b9533a1c63ef018bec9bf946db09b247b74c49b0b120b1435ede1b762c0bd4ab41235952a16cbbf4ccc54ef62b333923e49e6659aa8b034d131e6e65aa82b1c94d8bc1cb9615110e841ddffa7ac4332c0d00160caa6100124fb02398da81ab26421737f43feb6387f7aacf2e8ad0816228f2e378bf51473cee17d23721650dbb1296edb27e980d4d9cf95f6dc72a613fa3dd5fd6b23fab7064357efd645fb46cd0b1fdf1f4f9d7493cd9d593a8f87da18d8b0d4981cd9bb273646688f52b83147385970cc93cdbdcf774667892f89bb54cb4658dc804164713b8544006b416f2cdd876c4bad9c23db1a5ec6441be2c6b504f32bc86da9ce9a1ec1cf5ff8eea87ae0bc5713dc65d363cfa53db5245e0c8598f0160dcef79f51c1b1c93fd03cdd07bc0262ac467d6d970532d89de061a1dc42b4cd67548d649c4ca4b15b5553a0191d4f9d52c67b14c2cdd380f03462606d8ff4f4462541ae18eebd0822e34c8129274693fedd3f229e1961a7a2b567af136eb9f67204df30e5ebdce9d607dfb5e1865ac233ace2cc7c212c73b86c9b36dfd427ea51f34df2ee63cdf4740087507aadbcb6849555abc617ebdcb73bcf6a8795ce626601c99581cac8f2cbcdff8146c0eb2e18bd60c9e0045cf6ddeb710b34348a02a2b75afa4617eeaae9c78ae502b82f0255d8d6e0a9dd1285a15b90d03539d266dc3880db18e16f639b57b26544a0afc791cd931471cc7720a0971e1efafbaf11ff6f32980cfba075c816999c11886925bed7ee3aac347a4afddef90a1978e242b977925ad3ea8e7835d215e26d922ed297eb85522cb01dbb89bdc7aefd1cecc3c7ca99437b731e21fa29bf9da7b7da36cd15c2547cd28835eff0eafe2438b4356e884e459966d584afd11ed89eb3a09ab869a6da32b1f1f459aeaea1fc9a3261d1d07c7a480ef8df054a5ee1622e334f4d0c1759ead9165779d1887e1923e5520bc81ea214574652a322c04df09809ec0c7ab4432fde632666b00f4cd8409d09983990569254f3c82e09579762b163b1bf5ae656e9d716aaf5bed128edb62726ae68daecc0def6dbf8a5443962eb9be105c59d97bc9ed10028923fccfe6a3b66dde2288922913dedec36720bb82dc1ee12ae34f763bc53acf215bce934b6453ad423ceb3f3ef9d4558bb24bf4b55706571ecebb8dc6ecd49b30b98231fe249427594432109c488f1d5d61aaea243b2b58e21957a2437eaa1da68923b16c368d59bbf30ea7b6106207590f9fe886ffa7d7803d1b358da242ee16cabea6ccc09bef517f4f6c793faa71da2000dac0cf4bbb53e818c0401faf8367643ffda4c1f16ba66a868b44cb9843f83b095debb35b0e94752000c265e31b2bba5a0f44e0797b41bba7277900e2abb86fc0ec24202a47148a862b8efeba56b10c34b0681d59f8d8d7cdd1b73e961d7664eb209aa3dc884b6a6d0e3b0ec255ef4d02d767ecb2ecc14fae129347843a642a40562b9b2155ecbe469cabb53078f68146a33533c7c3c7eb2b4dfbe394abc8fa15e7d80ea4b397f3119aab1708cf8f6c7d4b2b3eefce8db1885586a214a1b44d7662a9cf79fdb4db11ddd52b7346085ff164656ce62366200cfadc34375bf9fbba0e474e537090fe15737ee2434b93394572c184d88262196e382af3247f9a9ca909ebf8d40bc1db250ac033895a31a567333655dcd8739880c25a5802dc5e49744e66afeadafc1827524cb07df173cefbd6f435f2ad37b4c31e5f60c4247ebe31e520abb091c73036ae04fbfba744d8c2d94bcc53abf8b74883fb8076394235b54da9c39dc5cd7a4632c42daf4e59b79a497a5c1909d0dc7dca903c159eb3b723a5e2701f39c7e58c26472171ca6b2b5a77277d31c59310da110f0e64a69a85444af63f024c62464c0d9ff7de9b190833bd18b33211e803b46fe22a2ba14c7a8b3eaede20fee8dedd6b92125f75d61e03d608e08a601984545e201b583cd4b70284c8ede05f90624a2a399fa6d2b49e2668881911976ec848766792e316d71497c17741b4ca207d330f4b8813e11c9e6ea9aad14b1dc76f7b4b55dbaf2b7362a38f981d3874e1b28102dda90fc49d1593a013495869948c5ff90cd087c1deeea61e80ccd7823d03514b5164f32d0beae10fe1020776f2c1d2f04153985fa95c52875bd4c5a1abd457b60ee8ca527de02385cb36e83f35684bdc7031406b4e8825927fc9619ad70cca2f98c2f71b474c62e8d6b330dea84305106f3454ede39d84faf43c3c8fa2689988d55feae98022a7284d6fcb19255139cb6c1e8a4767dac87620c1f2b2374847ee76263e55bc41bed42ad69d7a213f89634039a2841b4e663556766910d64efb1fd81493275ceb5ee47b226e075e168c7354b43242b6e458eaad94bb271eef298d0d009ece565020cf25f4d18989e255bb052d316c22aba1373d699adc529dc79dd262614c7190f7143fb5ecf9e4d454f0bb17e0f06d53f2e71cd9349caf51a95b08da912b20f10fc328d0a5de736606a2799cd46d5861cc7733706346bbc343169bc5d27b435b6184d58024096c5b0d70db2723ac195a0a338398c3e182a66eb05432213af77f99845927b98a73c14fc3f87a94c6228d5d6fa18dc277b56ad6e661e89920625d6db9a5980f1bafd60c75079271bafc55b62d7d4b99e66acfe8a1c4482a6b1ce4912c154f494a12bd9e36e27570944421f1f30ec952c30475cbe1d1c3150c4452c6174ee55f149cf88422440dcdcfe77b937bf897a12066ec06e5a79a447b7d200d5b406f4e387dccf04819223db23ff02c3e7bd6d17b9d030583115fc409a9977ab0a4c5741c7d816a5b4b059718298a7654392e04ef92a80f5667d8b37762fb1ff089584be30f2aea39022d7e31468625bf52fce28e4738f7fea0eb64ad76f22865570176ef7d8179c11e182b1f330d7c9b22e19e7fb40eb39a3160388a1f2f4cb9c3bb9ea772ae7033736d3ccaa7ee10c4edfef6989171dacf24db882f2f01fddcb1c3ee1221f40edd3cc44d0a16ef392a90a14033acba6bc6c0201de8098828b4574085a8aedfd1d4f1d54c1ae716de95da417afafb4809cf8d041ce308bd9e16775fd137a94dfbcb511e741851e6b8940993352a32179ac9de2de4fc175c44376803faee953d7bd06d880627fcb939219f7c5d20bf2cceb0aea24d379c11ebe0075d7607082c3881b2480b95646342b1a2d50e3bf091f5fcdfdc94ef4220217eabdbebdb0e2f0b7908ce6137a177462610b2d66b8b3749acde13e14dfea044c24b5b666288d6bf3d86443c84cb4d481bd870c82e44728ad848ce72ab85d1ebfa176d3912e980db40d48b7e5282b27633edb8e42754356f9886e1a7d28800b0004c5a015a2c7722b7681493a3d75cc81f2383d642409429cf6f92bd8052bc0ce34bce8a6d2c3beaa35bbe6d97f59db8e168a01065ac45e396912962c14a295e85d85bee6b779423447dace38ec1979066c9535c79e1370713a92a09c63b07645b9971745d2c2141e9ee126c3187d31b5b1d58313c148e1af7f393c40f11f93e8893d14884f31514adc3af6eb98bc73105e182b7e2fc6fe6893765f9df1c5dd5d0fb64c34ce6be661d3841c4c311e20400636d2c85cabb48fed68db03d0d20150cfa12c650fa5f672fa389af2b57b1216026cdd2780eb9cab878988e64d544400076101c39f0ba45de388738e2270033dd0ab5e74b9374ebd4a4b2efca8a9a6345856b948ecef430ec845a2c78ac203a0226a46da4559b43c2206e9481b162e3b9cca23c18a69c95137400253dbb587d3ea2c40e1435234d5b9fb09f515e1978fca441e7b629d68e1ec6128841dbe0341adaa49f364f8ddfd159edf7eb693473ff8a1495bb8747197f1e9b4c0589a1f39a8c29bffccf1cf897264795b2022b106e7322a6ebf1b5bb9a239bc7f3418224c56d476ba6b439b6a8369187167fa106381718b3c323d23da0fa2b22612765379cdd065908e34521070d56a734beccbf6e8d498b4c547b90d768c233fa0857adcab8b782f0cd6711e897d21082c50e63a5a38b291f06c16767eb0dfae46563c99ffb7c4c968383aa8d2294b37e6d3a6f60bc3e963a993de1a648065342e8175098265db8b52b0fc92eb1be1c3af6d4baccaedb8cd51e9ba4c2bf5824b2de6578fec5f63eb3ebc4d2bb82350f19938d8e14bd07181edd6118ff35aac4e4be76692c2bc42dc381158c6ce906169a1daeb0a7d7a3dcc25a2afb07feca25c919d67544ae7f1bd0e23c31f837a7fe6cc550019611b6c32ede9565a6507fc09f01c4e792e3c27b599748e979fc63c14fe8d8a899acf056d7f14863906b6d59bc095b688615108a5f81853844a99fa2712e725799e94e4d79a8b1d8420ecadbe147fdb6f91b21fac1331f937cc9c029957cdda75a2bec19e9b94d8b9212750ad15630cada1602f87070f2b41ada5baf036b09bbfcc58ce72257a20594ba02d9bef1b5c83ebedc089875dda82e2f986543ca56d19cb0ce9aadf3466127db0732ad98fb1667969609990fcf123b17cbe29af99244f765de8ae0d1db44ecb5923ff9cd00cdc4e7935133a3b95b1a22b45fa4a86c60f4cd238020cb45d0e163805808ce4e7477c78725902412030946a0f3c2b40cc34c4363f175d5aead83e2bb37b191eeea5d1b429f20bf4b53483f25554a3fab5056fc2249ccfe3d961bb4546b037e6bbab6e2b485633ead6f2d76975250cc41ea954daed74addb357c14398d143d3e56c825b8721e9d9c4fcef196a570f88dcee010945eabe1e01e7b4f8ee81a8272e9327267d337e3cda6107cf2778af4c712a08e5399b25226d572de48706fcffc81b17be33e2e2ccf6be12af70220e741b0dca7f31c4d2eee8d9ce3e6da26f634e75235ffdbaf7961c09f9c42fb50d90da6547ee159791a47f1e2a9906bf2ba1d21d01e4db83b897b58fc455c2928417be29fb5e69512dfc7300a2270b0570f096a679a595780bea8266b59b82c4fe454ef709f3b1e302addd0a838e71556e7099282031185b8dd379baa213818126fef1fb54ba6261c6b05d24bd43332a8addcc4338ab2bc71a3bcd3a174257e692dfbe065182b2feeb6c99cb37850c3548f6179327772286f390c33aac7759d93bf955f651122ce561ffec6dc80b2c15048fcb6a258f4d17c5370628a0cdd53a9f425d27af37317fc3ae635fa55e7b78f1b2e0d1f981a3ec83c1218cd2dd17aa4cbd2c5080b1a01e3924157405548edb4f8a58d5fa949b687258fbcdd40693fa58e8d338b1da0255a739b8732ef007ea06bdb1d90d585398e09df757e5bba8b16b42abe939d7ffb6bbedcce17c6a5968157b48b475</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - ssh的使用</title>
    <link href="/2024/03/11/Linux%20-%20ssh%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/03/11/Linux%20-%20ssh%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install openssh-server<br></code></pre></td></tr></table></figure><p>时区选择: 6 Asia -&gt; 70 shanghai</p><p>安装完成后要修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件, 允许root用户登录:</p><ul><li>PermitRootLogin prohibit-password改成</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PermitRootLogin yes<br></code></pre></td></tr></table></figure><ul><li>PasswordAuthentication 改成</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PasswordAuthentication yes<br></code></pre></td></tr></table></figure><p>验证配置文件, 重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sshd -t<br>sudo service ssh startssh<br></code></pre></td></tr></table></figure><p>如果出现了报错：<code>System has not been booted with systemd as init system (PID 1). Can‘t operate.</code><br>Linux主要有<code>service / systemd</code> 命令和<code>/etc/init.d</code>脚本管理服务两种方法。较新的发行版可能更倾向于使用 systemd 作为服务管理器，而不是使用传统的 init.d 脚本。<br>报错说明这个系统里没有使用systemctl、service来管理ssh服务。</p><p>改成<code>/etc/init.d/ssh restart</code>即可。</p><h2 id="常见文件位置"><a href="#常见文件位置" class="headerlink" title="常见文件位置"></a>常见文件位置</h2><p>hosts: <code>/etc/hosts</code></p><p>.ssh: <code>~/.ssh</code> 里面包含</p><ul><li>authorized_keys: 授权的key</li><li>id_rsa: 私钥</li><li>id_rsa.pub: 公钥</li><li>known_hosts: 记录远程主机的公钥</li></ul><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>创建指定邮箱的ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;channinglcj@gmail.com&quot;<br></code></pre></td></tr></table></figure><p>切换当前的ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-agent bash<br>ssh-add ~/.ssh/id_rsa_lcj<br></code></pre></td></tr></table></figure><p>把自己添加到指定的服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-copy-id -i ~/.ssh/id_rsa_lcj.pub dbcloud@10.28.5.208<br></code></pre></td></tr></table></figure><h2 id="可以通过终端ssh登录但无法通过VSC免密登录"><a href="#可以通过终端ssh登录但无法通过VSC免密登录" class="headerlink" title="可以通过终端ssh登录但无法通过VSC免密登录"></a>可以通过终端ssh登录但无法通过VSC免密登录</h2><p>查看<code>/etc/ssh/sshd_config</code>文件：</p><p><code>PasswordAuthentication</code>这一行，将其值改为<code>no</code>。</p><p><code>PubkeyAuthentication</code> 这一行，将其值改为<code>yes</code>。</p><p>重启ssh服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service ssh restart<br></code></pre></td></tr></table></figure><h2 id="服务器重装系统后无法ssh登录"><a href="#服务器重装系统后无法ssh登录" class="headerlink" title="服务器重装系统后无法ssh登录"></a>服务器重装系统后无法ssh登录</h2><p>报错如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh dbcloud@10.28.5.208</span><br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the ED25519 key sent by the remote host is<br>SHA256:sAongpc4Eqh1mD3ql6M64rZsFCK2RD/lnJbBsXm7ppk.<br>Please contact your system administrator.<br>Add correct host key in /c/Users/ChanningLau/.ssh/known_hosts to get rid of this message.<br>Offending ED25519 key in /c/Users/ChanningLau/.ssh/known_hosts:7<br>Host key for 10.28.5.208 has changed and you have requested strict checking.<br>Host key verification failed.<br></code></pre></td></tr></table></figure><p>known_hosts文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[222.73.129.237]:60208 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIF96Nhotk5rCYzjlSp/m3jZ4rdzvt+VN+x+9l8lf48e7<br>[222.73.129.237]:60208 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC86MWK124eMG1sSswf1Ao4NbCfZCa+TByWyO45bmNfVcqCUWiBMU70eylzbO5AYm/XN7ClB+xprRcFbTzGYrIj35hCGUD2jOtOzza32ssJ80k9LhaHouNR58t6QBnBZYgWJ3swLgNhRYvWlmHeEWvY+QLa/0PS8lPOheHGMt8Ae2qJS9VIQVI3KqbPGoCujLMyfHORGGd6B1a4EyQTxsGb4yUaIlmX67fXf33MMLl9D5ZnVsmYZLaE732mtdHRqQ7dASMEsda0fHi/OANa0ckfS7Sf1HNR5NWzp6JJlyA3mwcu7pQgkwk/p3iIWkjvoWor1qaZD1aa9CoYbL1E60ad<br>[222.73.129.237]:60208 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHu+eT4jz/DX4gB4zugUI0nacNlTt1OCFsoTbbTD55abULv57HdWkuVdXuqousUhbpIwzJcctw5tbP+nblBVpl4=<br>10.28.2.138 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDvxtAqu8z7rmDddmQ8TenjJjZIRi289tKq9AjCau3D5<br>10.28.2.138 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD4b1n4CWj07hVRfZ1NPBfk0eX7xLeAhqxNABCFyqeBo7RO/lsQ2Y6Pjba7cR0jvjCKMdLLyBgObgXZVsIm6yo/iq2MkqKd3Uo/NtYwSSlW7Yc+k1cm2SoMGhwcXAA/iUOPkjEfBsXNk/sroHpN8qrPpxoOu96iWtMQFylzZtmULRo7AQocvjd662FlC1sKv2Ya+InaecQl+U8TDSG+Rb0JDmw//Mi2HvXIdd/8kYGOFacj/9j0kCNDuAE5RqOmDKcx7E9mr4Pb0hSeeqjPipMI2XhFgnBAr5scZ5EulgDX0hOXzRM4Lb2CEjPCIAvYRsnEa3A8pZvZYlnE+BJhA0pD<br>10.28.2.138 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHIhxlY3kfFsWib1I2u9Cut9P3/AoKFmwhciwusEk5ZZY20QmyJpyQlr9FZERRBwBIFNuTVLkKkm5hzW9IBHu/Q=<br>github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl<br>github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=<br>github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=<br>10.28.5.208 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIF96Nhotk5rCYzjlSp/m3jZ4rdzvt+VN+x+9l8lf48e7<br></code></pre></td></tr></table></figure><p>此时需要在本机的known_hosts中删掉之前服务器的记录, 然后重新ssh, 生成新的记录.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
      <tag>Cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - Conda cheatsheet</title>
    <link href="/2024/03/11/%E7%AC%94%E8%AE%B0%20-%20Conda%20cheatsheet/"/>
    <url>/2024/03/11/%E7%AC%94%E8%AE%B0%20-%20Conda%20cheatsheet/</url>
    
    <content type="html"><![CDATA[<h2 id="conda安装-miniconda"><a href="#conda安装-miniconda" class="headerlink" title="conda安装 (miniconda)"></a>conda安装 (miniconda)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br>bash Miniconda3-latest-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>每次创建shell都会自动切换至base, 用下面命令关闭:</p><p><code>conda config --set auto_activate_base false</code></p><h2 id="查看env创建时间"><a href="#查看env创建时间" class="headerlink" title="查看env创建时间"></a>查看env创建时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda env list | grep -v &#x27;^#&#x27; | perl -lane &#x27;print $F[-1]&#x27; | xargs ls -lrt1d<br></code></pre></td></tr></table></figure><h2 id="conda-本地环境常用操作"><a href="#conda-本地环境常用操作" class="headerlink" title="conda 本地环境常用操作"></a>conda 本地环境常用操作</h2><p>获取版本号  </p><blockquote><p>conda –version 或 conda -V</p></blockquote><p>检查更新当前conda  </p><blockquote><p>conda update conda</p></blockquote><p>查看当前存在哪些虚拟环境  </p><blockquote><p>conda env list 或 conda info -e</p></blockquote><p>查看–安装–更新–删除包</p><blockquote><p>conda list<br>conda search package_name # 查询包<br>conda install package_name<br>conda install package_name&#x3D;1.5.0<br>conda update package_name<br>conda remove package_name</p></blockquote><h2 id="conda创建虚拟环境"><a href="#conda创建虚拟环境" class="headerlink" title="conda创建虚拟环境"></a>conda创建虚拟环境</h2><p>使用 conda create -n your_env_name python&#x3D;X.X（2.7、3.12等）, anaconda 命令创建python版本为X.X、名字为your_env_name的虚拟环境.<br>your_env_name文件可以在 miniconda 安装目录envs (~&#x2F;miniconda3)文件下找到.  <br>指定python版本为3.12, 注意至少需要指定python版本或者要安装的包, 在不指定python版本时, 自动安装最新python版本.</p><p>创建名为your_env_name的环境  </p><blockquote><p>conda create –name your_env_name  </p></blockquote><p>创建制定python版本的环境  </p><blockquote><p>conda create –name your_env_name python&#x3D;2.7<br>conda create –name your_env_name python&#x3D;3.6  </p></blockquote><p>创建包含某些包 (如numpy, scipy)的环境  </p><blockquote><p>conda create –name your_env_name numpy scipy  </p></blockquote><p>创建指定python版本下包含某些包的环境  </p><blockquote><p>conda create –name your_env_name python&#x3D;3.6 numpy scipy</p></blockquote><h2 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h2><p>Linux &amp; #Windows  </p><blockquote><p>conda activate your_env_name</p></blockquote><h2 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h2><p>使用如下命令即可退出创建的虚拟环境</p><p>Linux &amp; #Windows  </p><blockquote><p>deactivate your_env_name</p></blockquote><h2 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h2><blockquote><p>conda remove -n your_env_name –all<br>conda remove –name your_env_name –all</p></blockquote><h2 id="复制某个环境"><a href="#复制某个环境" class="headerlink" title="复制某个环境"></a>复制某个环境</h2><blockquote><p>conda create –name new_env_name –clone old_env_name</p></blockquote><h2 id="在指定环境中管理包"><a href="#在指定环境中管理包" class="headerlink" title="在指定环境中管理包"></a>在指定环境中管理包</h2><blockquote><p>conda list -n your_env_name<br>conda install –name myenv package_name<br>conda remove –name myenv package_name</p></blockquote><h2 id="使用国内-conda-软件源加速"><a href="#使用国内-conda-软件源加速" class="headerlink" title="使用国内 conda 软件源加速"></a>使用国内 conda 软件源加速</h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  <br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  <br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  <br>conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure></blockquote><h2 id="使用国内pip软件源加速-更多详情请点击-pip的使用和清华镜像源的设置"><a href="#使用国内pip软件源加速-更多详情请点击-pip的使用和清华镜像源的设置" class="headerlink" title="使用国内pip软件源加速,更多详情请点击 pip的使用和清华镜像源的设置"></a>使用国内pip软件源加速,更多详情请点击 <a href="https://blog.csdn.net/hejp_123/article/details/92181614" title="pip的使用和清华镜像源的设置">pip的使用和清华镜像源的设置</a></h2><p><strong>1.临时设置方法</strong>:<br>可以在使用pip的时候加在最后面加上参数 <code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>例如: <code>pip install networkx -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p><strong>2.永久设置方法</strong>:</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pip -U  <br>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></blockquote><p>例如: pip install networkx 切换为阿里云进行下载</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pandas -i http://mirrors.aliyun.com/pypi/simple/   --trusted-host mirrors.aliyun.com  <br>pip install pandas -i http://mirrors.aliyun.com/pypi/simple/<br></code></pre></td></tr></table></figure></blockquote><ul><li>阿里云 <code>http://mirrors.aliyun.com/pypi/simple/</code></li><li>豆瓣(douban) <code>http://pypi.douban.com/simple/</code></li><li>清华大学 <code>https://pypi.tuna.tsinghua.edu.cn/simple/</code></li><li>中国科学技术大学 <code>http://pypi.mirrors.ustc.edu.cn/simple/</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - RAG论文阅读</title>
    <link href="/2024/03/11/%E7%AC%94%E8%AE%B0%20-%20RAG%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2024/03/11/%E7%AC%94%E8%AE%B0%20-%20RAG%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>主观理解：RAG一般是由retriever+reader+generator组成，其中generator一般使用LLM， 并且generator的输入是retriever的输出。<br>这里的retriever我认为有点像传统passage retrieval， 即使用一些预训练的模型（如SBERT、DPR）来检索相关文档， 然后将文档作为输入给reader。<br>主要的工作在SIGIR这些顶会上比较多。我想这对显卡的要求应该会比后续微调reader、generator的要求低很多。因此我想着重研究retriever。</p><h2 id="Question-Transformation-查询重写"><a href="#Question-Transformation-查询重写" class="headerlink" title="Question Transformation (查询重写)"></a>Question Transformation (查询重写)</h2><h3 id="HyDE"><a href="#HyDE" class="headerlink" title="HyDE"></a>HyDE</h3><p><a href="https://arxiv.org/abs/2212.10496">paper</a></p><p>Hyde全称是Hypothetical Document Embeddings, 通过LLM对用户的query生成一篇假设性的文档, 然后根据这个文档的向量去查找相似的N个向量.<br>核心的原理就是: 生成的假设性文档要比query更接近于embedding 空间.</p><h3 id="Query2Doc"><a href="#Query2Doc" class="headerlink" title="Query2Doc"></a>Query2Doc</h3><p>跟HyDE类似, 也是通过LLM生成一篇假设性的文档, 然后根据这个文档的向量去查找相似的N个向量.</p><ol><li>利用4-shot提示prompt生成伪文档：从IR的训练数据中随机选择4对query-doc pair对用于LLM生成伪文档的提示, 利用LLM(GPT3)生成待检索query的答案片段pseudo-documents</li><li>不同检索方法的query和伪文档的连接方式:</li></ol><ul><li>对于Sparse Retrieval （BM25）由于query长度远小于伪文档长度,  因此 query 会重复 n次再和document concat (paper 中设置的n&#x3D;5).</li><li>对于Dense Retrieval 由于向量encoder一般具有较好的泛化性, query不需要重复n次. 直接通过[sep] 连接query和伪文档, 论文中dense Retrieval使用的是DPR. DPR 模型需要额外训练</li></ul><h3 id="Step-Back-Prompt"><a href="#Step-Back-Prompt" class="headerlink" title="Step-Back Prompt"></a>Step-Back Prompt</h3><p>通过首先回答一个 后退一步(问题的抽象问题) 的问题, 然后将这个问题检索到的答案和 用户的 QA 对 检索到的信息放在一起, 让大模型进行回答.</p><p>这个提示词的思路就是, 如果一个问题很难回答, 则可以首先提出一个能帮助回答这个问题, 但是粒度更粗, 更简单, 层面更抽象的问题, 下图是Step-Back的提示词的实现思路和介绍.</p><h3 id="ITER-RETGEN"><a href="#ITER-RETGEN" class="headerlink" title="ITER-RETGEN"></a>ITER-RETGEN</h3><p><a href="https://arxiv.org/abs/2305.15294">paper</a></p><p>使用生成的内容来指导检索, 迭代地在检索, 阅读, 检索, 阅读流程中实现“增强检索的生成”和“增强生成的检索”.<br>这种方法展示了利用一个模块的输出来提高另一个模块功能的一种创新方式.<br>每次的结果都会跟原查询q合并, 再继续丢给下一层.</p><h3 id="ITRG-RETRIEVAL-GENERATION-SYNERGY-AUGMENTED-LARGE-LANGUAGE-MODELS"><a href="#ITRG-RETRIEVAL-GENERATION-SYNERGY-AUGMENTED-LARGE-LANGUAGE-MODELS" class="headerlink" title="ITRG - RETRIEVAL-GENERATION SYNERGY AUGMENTED LARGE LANGUAGE MODELS"></a>ITRG - RETRIEVAL-GENERATION SYNERGY AUGMENTED LARGE LANGUAGE MODELS</h3><p>跟ITER-RETGEN差不多, 不懂具体差别…</p><h3 id="Rewrite-Retrieve-Read-Re3"><a href="#Rewrite-Retrieve-Read-Re3" class="headerlink" title="Rewrite-Retrieve-Read (Re3)"></a>Rewrite-Retrieve-Read (Re3)</h3><p>使用一个预训练语言模型LLM生成查询, 然后使用网络搜索引擎检索相关文本.<br>为了更好地使查询与冻结模块对齐, 提出了一个可训练的方案.<br>采用一个小型LM作为可训练的重写器, 以适应黑盒LLM阅读器. 通过强化学习, 使用LLM阅读器的反馈来训练重写器.</p><h2 id="Retriever"><a href="#Retriever" class="headerlink" title="Retriever"></a>Retriever</h2><h3 id="TextGCN"><a href="#TextGCN" class="headerlink" title="TextGCN"></a>TextGCN</h3><p><a href="https://arxiv.org/abs/1809.05679">paper</a></p><p>将GCN用于文本分类任务, 构造网络模型text GCN, 并在4个长文本数据集 (20NG, R8,R52,Ohsumed)和1个短文本数据集 (MR,电影短评论数据集) 上进行了实验验证, 证明其效果较好.</p><p>主要<strong>关注本文的建图方法</strong>:</p><p>提出使用整个语料库构造成一个图, 图中的节点是语料库中的 <strong>每个document</strong> 和字典中 <strong>所有的word</strong>, 构建一个大图, 并用邻接矩阵表示.</p><p>图中的边有两种, 一种是document与word之间的边, 另一种是word与word之间的边, 也就是说document与document之间是没有边的, 边的权值有以下几种情况:</p><ul><li>PMI(i, j). i和j都是words, 只保留边权 PMI &gt; 0 的边</li><li>TF-IDF. i是document, j是word</li><li>1 .   i&#x3D;j的情况</li><li>0 .   其他情况</li></ul><p>PMI (point wise mutual information):</p><p><img src="https://pic4.zhimg.com/80/v2-d7ac9186c890f88761083894258ea2b3_720w.webp" alt="PMI"></p><p>TF, IDF值是 某个词相对于某个文档 来说的, 即某个词在特定语料库中的TF, IDF值的计算方式如下:</p><ul><li>词频TF &#x3D; 某个词在文章中出现的次数</li><li>逆文档频率IDF &#x3D; log (语料库中的文档总数&#x2F; (包含当前词的文档数 + 1))</li><li>TF-IDF &#x3D; 词频TF * 逆文档频率IDF</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 03.04-03.10</title>
    <link href="/2024/03/10/%E5%91%A8%E8%AE%B0%20-%202024%2003.04-03.10/"/>
    <url>/2024/03/10/%E5%91%A8%E8%AE%B0%20-%202024%2003.04-03.10/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ae9bc5ce216328e72529e5f77c3fb815819c9cd54e7c1442e57e6065c1acf26b">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7618b53b8803025b97ef64d9da3e6ea59793705e38b09d0403298f7e5738f8912563647445c70a752fa7c07018640533b67a5bba0e2312f4bdfd83c96d16e88f9d2d76130d52389482474effb77461d43f859365fcaf5d95e8bc8da7f8cea3b68f05c32a6ee58f6db529f52d8e2eec16d1bcb3f4ea3d0b23fa87bd7de4922709500b169b36df63c5775ce121ad348b71419013c3a480d5cd9fdcab797162c20e4c6dd6de61f56f09b62f9965663a2ffe0a3d954b7aa978e1991ef1a9cb538151bc72b5bf5c8b987e692a636ef5615eda4c4d6a7a4934e5dff467e050b30288b6c87ca7f62709eda0880c7da1d8525cc4a5051853f04b01656284905958ba135ecf63eeaf8061af62d5e93db14b947deed308daf26c84f1bedf1b096be30626b6c0115fb7b3fd5157328f484ef47c685fada67df71dc3b933c34e86828d62cfb6f35c64f9594c83813e7d62d6ee1508cc63110bf055fe5a2df87479a8b047a32281a838b9d42f93fa102b76e3e4d30b102b612b2a379935d19009f628f65f9f6cb8e5fd9a60df7dba4e4ad367c3cb968ea56a18c4e8e5383260161bc33ccf504e75a31115779ea4e5f9fe184baa121f9d1c75a948e015af6d75464d1cf73244cfd656aabc1b2b34b8cbba44c35898755219289d3fd93f53178ce18c5b0a48d9173ed34848b1dae294b360f8d866406f588e8d4efe473e94517d954baa016350167940a1b29825d893a3f59e6549de03c66403482dfe643e9f6317a08d07619effb07510826ce78bdd0db1d4feb3f334d66330e6cecc465badd68112668da94e84a10eab0dc41aa8ea33f4d801cc60b98c0891d8cd678ed09915eb460b2c00f81d7277d54251cf30bcab02844b6df98a85bddd0ad10bf46610917e7d58c024c8b90c250c0977f98e817d00ca1b22f43757fd5de6189ccfb597a90070906280097d93b0c164f6e79e7c112ea4cc9ccdbb61a975e036fcb7eaf719ec16ed7f375d3fe75090a92fc4377cf7264ebd19d337f8e78e61988a7db4bcb417044259d388a4ad066a4b854679868c79f9faa7faf6c43ed1aea5e45c0d58af6606f8cadb6415aabfa683207233cc957fcbda64af1528b562c210d9d18478ced0ac70b0aeea5320755fddd197dc9d2b1c6b2e2504e8ff47ab0967f5e4c4c11bd1eefa6e77d49d4a87a95675f1a179d5eeaa1112555151fda2890898f0ca6c8e51e52719ce956319a739e2af277dbfdd56978b287a24056d0b4ce94bd06c624a3e0286c320840fe4aae695620b6df66e827223e2416539d9f8301b99ccd66815a6be5db1f0d88c1aae8d14eb077a0b931ce7d0d27a5a293563667361aa52a0c6aaf31c1bba1f2c5a3e4d857ffc29db794c805849e00fdfa348c3a77050e019c1461a91cc3dd5836446af56308f90cc8936f99f7072d5ce27b2cf6b2548ebccd10da98e56122345118e50bef5c7422ece3c3768b35ce99bb045d3a78c3b361f46f41224068a41a6d4a345a85b52eb64064fcb7380c77296423da22142eba465bdf658c5e449be31c459d7157d0d7e693e6caa2df0ad206d88e63a96f181327251cbaf50e8728e87c012523fc98ab5847fd3ec9182ab21f6cf45bf353c136cd60d63f26c1e09a9787cffa3903f490fee3216d97c16340c88073ff54bd9e87583f5e59799ed555b3c07fbdc919a9ef5ab45b907d72f3b6ef1fd4ed5a8e47f574d1f27df426d37b3b3caaac9762788c612c149040fe4dd483389fdc9bc3249b021d4ead7d2d6a650e53618b7c85dffa524eb48c4666fbc3d8fdb0a8d82bc53b4546db8fe8ec1da98879e2d18d9d5349e9410293ae1c1ee1a5ab79aaf39364024d5a9fb57cb22242bd1eff789f1361dfb94a9eb02cc3bb9d28ceb0e09933325ecf39eac4d55b31be99b3a3244278012eb06ff2cf89c900396d69405f0ccdd76a0a66d2b0299cc4fd11f11654858848dfbb6b6d0048c0b45ecdbbd1ff4102532265b08ae3748797f6c1682a70b5becd553027fb723cf7e2215cd0c39cde945b89000f96c8391f78a4995d517b46bf0523945e30688bb5c5eb528526b9cc4af6c458fc0a82e985c9379bf2926d70bd4bdc99c09b4df5b24645a253b6ca43f6aee88ab059b340382a7fb60c6b4f4601332fe82c2e49488adfb37333b3e00c1fa3e756781b3d43f00e16a6be21d9f370cc079d56e6ee0f167b093af4dc7d4a4d121f8f2614e91c031b69fdff03d98d46b82ecc0a3540da26ade0f31f5d7f223c6d85bd0833f2aec61ddc1d99ced3b878e426ca5ed02abfed7acee0384041c94d22ad757917cda27c184931a993cbe01e1b58da5f22f6b50afa160531232aece1263461c79cf08ef6d782f44e273afe12a4debc3a7f1e4994bd602377c34f00f0c56e9a4d896413651ac3400d8c01b73321a2f7f0f39b65f038cebab48a96570e516c8a4fb5167735042fc7abd5c575e31ecf741222b9deae2e106baa89418d95a991193c05fe801969196264d1db3430a5b254cb3ae3f4017913bc420c7a680dd11211ac981500c34b3289e33618352ad2c14c594eea383034b3aa9793297e90e135103341408b8bee6c733f93bb8031861380f17e305f4ee5fb1439922145a3538006b8ba9103b9353eb88f80d3527646c1ef5f392cdb793db2271196162f4ba88b1e22a21f9e4c3d2a44604d577b07b845ed3866086d131e9cb3d306796bdc07d9d9eee190a6e4df3d2a5ef050afec547cd4663863445f5263741e21b6cdcb9fab14ba72a772e70956b1510929f0867e9a57e00b1f42009de6341771e8a9f5d7fee628c1a4a05fda83e71de140baad5a7240ad90e0015d9bed15c433dd1084adc6c8120bb35162a530369c725e97a3c65183ab544d46e2992e0e0ce19abf48489ab992dcddab24ce8ae55ea3a5b23b915075179a3e978b5e186597676dc6184f2e6e9673ea98109d5b984b152af4d2e3136725830a57c9c99d3d19c132361173e02c3509e4674a86ff3cdce5c56d6dc86528d1effb88ec458ca9e060fadf08b57514849e91c2cb327dfbab4aa0c78b3f82778013402c68767db640bad23295cf31cd5b9934c5f66f56c24d52c3f538e0d97c16e61f13cdb4413520af6d9f2ae92075c5d219ddf98d83805f1fb7d59722044c17529d7139085afb46d1f38b295035e35cb2f815d7d3b7412edc0043f52f64334a545361c508561320d1bf6440772cdab94d010d49357610ddd6ece0108fcf38c613c625cc553716280ef79b003887b7c2b1e6c402d5b0e20ece331fb883d87ec6db35e1a822ee1d9762bd905feab3eb7a0030774442519404967e8768750da93f86b7b0397c2b3338167677101e4d688eaa23dc7963f4e30943e8a4fa64f21274f48b9a8edf19e8162c8fa9c3588ea227aef1eafdbcaff255222c80ddff0c34849a1445bc7e4d83f1fd2b422697ff575f8b64e5c9ee0952fab7715f6cf105207bd5615ddc414169457c302d8ecf7fb95da716d8219f08fd7faefa4d5c2a560d0bf798ba80440da5ab029f4f564eff6bd2c0b421230ac26c796c605e71dbb96fefad51eef913cc323b3442c5cffe24f3f72e23e964ebefa67494a06057bd5819ec50683f62e3bcb5d0e0282bc431f24e52388082a9c5b80d9c9d9b2aea4a1095878f1e10e3f02254b49efc67ae574d3879d914999353b7d3d255d7ee8baf4d0a5b21fd06f590fd0cf70cdd661a03f20839e50582d483e2487312766aee4669392e8cbabbb45f950e16624015227113996200c4d37ee3f292d4bd69bc529f11f9fa7f7493d0db086c2a832bbb40a695362474532eff022f361b70143335436a8e4bf85eb96cc81b3364f3e0abc55c6b2247d8a447f2f4b07b18d4452af17a37f5d2be378a822c592fa5d81299947e72ca5c59add317c7ddae0db0971a294a3a51b4ba0003e1a1210292f4fe8b546939f6b4fb0e041a2e46e7a6911cf0e13fcfe983d9ee693a20604363e531028d23c84b55127918db086761d002e023f7c3d696a4a93858d1dd993146d69e9e6a9a219e379f3d8934de87f00f06f94e13e6413dd6c8ee35f6141f924173043efd4d2217d152adef077fd319dc1ef207f73cacfe82cb165daddd4842aad024a65d326425c71fc551ea11bd27ad9f09f3be96008ffffb3e951ab481371451128e059e3713508cca97f89144cdd9dda07dd8a6f49d5f749484d7d6f62cef1bfa0445d3fa19205597a37ec53a62deb4f8451befb6b87f8da8933941d7baf96e6f03bf0baf904ba69bf0c08c4d3fb3ade965c5ff4102e5bcec444ccfd102dd14a6c99e9371f864ac72a9bb2f4a1b60a5c1d9bb84d34d94351092a9854dc859e397f9fe3bd38b1a91d0ca02c8a24a787bb222ce0af2a4fca35270a80bfcef49815b1a21b2796535b129d0c91c372d583d65b03a28a306e9e83d1c94bac2648ea00ee8c0d30eaf0862890570ea4324cbc06d13b421eaa4b0e52b2b00b3907fc4ae03f028f5e9cf05b4f15a0a069dc95705e30884f0d677ce1a1892870941639883178fa9364a21a45422eab3d2758b962a0579d6b2aab022f598c0976469aaa870904843d135c265f270d695ea6f57141d2c04516710cc1ba526b7cdc035926434a8b9379118a631842f038fe8f4df9b5e5411995417f3a09d0b1a9f22a6ef3f32361c28d075a4f3a3e0465f3b0e7fda5cb74be8f5630713224ff20abffdbaf7b594615fcc4cc9859f244ebf9dabd012943747cac4cd5b83f00e0818cd3683c6f2116a8ce6393bfcaddc3519a0e3c065b07d8e6aa8a081c4fabf1f0ef8da8c47723208648676300edfe835160912605f95551b0d00db2caf6ecd5ba13efe8d3b186fd1afc38185bcd38a520e83a6271f9a2b1233e21ef24b354f9b69757b9fcfe6618d716661fefaf2941baaaae270a1b2cfe68df3fc1fa9b48f392d2655def15ed5a2b169060a30e3d2dfa7993de79e7b803ca47d47cdc6b0baf3cd887aa4a83830958a5824cc24a824f977a0c12425503be30868c3d4eccf5d353ce7359bec43a1e5ed44cdda53bd2d47a62950007b99444900f10f98bed5fe83e3b33d4c565fc2d37fdaf760da193bfe261f24ad148ecf7cdd97494cbecfa91324d83617c2c3d437f72f28b0ce955672db145724abd46ad8ca586636eb9bf31a340125f38dc82d678a019197af53f6159dab2673332cdb2f058d8866bb33581280a0df32684a2f634c57ef2898f2384e89b2498bd4ef2fcea707bcf126ef81601eff806133ef2a19594931f3984d4ab9abea337f20093ca396146d7b02c496007147247f3f39ffebd922c99b99a882cf00ad04b658ba754cb5b513123020ae572f671e04b73db60dcf665f6c9c6ee335a7ddb385f422fa28560f0dafe1540db1a4d53b5cf1e781aec5ed942b1f588fc1069a934293f6e5e560dde294d2cc3c73d2064dd566fae7a90f6a701a1a9f32557636b5229eaadd134bd03c23eab0c32f73d7d27537f2566e44d6453a36237b0884b574110ca3d06d659cde11fe07d5bc1a38939face5713b91164b02f1eed41d9e6df34af75f79b85c0a2b7378a4c27aea8b9cf6d46ffa5ae008d17f35ab68c45a8e2341eb5f8ce5c4c8fff3089e0dd651d1decead1ae64774dad386cc86e7d02c21e54ecae91f46881906d417cac05f4826cc06e51afcd34d18eed35e5ffacd4822d4e76b7698994604cf031d9c66e52e6626dfb52005fa74b076415fb79403ea68fb83d469662df5713ed5cf760b88cd1dab6e144c204c5008a4007865f02bc8bfdbef8de9762280afae46c5d1024c464aa17a0e6e3b378eddde5d4ed9508fe8be5747f3f60108f0ffe8e2df1650b4064a072befca95a53491f492c08e474b976f1cc737c98ed56f8d7318a5132e9b35b72f7dea7685a574fdcb418b9ba539c5dab0ebf80cde899b4c39ee64f0d40672c21905c17ebe6eb14a48c7a27030e2f1158020a65f3e404d3f73b7d6e5d34c33d41e7df18091091253c8690745fcae4d9b87707fd2f7154eca3f5966f311d31df35237b178412b155c9d4154afc6b552893770ff7f78d933edfa0bf644057456abb88c9dae5e480e02d59909b322580011ca57ef74e309eada2c2c152cb3756428cc361e73d3c80757cff4ed0b56d4c1eaf7f3af72573f70bbed84e0403a8762e6aa6714c07f0225989371241ac4b6cfd74230902cc2b85e2c5d52fec2b9931e6bd6764ea52072e1163f8362e733fbe3124a162362c86a31e77965b30224ecdb9e05527d631ab62ee6f1610c4288f838610089117cf1b29804e63ca51d62f91da0f173674baed7567b59784c65565fb272d31dceb697c56645e9f5190065efb3a1933112ab4ecd1326d56be2efe5d1cd30dc32f8418ee6bc7143d27d576b11b9e4ee4806b29360d4cdd47e1e786aaf8bed512d7f830e0a5e4064571b02063488d806161b39ffeaaa3c3d377216de854cb1b31daaf4ff1943d62df90416e6def72d10c6966c4e6f8717e017d513652b3d230c21011bd8f5f4e861b137593949bbeac7862c3ac80c545803b56ebeb8713927d263879f24efda01ecbf5f01e64d6c40411cf5bc1e5138272d59a26d802e8fc1bfd7885a8c0a7425ac9678c333f2b556e86638345e8666814c33cc698941d007149c6716dcd1150ea8be9b5ebacbdbf85bc8002f7125a2b88941ebb550386c567fed98b934063726cbc03367aa40b48eeb72202d6c935a798a5987ac95be3b65f40ec79723e5f34a371b7778a0467f734dc8b234782f4ac06b616c62b1d207cf0fcf6f02ca37dd23328db0c01dcb3d2707b25821add17f0f6e514d3f9285ed9aab9f68c18100c9438874c0c2e1ab232d1d37d9595053c25d8faf9b9d42be284b8cc06a14dda4028e97fa2436a2eb097c115abd613759da4b452e71feb903f5eaa0895483d05c68686a9d0b8d1206572c0ede503af49f9eb342936b7270aefc97f9994b0685cd7c77a5ce85e3568d5166c606ecbdb7a19794dbe018f9321b473db76b933a45ee54365de084bdd36a5a1d2f88315971f8e95780bc3e1a1de582422989d9718c5207a91057caa4ff98a5c0fd04cc7d00f630ab1a40aa8fece6cac76250f18972785302d43e17f98b5674c7f94695c072f6a2dea0d139661d963fe9d6de030cc70d3b016757f4c42100e0e09104475225bb114dc78ec804b857410409b0e13221e4ea7da11c102780619fa982613548b9f23a93bd77a8b9e576c0ca1c1ed1ce0d71c2c61b2f13603f28483f4df72c43f27246e908a7c10754cb96b8609dd7e17f5054b970213b7cbfd1c499e77fa487383b40b326f40f5919abb0d24773d474bc24d1cf158afa5649c0d6df4d4c9f435c1ea47ad11629a1682f9eaf6e8e362a37925d54b98bf97a0e2aca59708e8928801768ad321aa04ed4764e24d36a614c3fdf6b440169c86c1d4f94a32edae4aabc8335003f79121e0578bb9b39219ed59f6b2f23983a30e7359e08b5c7b48bbaea2e22731df0b1bec3513fb25b321c58ce3054194f3476fabff100b65562a92c9101898054d258b3c588fa5472ea22e59317c28796ab395e43713967c2023b9ea827c414e12f519b924a3daae3c2d3ef868fe4725d38f8b4dc175f0ebce6088ef09833bca5b10a8438ba7c6aba3874a198fbbd9c1025cbff0d1db44fb1b767982a0bd063da8ded2c02bff5bfbe07570c33031c6cf55e7fa5074ea3a02e780ac7100698c24ce6cd0334d4286c211a418ecc3261fe9f5a12c8515cd01c3731771f9c35d73f8a5e5307d606a3e70493891a08873e6af10bcfb6529ba20f044fa1990872513689c7afacac176db3633fbd563c718c777b3090be0cee028de30eb2f58e55634ba8f2a1efb72e803889961c35e7289e909d90772185ac6f85b8e7907f2b90738010f439d0e04891f2472fa1bbe0fc6a68bb6521b7bedf02580ad1893a71ec90233f5122699af8caa9af852692b8fd4eeb748024ac56fc9676992c0748f4987961f67c022cf1da3c7341fe99d1c06fae8f27a3af57a08cb5b9c458944668e174c29374b7bd736d8e2eaed527de7ed0e8efdb4cb4dd730e53357b0f1148f75881ad74c7d4f007cba9ba433ad6acd6f7e1a99c33375cfd7fd63021c48dfd0f33477dc695c657d8122201fdead5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - Ubuntu 下多github账户共存</title>
    <link href="/2024/03/04/Linux%20-%20Ubuntu%20%E4%B8%8B%E5%A4%9Agithub%E8%B4%A6%E6%88%B7%E5%85%B1%E5%AD%98/"/>
    <url>/2024/03/04/Linux%20-%20Ubuntu%20%E4%B8%8B%E5%A4%9Agithub%E8%B4%A6%E6%88%B7%E5%85%B1%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>故事发生的背景是这样的: 我和学弟共用一台Linux服务器, 学弟和我都需要使用github.<br>也就是说需要<strong>在同一台电脑上以不同的github账户去使用git</strong>. 这就需要管理本机上多个ssh key.</p><ol><li><p><code>ctrl+j</code> 打开终端, <code>cd ~/.ssh</code></p></li><li><p>生成新的ssh key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;channinglcj@gmail.com&quot; -f ~/.ssh/id_rsa_lcj<br></code></pre></td></tr></table></figure><p>生成ssh key.<br><code>-f ~/.ssh/id_rsa_lcj</code>: 把密钥对命名为id_rsa_lcj和id_rsa_lcj.pub<br><code>Enter passphrase (empty for no passphrase):</code>  提示你输入提交项目时输入的验证密码, 这是为了防止别人随便在你的项目上push东西<br>这里我不想每次操作都输入密码, 就直接按enter不填.</p></li><li><p>添加新 ssh key.<br>默认ssh只会读取id_rsa, 所以为了让ssh识别新的私钥，需要将其添加到ssh agent.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-agent bash<br>ssh-add ~/.ssh/id_rsa_lcj<br></code></pre></td></tr></table></figure></li><li><p><code>code ~/.ssh/config</code>添加:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host lcj2021<br>    HostName github.com<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/id_rsa_lcj<br></code></pre></td></tr></table></figure><p> 其中 Host 的名字可以随意方便自己记忆. 但HostName必须为github.com<br> 这有点像windows版vscode的remote配置.</p></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@lcj2021<br></code></pre></td></tr></table></figure><p>如果出现 <code>Hi channinglcj! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 说明配置成功.</p></li><li><p>配置github<br>在github上添加新的ssh key id_rsa_lcj.<br><a href="https://github.com/settings/keys">SSH keys</a>.</p></li><li><p>配置git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;lcj2021&quot;<br>git config --global user.email &quot;channinglcj@gmail.com&quot;<br></code></pre></td></tr></table></figure><p>多人github账号共存的情况下, push之前一定要先执行一次确保当前使用的是自己的github账号.</p></li></ol><p>实测在push之前需要再执行一次</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;lcj2021&quot;<br>git config --global user.email &quot;channinglcj@gmail.com&quot;<br>ssh-agent bash<br>ssh-add ~/.ssh/id_rsa_lcj<br>source ~/.bashrc<br></code></pre></td></tr></table></figure><p>然后<strong>重启bash</strong></p><p>本地新建分支，并且在远程上也创建<br><code>git checkout -b lcj_dev &amp;&amp; git push -u origin lcj_dev</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 02.26-03.03</title>
    <link href="/2024/03/03/%E5%91%A8%E8%AE%B0%20-%202024%2002.26-03.03/"/>
    <url>/2024/03/03/%E5%91%A8%E8%AE%B0%20-%202024%2002.26-03.03/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c589b9a80a0d6fbbfcbe8b668fca5479ccb0cd628923791bbf832233efdd92ff">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7ae52ed7c754562c5302eda29efa5e6a67eb32c42742fb1afbf3b245b8dd219baedf239ad8276720adb5491b426ab8221537797af8974c928af8a88f20c7b1cf612f97efbd724683b1f179e878dc7cee50b5b21c00c35396c4146dd87300b12aa15e0efad9c8e0fdc1271b4e5a42b620793895e1b9580f844bf36b908656de9252f215359e1aa7fd11b0f353918adfff26ee695c8ea41447794af78aafafa3d791cbc89bea04cba4efbbccd1ec60e015896fbd63822d0dea30d653de870d8a76a515377f4d02956470627cf086e85b5f42b9dacefd2e7eb3c76d899dd096299fced6580f481c9b2cb0ff33ecd36a3fb44208ff4b6769b6806e1ac740685aae7f4e088342a1bdfbb283026a357f002025f71f19aec10ba4cc9fc5ece69f2ef998afb4473e244fa521c1ce7bca0411b56c92a003f7f516e02ee2f1c9a10dbdf0b91645f963241b9d2d5c3fd284149ffbeaf0393ec976dd944f092aa7a4f1ee36f5f649a2569dddc0f89ecf4fddcc863550d91c8ec59c520ed54ea01f2271d1a0fd4707439e047f44816eb406f22591d906501cddf9cd25a1b7679181eec0b4f902447b19dd371d8f376b5135893b73922c7f798b6a351dc8a48c3f920e17318f1207ed8610c0906219f21c9d87d5a272130e4e74487c4a2a71a439549459115b2fff733bc7bddb479dde2a6ede7a5804f3a91fd7792bd843a30003ff5b8590140321f8c2737ae26754af49a10ff0236eaab66320b0eced4ef3bdb039c46b79419e3dc64acaec80bac946b20b0defe3e1e299940a2a7c4e1bdac5968a786153c67d14bfe9ae73fb875d8d50142571194a3d8f800d1d2774efa5a42d07f26a4cef22642dd5765aa9ca6e1517f79b4c6583b2aa34e5b3254731ac68eb94e043d044b88709e44e18dc31761ae44423cc225184856fe014e3a6e2c494078a4476b6c96202b1e96c33c2012bf4de3a7387a8baa9b0cf2f7bd485c7aaa2051a55bc9b8fe1f113272c7b8622ee89ae2c8a46577ec31c813b59e95d1c998131f121fbf95410ba4bda19522a662fb14cd2bd7980a78ead22072e53dc0ea287e77776f0ec45294781ae8433ba133326cc48ec41d8d2042020d032c2bfd784517c5559b895c9dfa17b4bda321a9532143685481bed27533079a8ce0c7b892c74308de3982f2516703245642acc600bd5d178ae4b7c7eb7df06dc35d8675909af53a0614c42a500ec193ca02c3b1952395bf4673cd0f713559dc84eed1bbad359692100adfcdc1820321436fcb315d9f9957d77270fc3b0a54524a8fe5f139ad2da2931e617bbea535b0e13cf630ca1390f0be944bb7a36a342f0e60dd6dfdf0ccce64e0db38a88fc0a48c866277f055422254514af2443884d0739df02d4226cd512f6a0f981f72ff953de22b9f6f5f7ed9d182540835443f196b3ef113316de07cd118bddd36b559eba2846b6bef3b97c378456a86964f499eeb696061b259de2a5b082d2a14c5ad8d7d6daae3cc5159339bd38dd299a8dd7471677f7e35c8cb65f9dc0a2854aec64b473fdf7c083290252caedc8ed776da7d2924faba1b0d885adb95e4123fc7302fa85478544df068b77ab13f1cd9446e5ff706e892c6ed0f56068e71e863f282156f5b44db15e6b0a7ddda5bb45fca92e9fc4951a0046425cca0b20f59b5bbbb53b6767429f075de7699d66fb9f7dcb1cc91f35c6a21ca564dbad25017cf4c1ae3530ae871b0ae22764dc01ab3c9f9a60349c09cd009ed7bba4b019c67de8afe9773cd4131b790e072fd7b0f51b68d121011e1de9cb06b0efc0d3f649e4606b3a2f5948e68d77b5c30a0c4100aefe74a5b878d71cb59ce3284e66228af2474d2f4eef40f05cbc599b768b7814537a3a54ddbf1450a8f9f3fb7006fa5358394c49153642efa2326ab89a9ec634853da5de3f4893e22c8023435dc8a14033ed3bc6f8ece4b684d13f6d69337338aa5e736ab1cd11c766f99d9538238ac50bff820750f351206d01d177b686b085a8ddf2ec453f03f6b289f1d541d0cc174ea0e784966aabc283d137b04218f906466121ba49281670a45e75298a8f761f63b9f6bad0034709d6ed75bc9532b83583d4505734fcb4792c252e49f0619e7c534b5d24311da57fe1504c4eee9c3f3cbd9329ba32508dc247ea2bf60a91f74070b1304c4a636b566d835d575f6402818d973c0bda6e52b2bd66580ba464d2b469302b3d1014dbc91ef1b2d095f9014f926d14b3fd0818516d4ca8e8185ac2f3137046d3ddd6e6a8359c08124637014d380068517e0fe5a609f419fc26f4209a66a8e3d3a63188e775bf408ac803770291aef11ef0b4a6f9a93edcaebeac7599e66fd46c81950e3e071c36fef345c06cb94e46576f8a36afde5b54b93f050b905e9fe35300f2f21dd6e6b37ee239accc12d0a9a33e39ca583c736c62e3805547cd31432b5a70d3eecb22b04a23a9d9bb2887c147e6baa1c2e0bf94aba36de5379443bf62050f0fe6a161a5f308fe4609a8e96649a2d1313f0b77ea9752b294f87e3841f5b58a34b3be3f8d8e7e6f2b23a41a9ed8f18549fe8891c9e496ade61599052d0a42e9e06b5106400d2c80352c301c29463b92073c100c47f664fc3150b9558e187362d69a92baf142290f292ac90b0e628c509ab75b0511af828f264e6c7a9fcef3607af542b4d81ecf1894e99657b6366f61ed38caae50428c6ec1df5b664a69b0cff77eac127375529a5e488a14712d873c3ee11b9c6e46ad5754c5e550096d369e52098ddb3eaf616e9bed511179d932afc0e0798016880025cc85df4de5d93a7dfb01c01ba7c48d641ade6adc47eb9a7de344491452451ec58e4151e1eab5d8523b00f962ad1a496cffef8e1be880ecdc82d23ac6b984f3109c266e517d2315036353eed94533f92dac77a70e8b8d528ce3d5a0ab4619584f641841841ba5e9dd5da22899ef7de3a0ef106f2682110b0f0a7ce8c97e47a7a4013f0775c842754a8b117edd85c55f079be1b3d018af0d343800f5126424ad8cc485512e8c6eacf4257d5f079e6d3e76a01375f4d04fb8e10b953a44c7c03d8960391f7a7ccbecb10615de26c91b9ba852160a9ce4ca68fe4000f5bcfa53288e76a7df70523f02fb2fc61081de8e33c9e6766f348f66c48596463cf1748a679bbd4d45ec90116fd415b8fe0c3a38d645c710c8c6a22377b9873224fe0e04fe092d12e8e76e48f3bcc8d9e3c1d687ef2decd7de2613077ebb5bad89e2ec42adf7bb7763493aebc02aae1e5b03cd8d9ec8daefba1fd21add59fa2719e661905c7f6c7aa27bd6a5260f7b673ae0db874c5c6a74af4ad0b285e52ee44968bd2db15f6e97b9babb9ee16cf0c458e80c0aca87f97985b63f98e7950225b4a54625bfc40846b27d1cd6ad47833bc1e5a93a239fbf96952cd700ed7e32c40f2b9b2e10420ed9418a6c86f06e94e12ab2d90d0f98bff334bff92d2488ec62f7d47caa01ed7cf98e851ed1e6807614a0622c18030331d5e23dc51c1adaee0b5b3bc9932282dc3f9b6f86c684dcda29b17f2d0748e2e78bff6a0aee8290c56bcf153b874e03d76c4a21be74e309cff79644e63af79f606df2d5cd287a0e98279dd4d04c64850d9a65ba4fe8942e9a09337c4139f4812494b9dc16f0c993119e00f42c95df6acf9864c6fe456b3d104ad3d731c33f3b9a1b6628527909bd8d8a7bd87f461f52d58eae02870c46729d440d3017aade6d28a00a82ae9c57e22fda0bcfacbaca506786bbd498f6bbe02898a160a10a579035340fa82cce8416f428479dda79883ac449feff203052cc05795251484d3f5e10644ca6f7e4a6f36a91bc4a7703ff5f13eb09631c90c7d3be9ff7028b5a332b3e979a120b9e7c7ad81031d1010cbc87ccc803336d382dea83f650c424854c8bfaee3b5f28799e4f48c717653b83bd608da42a3037b0058ddd5cc8d55d26852a9c9e5804a957a78503fed790a0e882d20c08c6b5a110499a0bbcbf738136cfb57f29219a01f8dee66168713018ec85699cfdf39fdb01c6f5fd21f7068506b729723591e456b9f7a65c189ba703fb600acc6cdf639af33660acf65990493b5798934d5d39b7de2ac2b3149e4bbd3da78c31c2dc98088dcb6b81ae5196b5ae535ba466aa824f908ed2740af2991ee2e0cbf0b19c1de909048843df732418dfe3f581f1f065500cb924fbad74657fe683bf571db02ee0fee0480a3195a96de5ffe20845caaf00eb66a06d63144e57c912641c823bfb9fbcab1da3a958a396dd770769de2ede30b2b4923ba7df99f7dabbb85758e6762978ede8fc20b79db74a175858b26d439572616eac35b8f3d485b685ec1195781c8758bd3a075bee52c8ba0b72eca48061ade6884238b2d3b8433c82c2c0755c58b8d72d356812728217a275d5c19c30872a7753c555f1389f353735d1a425574c9ce35962904042c78bc97ed6735c738abd18b79a4a325799bf033bb942ea2b7ba268ba320ce28208ef8a507157873db295f9697503cb4ebc76d233ba8dd300e74ff97b970d7b609a5eb78b1413b0dd6d28f8b88343a4ea02acc2c39228f39aa8da03f24b7b02fc1f96aa65ec0e1cac5427511d53e7ebeebce2475af570c4a359c9ad166aa487598b6060bfe75bbc9c5104636bdddd661319e53c728bca07b7efdb1905dc30b8e49456f1cd1cf8f42f6c949936f6b0523ca8aeb1885fadec936125545bd7a4f6176f212864256003439574746932c7690efea73ce2320f4beb4b9e8c30cbb9b1250825650e45a875227c6edc0028505b914caf89610a48a2a9b0cb3795708154dbfd0c11a9c80a2df837feb14ee06554f15210da4fbb306d977a9e8024b6b5d9605b2fc4397ea3ac57b82adc47a83d4a4f7883ea5adf98df34581771f44380aff83916b876fe27cd7391befebf754d64b93c57d6c2874ae1b0cacb76727fb080a70bb70392b23e559dac22145c9a8435419ec8d18f80401db6afa6dddcb70bbb0abc2bdb464d7158b0ba4646f62d509fa859e20f0358a58a53d7196311da03550f9e4035da412b830e437ddd55ea156ee2d2514b4c538f7fc2cb7f06454d92b57f087ad1b462abdec5e519b25232a14b8f15f3b3b4b874e96b3fab13000bb8881def7596f8a57eea89d8ccbeba89e9a572d390060aa14d65dd7cb7b897be28b7ddb669e9cc566222879d6cb627e01f913117baf92afd1fd194fc361a153a0b6a6f68196442d23839932450756ceb7b911f320d5b635b63699c05887bc5a6e5cfab5314245c2066fcfff7d419882fcd1abb8a05f53c7d6953b2fc544b1f1b949adfbfe41873b37bb193d48d2ea80d4b983cb538f73feb6035c33c98036351fa56b2e0e0b2bfad3e1b5e63b8e628e62192728cf81b732386afa279798c6de4e1e78226f5666b8c7dc02fb1719cb4c140c4784e5355570e3e934fa7a18c0b7fb86ec0b6e4b02716b23c35c19b427ed12d3147dc108c60cc85443bf103f9dc1ad79ef2c2e7ffe152b69ccba4a156beb1199cb0a89b6fd5a149965606027d558abb2d618fac4e1272a1c52af067cdaa839d5a7e5807d645fa96c4fd15d0366312bd2a1f00d02c17a4038cf84ca02f4cffdebdf204cc52799609b9d20c4940c16b6d67c5b5e9d0abb744c64e89575ea1e746c9e2f8330f7627ef2e4d5373e767931102a52f3141014fbb5c21356dd9f33689e16ad0afe4584cedb207363427b248adcea389447d15cf3e5a3a89c1a8300746ffaecbc9f4c4835ae9a9ad95c63f0f30f4063c7f0104d82f1d80eb54c164d5656267fde2a6fe2c94df379cc367f51558a23460783a522e578e19377a3a22c3e23ac3a82c787036d7950a378297b29786f21b7fef6a7b09aca5f93968ebc079b1e26e67cf6af6361b8630a9c1570d9c98640edbc7e28c344a89deab0ebc5d4e57936366f2e77521929242169bea9929e42d772a3821f652bd9a21fca84563d3574d107847eb0ebd08aee47bcc2625318ef94c827ce066726891f65403f21a7b07d78e747c6104502e696ad1e1a487830ffe9589f5d58b6ba9e39715091b2b275e4d710e6052a3ef4fc892353ee4051c1671b1aa09d663ad3d2779047b4896754320e2ffc96add1b7c581b41e96ee80a2423d978bf22a6339e9a54dbd7f9772ef74713bb2a3e22604ff1e37dcfaee2dcb215d70e95e002b3140761a7b9ee2091b04c90f49503ff2e1678608c5c1d822f8a7ce2f0bf7887adf7248b7380288a56a4fdb50f8156eb455f728fdd85a471092875ec0079147ea12c889aeb4567642371c8c0fc748495bbdaf18c46e172f57bc6f016640c55a213af8dcea50295b3e15c269a567baf692bbae46e0604572b7fc493537d54375e745974263b8a404a3260493fc3ee3fadfdaa5116fcca2919e73484b0f278e85f70b351b8f4dafcd127e2aaa0aa7e7dbaaec3bd7ffb246008e939136d4401e82f2b5a1720534cf679bededcb6d59cf7a93c405794533285fa097dc5cd612ca5f58ff396943244ebc4370d97caec34cd62378cea67216ac99a10c0bcf023aeb93fab6cdd09e4277aee2cc7f9973121c0afe498969276089643e3a419f4295940610d66a1c2c5d29fb1e241a121d54f04cda4582d7171de6665464f93b60d3509aeefed58e2aa0b329ed36e2969e4282f8c00a7fcfcf58d956e58b69eb4d64aa03cdede9091b11f8e5083ed18de65c306f2dcaf17c8afb584217e615cfcc6dde639c50a28544c460702216f7ddfe6eb00ba7b14907ae581497b25732ebd82b1de5f0875c7538b2bb22639653f5573c36059c2a29437383722f8abd2f9f0ce309bc3230fbac720e5dffe4d4398b09e727995323fcec7575b9afe9e84c6650f994dc69f442d9978038eba652c8d61723c703fa18702d7c6f49b637337346ea87e3d64d85654f37048e215a71cd76458a1fd6b3400850a09d0908400655f77b90977577167fec12b5751ecce760c661114f04f95770c9e16617383f62e469fab7aba973296b580d6b9e23a3254829df5abed5037604b12290dc46b658712b25aa5ab1313ac88917731bd096a8977fb2e5eed71064abc2e0b4dff025dfc6e776d6249b630953fbbef7dac5ed62afd2dd8f99de3208e5f9d3ec945ed72ca1596ba23e38eb186a9b5ae617d206b90409070213e1cf895fd1bb4a5401a0ae45b064c8bc0f59200be8782ff65f26f83f64ceda9f80bf223f26158b2a310129b2e967b75837b5e4d6f43bf63bc34ee6ca4de7add3d2746f8a1411c612da9587529d87afb71821540b3c274e8f9cd20d00927ba7701cfbd6b4539488d9d8733d17618125c3e1ab72dd4b6e27715f3c58067927f6782b31f2407b4e7cd9713a288e4aebd512f38ab8aa180926cbbcf5fbbff9fe9a717f1fa4f6cdf684ca830d9d1b02ff3194262fd4395b8db1ea98243016d1d5df9243745c0338f83601ed55a8583bcf6565b17717afec9a4e66426e748d7ad8a52287baee40b56f7fc173e90325a1c90acdda6bc5029afc3c33e884175651fc2565d1869a15c52c2c920c85613effdb2f9a38f5d8b6d8ec396cbb71f745072213c9724fbc8849dabde414ca1d25adca3d479081a91fc668fed50777e2f03a6ab91e621f400a39ab109d5963ffee969a07916c7ea719ddbfde478c99b84f124345d8a8d766982822eb584f496f125ca7dd58612b3a281dd48a87b9189c8d98536ea033bdd3d3773d953f654139e3a50a5b98df3a5aa987c908bd7dc4c7a42377d0085d4a00d0bec2a6c15c26a82e892094d0002d7870851464c24d73973e4fecb5824305cd67908a8c5708ad2d5cea77a630d999ecaa8bfb0e1b213c52e0493be889737e5362252f391d7e79b967b4395ebb5775a6c5ee965405be28ddbe2cf873cac3a0b6ec70d82799b072018fa1e73bbe133bc28a412d52c58023ef826098b30961deba46ba4ff7316b3adcb487fb2c715e76f9007be0d7539de1f4187b7afd6b5f6bb010c1c401d071d8c012e5c4d6ade421e85391f14f356740a61ce1f456ab7dbeb07394122296e778db22c12dcd095f9d2a80ebbe071d7c3ba44e39cd5a074fdd3895b5fe419d3bb7d3de5e5f70b34e8951d280701f8f3cc195d3411c8ce56c8907849acbddcdca119c24961d23f42c1fb71fd3df80d51d5dfe477e139bcfbfe53e086a4db84a2f1e407d2237728eeb8de0a96f9876e08446855c12d9b3c946da473ad44deeed66c99303a9a7eadd04256cf0b05a7075f8da69f6a0ee2ed3b76693b7276633fc8aa2e7a95ad202a0b7f5533a187ec03338fa895339b254656e1ea3b8d1664767692ff1a88cadae4f2ee5e0724e9a14867844ff5c67d85fb72594c17588b253a5ac69889d02d01e36fafb2ffc2836b967d86c2231cd4a119a01bc16bb5246119b6de7c6c424ba74f638a5d80dd0452fb59b37f09bf760175f129d129c40a2690323fbeae7369005be1d174b025568f09df3273af9ed8d2878dbf10dd5a3bf6c2489b19cbdea24cc2e7a31d78ee8cf5f83e13c549a5fdab57719aec4be4da615c29fb0fd178cf20c1668c63a15315e17b5c73f7807469bd8914ca16b1cfa3a681e7c627e3fb92638cb6fc786f8a996fcd3ce55f89fea95a84b8c5b54a6dd363fb3afa6b1beae178745b72eb399cecda0a7f1fedccee92aeb62701161531c59db5353b64cf1537dce7090ba1be7b58ba55b25c8de6e03a853196fa9d2aa1b5b4588bc1fabf362c41e5700e6c7c76f782ad6b61df7273df285f7e780b7bc42599526cfe0b7152a71c6891e19398baedf74a510661bb5bd8484a25a547e60e6414f95614c7c7d243ce328a2fbe6becdb54aeac6c3cba63cbd66cb86df366ee95aed0b412318a3246a51402bec4fcd2f12fa3651c4e218523188d2978cd481a56538b7fc355540464d25826d31413a1a7fdc4f357ea508781a7d36a6374677dbdfa7a89ab6e6f68804ea2a32fdf38490c9e53382019f774dff54abd28cbd0eaa4a27a3da4706049cea5fe014d2039fb54396ac7d51e594f0a17aa7413f86f5ded88d46ef1bfdfed54480b5c51a211032fce1a1b10948f70ce6e8f47eb5cdc4a2eb992b2d6c68835e072e67d182e7da6c691bafa3d71028c7d3054bc59da9989e0daff56560766c2da0bded01d121af727405c73dd67b2d12e9935578a1e9a92488cf84a6ef99b47cbdc37add48083b6b147ecfe6deb2b360dbbf86768594d12a657827e011c3453848a3c5586872b449c19c4b0dc7fea33eb0c2157e224d17b6718689230ba54c50d923b4546589b8519fad2f1d82ab274bf97306073e50788c3ef96cb89b7c02cb7c2511895f4e0ab6af3b5da0968cfb9ffec29863fde81494744c527823344a7b655f9c408b2c350eab3bf7b90aa2cd196ff22acd8f2137c4b93c7e310d5e25cf7d88659882482f6cf34c85543c22d306d8ab10b05d617d20f7aea7406414253652d8dd8aa8cdb7dca34a852889bce34a6dc1d03fedec85487edaeff7ef704caf5b0c55caae9c89df16e76939c116515408c29b4000934109ef481678c53d76fff0273d2254795217cc24d2c1e130c977832e9da2112bd70fd3dc51917dc515d19c73dfa0b01d92b73a679c7cb1ccb63d97bde9fd800fe6a3d0556f7b968bd8bfdb4596b00b4695f41fe2f429b37333a7a6d1ab98f0106ff76ba8e7507bcf04dfd941cb68603500208deac9de293ef8ff54b5322053169492e848123f53196509171884ddd70ad354161f2035b3737f7b46f3f388acb4e8c71b49ec3c5bbd58113468aaf5b69a950d92055939dfcac6e03cfc6c9b5d0a5eb0c84ae7faf4e6ab74a4694755f3d720ae510258257cb54c8de64f3d16d12e61bd413ad986f6a6512637eb6a111a97c383f149a67e3febb91497c29cfc36a53df29213800f16d0a8968b582351b4122960922aeeed8ee66c4e66bf83c246b6a7cb9648219bf0dd7479655446e70d82111f7063e0683514cbaf3376021e99a8da70d5b82b70728ea14913172b1cd6e5dc3d07123916da9d9bd4f12b53e9a7dde826c3bddef61aa38383721616b1bdebabdd4ce85e5afb91b660453715bb11cca400432fd5ff829e86d156f0bc79b7a26f29a89d8e46bfdc09364ac6346715f99698fd5d109be7d2bb0bf47151965e09b10ac7cc0aa8044d15e116b2b5d5e0d6fa229285391ba88e4e4a826ab2eb8f7803ae4842f0130ed26b87a734fd888c0a1b52ad06f9a19370af65a6b320b87bdfdf6ea5f7197f32c16e398852c83661970d61a32fb76a07935d0871abd9f1beb1bf31e49fa9ab75909436d2a4eff55e1175bb2661fee807e635fd5c529cde57bce3eddcb5c89b8bb7bae4ff8ea93e6ba8fa09cbdbe99ec0016b294634c2b529a771d65b053f19929b448ccca31f5cd16c3d672739e3d56427d0b6f91b02a0c20ee187e3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>年记 - 2023</title>
    <link href="/2024/01/29/%E5%B9%B4%E8%AE%B0%20-%202023/"/>
    <url>/2024/01/29/%E5%B9%B4%E8%AE%B0%20-%202023/</url>
    
    <content type="html"><![CDATA[<h2 id="2023-年终总结"><a href="#2023-年终总结" class="headerlink" title="2023 年终总结"></a>2023 年终总结</h2><p>刘城君</p><hr><p>省流: 吃力不讨好 (NeurIPS’23 Competition Track: Big-ANN打白工, 连参赛者名字都没) + 一事无成的一年</p><h2 id="NeurIPS’23-Competition-Track-Big-ANN"><a href="#NeurIPS’23-Competition-Track-Big-ANN" class="headerlink" title="NeurIPS’23 Competition Track: Big-ANN"></a>NeurIPS’23 Competition Track: Big-ANN</h2><blockquote><p>7月 - 10月</p></blockquote><p>参与filter赛道的讨论.</p><p>尝试使用NN预测probe (probe内排序lr搜索半径, 簇中簇…).</p><p>编写python-cpp缝合代码 + 找性能损失原因.</p><hr><h2 id="Nebula-k-hop"><a href="#Nebula-k-hop" class="headerlink" title="Nebula k-hop"></a>Nebula k-hop</h2><blockquote><p>7月 - 10月</p></blockquote><p>协助分析async版本的性能损失原因 (断点, 时间统计).</p><hr><h2 id="分布式ANNS"><a href="#分布式ANNS" class="headerlink" title="分布式ANNS"></a>分布式ANNS</h2><blockquote><p>9月 - 11月</p></blockquote><p>NN-based ANNS只在nprobe小有效 &#x3D;&#x3D;&gt; nprobe小的场景 &#x3D;&#x3D;&gt; 分布式.</p><p>尝试使用查询历史优化数据分片 (workload, memory, random).</p><p>老师建议做综述性研究.</p><hr><h2 id="FSM图划分"><a href="#FSM图划分" class="headerlink" title="FSM图划分"></a>FSM图划分</h2><blockquote><p>3月 - 次年1月</p></blockquote><p>3月: 毕业设计 &#x3D;&#x3D;&gt; FSM.</p><p>6 - 7月: 实验完成 + 补充近似率</p><p>7月15日: 完成论文初稿并投稿SIGMOD.</p><p>9 - 10月: SIGMOD拒稿 + 完成VLDB投稿.</p><p>11月: 收到review. 复现, 加入新baseline.</p><p>12月: 加装集群内存, 重跑所有实验.</p><p>现在: 完善文字部分.</p><hr>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2024 01.01-01.07</title>
    <link href="/2024/01/04/%E5%91%A8%E8%AE%B0%20-%202024%2001.01-01.07/"/>
    <url>/2024/01/04/%E5%91%A8%E8%AE%B0%20-%202024%2001.01-01.07/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8dcf1aeb4ae86c6e8a078be6226f61acfe1318c0eed9ccd70fa0ce0091bba7eb">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a7e1dd5c45119deea5b8e43e058f8ad48aee938d2c665b713e72a19ca0d2e83be0f1d371c6fe3a4cc3eda16a9a216771646257165b427496fe4e04c636de88a4fff7cb389ba6bb2f2e6829e79dc0a12adcdf17bd1b41deeac384b36b599796ae95e54c44af67f7aae30893957e1953af7da3f4b3cdea80e8eaeb9c574faf0e78387f44b1870b1a321fa88bc8f3b73db365b6ee954ba0f30f3125c96f7d5a6fcba1718e9b94b42599f59f33e5f4722174eb378a4ef0b6fe33ae85e4372d04fec6c37307437b4ddafc8b10d3fb5ed52b17c1313a29291e87302eb08870651ccfa588f078348213f92dac582de19308a6bbcaff9a51d17371ce73f7ce834b1c181f1c11e814a40fe633ec82ea514656254f3b276e4b058a15a085415f2bc002403c30a1a5560342693fbf68b1caed5c24f2ba0956dc5fa5f2648c5bb5a129c47294b0d8ef16f04e10d8e47ab24aff7b9db8b7550c7fb867e5308db63a2bf4467d299997bee208f5eb2fd92d70e43c77a7f3cad5a80653045326126e918cb78e490da6363a765d09890cf67d78009db36a912e13ce382a471b15c5bf809ef998bda0e9ba94f034a8a6d91a6dc4b73adba3832e818a3f9f3732aa4e31ab6fb5981802b4efb05380e1ac92284d09fa2a44d372af9e2312d89717563b7be7f276904683d67fa2076a3039818027baf42445fa8ccf940cbe8546a730feb2dcaaf9d86b2f35e04feaa81eca97cfee7b07c2e21349989ddf02e1f377e83f011b24c68398a3cd7276dde9f6a9542bd6984b4cec29bebafa6dce674c2734727e2a361718139e7a79683a495539cbe2627f36eb6ad84496207bbe9b64f2c5963c2fb1df152a7397587b8f6d0ca82fb39b58486bd7f44186e8c625322c65f9a2ff931ac59a87c4f143923c35cbb4f13e0a240e27994cd471f1183c37d1cef0cc9a312cf53d10038bb56e7c8466988bbff37595c4c1ccb62b68445e0de39e9d79494bbd3cc0f27c206cd6dd59ed4b91c88f92c165566f020e04b3f6606159e7789eead15427147ad20edccdffc23a7e6a61a147bd84ae388f483d118463093a16dfc8f72dbdb76377bcab8f2c48090b4b1c3b968c2f2c0fc98fa05637f4b1f9f2eb8e676a5863098a35ecfa000158853ed1ac899396876fd8004e55c1e2ef870db8fb4346d1f31f8767b102ce27bb4223a88fa1aaefc59da9a37d76eda135e9dd922872720339d48056da82dedf8b723c6bba2acb80a424ac1d0f1c6b5b6a123ef12ca9fe3b8ace92c960fb06ccf761dfe7a29cea03ef3e03e386031ecfa3ac1170c867567bce583fe7140c3d7558e33549daf865154ea4410d788dfbafae2e97faebdeb862631c6f2d542606f988aaa4c6db5df222b7707b23ae76432d36131c1b490ada60906093cb288cea7b77e0ce0c130c60f08a0a0026d3323ff00944261ec539eee012ddef1400ce9bd8cf5297ab5bcd6c3e70b7e9563f7074a818e1afb972cea4d65c4ee719d3cd22df681763337f07955478c1b055b5f28426d25d20cdbb87d0205285456488c43801644364773ddaa6cb2016140fbd220cd729d30b3831cf2160e5d9687d2bf6b75427839d183f581ee2f95eb40548437d60ac2bf0b8b758aab27a50ed8729910494ba4e84b99c3af5601a230aab33da09ea9a8e35704c19967f40756df42e279f8db5da026815f193293d797ea2664185395407a3afe1a46a434ce49268256fab8b763ed2d71a18c9cb16ac63e855206e4bf9f77194174b03f9af0dc4a629aa15855a31eb93167d6da8941c1203b25494877466b4c17047431624bd39d76036d20bbc8d3326249cca3d81a9843d077ef80606c7ebdd68986a5cf70192c42e4e21255809562b38bc1c99ef992b9b67abb2ae2aa02a45efa5680d98864e5516c902a9a13d91e235cb644c7fefae8ed096f4176b3bcbd191e142ade4d4b1992265c5e3295f1f2c896141f6c0f71655be86e60bd4a99e758ef7f9e9d55993b8147b483673a8365c3f7900f06d8466e6e5fb4c8ed43d2a5df94cbce20e409c28d77ed92a5213a032be0316c1805612864da6f3e70edbcccbf22fc74af42bd266f4d4a306ec4553247cf8e1544b469eff71f88efda00ef7bee48ce38edb1a818fb75e8074cb84b6a7d5427fa2cc29ab30947585646fddb183a832d419f2c8556e560c7720b7969b8cd63a216d90e8e7eecb19c59bc22c3dae2e4bdd2a5bfb553bda52c9dfe32f4ec1203cb56216c11282b7fd7a0a70c3897ccff79a1a25daecefdeb635a0b979341cd4a8fba98ce4ded04477fdcc2ecd98f7219cf665832fe400b2880391af016c1718efb375ed91f3d9afc760a5a9cc5cbeb000283cd8bf9c87e436013db38135cf265b8207db25d6ce30507ac5cc0ee22a2e98b486eff05994c261d5589424a72563b6b25990bd1a6f3fb5f3a9d8072ad036bdf58cb1546a08ce450a1b2d2e354d0300c93b60b352dd8ad099d43e30df3802e8260fa1ae5e67feedf8ab58923d68935533238590d4720993cba35e8c6c7ed6ba0833236a28f6a3a217079752a34597808dda33c0cd03ba9576242cfd16149fd364f52666831bb8cec363c05582e2cd089aa5a1586f6fe0318039fda6d2fcb99f523ba0991cfdf21eeab1a709a245f51fc3d714f268ee549cccf937c5cf7b40a9f519ace284c185c0cc0c181bf54c0eb3b18a6163c6ff93ebf7d239d742b99c5f979939d353aa091aa656ac6e27b6f7714da16fbd1877389277967aa5b3e5e8adc3a6b02c9f0f63aab1a1758326be788a5ebb0884bfc3dda55650bb9b9f180434534e21bf8f7619be0497e5084e6deab02679bc351688720362890e38149af783ecee32fadc11e34efe61a286f5648b3d895f8e4370c59ceeb4cd4038bfcddcf60f328cf19fb74891bf71acde1591971dadabffdcafedd43a26122ff219983e0dae6abb11a0085b85fb09e1d20e519bad6e9f5a8e7b26ab2c431ff0d31984e085e3749d4d00</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - 新机配置DNS</title>
    <link href="/2023/12/02/Linux%20-%20%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AEDNS/"/>
    <url>/2023/12/02/Linux%20-%20%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AEDNS/</url>
    
    <content type="html"><![CDATA[<h2 id="centos系统ping-baidu-com不通"><a href="#centos系统ping-baidu-com不通" class="headerlink" title="centos系统ping baidu.com不通"></a>centos系统ping baidu.com不通</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>首先配置DNS: <code>vi etc/resolv.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Generated by NetworkManager</span><br>nameserver 144.144.144.144<br>nameserver 8.8.8.8<br></code></pre></td></tr></table></figure><p>然后重启网络服务: <code>service network restart</code>.</p><p><code>reboot</code>一下就OK了.</p><h2 id="升级glibc"><a href="#升级glibc" class="headerlink" title="升级glibc"></a>升级glibc</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">configure: error: <br>*** LD_LIBRARY_PATH shouldn&#x27;t contain the current directory when<br>*** building glibc. Please change the environment variable<br>*** and run configure again.<br>[root@slave8 build]# export LD_LIBRARY_PATH=<br></code></pre></td></tr></table></figure><h2 id="yum安装软件失败-yum-lock"><a href="#yum安装软件失败-yum-lock" class="headerlink" title="yum安装软件失败 (yum lock)"></a>yum安装软件失败 (yum lock)</h2><p>错误代码如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install gcc<br>Loaded plugins: fastestmirror, langpacks<br>Existing lock /var/run/yum.pid: another copy is running as pid 44478.<br>Another app is currently holding the yum lock; waiting for it to exit...<br>  The other application is: PackageKit<br>    Memory :  26 M RSS (436 MB VSZ)<br>    Started: Wed Oct 16 18:47:32 2019 - 00:25 ago<br>    State  : Sleeping, pid: 44478<br></code></pre></td></tr></table></figure><p>解决办法:</p><p><code>rm -rf /var/run/yum.pid</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 11.27-12.03</title>
    <link href="/2023/11/30/%E5%91%A8%E8%AE%B0%20-%202023%2011.27-12.03/"/>
    <url>/2023/11/30/%E5%91%A8%E8%AE%B0%20-%202023%2011.27-12.03/</url>
    
    <content type="html"><![CDATA[<h2 id="11-27-周一-晴"><a href="#11-27-周一-晴" class="headerlink" title="11.27 周一 晴"></a>11.27 周一 晴</h2><h2 id="11-28-周二-晴"><a href="#11-28-周二-晴" class="headerlink" title="11.28 周二 晴"></a>11.28 周二 晴</h2><h2 id="11-29-周三-晴"><a href="#11-29-周三-晴" class="headerlink" title="11.29 周三 晴"></a>11.29 周三 晴</h2><h2 id="11-30-周四-晴-晚上冷"><a href="#11-30-周四-晴-晚上冷" class="headerlink" title="11.30 周四 晴, 晚上冷"></a>11.30 周四 晴, 晚上冷</h2><p>今天早上一早收到&lt;电子文献检索&gt;老师发来的邮件: 今天上课会第三次点名, 不要迟到.<br>再加上今天可视化上课还有一个可视化大会, 陈思明老师让我们不要迟到早退缺席. 整个下午都排满了…</p><p>下午满课, 所以中午只能吃很少东西. 第一次试了北食左手第二家店, 点了小笼包和卤鸡蛋. 感觉分量还行, 不会太多.<br>事实上&lt;电子文献检索&gt;并没有进行第三次点到. <code>45*2+10</code>&#x3D;100分钟下来电脑刚好没电.<br>&lt;电子文献检索&gt;一下课, 我就骑车去二教, 在可视化课的后座抢了个有电源的位置.</p><p>&lt;可视化&gt;上了一节课之后WF就说到复旦大学地铁站了. 所以我直接溜出教室, 去正门带他进校了. 跟他骑车绕着邯郸校区骑了一圈, 到光华楼门口草坪</p><blockquote><p>回忆于：2023-11-05 22点<br>BGM: &lt;友人A君を私の伴奏者に任命します&gt; 横山克</p></blockquote><h2 id="12-01-周五-晴"><a href="#12-01-周五-晴" class="headerlink" title="12.01 周五 晴"></a>12.01 周五 晴</h2><h2 id="12-02-周六-晴"><a href="#12-02-周六-晴" class="headerlink" title="12.02 周六 晴"></a>12.02 周六 晴</h2><p>今天约好了和WF一起上海city walk</p><ul><li><input checked="" disabled="" type="checkbox"> 发邮件给NUDT李东升问TopoX的代码</li><li><input checked="" disabled="" type="checkbox"> 继续配置slave8和slave9</li><li><input disabled="" type="checkbox"> 准备12月4号的知识图谱开题报告pre的PPT</li></ul><p>随手记下两个看上去还不错的游戏, 那种rogue风格的, 适合做成独立游戏: </p><ol><li>Tales of Vesper</li><li>Rogue Heroes: Ruins of Tasos</li></ol><blockquote><p>回忆于：2023-11-05 22点<br>BGM: Sincerely 猪仔钢琴</p></blockquote><h2 id="11-05-周日-晴"><a href="#11-05-周日-晴" class="headerlink" title="11.05 周日 晴"></a>11.05 周日 晴</h2><p>早上7点半就起床了, 因为和PZ学弟说好了早上8点半到子彬院1楼交接vldb实验事项.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 11.20-11.26</title>
    <link href="/2023/11/26/%E5%91%A8%E8%AE%B0%20-%202023%2011.20-11.26/"/>
    <url>/2023/11/26/%E5%91%A8%E8%AE%B0%20-%202023%2011.20-11.26/</url>
    
    <content type="html"><![CDATA[<h2 id="11-20-周一-晴"><a href="#11-20-周一-晴" class="headerlink" title="11.20 周一 晴"></a>11.20 周一 晴</h2><p>蔡学长早上跟我说他甲流发烧了, 让我先写一版WWW的review. 哎, zls昨天上午开会才说我可以不用看WWW的论文了, 先搞vldb的rebuttal要紧.<br>现在手头上又多了样活咯. 这篇WWW的论文是关于ood (out-of distribution) anns的, zls说跟陈萌学长的做法非常像.</p><p>事实上手上还是很忙的. 上周四 (11.16)晚上8点vldb的review出结果了. 但是vldb的审稿人要求太多了, 涉及到复现和跑实验的主要是以下4件事:</p><ol><li>复现并对比BPart</li><li>复现并对比MDBGP</li><li>对比Powerlyra (系统, EuroSys2015 best paper)</li><li>对比TopoX (系统, vldb2019)</li></ol><p>不得不提审稿人是真的抽象. vldb2024, 都2024年了, 还让我拿俺的fsm跟15年的Powerlyra比…</p><h2 id="11-21-周二-晴"><a href="#11-21-周二-晴" class="headerlink" title="11.21 周二 晴"></a>11.21 周二 晴</h2><p>一早起来就收到NIPS比赛的邮件</p><p>今天轮到我去讲组会论文了. 这周的组会地点改到了计算中心南501. 下午讲的论文是 BLISS, 一篇关于learning2hash的anns文章.</p><h2 id="11-01-周三-晴"><a href="#11-01-周三-晴" class="headerlink" title="11.01 周三 晴"></a>11.01 周三 晴</h2><p>事实上这几周我都有去江湾上&lt;新中特&gt;. 课上一直在想fsm-hep怎么优化内存.<br>想了下, 发现</p><h2 id="11-02-周四-晴"><a href="#11-02-周四-晴" class="headerlink" title="11.02 周四 晴"></a>11.02 周四 晴</h2><h2 id="11-03-周五-晴"><a href="#11-03-周五-晴" class="headerlink" title="11.03 周五 晴"></a>11.03 周五 晴</h2><h2 id="11-04-周六-晴"><a href="#11-04-周六-晴" class="headerlink" title="11.04 周六 晴"></a>11.04 周六 晴</h2><h2 id="11-05-周日-晴-晚大风"><a href="#11-05-周日-晴-晚大风" class="headerlink" title="11.05 周日 晴, 晚大风"></a>11.05 周日 晴, 晚大风</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：2023-11-05 22点<br>BGM: <code>Nuit Silencieuse</code> By Days</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 10.30-11.05</title>
    <link href="/2023/11/05/%E5%91%A8%E8%AE%B0%20-%202023%2010.09-10.15/"/>
    <url>/2023/11/05/%E5%91%A8%E8%AE%B0%20-%202023%2010.09-10.15/</url>
    
    <content type="html"><![CDATA[<h2 id="10-30-周一-晴"><a href="#10-30-周一-晴" class="headerlink" title="10.30 周一 晴"></a>10.30 周一 晴</h2><p>上周四晚上开完会, zls和蔡学长让我把diskann (图搜暴搜结合)缝进比赛框架… 一直忙到现在. 上周六蔡学长还跑来我宿舍一起缝了.<br>虽说昨天缝好了, 但是却发现python调用cpp之后, qps会有20%左右的折损…</p><p>早上早起去四教上8:55的&lt;高等统计方法&gt;. 晚上睡前彭老师发邮件问我有没有MPC工作中的IEQ代码. 我回复说明天早上看看.</p><h2 id="10-31-周二-晴"><a href="#10-31-周二-晴" class="headerlink" title="10.31 周二 晴"></a>10.31 周二 晴</h2><p>一早起来就登录HNU机器看了看之前的文件夹, 没发现有IEQ相关的 (我自己印象里也没有, 之前都是手动分解查询的hhh). 所以只能回复彭老师说没有.</p><p>中午我和ym和蔡学长他们都在忙活着把faissplus和diskann两个版本的代码交上github. 中午也就躺了10+分钟.</p><p>下午又是组会, 组会我全程都在和蔡学长检查结果. DDL说是说15:00, 可是事实上ym后面还交了几版hhh.<br>得知有人搞出了2w+的qps, 而我们最好也才4~5k的样子. 只能说重在参与hhh.</p><p>搞到这, 这个NIPS比赛算是彻底结束啦.</p><h2 id="11-01-周三-晴"><a href="#11-01-周三-晴" class="headerlink" title="11.01 周三 晴"></a>11.01 周三 晴</h2><p>下午本来没打算去上&lt;新中特&gt;的, 可是想着计划好了在课上能够看完&lt;秒速五厘米&gt;, 就还是去了.<br>结果老师看来上课的人很少, 就说来上课的都可以私信助教, 并且期末会给到相应的照顾. 说来惭愧, 到目前为止我总共就来了4次课, 没想到正好撞上了hhh.<br>尽管如此, 下次课还是不打算去了.</p><p>快到16:30的时候, 蔡学长突然说要开nebula的会. 我直接没去线下</p><h2 id="11-02-周四-晴"><a href="#11-02-周四-晴" class="headerlink" title="11.02 周四 晴"></a>11.02 周四 晴</h2><p>晚上终于没有NIPS比赛的会了, 太舒服了.</p><h2 id="11-03-周五-晴"><a href="#11-03-周五-晴" class="headerlink" title="11.03 周五 晴"></a>11.03 周五 晴</h2><p>今天zls强制我们参加下午蚂蚁TuGraph的讲座. 时间是13:30, 我在路上遇到并认识了跟我同级的专硕 谭玻伟.</p><h2 id="11-04-周六-晴"><a href="#11-04-周六-晴" class="headerlink" title="11.04 周六 晴"></a>11.04 周六 晴</h2><p>早上心血来潮想玩玩&lt;高考恋爱一百天&gt;, 玩了42分钟. 想起之前看到的, 这个galgame的背景是华师一附中.</p><h2 id="11-05-周日-晴-晚大风"><a href="#11-05-周日-晴-晚大风" class="headerlink" title="11.05 周日 晴, 晚大风"></a>11.05 周日 晴, 晚大风</h2><p>下午看了一会</p><p>晚上吃香煎鸡扒饭, 饭后去拿了快递, 又是一箱盼盼小面包, 还不错, 多谢老妈hh. 哎回到宿舍坐一会, 就拉肚子了, 这次好像是脂肪泻. 胃病真TM折磨王.</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - C++踩坑记录</title>
    <link href="/2023/09/05/%E7%AC%94%E8%AE%B0%20-%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/05/%E7%AC%94%E8%AE%B0%20-%20C++%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>(1) 常量指针 (指向常量的指针) 为啥可以delete?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HStackInvertedLists::release_ids</span><span class="hljs-params">(<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">idx_t</span>* ids)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span>[] ids;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p><code>const idx_t* ids</code> 表示 ids 是一个指向常量的指针, ids自己是一个变量, 也就是说, 通过 ids 不能修改所指向的数据, 但可以修改指针本身指向不同的内存地址. 这种声明方式常用于表明函数不会修改通过指针传递的数据. 如果要表示指针本身是常量, 不可以修改指针指向的地址, 应该使用 <code>idx_t* const ids</code>, 这表示 ids 是一个指向 idx_t 类型的常指针, 不能被重新赋值指向其他地址, 但可以通过 ids 修改所指向地址的数据</p><p>delete[] 操作并不直接与变量的 const 修饰符有关, 而是与内存分配方式和所有权相关. 在这段代码中, delete[] 用于释放一个动态分配的数组, 不管变量是否声明为 const.<br>需要注意的是, 虽然函数参数声明为 const 表示函数不会修改传递给它的数据, 但它并不意味着函数不能释放内存. 在这种情况下, 函数只是释放了动态分配内存的所有权, 但并没有修改数据本身. 可以释放任何指针指向的动态分配内存, 不管指针本身是否被声明为 const.</p></blockquote><p>(2) 命名空间和struct 相同点 &amp; 不同点?</p><p>(3) multiset&lt;int&gt; v.s. map&lt;int, int&gt;计数?</p><blockquote><p>1e5数据量下, 用map计数的方式比multiset快.<br><a href="https://codeforces.com/contest/1926/problem/D">D. Vlad and Division</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 09.04-09.10 (FDU上课第一周)</title>
    <link href="/2023/09/04/%E5%91%A8%E8%AE%B0%20-%202023%2009.04-09.10%20(FDU%E4%B8%8A%E8%AF%BE%E7%AC%AC%E4%B8%80%E5%91%A8)/"/>
    <url>/2023/09/04/%E5%91%A8%E8%AE%B0%20-%202023%2009.04-09.10%20(FDU%E4%B8%8A%E8%AF%BE%E7%AC%AC%E4%B8%80%E5%91%A8)/</url>
    
    <content type="html"><![CDATA[<h2 id="09-04-周一-晴"><a href="#09-04-周一-晴" class="headerlink" title="09.04 周一 晴"></a>09.04 周一 晴</h2><p>下午13:30在四教上研究生的第一节课&lt;知识图谱概念与技术&gt;, 教室在106, 来的人很多, 没点名. 在13:20+, 我打开了选课系统和英语免修申请的网站. 惊喜地发现有一门2学分的江湾校区的政治课, 在周三下午6-7节. 芜湖直接起飞, 不用冤大头跑到张江校区上课了. 英语免修申请显示还处于”待审查”. FDU的上课时间不是一般的逆天, 居然在人最困的时候上课, 属实无语了… 前两节课我一直在打哈欠, 一边看nebula一边摸鱼vx聊天. 随手记下了一些问题.</p><ol><li><code>const std::pair&lt;nebula::storage::SchemaID, std::vector&lt;nebula::storage::PropContext&gt;&gt; &amp;ec</code> 中的schemaID和std::vector<a href="nebula::storage::PropContext">nebula::storage::PropContext</a>分别是啥意思.</li><li>spaceID是啥</li></ol><p>16:10下课, 我就去旦苑食堂吃完饭. 路上突然想到: 如果把RF现在的特征之一 – queryraw 换成 query和簇中心的残差会如何呢? 于是就赶紧跟YM说了. 在旦苑食堂二楼吃了番茄鱼, 还不错, 就是有点酸.</p><p>晚上跟YM会议了2小时, 我突然就想到用一种保证radius下界的方法来优化”q在lr范围外”的情况, 按照YM的说法就是截断. 稍微试了试发现效果还不错. 于是YM又提出了针对每个簇都建立一个阈值表和赋值表: 当radius较小的时候, 大概率会出现”q在lr范围外”的情况, 这个时候我们就给这个簇, 这个radius定一个新的radius. 打算明天一天内把这个统计好, 看看效果如何.</p><h2 id="09-05-周二-晴-阴"><a href="#09-05-周二-晴-阴" class="headerlink" title="09.05 周二 晴-&gt;阴"></a>09.05 周二 晴-&gt;阴</h2><p>今天上午都在搞阈值表和赋值表, 但是效果不行. 主要痛点是没法仅根据radius就判断是否属于”q在lr范围外”. 因为”q在lr范围外”基本都属于下面这种情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">radius: refine, cnt<br>1: 10, 200<br>2: 12, 22<br>2: 13, 19<br>...<br>10: 19, 10<br></code></pre></td></tr></table></figure><p>可以发现radius&#x3D;10的时候仍然会出现”q在lr范围外”. 所以采用这种表的话, 时间会增加很多. 同时我还尝试了只往左边搜, 且radius翻倍. 效果也不行. 最后还是发现昨晚我提的”截断”效果最好. 谁知道中午做着做着实验, 208突然就中断连接了.</p><p>下午15:30开第一次大组会. 会上保守有20+同学, 大部分都是专硕, 就没认识几个, 着实难蚌.</p><h2 id="09-06-周三-晴"><a href="#09-06-周三-晴" class="headerlink" title="09.06 周三 晴"></a>09.06 周三 晴</h2><p>上午看了会faiss的源码, 想到目前ivf搜索的瓶颈会不会是在partial_sort部分.</p><p>中午很早就吃了午饭, 回宿舍躺了一会. 12:40出门骑车, 去坐到江湾的校车.</p><h2 id="08-31-周四-晴"><a href="#08-31-周四-晴" class="headerlink" title="08.31 周四 晴"></a>08.31 周四 晴</h2><p>9:30带着六级成绩单, 复印件和学籍表去</p><p>“手绘明信片”: 7天内任何生活中的数据. 画在一张明信片上.</p><p>d3.js &lt;&#x3D; web编程 个人作业</p><p>相对完整的可视化系统</p><h2 id="09-01-周五-晴"><a href="#09-01-周五-晴" class="headerlink" title="09.01 周五 晴"></a>09.01 周五 晴</h2><p>40%: 12-13周期中考试<br>20%: 2周1次作业, 共7次左右<br>40$: 1-2人一组期末PJ</p><p>梯度下降法<br>牛顿法</p><h2 id="09-02-周六-晴"><a href="#09-02-周六-晴" class="headerlink" title="09.02 周六 晴"></a>09.02 周六 晴</h2><h2 id="09-03-周日-雨"><a href="#09-03-周日-雨" class="headerlink" title="09.03 周日 雨"></a>09.03 周日 雨</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：2023-07-24 00点<br>BGM: &lt;Grand Escape 天気の子&gt; By Animenz</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 08.26-09.03 (FDU入学第一周)</title>
    <link href="/2023/09/01/%E5%91%A8%E8%AE%B0%20-%202023%2008.26-09.03%20(FDU%E5%85%A5%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%91%A8)/"/>
    <url>/2023/09/01/%E5%91%A8%E8%AE%B0%20-%202023%2008.26-09.03%20(FDU%E5%85%A5%E5%AD%A6%E7%AC%AC%E4%B8%80%E5%91%A8)/</url>
    
    <content type="html"><![CDATA[<h2 id="08-26-周六-晴"><a href="#08-26-周六-晴" class="headerlink" title="08.26 周六 晴"></a>08.26 周六 晴</h2><p>6点左右就起来了, 要赶去广州南坐8点的高铁. 在高铁上硬是坐了7个小时. 广州南 -&gt; 郴州西 -&gt; 长沙南 -&gt; 南昌西 -&gt; 杭州东 -&gt; 上海虹桥. 到长沙南的时候, 心里有种同途殊归的感觉. 上一次经过这里的时候已经下车了, 而这次要多坐一倍多的车程. 下午2点50左右上的高铁. 到复旦校门口已经快4点了. 我拖着大行李箱和床垫, 硬是从复旦大学B出口一路走到了正门. 然后又在园区里瞎打乱撞, 看到子彬院了, 结果绕了一整圈没发现怎样进去报道.</p><p>晚上去门口那个生活超市买了拖鞋, 回到宿舍跟蔡yz学长碰了个面. 蔡yz学长说要请咱三位新生吃个饭.</p><h2 id="08-27-周日-雨"><a href="#08-27-周日-雨" class="headerlink" title="08.27 周日 雨"></a>08.27 周日 雨</h2><p>今天一早起来就发现收到了”202307投稿”群的消息, 说是review结果出来了. 一看老师消息: “也要认真写. 还有希望”, 我就蚌埠住了. 郑老师让我们先把review的回复整理成表格. 晚上拉YJ, 蔡yz, 杨by学长开了个会. 结果从18:30一直讨论到了快10点.</p><h2 id="08-28-周一-雨"><a href="#08-28-周一-雨" class="headerlink" title="08.28 周一 雨"></a>08.28 周一 雨</h2><p>昨晚因为讨论review开会的时候错过了第二批体检 (13:00)的预约, 又不想下周开学了再去体检, 所以只能约了早八的体检. 跟非哥去北区食堂吃了早餐直接骑车到校医院. 到校医院8点不到, 但是队已经占了篮球场长的一半. 等我到门口的时候, 才发现电子校园卡不可以用来刷. 又</p><h2 id="08-29-周二-雨"><a href="#08-29-周二-雨" class="headerlink" title="08.29 周二 雨"></a>08.29 周二 雨</h2><h2 id="08-30-周三-雨"><a href="#08-30-周三-雨" class="headerlink" title="08.30 周三 雨"></a>08.30 周三 雨</h2><p>已经连续下了4天雨了. 早上出门第一件事就是赶紧趁雨还不大, 赶紧去玻璃房把洞洞鞋拿了</p><h2 id="08-31-周四-雨"><a href="#08-31-周四-雨" class="headerlink" title="08.31 周四 雨"></a>08.31 周四 雨</h2><p>郑老师在nebula双周会前, 还让我们在16点先过一遍明天汇报的内容. 16点到了子彬院301结果老师16点半才到. 讨论了一堆, 结果问到我明天有没有可以说的, 我这几周先是在忙ANNS综述+LR预测的工作, 然后这一周每天都在找老师开会弄review. 根本没时间弄啊.</p><p>下会之后蔡yz学长请我和YT, YJ还有phd之一的ZJ学长吃饭. 我们到五角场那边的一家名叫”港丽”的饭店吃了一顿.</p><h2 id="09-01-周五-晴"><a href="#09-01-周五-晴" class="headerlink" title="09.01 周五 晴"></a>09.01 周五 晴</h2><p>早上8:30起来, 跟非哥去光华楼草坪参加开学典礼. 在光华楼草坪后面站了十来分钟就结束了. 结束后在后面的座位上拿了一个装着黑色帽子的物资袋, 就跟蔡yz, YJ, YT, 杨by他们一起去开nebula横向的会了. 会议我经典全程装傻, 只顾着自己. 会后我们几个一起在北食吃了午餐.</p><h2 id="09-02-周六-晴"><a href="#09-02-周六-晴" class="headerlink" title="09.02 周六 晴"></a>09.02 周六 晴</h2><p>整个上午基本都在闲鱼找电钢.</p><p>下午看了会nebula. 老师想下午4点开会, 但是郑学长没空, 改到了明早9:30.</p><h2 id="09-03-周日-雨"><a href="#09-03-周日-雨" class="headerlink" title="09.03 周日 雨"></a>09.03 周日 雨</h2><p>早上9:30要去老师办公室开横向的会, 讨论下异步loop细粒度化的具体实现, 13点才吃上饭.</p><p>下午3点从邯郸校区坐校车去江湾校区找IORI. 在车上突然就下起雨来了, 还好我穿的洞洞鞋出门, 全程基本0损失. IORI带着我绕着江湾走了一圈</p><h2 id="附注-至导师的一封信"><a href="#附注-至导师的一封信" class="headerlink" title="附注 至导师的一封信"></a>附注 至导师的一封信</h2><p>尊敬的[导师的名字],</p><p>我对于当前ANNS的研究课题和比赛非常感兴趣, 但是目前我正面临一些困难, 我觉得有必要与您分享.</p><p>首先, 在开学以来我一直在致力于实现图数据库nebula的k-hop邻居异步实现项目. 这是一个极具难度的工程项目, 我在这方面的经验和知识为零, 而且目前的进展并不理想. 虽然我已将目前的ANNS比赛和研究进度暂停, 来全身心投入k-hop, 但要实现这个项目可能需要比我目前所具备的时间和技能更多的资源.</p><p>其次, 我当前正承担较重的课业负担. 我是计算机科学专业出身, 因此在统计学类专业课程上学得较为吃力. 这让我感到非常紧张, 因为我希望能尽力学好这些课程, 需要投入大量的时间和精力来学习和准备.</p><p>此外, 我还在同时推进NIPS ANNS竞赛的参赛项目, 以及我们的learning-based IVF ANNS研究项目. 这也需要我和学弟投入大量的时间和精力. 我深知这些项目对我的学术发展非常重要, 但我感到自己的精力和时间资源有限.</p><p>最后, 我还需要处理上一篇投稿的FSM论文. 由于FSM的代码、论文和实验等都是我最熟悉的方面, 因此可能只能由我投入时间来修改或添加实验, 以将其转投到其他会议.</p><p>此外, 我不得不坦白地告诉您, 我近期的健康状况也不容乐观, 我的入学体检的BMI仅为17（180cm&#x2F;56kg）, 我已经被严重的胃病困扰. 这让我感到非常虚弱, 影响了我的日常生活和学术工作.</p><p>鉴于这一系列因素, 我感到我现在的精力和时间已经无法满足所有任务的要求, 这对我的健康和学术表现都构成了威胁. 因此, 我认为我需要休学或退学, 以便能够更好地管理自己的健康问题, 并专注于克服目前面临的学术挑战.</p><p>我深感抱歉, 因为我非常感激您这一年多以来对我的指导和支持. 如果可能的话, 我愿意在适当的时候与您坐下来, 详细讨论我过往的身体情况和决定, 并寻找合适的解决方案.</p><p>再次感谢您的理解和支持, 我希望您能明白这个决定对我来说是非常困难的. 我很喜欢这所学校, 很享受目前ANNS的研究课题, 也很享受和老师同学们一起交流学术上的难题. 但我仍需将我的健康和未来置为首位.</p><p>诚挚的问候,  [您的姓名]</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：2023-07-24 00点<br>BGM: unravel By Animenz</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 07.17-07.23</title>
    <link href="/2023/07/24/%E5%91%A8%E8%AE%B0%20-%202023%2007.17-07.23/"/>
    <url>/2023/07/24/%E5%91%A8%E8%AE%B0%20-%202023%2007.17-07.23/</url>
    
    <content type="html"><![CDATA[<h2 id="07-21-周五-晴"><a href="#07-21-周五-晴" class="headerlink" title="07.21 周五 晴"></a>07.21 周五 晴</h2><p>午睡一睡醒, 打开微信发现老师发来消息, 让我去参加华为的例会. 真的难顶, 哎只能硬着头皮听几个小时, 到最后老师说异步任务的学长效率太低, 让我”深度参与”, 还让我跟杨m学弟一起, 裂开了. 下午我和杨m打了个电话, 说明了大致情况, 同一了咱的意见, 大致就是科研和比赛优先. (写到这我觉得把博客加上一个上锁功能…)</p><p>晚上10点半我和ly去天台聊了聊, 先用英文沟通了一会, 发现oral确实是大问题. 我说我打算考雅思, 有出国的打算. 并且表明我会尝试跟老师说明情况, 表明自己科研比赛优先的立场, 最后我才去找窦教授开R-CPD的证明, 来说明我身体确实不行. 我从ly那里了解到LLM现在已经非常出圈了, 哎我也想搞LLM可是这些东西感觉都是需要一定的算力支持. 老师让我选下一个研究的课题, 我也不知道该选啥. 其实我个人是想搞推荐算法, 可是gjw学长却说这东西只能在工业界搞.</p><h2 id="07-22-周六-晴"><a href="#07-22-周六-晴" class="headerlink" title="07.22 周六 晴"></a>07.22 周六 晴</h2><p>早上全家都去南方三院检查幽门螺杆菌, 医生说老妹不需要检查. 检查的结果是全部阴性.</p><h2 id="07-23-周日-晴"><a href="#07-23-周日-晴" class="headerlink" title="07.23 周日 晴"></a>07.23 周日 晴</h2><p>上午练(摸)琴. 因为非常想弹出”路标”, 虽然看上去不是太难, 但是由于是A大调, 指法完全不会. 我想到这种指法编排可能又是某种最优化问题, 应该会有一些算法. 于是在github上找了找<code>piano fingering</code>, 找到了一个600+人star的repository. 结果它的输入要求是.midi文件. 又只好搜了这个格式, 找到一个叫<code>MuseScore</code>的软件, 发现虽然可以免费写谱, 但是网站上的谱子又要vip. 于是在github上找了一个免费下midi的软件. 所以整个流程是: MuseScore下谱子 -&gt; MuseScore把midi转成xml格式 -&gt; fingering指法编排 -&gt; MuseScore把xml转成midi格式. 拿了&lt;路标&gt;和&lt;私の嘘&gt;试了试, 虽然看上去有模有样, 每个和弦都有标注指法, 可是弹了私の嘘, 发现不是很顺手. 哎, 不是很靠谱.</p><p>下午3点到5点一直在对照着github的一个repository来实现FENNEL图划分算法. 发现那位作者是来自印度的一个大学, 看上去<strong>也是打acm的, 结果他最后去了google.</strong> 羡慕ing. 打acm归acm, 可是我看他的FENNEL代码也完全是纯纯的acm风格, 这就有点不妥了, 最离谱的是他的邻接表居然是<code>vector&lt;set&gt;</code>. 并且我看他的评估函数看了半天也没看懂, 最后还是在知乎上看到有人发的伪代码才达到效果.</p><p>晚上看了&lt;紫罗兰永恒花园 外传 永远与自动手记人偶&gt;. 是一个合理且略带遗憾的ending: 泰勒和艾米最后也没能重逢.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：2023-07-24 00点<br>BGM: &lt;我的青春恋爱物语果然有问题. 续&gt; ED Everyday World</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事记 - 在HNU的最后3天 (2023 06.14-06.16)</title>
    <link href="/2023/06/16/%E4%BA%8B%E8%AE%B0%20-%20%E5%9C%A8HNU%E7%9A%84%E6%9C%80%E5%90%8E3%E5%A4%A9%20(2023%2006.14-06.16)/"/>
    <url>/2023/06/16/%E4%BA%8B%E8%AE%B0%20-%20%E5%9C%A8HNU%E7%9A%84%E6%9C%80%E5%90%8E3%E5%A4%A9%20(2023%2006.14-06.16)/</url>
    
    <content type="html"><![CDATA[<h2 id="06-14-周三"><a href="#06-14-周三" class="headerlink" title="06.14 周三"></a>06.14 周三</h2><p>今天主要是早上八点左右到院楼门口拍年级集体毕业照. 得知颜ZH签约了深圳某银行, 年包20w左右. 感觉也不错了, 本科生也能20w, 我坐牢三年刑满释放, 还不一定能到呢 (bushi</p><h2 id="06-15-周四-小雨"><a href="#06-15-周四-小雨" class="headerlink" title="06.15 周四 小雨"></a>06.15 周四 小雨</h2><p>晚上跟jimmy去五一那边吃”在湖大最后的晚餐”, 事实上明晚还有一餐hhh. 可惜zzm得跟他家人一起聚餐, 不能一起来. zzm送我俩走到后湖阜埠河地铁站, 他就去跟他家人聚餐了. 我和jmy选了亚马逊, 其实也就是&lt;云计算技术&gt;这门课最后果哥请我, wf, 林st和武xy聚餐的地方. 在地铁出站时遇到了雷yl和陈sy, 刚想说巧, 谁知在亚马逊又遇到她们了. 这次来主要就吃了4-5杯冰淇淋, 巧克力, 荔枝, 芒果味. 人均150左右, 吃的很饱.</p><p>饭后我和jimmy在五一广场兜了个圈, 开始想去地下商城, 谁知几个入口都被堵死了, 只好作罢. 随后我提出走到湘江边上, 沿着大方向一直走, 路过了太平街. 这我才想起在开学第一天晚上我和老爸就来过, 行程与4年前形成了”首尾呼应”. 走到江边发现找不到地下隧道之类的到江岸, 又只好作罢. 最后我们走到万达广场, 从就近的地铁站回了宿舍.</p><h2 id="06-16-周五-毕业典礼-学位授予-小雨"><a href="#06-16-周五-毕业典礼-学位授予-小雨" class="headerlink" title="06.16 周五 (毕业典礼 &amp; 学位授予) 小雨"></a>06.16 周五 (毕业典礼 &amp; 学位授予) 小雨</h2><p>今天就是毕业典礼了, 也是在HNU的最后一天了. 早上六点多就起了床, 跟jmy和zzm俩一起坐地铁去, 咱穿的文化衫都是蓝色, 不过信息院的文化衫似乎质感有些差, 电气院的是棉的hhh. 毕业典礼上我和刘hp坐在一块, 才知道电气院已经有大佬发了CVPR, 是真的猛. 听毕业典礼的时候下了小雨, 不过座位上有雨衣所以问题不大. 典礼结束之后去大礼堂参加学位授予仪式, 路上遇到了zwling, 以后的stronghold in Beijing, hhh. 寒暄了几句便开始排队了. 授予仪式的时候我忘记向老师鞠躬了, 难顶. 学院的毕业礼物是一个学院形状的的箔片和一块鼠标垫. emmm…</p><p>学位授予弄完之后我就和8班一起拍了集体毕业照, 就在岳麓书院门口和大礼堂门口拍了几张. zzm和jmy等着我和他们一起拍毕业照, 可是这边的学位授予搞了太久, 还是没能一起拍成. 之后就和wf, 吴老师和夏老师4个一起在红楼门口, 信息院门口拍了几张.</p><p>中午回到宿舍睡了一下, 一睡就睡了好久, 以至于我赶过去院楼领双证的时候, wdy都已经快回到宿舍了. 这也是我最后一次来院楼了, 当我在院楼门口的升学去向和优秀毕设展板上看到自己的名字的时候, 一种自豪感油然而生, 这4年的光阴也算是没有虚度啊. 领完双证, 我就在彭老师开组会的教室门口等了大概40分钟. 跟彭老师和同门们一起在院楼2楼和院楼门口拍了毕业照. 一想到将来可能就基本没有机会见面了, 自然是难受. 彭老师说以后肯定会去上海, 我这才好受些.</p><p>在湖大吃的最后一餐, 我选择了师生缘二楼大碗饭的土豆牛肉, 并且没有打包带回宿舍. 四年前的情景仍历历在目: 到湖大的第一餐, 就是这个位置, 这道土豆牛肉 (可恶当时没有拍照, 到FDU的第一餐一定要拍照留念!). 这四年时间里, 食堂窗口换了又换, 幸运的是这家大碗饭还在. 真的很喜欢这种感觉. 四年时间画了一个华丽的圆, 最后笔尖落回原点.</p><p>回到宿舍, 收拾剩下的床单被褥, 才发现根本无法随身带, 这时下起了小雨. 我冒着雨狂奔着把东西抗下楼, 赶着最后一批顺丰寄回家. 临近出发, 我和舍友穿着学士服在我床前拍了几张照片. zzm和jmy送我到一楼大厅, 临走前还是没忍住泪如雨下.</p><p>此去经年, 顶峰相见!</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>TO HNU</p><blockquote><p>虽然你和我想象中有些不同，更加喧嚣，浮躁，甚至治安差，成天在施工。似乎是欲扬先抑的标准开头，但确实是这样呢。<br>故事的开始，我由于疾病不顾考核翘晚自习，报复式地在疫情期间玩了数千小时的游戏。直到转专业通知下发，那时我便知道，我…得开始奔跑起来了。<br>为了不将遗憾带随我毕业，我不顾他人眼光，做了很多事情。拿着刚及格的高数成绩去转专业，经常地翘课去各大医院求医做检查，从弹力带到负重的引体向上；重新捡起大一时敬畏的算法竞赛，忍受着寂寞在暑假留校训练，无头苍蝇一般尝试着各种疯狂idea并测试效果…<br>将要跑到终点时，这些场景真的像走马灯一样：期末周和同学在研讨空间的争分夺秒，申请加入课题组时的紧张和期待，“高数一百”成立那晚的树下会议，跟舍友赶早八的3人电瓶车，一个也没能完成的“510大四计划”，看鬼灭之刃时在舍友面前中二地重复各种呼吸的名字，总是停留在理论却从未实践的发型与穿搭；和发小在后湖夜谈喝下了第一口酒……<br>好生气，没能找回研楼弄丢的耳机和综楼被偷的自行车；<br>好满足，你的每个角落我大概都逛了个遍了吧；<br>好遗憾，四年里没能欣赏到湘江的烟花，也没能遇到她；<br>好惭愧，起初我总是抱怨着你的种种不好；<br>好开心，我遇到了510的三位兄弟，好幸运，能加入到心仪的课题组和优秀的老师同学们讨论，好给力，我结识了两位实力强劲的队友；好荣幸，能和大佬们一起在考前突击…..果然，是你真的太好了。我相信几十年后的我重温这段时光，他会自豪地说:跟你度过的这4年没有遗憾。</p><p>2023.06.16 长沙-&gt;广州</p></blockquote><p>回忆于：07.22日15点30分<br>BGM: <code>みちしるべ-路标</code> 紫罗兰永恒花园TV ED</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - NFS的使用</title>
    <link href="/2023/06/06/Linux%20-%20NFS%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/06/Linux%20-%20NFS%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="应用情景"><a href="#应用情景" class="headerlink" title="应用情景"></a>应用情景</h2><p>我的graph partitioning工作的最后环节需要用到集群, 8台机器命名为slave0~7.<br>其中slave0作为master节点, 由于slave0的磁盘只有1T. 因此需要利用另外几台slave的磁盘.<br>一个比较好的办法就是用NFS把slave3的dataset目录挂载到slave0对应的dataset3上.</p><h2 id="服务端-slave3"><a href="#服务端-slave3" class="headerlink" title="服务端 (slave3)"></a>服务端 (slave3)</h2><p>安装 NFS 服务器:</p><p>centos: <code>yum install nfs-utils</code><br>ubuntu: <code>apt install nfs-kernel-server</code></p><p><code>mkdir -p /home/lcj_graph_partitioning/dataset/</code>.<br>其中<code>-p</code>表示创建目录时, 如果父级目录不存在, 则会自动创建父级目录.<br>如果目录已经存在, 则不会报错, 也不会覆盖已存在的目录.</p><p>打开 <code>/etc/exports</code>, 并加入下面1行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/home/lcj_graph_partitioning/dataset/ slave0(rw,sync,no_root_squash) slave3(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p>启动nfs服务 <code>sudo systemctl restart nfs-server</code></p><p>重新加载 NFS 服务器配置: <code>sudo exportfs -a</code></p><h2 id="客户端-slave0"><a href="#客户端-slave0" class="headerlink" title="客户端 (slave0)"></a>客户端 (slave0)</h2><p>把slave3的dataset挂载到slave0的dataset3上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount -t nfs slave3:/home/lcj_graph_partitioning/dataset/ /home/lcj_graph_partitioning/dataset3/<br></code></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>(1) slave3挂载到slave0后, slave0的磁盘会不会被占用?</p><blockquote><p>当你在 slave0 上将 slave3 的目录挂载到本地后, slave0 上会出现一个新的目录, 其中包含了 slave3 上的文件.<br>这并不会占用 slave0 硬盘的额外空间, 因为实际的文件数据仍然存储在 slave3 上.<br>换句话说, 挂载后的目录是一个虚拟的视图, 它显示了远程主机上的文件系统, 但实际数据并没有复制到本地磁盘上.<br>如果你在 slave0 上进行读取或写入操作, 实际上是通过网络访问 slave3 上的文件.<br>这也是 NFS （Network File System）的基本原理之一, 它允许你在网络上共享文件系统, 使得远程主机可以像访问本地文件系统一样访问远程文件系统.</p></blockquote><p>(2) 客户端mount -t nfs master:&#x2F;… &#x2F;…后报错:<br>   mount.nfs: access denied by server while mounting master:&#x2F;dk&#x2F;lcj_graph_partitioning&#x2F;dataset&#x2F;</p><blockquote><p><code>code /var/log/syslog</code> 查看服务端的日志. 发现<code>refused mount request from 10.28.2.138 for /dk/lcj_graph_partitioning/dataset/ (/): not exported</code>.<br>即服务端没有导出该目录. 发现服务端要导出的路径名输错了…<br>其实是<code>/dk/lcj_graph_partition/dataset/</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>Cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2023/04/06/%E7%AC%94%E8%AE%B0%20-%20Docker/"/>
    <url>/2023/04/06/%E7%AC%94%E8%AE%B0%20-%20Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="报错-Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running"><a href="#报错-Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running" class="headerlink" title="报错: Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?"></a>报错: Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</h2><p>(1) 关闭docker<br>(2) 启动docker daemon<br>(3) 验证docker是否激活</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service docker stop<br>systemctl start docker<br>systemctl status docker<br></code></pre></td></tr></table></figure><h2 id="坑点-Docker-执行entrypoint-sh后自行exit"><a href="#坑点-Docker-执行entrypoint-sh后自行exit" class="headerlink" title="坑点: Docker 执行entrypoint.sh后自行exit"></a>坑点: Docker 执行entrypoint.sh后自行exit</h2><p>Docker不是虚拟机, 容器中的应用都应该以前台执行, 而不是像虚拟机、物理机里面那样, 用 systemd 去启动后台服务, 容器内没有后台服务的概念.</p><p>我在dockerfile里</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> entrypoint.sh /sbin</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> 777 /sbin/entrypoint.sh</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/sbin/entrypoint.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>其中entrypoint.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>service ssh start<br></code></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了. 这就是因为没有搞明白前台, 后台的概念, 没有区分容器和虚拟机的差异, 依旧在以传统虚拟机的角度去理解容器.</p><p>对于容器而言, 其启动程序就是容器应用进程, 容器就是为了主进程而存在的, 主进程退出, 容器就失去了存在的意义, 从而退出, 其它辅助进程不是它需要关心的东西.</p><p>通过上面的介绍, 我们应该知道上面那个问题的原因了, 一句话：在Docker daemon模式下, 无论是使用ENTRYPOINT, 还是CMD, 最后的命令, 一定要<strong>使当前进程也就是容器的主进程一直运行下去</strong>, 这样才能够防容器退出, 否则主进程退出了, 容器就没有意义了, 就会跟着退出.</p><p>下面一些也是无效的启动方式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/local/tomcat.sh&quot;</span>,<span class="hljs-string">&quot;start&quot;</span>] </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/local/tomcat.sh&quot;</span>] </span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;start&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>下面这样写才有效, 但是前提是容器的环境中要有sshd这个终端服务器命令.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment">##SSH终端服务器作为后台运行 </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> /usr/local/tomcat.sh start &amp;&amp; /usr/sbin/sshd -D</span><br></code></pre></td></tr></table></figure><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>将当前用户添加到docker用户组<br>为了避免每次使用docker命令都需要加上sudo权限, 可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：</p><p><code>sudo usermod -aG docker $USER</code><br>执行完此操作后, 需要退出服务器, 再重新登录回来, 才可以省去sudo权限.</p><p>镜像（images）</p><p><code>docker pull ubuntu:20.04</code>: 拉取一个镜像</p><p><code>docker images</code>: 列出本地所有镜像</p><p><code>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04</code>: 删除镜像ubuntu:20.04</p><p><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>: 创建某个container的镜像</p><p><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>: 将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中</p><p><code>docker load -i ubuntu_20_04.tar</code>: 将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来<br>容器(container)</p><p><code>docker [container] create -it ubuntu:20.04</code>: 利用镜像ubuntu:20.04创建一个容器.</p><p><code>docker ps -a</code>: 查看本地的所有容器</p><p><code>docker [container] start CONTAINER</code>: 启动容器</p><p><code>docker [container] stop CONTAINER</code>: 停止容器</p><p><code>docker [container] restart CONTAINER</code>: 重启容器</p><p><code>docker [contaienr] run -itd ubuntu:20.04</code>: 创建并启动一个容器</p><p><code>docker [container] attach CONTAINER</code>: 进入容器<br>先按Ctrl-p, 再按Ctrl-q可以挂起容器</p><p><code>docker [container] exec CONTAINER COMMAND</code>: 在容器中执行命令</p><p><code>docker [container] rm CONTAINER</code>: 删除容器</p><p><code>docker container prune</code>: 删除所有已停止的容器</p><p><code>docker export -o xxx.tar CONTAINER</code>: 将容器CONTAINER导出到本地文件xxx.tar中</p><p><code>docker import xxx.tar image_name:tag</code>: 将本地文件xxx.tar导入成镜像, 并将镜像命名为image_name:tag</p><p><code>docker export/import</code>与<code>docker save/load</code>的区别:</p><p>export&#x2F;import会丢弃历史记录和元数据信息, 仅保存容器当时的快照状态<br>save&#x2F;load会保存完整记录, 体积更大</p><p><code>docker top CONTAINER</code>: 查看某个容器内的所有进程</p><p><code>docker stats</code>: 查看所有容器的统计信息, 包括CPU、内存、存储、网络等信息</p><p><code>docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx</code>: 在本地和容器间复制文件</p><p><code>docker rename CONTAINER1 CONTAINER2</code>: 重命名容器</p><p><code>docker update CONTAINER --memory 500MB</code>: 修改容器限制</p><p>实战</p><p>进入AC Terminal, 然后：</p><p>scp &#x2F;var&#x2F;lib&#x2F;acwing&#x2F;docker&#x2F;images&#x2F;docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器<br>ssh server_name  # 登录自己的云端服务器</p><p>docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地<br>docker run -p 20000:22 –name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像</p><p>docker attach my_docker_server  # 进入创建的docker容器<br>passwd  # 设置root密码</p><p>去云平台控制台中修改安全组配置, 放行端口20000.</p><p>返回AC Terminal, 即可通过ssh登录自己的docker容器：</p><p>ssh <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#64;&#120;&#120;&#x78;&#46;&#x78;&#120;&#x78;&#46;&#120;&#120;&#x78;&#46;&#120;&#x78;&#x78;">&#114;&#x6f;&#x6f;&#x74;&#64;&#120;&#120;&#x78;&#46;&#x78;&#120;&#x78;&#46;&#120;&#120;&#x78;&#46;&#120;&#x78;&#x78;</a> -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址<br>然后, 可以仿照上节课内容, 创建工作账户acs.</p><p>最后, 可以参考4. ssh——ssh登录配置docker容器的别名和免密登录.</p><p>小Tips</p><p>如果apt-get下载软件速度较慢, 可以参考清华大学开源软件镜像站中的内容, 修改软件源.</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 04.03-04.09</title>
    <link href="/2023/04/03/%E5%91%A8%E8%AE%B0%20-%202023%2004.03-04.09/"/>
    <url>/2023/04/03/%E5%91%A8%E8%AE%B0%20-%202023%2004.03-04.09/</url>
    
    <content type="html"><![CDATA[<h2 id="04-03-周一-阴-暴雨"><a href="#04-03-周一-阴-暴雨" class="headerlink" title="04.03 周一 阴-&gt;暴雨"></a>04.03 周一 阴-&gt;暴雨</h2><p>下午心血来潮, 又打开了cf, 随便找了道R1300的题做. 想了挺久, 可能写完加起来得有1h了. 然后又找了道R1500的构造题, 没想到直接红温了hhh, 干到下午5点多要吃饭了还是WA2, 直接拍屁股走人了.</p><p>晚上想试下用python的库来画出webgraph官网上的那种degree-frequency图(xy轴分别都取了log10对数). 然后就想起了数模摸鱼期间用的jupyter ipynotebook, 于是就在郑老师的服务器上创了个.ipynb文件, 发现连接不上内核… 寄! 明天再说8.</p><h2 id="04-04-周二-雨"><a href="#04-04-周二-雨" class="headerlink" title="04.04 周二 雨"></a>04.04 周二 雨</h2><p>早上8点半不到就起床了, 因为跟老师约好了讨论.</p><p>下午睡醒就着手于寻找最相关的因素, 首先先排除了”高度数点平均度数 与 平均度数之间的倍数”.</p><h2 id="04-05-周三-雨"><a href="#04-05-周三-雨" class="headerlink" title="04.05 周三 雨"></a>04.05 周三 雨</h2><h2 id="04-06-周四-雨"><a href="#04-06-周四-雨" class="headerlink" title="04.06 周四 雨"></a>04.06 周四 雨</h2><h2 id="04-07-周五-晴"><a href="#04-07-周五-晴" class="headerlink" title="04.07 周五 晴"></a>04.07 周五 晴</h2><p>难得出太阳, 宿舍连廊也有挺多人开始晒被子了. 气温也挺合适, 感觉今天很适合出行呢. </p><p>下午睡醒, 就和Jimmy一起去橘子洲on foot. 仍记得上学期期末那会, 我和zzm直接从五一广场步行回来, 沿途欣赏了湘江的夜景, 走过了1000多米的橘子洲大桥, 再一路走回天马. 所以这次也想着步行, 可是走到橘子洲, 才发现已经没啥力气再走到主席像那了.</p><h2 id="04-08-周六-晴"><a href="#04-08-周六-晴" class="headerlink" title="04.08 周六 晴"></a>04.08 周六 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：03.29日22点30分 &amp;&amp; 03.30日晚22点30分<br>BGM: &lt;四月是你的谎言&gt; OP &amp;&amp; ED &amp;&amp; OST</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 03.27-04.02</title>
    <link href="/2023/03/29/%E5%91%A8%E8%AE%B0%20-%202023%2003.27-04.02/"/>
    <url>/2023/03/29/%E5%91%A8%E8%AE%B0%20-%202023%2003.27-04.02/</url>
    
    <content type="html"><![CDATA[<h2 id="03-27-周一-小雨"><a href="#03-27-周一-小雨" class="headerlink" title="03.27 周一 小雨"></a>03.27 周一 小雨</h2><p>早上10点和郑老师讨论了下进度, 主要就是我目前的实验都是在爪机的WSL2上跑的小数据集, 最大也只能到orkut这种; 另外就是我简要汇报了下上周调研的路径规划的俩算法CCH和CRP, 然后4.9之前要写完个计划书之类的.</p><p>开完会我在昨天向蔡YZ学长要的服务器上, 装了boost, gflags和glog.</p><p>然后下午我又开摆了, 下午搜了下研究性实习的相关岗位.</p><p>晚上也摆, 看OIerDB看得津津有味. 睡前又稍稍看了看近期的CP比赛, 但是又不想思考, 做不动题, 颓废的一…</p><h2 id="03-28-周二-小雨"><a href="#03-28-周二-小雨" class="headerlink" title="03.28 周二 小雨"></a>03.28 周二 小雨</h2><p>主要任务还是毕设, 其实就是把之前写挫了的算法改改.</p><blockquote><p>把选块顺序从p-1, p-2…0, 改成了0, 1, 2…p-1. 这样有个好处就是最后double_expand的时候可以直接从FLAGS_p往后添加块了.</p></blockquote><p>然后写着写着突然想看看学学Effective C++和Effective STL了. 于是去网上瞎逛, 又浪费了一个上午…</p><h2 id="03-29-周三-阴"><a href="#03-29-周三-阴" class="headerlink" title="03.29 周三 阴"></a>03.29 周三 阴</h2><p>今天一整天基本都在搞毕设. 忙活一整天下来, 总结一下就是搞了以下几个东西:</p><ol><li>追踪了每条边的分配, one of 正确性验证</li><li>加入了边平衡性的检查, one of 正确性验证</li><li>加入了合并时分区间是否有交集的检查, one of 正确性验证</li></ol><p>然而等全部写完, 并且收集完实验数据之后, 才发现边平衡性原来出了问题… 想了想, 哦, 原来合并的时候只能俩俩合并, 不能说有些桶里只有一个块, 有些桶三个块, 感觉上是真的寄了啊. 于是赶紧把代码注释掉一行, 重新跑了全部实验. 好在效果差的不太多, 该差的还是很差hhh.</p><p>今天吃饭的时候都看了<code>Charlotte</code>, 看到有宇的妹妹因为被小混混威胁 + 自身崩坏的能力挂了, 有宇就直接黑化一蹶不振. 最后被奈绪救回来. 奈绪带男主去听演唱会, 男主突然找到缺失的一部分记忆. 从此决定去找找哥哥隼</p><p>晚上实在是想摆了, 但是啥都不想看, 啥都不想玩. 只能打开<code>Limbo</code>来刷刷全成就, 对着B站的攻略刷了半个小时, 刷完隐藏关卡之后才发现成就进度11&#x2F;13. 点进去未完成成就, 竟然有个成就是5条命内通关全部, 完成的人只有0.1%. 果断把游戏给卸了hh.</p><p>到10点多, 我又开始对着实验结果发愁, 光按照这个指标来说, 我感觉在实际任务上超过NE和HEP的几率不是很大… 仔细想了想我又觉得点平衡性参数里更加重要的是max &#x2F; avg, 毕竟每一个iteration的时长应该都取决最慢的那个分区. 所以变异系数感觉对于任务效果的表现力应该不如max &#x2F; avg那么大. 好烦好烦啊啊啊. 于是向郑老师求助了一波, 老师也答应明早10点讨论下.</p><h2 id="03-30-周四-晴"><a href="#03-30-周四-晴" class="headerlink" title="03.30 周四 晴"></a>03.30 周四 晴</h2><p>早上九点下床, 十点开始跟老师讨论实验进度和接下来的对策. 目前主要遇到的问题就是: 点平衡性的max &#x2F; avg下不来… 对策的话总结下来就是以下几点:</p><ol><li>尝试把一些点在分区之间转移. 即把点数大的块分一些点到小的块上. 但是会损失边平衡性</li><li>把k调大, 因为目前最后split阶段, k默认&#x3D;2. 我的直觉告诉我这会造成复制因子的暴增</li><li>大体框架沿(chao)用(xi)HEP. 即对高度数点和低度数点用HDRF和NE进行划分. NE部分换成现在的尝试5</li></ol><p>中午吃饭看了<code>Charlotte</code>第10话, 男主找到了他拥有穿越时空能力的哥哥隼, 然后有宇掠夺了隼的能力, 穿越回妹妹步未回学校前一天, 把妹妹的崩坏能力掠夺了, 然后又在小混混手下救下了妹妹.</p><p>中午睡醒起来又得去院楼毕设打卡, 不过还好天气还不错, 下午走在路上也感觉没那么冷了. 回来的时候去荫马塘做了10*双杠臂屈伸 + 10个引体向上. 想再来做第二组, 发现已经没剩下啥力气了… 第二组只能做4个双杠臂屈伸, 是真的难顶hh.</p><p>回来看了看空空如也的邮箱, 心里是真的难受, 我就想去实习下, 都是申请的那种研究岗位, 可是没有一封回复信hhh. 发呆了一会就干饭了.</p><p>晚饭直接把<code>Charlotte</code>第11~13话都看完了. 主要就是说隼翼组织的司机受到反派威胁, 把友利和熊耳(就那个浑身湿透能追踪能力者的人)抓起来了, 然后有宇只身前往, 结果熊耳寄了. 有宇在友利的建议下选择跑遍全世界, 把所有能力者的能力都吸收掉, 以此来保护他们. 到后面周游世界, 吸收了一堆能力之后是真的挺尬的hhh, 就挺像火影疾风传第二次忍界大战那会一样, 有一种战力崩坏的美. 总的来说还算是Good Ending 8. 评分的话我给9.7. 打算明天再把<code>Charlotte</code>的SP看完, 后天就到4月了, 可以看&lt;四谎&gt;了</p><p>晚上我照着对策2改了改代码, 其实挺容易改. 跑了下结果. 芜湖! 感觉还行诶. 大概就是以下这样:</p><table><thead><tr><th>点平衡 &#x2F; 复制因子</th><th>尝试5 -k 2</th><th>尝试5 -k 3</th><th>尝试5 -k 4</th><th>HEP-1</th><th>HEP-10</th><th>HEP-100</th><th>NE</th></tr></thead><tbody><tr><td>Flickr(-round 0, 1.25)</td><td>2.9481 &#x2F; 0.502106 &#x2F; 1.67129</td><td>2.01713 &#x2F; 0.310466 &#x2F; 1.75087</td><td>1.64356 &#x2F; 0.238927 &#x2F; 1.78978</td><td>1.34667 &#x2F; 0.18103 &#x2F; 1.99497</td><td>2.84698 &#x2F;  0.58959 &#x2F;  1.86156</td><td>4.36106 &#x2F; 0.78329 &#x2F; 1.71191</td><td>5.75499 &#x2F; 0.983405 &#x2F; 1.58445</td></tr><tr><td>pokec</td><td>1.19651 &#x2F; 0.107321 &#x2F; 2.5574</td><td></td><td></td><td>1.18711 &#x2F; 0.104949 &#x2F; 4.09252</td><td>1.45267 &#x2F; 0.193644 &#x2F; 2.37787</td><td>1.44878 &#x2F; 0.200215 &#x2F; 2.32288</td><td>1.51142 &#x2F; 0.204164 &#x2F; 2.32316</td></tr><tr><td>friendster_mini</td><td>2.10636 &#x2F; 0.404421 &#x2F; 1.38031</td><td>1.51315 &#x2F; 0.215674 &#x2F; 1.42383</td><td>1.29898 &#x2F; 0.127499 &#x2F; 1.46265</td><td>1.48519 &#x2F; 0.153918 &#x2F; 1.88687</td><td>2.37839 &#x2F; 0.391628 &#x2F; 1.50684</td><td>3.99433 &#x2F; 0.786431 &#x2F; 1.30828</td><td>4.00521 &#x2F; 0.786431 &#x2F; 1.30592</td></tr><tr><td>LiveJournal</td><td>1.1505 &#x2F; 0.0730565 &#x2F; 1.66522</td><td></td><td></td><td></td><td>1.28244 &#x2F; 0.28525 &#x2F; 1.72622</td><td>1.31918 &#x2F; 0.29089   &#x2F; 1.56135</td><td>1.32731 &#x2F; 0.299748 &#x2F; 1.57191</td></tr><tr><td>orkut(-round 3, 1.25)</td><td>1.15136 &#x2F; 0.07300 &#x2F; 2.68283</td><td></td><td></td><td></td><td>1.22523 &#x2F; 0.16664 &#x2F; 2.87311</td><td>1.31264 &#x2F; 0.1844 &#x2F; 2.50675</td><td>1.30823 &#x2F; 0.17113 &#x2F; 2.51108</td></tr><tr><td>orkut big(跟HEP论文不是同一个数据集)</td><td></td><td>2.44573 &#x2F; 0.328861 &#x2F; 2.87441</td><td></td><td>1.37673 &#x2F; 0.128226 &#x2F; 3.49912</td><td>2.30367 &#x2F; 0.411939 &#x2F; 2.93919</td><td>5.44129 &#x2F; 0.955494 &#x2F; 2.22548</td><td>5.41935 &#x2F; 0.948575 &#x2F; 2.23474</td></tr><tr><td>Wikipedia</td><td>1.14254 &#x2F; 0.082909 &#x2F; 1.61386</td><td></td><td></td><td>1.16362 &#x2F; 0.145142 &#x2F; 2.20316</td><td>1.48398 &#x2F; 0.29177 &#x2F; 1.58819</td><td>1.43262 &#x2F; 0.26002 &#x2F; 1.5015</td><td>1.39854 &#x2F; 0.254808 &#x2F; 1.4999</td></tr><tr><td>twitter</td><td>3.08953 &#x2F; 0.415019 &#x2F; 1.61932</td><td>2.41878 &#x2F; 0.288194 &#x2F; 1.64963</td><td>1.98601 &#x2F; 0.220865 &#x2F; 1.68786</td><td>1.27907 &#x2F; 0.162753 &#x2F; 1.95498</td><td>2.6003 &#x2F; 0.374952 &#x2F; 1.68446</td><td>2.24783 &#x2F; 0.361768 &#x2F; 1.53564</td><td>5.37025 &#x2F; 0.826788 &#x2F; 1.48832</td></tr><tr><td>it-2004(-round 5, 1.25)</td><td>1.85107 &#x2F; 0.22373 &#x2F; 1.0787</td><td>1.33886 &#x2F; 0.136391 &#x2F; 1.06624</td><td>1.17596 &#x2F; 0.0752637 &#x2F; 1.11086 (edge balance: 1.02442)</td><td>1.27731 &#x2F; 0.19878 &#x2F; 1.2172</td><td>1.71589 &#x2F; 0.38784 &#x2F; 1.09575</td><td>2.37903 &#x2F; 0.428073 &#x2F; 1.06285</td><td>3.245 &#x2F; 0.568176 &#x2F; 1.04482</td></tr><tr><td>sinaweibo(-round 5, 1.25)</td><td>1.59702 &#x2F; 0.3188 &#x2F; 1.06843</td><td>1.17168 &#x2F; 0.101349 &#x2F; 1.07115</td><td></td><td>1.71819 &#x2F; 0.263641 &#x2F; 1.14221</td><td>2.8689 &#x2F; 0.651315 &#x2F; 1.10154</td><td>3.06843 &#x2F; 0.699459 &#x2F; 1.0565</td><td>2.96213 &#x2F; 0.721086 &#x2F; 1.04583</td></tr></tbody></table><p>向郑老师汇报了之后, 我明确表达了自己对于正确性的怀疑, 打算明天搞个大检查看看hh.</p><h2 id="03-31-周五-晴"><a href="#03-31-周五-晴" class="headerlink" title="03.31 周五 晴"></a>03.31 周五 晴</h2><p>中午吃饭看<code>Charlotte</code> SP的P14.</p><p>下午在研究到底选哪个图计算框架来跑任务, 我看到的有好多的说: giraph(不知道是不是这么拼的), Gemini(thu大佬写的), powergraph(MPI), graphx(spark). 4篇论文里两篇是powergraph, 两篇是graphx. yysy我挺反感spark, hadoop生态的, 其实是因为我之前学过没学懂, 而且他们都是Java写的, 我对Java实在是没啥好感hhh. 说到Java, 我就想起&lt;编程新技术实务&gt;这门课, 我基本全称都是copy的github上的项目, Java可以说是只会一个”sout”.</p><p>先是想试试graphx, 然后spark不会, start-all启动失败, 寄.</p><p>然后晚上我查了查powergraph, 用mpi的可能好弄些. 但是hostname 好像一样是要多个ip, 寄</p><p>好像可以用docker来实现类似伪分布式之类的, 但是不会, 寄.</p><h2 id="04-01-周六-晴"><a href="#04-01-周六-晴" class="headerlink" title="04.01 周六 晴"></a>04.01 周六 晴</h2><p>四月终于来了, 今天气温感觉又回升了些了. 早上还是在查能不能用一台机器, 用docker来搞类似伪分布式的环境. 但是我docker完全不会. 哎, 这些基本功都没咋学过, 感觉是时候集中精力冲一波大电了.</p><p>早上想去搞一个真正的twitter-2010数据集, 之前下载的貌似不是完整版. 然后我去webgraph他们网站, 发现得安装他们的webgraph包. 无语了, java的东西, 整个上午都在搞这个包.</p><p>下午睡醒, 下床对着电脑网页发呆, 突然又想找找IT2004”偏斜度”的指标, 或者说目前算法能优化点平衡性的前提. 想起来webgraph网站上对于数据集有一些图表描述, 于是就打开了IT-2004和livejournal的对比了下. 发现</p><h2 id="04-02-周日-晴"><a href="#04-02-周日-晴" class="headerlink" title="04.02 周日 晴"></a>04.02 周日 晴</h2><p>早上一起来, 就发现昨晚睡前跑的uk-2007-05崩溃了… 重新跑了下, 发现光是载入全图, 内存就用了80+G. 好像得优化下算法了, 由于目前NE会对原edges进行修改, 所以我目前多加了个edges_backup, 导致内存占用差不多翻了一倍.</p><p>验证了下(vector) a &#x3D; b 会不会把b.capacity也赋给a, 还是说只会把b.size给a, 验证代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>;<br>    cerr &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    cerr &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (a.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1000</span>) a.<span class="hljs-built_in">pop_back</span>();<br>    a.<span class="hljs-built_in">shrink_to_fit</span>();<br>    cerr &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    b = a;<br>    cerr &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    b.<span class="hljs-built_in">shrink_to_fit</span>();<br>    cerr &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b.<span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 10000 10000</span><br><span class="hljs-comment">// 10000 10000</span><br><span class="hljs-comment">// 1000 1000</span><br><span class="hljs-comment">// 1000 10000</span><br><span class="hljs-comment">// 1000 1000</span><br></code></pre></td></tr></table></figure><p>结果还真是只把size给了a, 看来还得加上个shrink_to_fit()才行啊hh.</p><p>下午晚上都在思考如何才能减少内存使用量. 下午想到的首先是把edges和edges_backup两个占内存大头的vector<edge_t>删掉其中一个, 然后再通过在struct edge_t里补充一个bool来做边的标记, 这样就可以通过一个struct来完成任务.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge_t</span> &#123;<br>    <span class="hljs-type">bool</span> valid;<br>    <span class="hljs-type">uint32_t</span> first, second;<br>&#125; __attributed__((pakced)) ;<br><br></code></pre></td></tr></table></figure><p>考虑到内存对齐的reserved bit会导致内存占用变大, 所以加上了__attributed__((pakced)), 然而这样可能又会对性能有很大影响… 再三思考下, 决定舍弃原本(1 &lt;&lt; 32) - 1的数据范围, 留出1 &lt;&lt; 31的数据范围用作valid标识. 效果如下:</p><p>Memory Overhead(it-2004)</p><table><thead><tr><th></th><th>原版本</th><th>4.2优化</th></tr></thead><tbody><tr><td>it-2004</td><td>43.982g</td><td>23.713g</td></tr></tbody></table><p>终于可以愉快地跑uk-2007-05了, 毕竟webgraph上的统计特征显示这张图也是有大批度数相近的高度数节点的, 挺期待效果的hhh.</p><p>晚上和rcpd病友王xh打了电话, 我从电话中得知她之前打过一针, 并且似乎没打准, 打到声带了. 上个月她又去了次, 打完后起初有效, 可是前几天又不会打了. 我们讨论到了窦教授和Bastian打针手段的不同点, 由于窦教授是通过超声定位, 从脖子注射的; 而Bastian是直接通过喉镜注射, 确实从精度上来看可能会没那么好. 她跟我谈到了去米国找Bastian打针, 我表示我将来的最终治疗是将环咽肌切开. 她似乎也正在经历我中学到大二那8年的痛苦, 于是我说至少现在已经清楚了病因和治疗方案, rcpd也会逐渐被普及, 接下来交给时间就好了.</p><p>令我倍感欣慰的是, 我得知我的经历和帖子给她和其他十几位病友带来了福音. 我也再次为自己的这段经历感到自豪, 毕竟此生最大的成就, 或者说给世界最大的贡献就是作为国内第一人接收了治疗, 并且传播了这个治疗方法.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：03.29日22点30分 &amp;&amp; 03.30日晚22点30分<br>BGM: &lt;四月是你的谎言&gt; OP &amp;&amp; ED &amp;&amp; OST</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 03.20-03.26</title>
    <link href="/2023/03/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.20-03.26/"/>
    <url>/2023/03/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.20-03.26/</url>
    
    <content type="html"><![CDATA[<h2 id="03-20-周一-小雨"><a href="#03-20-周一-小雨" class="headerlink" title="03.20 周一 小雨"></a>03.20 周一 小雨</h2><p>早上八点左右起床, 先是去校医院做个体检. 首先做内科, 测的心率92, 刚开始以为爬楼梯爬累了, 所以没当回事. 没想到测的舒张压也快到正常范围的上限了, 心肺功能变差了好多, 可能宅家宅久了8. 测身高体重依旧是常规操作, 穿羽绒大袍, 然后往口袋里塞点东西, 这次没带哑铃所以塞了个个水壶. 结果一看身高181.5cm, 体重58.5. BMI 17.+ 还是要完蛋. 回宿舍的路上自习想了想应该是头发长度的问题8, 毕竟他的机器是激光测的. 不过准确身高应该也有180了, 大四体测测的是179.6, 有点难顶, 真的好想报身高直接报180hhh.</p><p>下午晚上都在准备明天的毕设中期答辩, 中午午睡的时候手机忘记调勿扰了, 结果微信哐哐的震, 午睡就这么没了… 原来是毕设群的那些卷王在问参考文献翻译相关的要求, 我甚至还没开始准备, 只能被迫下床. 其实直到下午之前我都还没想好最终应该用怎么样的方案去应付明天的答辩. 因为目前的尝试效果都不咋地. 冥思苦想之后突然想到把BPart和NE瞎搞缝合. 然后写了个最简陋的试了下, 发现单从点平衡度量来看好像还行, 虽然我知道这种缝合怪肯定发不了文章的, 但是应付下毕设应该还是没啥问题的. 于是晚上我就疯狂搞PPT, 到12点zwling要我帮他去掉译文的水印. 看到他的文章翻译的好得一, 于是我试了下他用的arxiv翻译, 发现几篇文章都没法翻译, 寄.</p><h2 id="03-21-周二-小雨"><a href="#03-21-周二-小雨" class="headerlink" title="03.21 周二 小雨"></a>03.21 周二 小雨</h2><p>P.S. 今天穿上了ICPC南京站的黑色棒球服, 简直不要太好看, 感觉在路上走自信力直接+50%.</p><p>早上8点半左右出门去院楼签到, 回来想去综合楼找个啥地方蹭下网, 下一些番, 主要想下&lt;追逐繁星的孩子&gt;, 因为据说好像跟&lt;玲芽之旅&gt;有点关系. 我找了间智慧教室, 看刚好生一个坑位有电源, 没想到是没电的, 电脑开机不到一分钟就自动关机了. 只能回宿舍继续肝下午答辩的PPT.</p><p>中午小睡了下, 但又没睡着. 下午1点半出门, 中楼121. 答辩可以说是水的一了, 就跟平时的实验验收一样, 只不过助教换成了老师而已, 老师看来也是接触过图划分的, NE的强悍她都猛地点头. 我说我想搞个双平衡的试试, 最后放了昨晚临时写的代码的结果, 老师说还不错, 问我是自己搞的吗. 我说老师指导的. 感觉还挺好应付过去的hhh.</p><p>“答辩”完之后我就去帮zzm盖章. 首先是跑到红楼教务处, 老师让我去找二办的信息化部. 然后我就被当成球一样踢到了信息化部, 谁知那个老师态度那么差, 又把我踢回红楼. 我只能跑去复临舍试试打印机行不行. 试了下发现还真可以, 于是就帮zm盖好章了.</p><h2 id="03-22-周三-小雨"><a href="#03-22-周三-小雨" class="headerlink" title="03.22 周三 小雨"></a>03.22 周三 小雨</h2><p>晚上老师来问我最新的实验效果, 我刚好可以把昨天下午新想出来算法的实验结果拿出来show off一下. 实验结果大概长这样:</p><blockquote><p>边平衡性全为1</p></blockquote><table><thead><tr><th>点平衡 &#x2F; 复制因子</th><th>尝试5</th><th>HEP-1</th><th>HEP-10</th><th>HEP-100</th><th>NE</th></tr></thead><tbody><tr><td>Flickr</td><td>2.14585 &#x2F; 2.92259</td><td>1.19371 &#x2F; 3.64274</td><td>2.72022 &#x2F; 2.68514</td><td>3.90338 &#x2F; 2.09799</td><td>4.22383 &#x2F; 1.98494</td></tr><tr><td>LiveJournal</td><td>1.07545 &#x2F; 1.88658</td><td>1.55617 &#x2F; 2.47976</td><td>1.28244 &#x2F; 1.72622</td><td>1.31918 &#x2F; 1.56135</td><td>1.36161 &#x2F; 1.56927</td></tr><tr><td>pokec</td><td>1.1298 &#x2F;  3.10058</td><td>1.18711 &#x2F; 4.09252</td><td>1.45267 &#x2F; 2.37787</td><td>1.44878 &#x2F; 2.32288</td><td>1.49803 &#x2F; 2.32138</td></tr><tr><td>orkut</td><td>1.06922 &#x2F; 2.97</td><td>1.19931 &#x2F; 5.40549</td><td>1.22523 &#x2F; 2.87311</td><td>1.31264 &#x2F; 2.50675</td><td>1.28039 &#x2F; 2.52495</td></tr></tbody></table><p>我还想在更大一点的数据集上试试效果, 于是相中了web-it-2004这个数据集. 主要是因为在HEP这篇文章里, IT-2004的偏斜度是最大的, 感觉上也是最有可能发挥效果的数据集. 结果捣鼓半天发现还得下载配置另外的java包才能获得完整数据集, 实在打扰.</p><p>晚上我还趁着春促买了些游戏, 这次学聪明了, 直接上steampy. 整了个&lt;千恋 * 万花&gt; 42.97R, &lt;高考恋爱一百天&gt; 20R. 又在Jimmy推荐下买了&lt;饥荒联机版&gt; 12R.</p><h2 id="03-23-周四-大雨-小雨"><a href="#03-23-周四-大雨-小雨" class="headerlink" title="03.23 周四 大雨-&gt;小雨"></a>03.23 周四 大雨-&gt;小雨</h2><p>今天下午睡醒去帮zzm盖章, 软件所在保研手续这方面确实是有些bureaucratic. Jimmy刚好要去复临舍打印复试的成绩单, 所以顺路就一起坐车去了. 为了信息院毕设的坑比签到打卡, 只得在荫马塘下车, 看到教室只有不到10人, 是真的难蚌. 打卡完就是到复临舍打印成绩单, 没想到打印机刚好没墨了, Jimmy也治好作罢. 最后是我俩一起去电气院院楼找辅导员签字. 一开始我找错了人, 那位老师似乎也觉得实在没必要搞这种bureaucratic的东西, 态度也不是很好. 上到3楼又跑回2楼, 才找到19级新辅导员的办公室.</p><p>电气院又换辅导员了, 现在的辅导员是小热, 似乎她对这种表并不是很愿意签字, 只得叫zzm自己打电话给她, 甚至还让zzm授权我替他签名. 几番折腾下, 终于把表签完字盖完章了, 这时外面突然就开始下暴雨了… 和Jimmy在一楼门口等了几分钟, 还是决定趟着雨去下坡路的公交站坐车回天马. 没想到下车的时候雨就小了很多, 运气属实不太好呢hhh.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - Boost &amp; glog &amp; gflags的安装</title>
    <link href="/2023/03/06/Linux%20-%20Boost%20&amp;%20glog%20&amp;%20gflags%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2023/03/06/Linux%20-%20Boost%20&amp;%20glog%20&amp;%20gflags%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>已经不知道是第多少次装Boost了, 这次就记录下相关的步骤吧.</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>到<a href="http://www.boost.org/">boost</a>wget boost的安装包, 以boost_1_81_0.tar.gz为例<br>下载完成后进行解压缩.</p><h3 id="编译器设置"><a href="#编译器设置" class="headerlink" title="编译器设置"></a>编译器设置</h3><p>进入解压后产生的文件夹, 运行bootstrap.sh脚本</p><p><code>./bootstrap.sh --with-libraries=all --with-toolset=gcc</code></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>./b2 toolset=gcc</code></p><p>出现:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">The Boost C++ Libraries were successfully built!<br><br>The following directory should be added to compiler include paths:<br><br>    /home/C_library/boost/boost_1_81_0<br><br>The following directory should be added to linker library paths:<br><br>    /home/C_library/boost/boost_1_81_0/stage/lib<br><br></code></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>查看gcc版本, 发现:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 11.3.0-1ubuntu1~22.04&#x27; --with-bugurl=file:///usr/share/doc/gcc-11/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,m2 --prefix=/usr<br></code></pre></td></tr></table></figure><p>所以boost也使用相同的prefix, 直接安装到gcc头文件目录和库文件目录下, 可以省略配置环境变量</p><p><code>./b2 install --prefix=/usr</code></p><p>cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;thirdparty&#x2F;gflags -DBUILD_SHARED_LIBS&#x3D;ON -DGFLAGS_NAMESPACE&#x3D;google -G”Unix Makefiles”</p><h2 id="gtest"><a href="#gtest" class="headerlink" title="gtest"></a>gtest</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>直接来一行<code>apt install libgtest-dev</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 02.20-02.26</title>
    <link href="/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2002.20-02.26/"/>
    <url>/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2002.20-02.26/</url>
    
    <content type="html"><![CDATA[<h2 id="02-20-周一-晴"><a href="#02-20-周一-晴" class="headerlink" title="02.20 周一 晴"></a>02.20 周一 晴</h2><p>随便做了些codeforces SWERC ICPC的签到题(&lt;&#x3D;R1500). R1300的题, 能直接双指针, 我还套了个二分上去. 是真的喜欢二分哈…</p><p>晚上跟一道R1800的交互题对线, 想了快1小时, 怼出来了, 猜数题, 归根结底又是逐位确定一个数. 不过要不是能看到错误样例, 估计要多花很多时间.</p><h2 id="02-21-周二-晴"><a href="#02-21-周二-晴" class="headerlink" title="02.21 周二 晴"></a>02.21 周二 晴</h2><p>今天上午无意间想起了12.18(南京站那天)的CSP认证. 想去看看难度如何, 于是就去CSP官网看了看, 刚好题目也放上去了.</p><p>首先当然是看看咱们的答辩T3大模拟难度如何, 没想到鼠标滚轮一下就滚到底了. 题面出人意料的短, 定睛一看题意也很简单, 大概意思就是对一个矩形进行花式遍历 + 套用公式. 可以说是有史以来最简单的T3了.</p><p>T2看了一眼, 感觉比T3难. 至少他涉及到了算法. 大概就是toposort + 自下向上的树形dp. 不得不说CSP的数据是真的弱, 代码有个逆天的BUG, 都能拿90分.  </p><p>T5 看了看, “区间连边”, 不是虚拟点就是线段树优化建图. 但是后者我掌握甚少, 打算明天系统学习一下, 顺便复习下线段树(我的数据结构水平连洛谷的线段树模板题2都敲不出来).</p><p>下午在yxc那学了会平衡树, 久光看了看视频, 就直接打扰了. yxc写的是旋转式的treap. 还没开始敲就知道自己搞不来. 所以我转而去学更加好写的split + merge的fhq 非旋式treap. 也算是对平衡树有了个初步认识. 不过以后就算遇到需要平衡树的题, 难题肯定是需要用到类似区间翻转之类的技术的, 我肯定也写不出来. 简单题我选择用pbds.</p><h2 id="02-22-周三-晴"><a href="#02-22-周三-晴" class="headerlink" title="02.22 周三 晴"></a>02.22 周三 晴</h2><p>今天一早在acwing上恰巧发现了昨天CSP T3”花式遍历”的简洁写法, 于是学习了下.</p><p>接下来便是痛苦的线段树优化建图的学习. 中午下午复习了线段树, 重温了懒标记. 补了一些线段树的基础题. 晚上对着maspy sensei的库学习具体RangeToRangeGraph的模板, 虽然maspy的模板也是基于zkw线段树的, 但是他并没有将线段树设成完全二叉树, 所以叶子节点不好区分. 学完之后拿来在codeforces 406D的模板题Legacy上试了试, 能过.</p><p>不过2022.12的CSP T5却样例都过不了. 纳闷了好久才发现样例的边权是带2的次幂的… 改过来之后, 再加上一个单汇多源最短路, 建个返图就行了. 最后骗了52分, 感觉还行.</p><h2 id="02-24-周四-多云"><a href="#02-24-周四-多云" class="headerlink" title="02.24 周四 多云"></a>02.24 周四 多云</h2><p>今晚打了小白月赛67, 体验是依托答辩. C题三角形切分那题题目也没说面积是否能为小数, 搞了一个多小时. D题是我自己sb了, 复制先前代码的时候忘记改符号了, 又得搞对拍. 然后用multiset又TLE. E题题意也是答辩. 看了半天样例才看懂, 最后5min才有思路, 其实就是倒着DP. 但是不完全对. 赛后5min才过. 不想鉴定hh.</p><h2 id="02-26-周日-晴"><a href="#02-26-周日-晴" class="headerlink" title="02.26 周日 晴"></a>02.26 周日 晴</h2><p>今天算是个值得纪念的日子, 因为就在今天, 我宣布<strong>LCJ正式进军钢琴界</strong>(虽然现在还莫得钱买真钢, 还是先拿家里的雅马哈小电子琴练着先). 下午花了一个下午, 尝试弹了弹拜厄的第11条: &lt;布谷鸟&gt;. 只能勉强把12小节谈下来, 不得不说是真的难. 首先难的便是识谱, 作为完全0基础选手, 只能一条线一条线地去数. 其次协调性也是大问题, 左右手经常打架, 是真的绝望… 不过听了下录音, 觉得还是有模有样的hhh.</p><p>晚上了解到妹妹之前玩的<Simply Piano> 这款APP, 手玩了下发现居然可以根据音频来评判弹奏是否正确. 可是会员贼贵, 一年得400了. 先试用一星期再说, 到时候再求助下万能的淘宝.</p><p>另外提一下今晚的ATC ABC 291. 发挥还行, 前期D题稍微卡了卡. 主要是看到”求方案数”, 我第一反应往组合计数上想了. 想了10min发现莫得思路. 于是看E, 发现E就是个类似差分约束的板子题. 直接toposort求最长路 + 判断是否为排列. 赛时30min的时候过掉了. 再反过来看D, 看到数据范围1e5, 这次很快转变思路, 想到了DP, 于是在第36min拿下.</p><p>本来没想着做出F的, 但是看了看好像又是那种比较能做的图论题. 类似删点最短路, 但又不完全像. 想着用线段树维护拓扑序区间内节点连边的最短路. 要维护区间最小值, 就要涉及到lazy_tag, 一涉及到lazy_tag, 我就寄. 毕竟总共就没做过几道线段树的题, 更别说lazy_tag了, 早知道之前下点功夫把maspy sensei的板子偷师下来, 放到自己的cp_library里面了. 怼了半天都没把样例怼出来. 最后zwl也觉得这种程度的图论题是应该做出来的, 哎真的难顶. 事后看了jiangly 发在B站的录像, 虽然也是起点终点求最短路, 但是他是枚举每一条边(u, v), 然后枚举(u, v)之间的点, 挨个去更新最小值. 我果然是思维僵尸hhh.</p><p>知足常乐咯, 表现分1300+, +30, 重新回到1100分.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.22日晚19点30分 &amp;&amp; 02.26日22点30分</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 02.20-02.26</title>
    <link href="/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.13-03.19/"/>
    <url>/2023/02/22/%E5%91%A8%E8%AE%B0%20-%202023%2003.13-03.19/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9d3f3a4a32e75a4e58ce95c38aab1d0d16840650bcdd0326b723fbe5911e0ec8">6700a10771cde00a4b64b788d85e15b48a9ba3b5fe3b673a8b4ad0b0f20623a705270a176cf21c2e9101f348f37f2a8ee4cd9799aee6c7ac539f7df31503e4df2d6204f40dc9a0f04f53a3456b8c20592cb3ac5df9aa776cc6e841bf9e45f5a6562e6e6a0fd21a963a35de0d66d2e69d1129798ee6ca9cf12b02b2876f79c1c65854a0bd41ffc2e9d2cba3acb4df6f59cee64114ab9e6a4e18890012aa89bdfe6786919ff8b7b1061826cacdc7337b26b6121389fe909a80e22fbbed58b6c0fb97a7c265045c5b6c893353073e8c1221b536afce2bfb2f89249b455b085ecee3f9d6b9be582b87b2fe9ee74f912958eda8c99e091ed783b858688ef56f2161b270dd8d29a92349f7d98cdb8076d806b2a30b6c4d440efd14a81293f029f4fdd682a430370d4d9cdf96f685cccd132131eed2c85beddd264b9a28620c68d923a9d3e9c0ed17c540b72729f36dab30d18c6a84659004b301e0edfa19e5fb59d28bda46b976228963058f46d70010d934e76a0972c93ae53a9d944fc88beb4cb4e131aea99bfed7cbff3cfa49f17eb630045a73a1f865c7270fa46d4d7b5c6109cfde9bdabdf6ce054f025a0aa97fd7cbe31e07d5a1474b86a85f921c500be28ebe305848387cfa9e1d1570429cc55ff770188ddd5e7f6b04440eca74b12b0f54c8be92655b8c748badea21b2558dadaf5ecc74e6d0b141c35318e97ebd9ea9c57503556f5aec60091383a3dcc988a884fa5c7fae4e09f9efbb84a5144c1a6ea1b86dd9ea385ef271ee9efcaab48d5412785f838fd5651e44fcc263fa4025c59946b3de61f6bc5c8be98fe3dffc9a12ade0755f7362db6431408b22e727fad185328ebf19d9e05f00b99c6a174555252475196578540c21901f2d06ade3891a9e079b61f162c29593293f2d71f3f6bb2665edadcc3adb920e280e9caa3df11552b2a6cfedfb423c1c33aaaabd5894d322af97d1871d53985c8b4df79aa99cda0c1c539c505d769a31ba60fd5a1d27c5e691233cc3a785a6217f66246cd3b6cbb271879412bf37993f8b25194761fba44e81b4699a692bf027383612a7f3274e3b1b226628c9f6deb822cc3c91471e457219a090f62836a88171e9fafafd4b51c30788a069bc5696612434acc610f0d36d661c91f38340dee947734b635e93d1c31932c47b60e69d6d2200ba0dc62164d06b1889d9dd01a7886319d1729d3c0db1952b4956a93434044741aaeb476f30dfbb252b5d4e41b2221c953b28ba643c9ecda317cfcfbab2a9219e2ec952c4ae8a7f982fb3603d5d8fd0466e532eb30424e9d3900ca141c51a9e869bdbe29392de77e3a9785514ca1022f782744baa6696bdd783e1682cd0c2706c83adc3f8a55084d43cb5851e78605273f5948e4455b500e3c89028605e7f31a255e07c86371e8795bb896d2474ad0a4e946146bd7b8ef165f4959888dc1cde841ce202dd552fdf792aeec4e7b3a011e535159b0c001b10fe3639dcc3f0d787960f1c091b006e113406ebd5a9419012488307b6c1a2a222c636918c04a504bfd1625194eb5fe12715004f0ed789ed341c48724fc4bf27b3f0a87b527cec81986e4ac755753f9d0422dd579c9c269ec02947da1a001334ff36c439296174966cbf262683871337e024b3480d427a83d588d68566833c5a45924efcf1b84a7a72de6fa3918caaeee3bcba7c37609879b4947ef98f6385945357f3900c46f1579619b123ff6b1d21761f470b811ad64defa22f17081ad959fca9c2c7fced7a070e336441cbaf0aaf6dbf6d75717cb822825d60ca3395e6573809fcd68d6ee8df5308e4ab374d1bb096a57706a72bf9f144ac495a8afd7fa7fc8be0952899e43f6b4ae311a521fee42f0fdf513197f48f146b9a23a56e59c66e2f19209448856d2c42597fe1c53bb9f4675034b485fcf5b8f2e03a0e7488cd5bf84486b0c073c18f26ecf87523fa8281e5491d6ea15eb4a5837c8e72112dab8163e13eb5beff0dcbc576b39ae6c948213f7e819348adf95499ee20a63bc077dba9ac1a8152e2c83da563697eeaefb023</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 02.13-02.19</title>
    <link href="/2023/02/19/%E5%91%A8%E8%AE%B0%20-%202023%2002.13-02.19/"/>
    <url>/2023/02/19/%E5%91%A8%E8%AE%B0%20-%202023%2002.13-02.19/</url>
    
    <content type="html"><![CDATA[<h2 id="02-15-周三-阴-大风"><a href="#02-15-周三-阴-大风" class="headerlink" title="02.15 周三 阴~大风"></a>02.15 周三 阴~大风</h2><p>今天早上得早起, 去中三三院对面那家 明兴康复中心 做食道测压检查. 早上早饭也没吃, 就出发了. 大概9点左右, 在岗顶路口遇到了JJJ同学, 我靠是真的巧了, 这波只能说直接”逮到”(Doge). 通过VX得知他大概也是45月份左右回学校.</p><p>这次食道测压麻醉方式跟之前不太一样, 护士是先拿普鲁卡因滴进去我的鼻子, 再插管的. 但是难受还是会有点难受的, 主要是吞咽的时候会有些许恶心感. 由于这次检查还是给窦教授测数据, 所以也没收费, 只是收了普鲁卡因的钱. 我从三院拿了药还回中心之后, 就直接回家了.</p><h2 id="02-16-周四-多云-大风"><a href="#02-16-周四-多云-大风" class="headerlink" title="02.16 周四 多云~大风"></a>02.16 周四 多云~大风</h2><p>今天来看窦教授的专家门诊, 主要是希望窦教授能帮我补1针or2针. 结果遇到了另一位不会打嗝的病友, 她是来自Melbourne University的, 她在reddit上有rcpd病友群, 据说有几万人. 她这次来也是参考下国内这边的打针情况. 窦教授说会安排专门的麻醉室来打针, 不过比较难约上. 希望早点约上吧qwq</p><h2 id="02-19-周日-阴"><a href="#02-19-周日-阴" class="headerlink" title="02.19 周日 阴"></a>02.19 周日 阴</h2><p>今天晚上的ATC ABC是真的悲催. 表现分直接干到了400+, 灰名水平… 哎主要卡了C, 当时我就知道这盘大势已去. 没想到D题没有仔细思考就上来写, 到最后才发现做法是假的. 感觉其实就是一道codeforces div2 B题难度的gcd规律题. 是真的难受啊. 直接-52. 掉下1100了. 离青名1200再一次远去.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.15日晚19点30分 &amp;&amp; 02.19</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事记 - 2022计算机保研回忆录</title>
    <link href="/2023/02/16/%E4%BA%8B%E8%AE%B0%20-%202022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
    <url>/2023/02/16/%E4%BA%8B%E8%AE%B0%20-%202022%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>术语:<br>CS: 计算机科学<br>SE: 软件工程</p></blockquote><h2 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h2><ul><li><strong>本科院校</strong>: 湖南大学</li><li><strong>专业</strong>: 计算机科学与技术</li><li><strong>排名情况</strong>: 14&#x2F;225(夏令营), 10&#x2F;221(预推免). (这俩都是挑的最好的排名)</li><li><strong>外语水平</strong>: 四级629, 六级598. 自认为口语能过关.</li><li><strong>获奖及竞赛</strong>: 详见 <a href="https://lcj2021.github.io/about/">&lt;关于博主&gt;</a> 页面</li><li><strong>科研项目</strong>: 本校实验室实习一年半(产出CCF A类会议挂名一篇), 复旦大学大数据学院一学期的实习(无产出)经历</li><li><strong>最终去向</strong>: 复旦大学大数据学院</li></ul><h2 id="院校选择"><a href="#院校选择" class="headerlink" title="院校选择"></a>院校选择</h2><ul><li><strong>学校</strong>：北上广的高校(中山, 北航, 同济, 华东师, 华工 etc.) + 华五人(理想: 交&gt;复&gt;南&gt;浙&gt;科&gt;人)<br>  个人不太倾向研究所, 考虑到将来的选择, 可能更加注重title &amp;&amp; 身为广州人, 也更倾向于回家读书.</li><li><strong>硕&#x2F;博</strong>：硕士博士都行, 但是优先硕士. 如果科研顺利可以转博.</li><li><strong>导师</strong>：人品 &gt; push程度 &gt; 学术能力<br>  人品rk first</li></ul><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><table><thead><tr><th>学院</th><th>入营</th><th>优营</th></tr></thead><tbody><tr><td>人大信院</td><td>❌</td><td>-</td></tr><tr><td>复旦大数据</td><td>✔️</td><td>候补</td></tr><tr><td>南大CS</td><td>候补</td><td>放弃</td></tr><tr><td>南大SE</td><td>候补</td><td>放弃</td></tr><tr><td>科大大数据</td><td>候补</td><td>放弃</td></tr><tr><td>上交电院</td><td>❌</td><td>-</td></tr><tr><td>同济SE</td><td>❌</td><td>-</td></tr><tr><td>计算所</td><td>✔️</td><td>放弃</td></tr><tr><td>天大智算</td><td>✔️</td><td>放弃</td></tr><tr><td>自动化所</td><td>❌</td><td>-</td></tr><tr><td>北航CS</td><td>✔️</td><td>✔️</td></tr><tr><td>华东师SE</td><td>✔️</td><td>✔️</td></tr><tr><td>中山CS</td><td>❌</td><td>-</td></tr><tr><td>华工CS</td><td>❌</td><td>-</td></tr><tr><td>哈深CS</td><td>❌</td><td>-</td></tr><tr><td>武大CS</td><td>❌</td><td>-</td></tr><tr><td>华科CS</td><td>❌</td><td>-</td></tr></tbody></table><blockquote><p>P.S.</p><p>中山大学: 由于个人操作疏忽, 在报名时, 忘记将最重要的盖了校章的资料上传了. 导致尽管有一群海王放弃, 开放第二波入营, 我也没能入营. 可以说是彻底无缘了.</p><p>南京大学CS &amp;&amp; SE: 并不是一批次入营, 而是在第二批入营的. 可是和华东师大的最终面试汇报冲突了, 权衡风险利弊(南大408大概率成为炮灰, 华东师范当时已经通过了笔试和导师面试)后还是选择了放弃.</p><p>科大大数据: 大概率是由于rk过低, 只能候补入营. 最后也没后补上.</p><p>清北的一些研究院也都投了, 显然白给hhh</p></blockquote><h3 id="华东师范大学-SE"><a href="#华东师范大学-SE" class="headerlink" title="华东师范大学 SE"></a>华东师范大学 SE</h3><p>ECNU的系统可以填报2个志愿, 所以我CS和SE都填了. 可是令我意外的是居然入了SE的夏令营, 听说ECNU有oq机制, 没想到居然放我入了SE.<br>具体考核的话, 分为机试 + 导师面试(包括看论文) + 个人汇报, 过程还是十分繁琐的, 这也算是筛除海王的一种方式吧.</p><h4 id="Stage1-机试"><a href="#Stage1-机试" class="headerlink" title="Stage1: 机试"></a>Stage1: 机试</h4><p>ECNU的机试是出了名的难. 这次我算是亲身体会到了. 总共3题. T1就按照题意模拟, 但我找不出BUG.<br>T2感觉像是树形dp, 不过保守估计难度对应于codeforces 2000+分. T3是感觉像是删边最短路, 直接打扰, 不配看题.</p><p>还好是IOI赛制, 最后T1 WA了一个点85pt, T2瞎搞DP, 骗了30pt. T3爆零. 85+30+0&#x3D;115pt.<br>有一说一T3直接暴力二进制枚举所有边, 可能还是可以骗些分的. 总体来说感觉还行.</p><h4 id="Stage2-导师单面"><a href="#Stage2-导师单面" class="headerlink" title="Stage2: 导师单面"></a>Stage2: 导师单面</h4><p>ECNU要求联系学院的一位老师, 联系好之后加了老师的QQ. 之后老师安排我阅读他的一篇<strong>长文</strong>.<br>我当时没注意到长文这一条件, 再加上当时在上苦逼的编译器小学期课, 天天在院楼苦逼地罚坐, 所以我临面试前一天赶忙看了看一篇短文, 大致是时空数据挖掘, 众包方向的A刊文章.</p><blockquote><p>P.S.</p><p>我还了解到我联系的这位老师和他所在的实验室都是热门, 他还跟我说学硕名额十分有限. 意思懂的都懂qwq</p></blockquote><p>面试首先要求我汇报文章的主要内容, 然后老师提问了我对于实时性要求更高的场景, 能不能提出在线的算法, 我想了想瞎扯了下, 老师似乎不是很满意.</p><p>其次便是算法考核. T1是问给定一个数组a, 要求把这个数组分成2组, 使得两组的总和尽可能接近. 这题还算比较简单, 就是一个简单的背包dp, 目标物品价值便是1&#x2F;2的数组总和.<br>老师听了似乎不是很满意, 要求我给出证明, 我只得面试结束后给他发过去.<br>T2看似是最小生成树的问题, 但是没想到怎么建图, 所以我就说二分答案. 老师似乎不太理解我的意思. 到这里面试便草草结束.</p><p>无论是机试的考核内容和难度, 还是单独面试的算法考核, 都不难看出ECNU SE 对于编程和算法的要求都是蛮高的.</p><h4 id="Stage3-最终汇报"><a href="#Stage3-最终汇报" class="headerlink" title="Stage3: 最终汇报"></a>Stage3: 最终汇报</h4><p>ECNU要求我们准备一个自我介绍的PPT, 然后在PPT内要放上Stage2所汇报的论文的内容.<br>汇报当天我在等候面试排队的时候, NJU CS的机试恰好开始了, NJU的小姐姐打电话来说要提前进场准备验证身份, 还说不参加要提前说.<br>没得办法, 只好先拖住了. 然鹅到NJU机试开始, 我都没能排队进入最终汇报, 只能打电话到NJU说放弃机试.<br>最终面试可以选择中英文汇报, 我由于时间仓促, 选择了中文. 到最后有个导师群面, 导师们用英文提问, 我只记得一个问题是介绍我在本校实验室所做的工作, 勉强支支吾吾答上来了.</p><p>最后夏令营闭幕式上会宣布优营成员, 还通过邮件发了优营证书, 属于是十分有心了. 我看优营还有SJTU的大佬, 属实打扰了.</p><h3 id="北京航空航天大学-CS"><a href="#北京航空航天大学-CS" class="headerlink" title="北京航空航天大学 CS"></a>北京航空航天大学 CS</h3><p>北航没有因为我过低的rank就把我筛掉, 估计是看在我那一丢丢算法竞赛经历的面子上才放我入营的. 知遇之恩, 由是感激.</p><p>北航考核方式是<strong>机试+面试</strong>.</p><h4 id="Stage1-机试-1"><a href="#Stage1-机试-1" class="headerlink" title="Stage1: 机试"></a>Stage1: 机试</h4><p>北航的机试一直都是以码农题著称, 我看了下往年的机试题, 感觉是难度还能接受的两道大模拟(低于CSP T3), 没想到今年的模拟这么逆天…</p><p>赛制是恶心的OI赛制. 可以用CSP的成绩来抵, 并且语言限定C++. 不过我CSP分数实在过低过于感人, 所以我还是来考机试了.</p><p>T1是字符串处理 + 结构体排序. 由于是线上机试, 所以拥有东道主优势(doge). 其实是自己的键盘快捷键ide自己比较熟悉啦.<br>T1应该拿满60了, 因为我T2实在是没办法, 所以自己造了几组数据梭哈T1.</p><p>T2是关于编译原理的应用的巨大模拟之依托答辩, 实在难以模拟, 写不出来就输出样例想骗一下分. 不过这次机试好像并没有筛人, 但是机试很明显是算在了面试总评里面的.</p><p>赛后在腾讯会议看到了自己的高中同学, 西电acm知名选手et3_tsy. 我俩刚好在同一个房间, 祝福他能取得优异的成绩.<br>赛后我俩交流才发现T2连他这种巨佬都没干过, 区分度属实有点过于低了.</p><h4 id="Stage2-导师群面"><a href="#Stage2-导师群面" class="headerlink" title="Stage2: 导师群面"></a>Stage2: 导师群面</h4><p>面试是压力面, 内容包括<strong>政治+408+数学+英语</strong>, 面试问题汇总如下：</p><ul><li>如今正处百年未有之大变局, 我们身为青年应该作为</li><li>函数极限的定义, 用\epsilon-N语言来描述</li><li>同时抛两个硬币, 其中一个是正面, 问另一个是正面的概率</li><li>一个随机生成的01串, 口述一个算法能够统计其中的最长连续1的子串长度.</li><li>续上述问题, 长度为10000, 最长的连续1的子串长度期望大概是多少.</li><li>为什么要创建网络层</li><li>电话号码 IP相关? (记不清了)</li></ul><p>之前在知乎经验贴上看到北航的面试很硬核. やはりや, 北航的夏令营确实是一种压力面, 就是那种几个老师会一起怼你的那种, 丝毫不会放松进攻节奏.<br>问到T4时我直接脱口而出dp, dp[i]表示以第i个字符作为结尾的1子串最大长度, 从dp[i-1]到dp[i]分为00, 01, 10, 11四种转移. 复杂度O(n).<br>しかし, 接下来的T5我直接就傻了. 概率期望类的题我一向不擅长, 我仔细想了想状态设计. 可能是我误解了老师的问题, 老师打断我说大概给出一个数字.<br>我就瞎蒙了个10+给他们. 到此为止, 可以看得出老师们对于我以上的回答都是挺满意的.</p><p>然鹅接下来的问题直接就拉低了我的分数. 一位老师直接开始问计网相关的问题…<br>“哦豁~完蛋!” 要知道咱的计网可是hsr教的呀(保研成绩单上扫一眼, 计网分数显著低的同学肯定是咱78班的. doge).</p><p>最终在我等复旦候补的时候, 打电话问我确认意向, 得知录到了计算机学院的0835 软件工程, 感觉已经很不错了.</p><p>北航最终认可了我, 再加上我的队友zwling也最终去北航了, 因此北航在我心目中第好感度和地位直接排进前3.</p><h3 id="天大智算"><a href="#天大智算" class="headerlink" title="天大智算"></a>天大智算</h3><p>天大属于海王营. 首先参加机试, 机试难度 &lt; codeforces div4, 感觉很多人都能AK. 但是是OI赛制, 就很烦. 我提前大约20分钟完成.<br>但是没注意到最后一题的公式弄错了个地方, 估计那题爆零了qwq. 最后居然在Q群上说机试仅作为参考? 迷惑行为了属于是. 后续我也没参加了.</p><h3 id="计算所"><a href="#计算所" class="headerlink" title="计算所"></a>计算所</h3><p>计算所我报名的是”网络数据科学与技术重点实验室”, 其实是实在很难找到方向匹配的导师, 这个已经是找的相对匹配些的了.<br>入营邮件是群发的, 一看其他邮件的二级域名, pku, tongji, 实在是打扰了. 虽然最后也没想着参加机试, 但还是先回复了:”lcj+确认参加”. 结果最后还是没去参加机试.</p><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><p>夏令营拿到了北航CS和华师SE的offer可以作为保底, 同时争取下复旦的候补, 此时我已经身心俱疲, 于是开摆.<br>只报了南大的CS, 估计是被拉黑了, 没能入营(虽然我知道就算入营了也不可能卷过408大关, 拿到0812学硕).</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于: 2023-02-15 晚19点30分</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux - WSL2 下使用宿主机代理</title>
    <link href="/2023/02/14/Linux%20-%20WSL2%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/"/>
    <url>/2023/02/14/Linux%20-%20WSL2%20%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>WSL2科学上网</p><p>前言: 情人节当天搞了一晚上… 最后参考的这篇才成功 <a href="https://www.cnblogs.com/tuilk/p/16287472.html">https://www.cnblogs.com/tuilk/p/16287472.html</a>,</p><h2 id="1-Windows下打开代理"><a href="#1-Windows下打开代理" class="headerlink" title="1. Windows下打开代理"></a>1. Windows下打开代理</h2><h3 id="1-1-允许局域网"><a href="#1-1-允许局域网" class="headerlink" title="1.1 允许局域网"></a>1.1 允许局域网</h3><p>以<code>Clash</code>为例, 购买相关<code>配置</code>, 选择<code>主页</code>选项卡, 开启<code>允许局域网</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519095954875-534125057.png"></p><h3 id="1-2-开启防火墙"><a href="#1-2-开启防火墙" class="headerlink" title="1.2 开启防火墙"></a>1.2 开启防火墙</h3><p>打开<code>Windows Defender 防火墙</code>, 选择<code>允许应用或功能通过 Windows Defender 防火墙</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519100052696-2100542151.png"></p><p>点击<code>更改设置</code>, 找到<code>Clash for Windows</code>, 然后勾选<code>专用</code>和<code>公用</code>:</p><p><img src="https://img2022.cnblogs.com/blog/2026333/202205/2026333-20220519100127832-1936469422.png"></p><blockquote><p>如果找不到<code>Clash for Windows</code>, 点击下方的<code>允许其他应用</code>, 然后找到安装路径, 将<code>Clash for Windows.exe</code>文件加入进来.</p></blockquote><h2 id="2-配置WSL2-bashrc-长期配置"><a href="#2-配置WSL2-bashrc-长期配置" class="headerlink" title="2. 配置WSL2(.bashrc 长期配置)"></a>2. 配置WSL2(.bashrc 长期配置)</h2><p>写脚本, 放到脚本文件夹. 通过在.bashrc里配置alias调用脚本, 实现proxy的快速set和unset.</p><p>新建<code>proxy.sh</code>脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>hostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)<br>wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)<br>port=7890<br><br>PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;<br><br>set_proxy()&#123;<br>  export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;<br>  export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot;<br><br>  export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;<br>  export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;<br><br>  export ALL_PROXY=&quot;$&#123;PROXY_SOCKS5&#125;&quot;<br>  export all_proxy=$&#123;PROXY_SOCKS5&#125;<br><br>  git config --global http.https://github.com.proxy $&#123;PROXY_HTTP&#125;<br>  git config --global https.https://github.com.proxy $&#123;PROXY_HTTP&#125;<br><br>  echo &quot;Proxy has been opened.&quot;<br>&#125;<br><br>unset_proxy()&#123;<br>  unset http_proxy<br>  unset HTTP_PROXY<br>  unset https_proxy<br>  unset HTTPS_PROXY<br>  unset ALL_PROXY<br>  unset all_proxy<br>  git config --global --unset http.https://github.com.proxy<br>  git config --global --unset https.https://github.com.proxy<br><br>  echo &quot;Proxy has been closed.&quot;<br>&#125;<br><br>test_setting()&#123;<br>  echo &quot;Host IP:&quot; $&#123;hostip&#125;<br>  echo &quot;WSL IP:&quot; $&#123;wslip&#125;<br>  echo &quot;Try to connect to Google...&quot;<br>  resp=$(curl -I -s --connect-timeout 5 -m 5 -w &quot;%&#123;http_code&#125;&quot; -o /dev/null www.google.com)<br>  if [ $&#123;resp&#125; = 200 ]; then<br>    echo &quot;Proxy setup succeeded!&quot;<br>  else<br>    echo &quot;Proxy setup failed!&quot;<br>  fi<br>&#125;<br><br>if [ &quot;$1&quot; = &quot;set&quot; ]<br>then<br>  set_proxy<br><br>elif [ &quot;$1&quot; = &quot;unset&quot; ]<br>then<br>  unset_proxy<br><br>elif [ &quot;$1&quot; = &quot;test&quot; ]<br>then<br>  test_setting<br>else<br>  echo &quot;Unsupported arguments.&quot;<br>fi<br><br></code></pre></td></tr></table></figure><blockquote><p>注意: 其中第4行的<code>&lt;PORT&gt;</code>更换为自己的代理端口号.</p></blockquote><ul><li><code>source ./proxy.sh set</code>: 开启代理</li><li><code>source ./proxy.sh unset</code>: 关闭代理</li><li><code>source ./proxy.sh test</code>: 查看代理状态</li></ul><h3 id="2-1-任意路径下开启代理"><a href="#2-1-任意路径下开启代理" class="headerlink" title="2.1 任意路径下开启代理"></a>2.1 任意路径下开启代理</h3><p>可以在<code>~/.bashrc</code>中添加如下内容, 并将其中的路径修改为上述脚本的路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias proxy=&quot;source /path/to/proxy.sh&quot;<br></code></pre></td></tr></table></figure><p>然后输入如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure><p>那么可以直接在任何路径下使用如下命令:</p><ul><li><code>proxy set</code>: 开启代理</li><li><code>proxy unset</code>: 关闭代理</li><li><code>proxy test</code>: 查看代理状态</li></ul><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>使用<code>curl</code>即可验证代理是否成功, 如果有返回值则说明代理成功.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl www.google.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 02.06-02.12</title>
    <link href="/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/"/>
    <url>/2023/02/14/%E5%91%A8%E8%AE%B0%20-%202023%2002.06-02.12/</url>
    
    <content type="html"><![CDATA[<h2 id="02-10-周五-多云-阴"><a href="#02-10-周五-多云-阴" class="headerlink" title="02.10 周五 多云~阴"></a>02.10 周五 多云~阴</h2><p>今天晚上参加了晚上7点的小白月赛66. 开局上来就被A搞了快10分钟. B更是因为没讨论 A &lt;&#x3D; B的情况调到40分钟. D题一开始也是不会做, 不过好在发现了平方式的用意. 最后还剩半个多小时做E, 想了会发现是道完全图的构造题. 想着用set insert + erase + lower_bound 3e5次(2s时限)硬怼构造边权, 不过没写完. 赛后写完交了, TLE. やはり(yahari 果然)还是找出边权递增的顺序去赋值边权才行.</p><blockquote><p>后话: 其实set硬怼也行, 不过得用到 霓虹大神maspy的 <a href="https://maspypy.github.io/library/ds/fastset.hpp">fastset</a></p></blockquote><p>最后四题, 感觉我做E的时候还是太呆了. WF说要暂不返校要填表, 而且明天之前就要截止了. 我想着没啥理由, 然后就打了个嗝, 不过不是很畅通, 是那种嘶哑的, 心想之前考虑打 “加强针” (中间右边再补针). 不如趁这个机会打了得了, 所以就这么填了.</p><h2 id="02-11-周六-多云-阴"><a href="#02-11-周六-多云-阴" class="headerlink" title="02.11 周六 多云~阴"></a>02.11 周六 多云~阴</h2><p>早上补昨晚小白月赛66的F题, 发现好像是个挺简单的一眼二分 + 尝试性贪心(只用从后往前合并和从前往后合并两种, 枚举下就知道哪个更优了).</p><p>晚上打ABC 289. 前四题依然慢速, 做了20+分钟… 尤其是B题别人用题目性质 + 双指针很快写完, 我还用并查集硬怼模拟. C题二进制枚举看半天题. D题因为转为index 0 based党, 所以dp方式也改成了刷表法. しかし(shi ka shi 可是) vector开小了, RE了一发. E题想了一个小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过. 以为是O(n^2)的, 其实是O(m^2)的, 都没看到边数m &lt;&#x3D; 2000. 属于是瞎猫撞上死耗子了.</p><p>表现分1364, +29来到1138. 离青名只差62分了, がんばって (顽张って ga n ba te加油)!</p><h2 id="02-12-周日-多云-小雨"><a href="#02-12-周日-多云-小雨" class="headerlink" title="02.12 周日 多云~小雨"></a>02.12 周日 多云~小雨</h2><p>中午起床收到微信下午开组会. やはり还是得继续科研进度. 开会讨论后, 认为应该从下游任务的实际实验效果看看. 所以得用到分布式图计算的环境. 但是我之前除了gstore外就没用过其他框架了. 问了蔡学长, 得知服务器集群得校园网访问. 实在难顶.</p><p>下午4点 场的codeforces 852 div2. 难得不是阴间时间. 直接炸穿. A40+分钟才过. 哎情况没讨论好, 多写了if, 其实都要考虑的. B一开始看到了条件”数组元素绝对值之差为1”, 后面又忘了这个条件了. C吃完饭后回来才写完.</p><p>表现分只有不到1000分呢. 我直接好家伙, 上个青名都费劲, 我好像只配打div3和div4. 哎谁让我上次div4没把握好机会呢? 要是上次写慢些, 老老实实把树状数组写了, 再检查好二分边界, 也没那么多烦事了. 不过呢, 这点掉分只能说是小问题, 打还是会继续打的. 只是cf这种rated波动那么大的比赛, 不如直接彻底开摆得了. 这样得失心放轻些, 说不定还能表现得正常些. 下次div2我想直接从C或D开始干了, 效仿rainboy大神.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.15日晚19点30分</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 289 A-E</title>
    <link href="/2023/02/11/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20289%20A-E/"/>
    <url>/2023/02/11/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20289%20A-E/</url>
    
    <content type="html"><![CDATA[<p>+29! 表现分1364, 历史第二高, 感觉不错.</p><p>E题冥思苦想想了1个多小时, 最后灵光一现想到了之前都没试过的bfs方法, 担心复杂度问题. 但是也没时间管那么多了, 直接写完就交了, 没想到能过.</p><h2 id="A-flip"><a href="#A-flip" class="headerlink" title="A. flip"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_a">A. flip</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将给定的01串s, 进行01翻转后输出</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;   cin &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)   cout &lt;&lt; <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-V"><a href="#B-V" class="headerlink" title="B. V"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_b">B. V</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我是直接按照题意用并查集模拟了整个过程. 对于</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x == p[x] ? p[x] : p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    u = <span class="hljs-built_in">find</span>(u), v = <span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    p[u] = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x, x --;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">wcc</span>(n);<br><br>    <span class="hljs-built_in">iota</span>(p, p + n, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>        <span class="hljs-built_in">merge</span>(x, x + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        wcc[<span class="hljs-built_in">find</span>(i)].<span class="hljs-built_in">pb</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(wcc[i]));<br>        <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">all</span>(wcc[i]));<br>    &#125;<br>    set&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)    S.<span class="hljs-built_in">insert</span>(i);<br><br>    <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> now = *S.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : wcc[<span class="hljs-built_in">find</span>(now)]) &#123;<br>            cout &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            S.<span class="hljs-built_in">erase</span>(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Coverage"><a href="#C-Coverage" class="headerlink" title="C. Coverage"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_c">C. Coverage</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>二进制枚举</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector <span class="hljs-title">S</span><span class="hljs-params">(m, vector&lt;<span class="hljs-type">int</span>&gt;(n))</span></span>;    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> c;  cin &gt;&gt; c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; c; ++ j) &#123;<br>            <span class="hljs-type">int</span> x;  cin &gt;&gt; x;   x --;<br>            S[i][x] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; val &lt; (<span class="hljs-number">1</span> &lt;&lt; m); ++ val) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">has</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; m; ++ b) &#123;<br>            <span class="hljs-keyword">if</span> (val &gt;&gt; b &amp; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <span class="hljs-keyword">if</span> (S[b][i]) &#123;<br>                    has[i] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">all</span>(has), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (sum == n) &#123;<br>            ++ ans;<br>        &#125;<br>    &#125; <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Step-Up-Robot"><a href="#D-Step-Up-Robot" class="headerlink" title="D. Step Up Robot"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_d">D. Step Up Robot</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>dp[i]表示i点能否从0到达. 我用的刷表法, 每个i点更新n个新状态.</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-type">int</span> m;  cin &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">is_trap</span><span class="hljs-params">(<span class="hljs-number">200&#x27;000</span> + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> x;  cin &gt;&gt; x;<br>        is_trap[x] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> x;  cin &gt;&gt; x;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">200&#x27;000</span> + <span class="hljs-number">10</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= x; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (is_trap[i])     <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> inc : a) &#123;<br>            dp[i + inc] |= dp[i];<br>        &#125;<br>    &#125; <span class="hljs-built_in">LOG</span>(dp[x])<br>    <span class="hljs-keyword">if</span> (dp[x]) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Swap-Places"><a href="#E-Swap-Places" class="headerlink" title="E. Swap Places"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_e">E. Swap Places</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>新套路get. 难得赛时能想出这种没见过的东西.</p><p>两点绑定在一起进行 bfs.</p><p>queue 的元素为&#x2F;[当前a所在节点, 当前b所在节点, 已经走过的步数&#x2F;]</p><p>同时用<code>dp[i][j]</code>表示a到i, 且同时b到j的最小步数</p><p>每个状态只会入队出队一次, 复杂度O(n2)</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : c)   cin &gt;&gt; x;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;<br>        u --, v --;<br>        g[u].<span class="hljs-built_in">pb</span>(v);<br>        g[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, inf)); <span class="hljs-comment">// </span><br>    dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    queue&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [ca, cb, cd] = q.<span class="hljs-built_in">front</span>();  q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (ca == n - <span class="hljs-number">1</span> &amp;&amp; cb == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; cd &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> na : g[ca]) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nb : g[cb]) &#123;<br>                <span class="hljs-keyword">if</span> (c[na] == !c[nb] &amp;&amp; dp[na][nb] &gt; dp[ca][cb] + <span class="hljs-number">1</span>) &#123;<br>                    dp[na][nb] = dp[ca][cb] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;na, nb, dp[na][nb]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-flip-1"><a href="#A-flip-1" class="headerlink" title="A. flip"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc289_a">A. flip</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_最短路</tag>
      
      <tag>算法_并查集</tag>
      
      <tag>算法_图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 01.30-02.05</title>
    <link href="/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/"/>
    <url>/2023/02/06/%E5%91%A8%E8%AE%B0%20-%202023%2001.30-02.05/</url>
    
    <content type="html"><![CDATA[<h2 id="02-03-周五-多云-小雨"><a href="#02-03-周五-多云-小雨" class="headerlink" title="02.03 周五 多云~小雨"></a>02.03 周五 多云~小雨</h2><p>今天主要参加了晚上10点半的div4 849. 开局虽然又被E (R1100)卡了下, 不过还是很快能搞定. F题一开始想不到好做法, 本来打算写树状数组, 但是没整理板子, 区间修改之类的又得重新写, 所以就投机取巧试了试用set维护还能修改的坐标. 一交, 诶居然能过. 然后就没理了.</p><p>G1和G2我一开始以为做了G2, G1也能一起交. 所以G1的罚时多了很多. G2我一开始想错了, 不过还是很快想到了二分. 并且很快写完了. 一看才400+人过. 暗自窃喜. 正式榜甚至进了首页, 表现分高达2050! zwling还觉得我能直接上蓝.  </p><p>没想到小丑竟是我自己…F和G2都FST了. 早知道F老老实实写区间修改 + 单点查询 树状数组了. G2是因为二分边界<code>l = 0</code>写成了<code>l = 1</code>. 我是真的讨厌这种下标从0开始, 从1开始的臭东西. 以后想坚定做下标0-base党了. 不过看到G2居然是R1900的题, 十分震惊. 感觉其他R1900的题比他难得不止一点半点.</p><h2 id="02-04-周六-小雨-中雨"><a href="#02-04-周六-小雨-中雨" class="headerlink" title="02.04 周六 小雨~中雨"></a>02.04 周六 小雨~中雨</h2><p>晚上有Atcoder Beginner Contest 288. 8点麻木地开打, 前两题签完到, C题经典手速慢的惊人, 一开始写toposort, 发现不对劲, 才改并查集. D题罚坐1个半小时, 一看全场就800+过, 是真的逆天. 属于那种大聪明之差分性质挖掘题. rk2000+, 直接完蛋, 不过最终-6. Atcoder yyds!</p><h2 id="02-05-周日-小雨"><a href="#02-05-周日-小雨" class="headerlink" title="02.05 周日 小雨"></a>02.05 周日 小雨</h2><p>晚上8点 tourist场的div2. 难得不是阴间时间, 但是考虑到tourist出题, 上次div1+div2合并场的A都给我干趴下了. 这次也不例外, A1 + A2直接给我整了半个小时. B题又是上下限约束题, 想了挺久才想出来. C题贪心, 但是本来1层循环4行的东西, 我写了一堆if 的答辩东西. 还WA了一发. 一看rk2000+. 好家伙我赛前看见register人数18000+, 现在只有7000+提交, 是真的逆天. 不过还好一分没丢没涨.</p><p>D结论瞎撞撞对了, 不过是真的难写. 其实主要是我的思路十分混乱, 其实只用把每个人视作多个 &lt;need char, give char&gt; 就行了. 先是恰好互补的人交换. 交换完剩下的一定只有3种人, 这3种人恰好能组成交换环.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：02.06日晚22点</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - CP模板</title>
    <link href="/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/02/06/%E7%AC%94%E8%AE%B0%20-%20CP%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="FOR-MORE"><a href="#FOR-MORE" class="headerlink" title="FOR MORE"></a>FOR MORE</h2><p>Please refer to <a href="https://lcj2021.github.io/cp_library/">channing’s cp_library</a></p><h2 id="计数模板"><a href="#计数模板" class="headerlink" title="计数模板"></a>计数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ModInt</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> mod = T;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">ModInt</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x % mod) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br>    ModInt <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x + a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;<br>    ModInt <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-type">int</span> x0 = x - a.x; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(x0 &lt; <span class="hljs-number">0</span> ? x0 + mod : x0); &#125;<br>    ModInt <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">ModInt</span>(<span class="hljs-number">1LL</span> * x * a.x % mod); &#125;<br>    ModInt <span class="hljs-keyword">operator</span> / (<span class="hljs-type">const</span> ModInt &amp;a) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> * a.<span class="hljs-built_in">inv</span>(); &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="hljs-keyword">if</span> (x &gt;= mod) x -= mod; &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> -= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) x += mod; &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> *= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; x = <span class="hljs-number">1LL</span> * x * a.x % mod; &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> /= (<span class="hljs-type">const</span> ModInt &amp;a) &#123; *<span class="hljs-keyword">this</span> = *<span class="hljs-keyword">this</span> / a; &#125;<br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-keyword">return</span> os &lt;&lt; a.x;&#125;<br>    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span> &gt;&gt; (istream &amp;os, <span class="hljs-type">const</span> ModInt &amp;a) &#123; <span class="hljs-type">int</span> v; os &gt;&gt; v; a = <span class="hljs-built_in">ModInt</span>(v); <span class="hljs-keyword">return</span> os;&#125;<br>    <br>    <span class="hljs-function">ModInt <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">ModInt <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">mul</span><span class="hljs-params">(x)</span></span>;<br>        <span class="hljs-keyword">while</span>(n) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= mul;<br>            mul *= mul;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function">ModInt <span class="hljs-title">inv</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">int</span> a = x, b = mod, u = <span class="hljs-number">1</span>, v = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-type">int</span> t = a / b;<br>            a -= t * b; <span class="hljs-built_in">swap</span>(a, b);<br>            u -= t * v; <span class="hljs-built_in">swap</span>(u, v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u += mod;<br>        <span class="hljs-keyword">return</span> u;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">using</span> mint = ModInt&lt;mod&gt;;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;T&gt; tr;<br>    <span class="hljs-built_in">fenwick</span>(<span class="hljs-type">int</span> n): <span class="hljs-built_in">n</span>(n) &#123;tr.<span class="hljs-built_in">resize</span>(n);&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br>    <span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        T res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (++ pos; pos &gt;= <span class="hljs-number">1</span>; pos -= <span class="hljs-built_in">lowbit</span>(pos)) &#123;<br>            res += tr[pos];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (++ pos; pos &lt;= n; pos += <span class="hljs-built_in">lowbit</span>(pos)) &#123;<br>            tr[pos] += val;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串-双-哈希"><a href="#字符串-双-哈希" class="headerlink" title="字符串(双)哈希"></a>字符串(双)哈希</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-type">hash_t</span> = array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod0 = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, mod1 = <span class="hljs-number">1e9</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">hash_t</span> base = &#123;<span class="hljs-number">13331</span>, <span class="hljs-number">23333</span>&#125;;<br><span class="hljs-type">hash_t</span> pw[N];<br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> + (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-type">hash_t</span> res = &#123;(a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>]) % mod0, (a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>]) % mod1&#125;;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> - (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-type">hash_t</span> res = &#123;(a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>] + mod0) % mod0, (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] + mod1) % mod1&#125;;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> * (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-keyword">return</span> &#123;a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>] % mod0, a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>] % mod1&#125;;<br>&#125;<br><br>pw[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++ i) &#123;<br>    pw[i] = pw[i - <span class="hljs-number">1</span>] * base;<br>&#125;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++ i) &#123;<br>    pre[i] = pre[i - <span class="hljs-number">1</span>] * base + <span class="hljs-type">hash_t</span>&#123;s[i], s[i]&#125;;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * n; i &gt;= <span class="hljs-number">1</span>; -- i) &#123;<br>    suf[i] = suf[i + <span class="hljs-number">1</span>] * base + <span class="hljs-type">hash_t</span>&#123;s[i], s[i]&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2023.01.18:</p><p>加入计数模板 + 字符串双哈希模板</p><p>2023.02.06:</p><p>加入朴素fenwick模板</p><p>等cf上1500 &#x2F; atcoder上青名, 就着手构建自己的library</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记_模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 848 (Div. 2) A-D</title>
    <link href="/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/"/>
    <url>/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20848%20(Div.%202)%20A-D/</url>
    
    <content type="html"><![CDATA[<p>比赛次日早上做的题, 50min内能出ABC, 感觉前面题目不难.</p><p>补题: D期望dp, 期望公式dp[i]依赖于dp[i-1]和dp[i+1], 每一项dp都用k*dp[1]+b的形式表示. 递推到最后一项dp[n]&#x3D;dp[n-1]+1. 从而求出dp[1]</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定由 1 和 -1 组成的数组，你必须选择两个相邻元素，然后翻转它们的符号。</p><p>求翻转后数组的最大和。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于相邻的2个数, 总共3种情况:</p><ol><li>(-1, -1)             总贡献 +4</li><li>(-1, 1) &#x2F; (1, -1)    总贡献 0</li><li>只有(1, 1)           总贡献 -4</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">all</span>(a), <span class="hljs-number">0</span>);<br>    <span class="hljs-type">bool</span> add0 = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; a[i] == <span class="hljs-number">-1</span> &amp;&amp; a[i + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; ans + <span class="hljs-number">4</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; a[i] * a[i + <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) &#123;<br>            add0 = <span class="hljs-literal">true</span>;   <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (add0)   cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>        cout &lt;&lt; ans - <span class="hljs-number">4</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定排列 p 和数组 a和正整数d.</p><p>定义a是不好数组, 如果对于所有a[1~m-1], 都有pos[a[i]] &lt; pos[a[i+1]] &lt;&#x3D; pos[a[i]] + d</p><p>比如: p&#x3D;[4,2,1,3,6,5] 和 d&#x3D;2</p><blockquote><p>a&#x3D;[2,3,6] is a not good array.<br>a&#x3D;[2,6,5] is good because pos(a1)&#x3D;2, pos(a2)&#x3D;5, so the condition pos(a2)≤pos(a1)+d is not satisfied.<br>a&#x3D;[1,6,3] is good because pos(a2)&#x3D;5, pos(a3)&#x3D;4, so the condition pos(a2)&lt;pos(a3) is not satisfied.</p></blockquote><p>请多次交换排列p中相邻的元素，使得a变成好数组</p><p>求最少交换次数。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>要破坏现有满足的2个条件, 只需要破坏其中一个条件就行.</p><p>枚举每个数, 分别计算破坏左边不等式和右边不等式的代价. 取个min就行</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span>, <span class="hljs-title">a</span><span class="hljs-params">(m)</span>, <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cin &gt;&gt; p[i];    p[i] --;<br>        pos[p[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : a)  cin &gt;&gt; x, x --;<br>    <span class="hljs-type">int</span> ans = n;<br>    <span class="hljs-built_in">LOG</span>(a)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> x = a[i], y = a[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> px = pos[x], py = pos[y];<br>        <span class="hljs-keyword">if</span> (px + n - <span class="hljs-number">1</span> - py &gt;= d - (py - px) + <span class="hljs-number">1</span>)   ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(d - (py - px) + <span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)<span class="hljs-number">0</span>));<br>        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(py - px, (<span class="hljs-type">int</span>)<span class="hljs-number">0</span>));<br>    &#125; <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Flexible-String"><a href="#C-Flexible-String" class="headerlink" title="C. Flexible String"></a><a href="https://codeforces.com/contest/1778/problem/C">C. Flexible String</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>现有字符串 a,b 。请选择修改 a 中至多 k 种 字符，对于 每一个 这样的字符，都可以将其改为另一个其他字符。</p><p>求修改后 a’ 的子串以及 b 的子串中，满足 a’[l..r] &#x3D; b[l..r] 的数量的最大值。保证 a 中至多有 10 种字符。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>n(1e5), k(10).</p><p>暴力二进制枚举子集, 最高O(2^10 * 1e5), 2s能接受.</p><p>枚举每个子集, 对于a[i], 若是子集里的字母, 都替换成b[i]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1024 * 1e5 2s 应该能过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    string a, b;    cin &gt;&gt; a &gt;&gt; b;<br>    string unique_a = a;<br>    <span class="hljs-built_in">uniq</span>(unique_a);<br>    <span class="hljs-type">int</span> m = unique_a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">LOG</span>(unique_a, m)<br><br>    <span class="hljs-keyword">if</span> (k &gt;= m) &#123;<br>        cout &lt;&lt; n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; val &lt; (<span class="hljs-number">1</span> &lt;&lt; m); ++ val) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">popcountll</span>(val) == k) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; m; ++ b) &#123;<br>            <span class="hljs-keyword">if</span> (val &gt;&gt; b &amp; <span class="hljs-number">1</span>) &#123;<br>                change[unique_a[b] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>, curr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (change[a[i] - <span class="hljs-string">&#x27;a&#x27;</span>] || a[i] == b[i]) &#123;<br>                len ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curr += len * (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                len = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len)    curr += len * (len + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, curr);<br>    &#125; <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Flexible-String-Revisit"><a href="#D-Flexible-String-Revisit" class="headerlink" title="D. Flexible String Revisit"></a><a href="https://codeforces.com/contest/1778/problem/D">D. Flexible String Revisit</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定两个二进制串 a, b.</p><p>每次随意翻转一个二进制位，求第一次使得 a&#x3D;b 所需的期望次数。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设有 i 个二进制位不同的情况下，所需的次数是 dp[i] ，则有转移方程：</p><p><code>dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</code></p><p>其含义是，我们进行一次翻转后，有 i&#x2F;n 的概率减少一个不同的位，这样就还需要 dp[i−1] 次；其他情况下将增加一个不同的位，则还需要 dp[i+1] 次。特别地， dp[0]&#x3D;0， dp[n]&#x3D;1+dp[n−1]</p><p>但是(しかし), 期望公式dp[i]依赖于dp[i-1]和dp[i+1]. 而我们的初始状态只有dp[0]&#x3D;0. 因此需要通过解方程的方式才能得到答案</p><p>$$<br>dp[i] &#x3D; 1 + dp[i + 1] * (n - i) &#x2F; n + dp[i - 1] * (i) &#x2F; n \</p><p>dp[i - 1] &#x3D; 1 + dp[i] * (n - i + 1) &#x2F; n + dp[i - 2] * (i - 1) &#x2F; n \</p><p>dp[i - 1] &#x3D; 1 + dp[i] * (1 - (i-1) &#x2F; n) + dp[i - 2] * (i - 1) &#x2F; n   \</p><p>dp[i] &#x3D; (dp[i-1] - 1 - dp[i-2] * (i-1) &#x2F; n) &#x2F; (1 - (i-1)&#x2F;n) \<br>$$</p><p>dp[2] &#x3D; dp[1] + … &#x3D; k * dp[1] + b</p><p>用 dp[1] 看作已知，各个 dp[i] 表示为k * dp[1] + b.</p><p>一直到 dp[n] &#x3D; 1 + dp[n - 1]</p><p>dp[n] - dp[n - 1] &#x3D; k * dp[1] + b &#x3D; 1, 这里的k和b都是已经通过递推算出来的, 所以dp[1]的值也就算出来了.</p><p>答案就是<code>dp[diff_cnt][0] * dp[1] + dp[diff_cnt][1]</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;mint, 2&gt; <span class="hljs-keyword">operator</span>-(array&lt;mint, <span class="hljs-number">2</span>&gt; a, array&lt;mint, <span class="hljs-number">2</span>&gt; b) &#123;<br> <span class="hljs-keyword">return</span> array&lt;mint, <span class="hljs-number">2</span>&gt; &#123;a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>]&#125;;<br>&#125;<br>array&lt;mint, 2&gt; <span class="hljs-keyword">operator</span>-(array&lt;mint, <span class="hljs-number">2</span>&gt; a, mint b) &#123;<br> <span class="hljs-keyword">return</span> array&lt;mint, <span class="hljs-number">2</span>&gt; &#123;a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]-b&#125;;<br>&#125;<br>array&lt;mint, 2&gt; <span class="hljs-keyword">operator</span>*(array&lt;mint, <span class="hljs-number">2</span>&gt; a, mint b) &#123;<br> <span class="hljs-keyword">return</span> array&lt;mint, <span class="hljs-number">2</span>&gt; &#123;a[<span class="hljs-number">0</span>]*b, a[<span class="hljs-number">1</span>]*b&#125;;<br>&#125;<br>array&lt;mint, 2&gt; <span class="hljs-keyword">operator</span>/(array&lt;mint, <span class="hljs-number">2</span>&gt; a, mint b) &#123;<br> <span class="hljs-keyword">return</span> array&lt;mint, <span class="hljs-number">2</span>&gt; &#123;a[<span class="hljs-number">0</span>]/b, a[<span class="hljs-number">1</span>]/b&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;          cin &gt;&gt; n;<br>    string a, b;    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)    diff += (a[i] != b[i]);<br><br>    <span class="hljs-comment">// dp[i]: 有i个不同之处的期望: dp[i][0] * dp[1] + dp[i][1]</span><br>    vector&lt;array&lt;mint, 2&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);   <br>    dp[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    dp[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// dp[i] = 1 + dp[i + 1] * (n - i) / n + dp[i - 1] * (i) / n</span><br>    <span class="hljs-comment">// dp[i - 1] = 1 + dp[i] * (n - i + 1) / n + dp[i - 2] * (i - 1) / n</span><br>    <span class="hljs-comment">// dp[i - 1] = 1 + dp[i] * (1 - (i-1) / n) + dp[i - 2] * (i - 1) / n</span><br>    <span class="hljs-comment">// dp[i] = (dp[i-1] - 1 - dp[i-2] * (i-1) / n) / (1 - (i-1)/n)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        dp[i] = (dp[i<span class="hljs-number">-1</span>] - <span class="hljs-built_in">mint</span>(<span class="hljs-number">1</span>) - dp[i<span class="hljs-number">-2</span>] * <span class="hljs-built_in">mint</span>(i<span class="hljs-number">-1</span>) / <span class="hljs-built_in">mint</span>(n)) / (<span class="hljs-built_in">mint</span>(<span class="hljs-number">1</span>) - <span class="hljs-built_in">mint</span>(i<span class="hljs-number">-1</span>)/<span class="hljs-built_in">mint</span>(n));<br>    &#125;<br><br>    <span class="hljs-comment">// dp[n] = 1 + dp[n - 1]</span><br>    <span class="hljs-comment">// dp[n] - dp[n - 1] = d[0] * dp[1][0] + d[1] = 1</span><br>    <span class="hljs-comment">// k = dp[1][0] = (1 - d[1]) / d[0]</span><br>    array&lt;mint, 2&gt; d = dp[n] - dp[n - <span class="hljs-number">1</span>];<br>    mint k = (<span class="hljs-built_in">mint</span>(<span class="hljs-number">1</span>) - d[<span class="hljs-number">1</span>]) / d[<span class="hljs-number">0</span>];<br>    cout &lt;&lt; dp[diff][<span class="hljs-number">0</span>] * k + dp[diff][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-Flip-Flop-Sum"><a href="#A-Flip-Flop-Sum" class="headerlink" title="A. Flip Flop Sum"></a><a href="https://codeforces.com/contest/1778/problem/A">A. Flip Flop Sum</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_暴力</tag>
      
      <tag>算法_数学</tag>
      
      <tag>算法_概率期望</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Educational Round 142 (Div. 2) A-D</title>
    <link href="/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/"/>
    <url>/2023/02/02/%E9%A2%98%E8%A7%A3%20-%20Educational%20Round%20142%20(Div.%202)%20A-D/</url>
    
    <content type="html"><![CDATA[<p>C题洗澡的时候想了挺久, 还是想出正解了. 并且D题属于一眼Trie, 但是不太会倒映射.</p><p>6号中午做了一下B, 是那种讨论题. 虽说只有1200分, 但我还是WA了2发, 并且花了半个小时. 是真的难顶.</p><h2 id="B-Stand-up-Comedian"><a href="#B-Stand-up-Comedian" class="headerlink" title="B. Stand-up Comedian"></a><a href="https://codeforces.com/contest/1792/problem/B">B. Stand-up Comedian</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>Stand-up Comedian: 单口相声演员</p><p>有四种类型的笑话：</p><blockquote><p>第一种: 使AB的情绪都 +1</p><p>第二种: 使A的情绪 +1, B的情绪-1</p><p>第三种: 使A的情绪 -1, B的情绪+1</p><p>第四种会使AB的情绪都-1</p></blockquote><p>两人的情绪初始为0. 求在AB中某一人情绪降至0时可以讲的最大笑话数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>又犯了经典错误之 <code>b -= min(b, c);   c -= min(b, c);</code>.</p><p>第一种类型直接加上</p><p>所以 ans +&#x3D; a</p><p>第二种类型和第三种类型交替使用.</p><p>所以 ans +&#x3D; min(b, c)</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价.</p><p>所以 ans +&#x3D; min(a + 1, b + c + d)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>    <span class="hljs-type">int</span> ans = a;<br>    <span class="hljs-keyword">if</span> (a) &#123;<br>        <span class="hljs-type">int</span> dec = <span class="hljs-built_in">min</span>(b, c);<br>        ans += dec * <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// b -= min(b, c);</span><br>        <span class="hljs-comment">// c -= min(b, c);</span><br>        b -= dec;<br>        c -= dec;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(a, b, c, d)<br>    <span class="hljs-comment">// 此时 bc与d的地位等价</span><br>    ans += <span class="hljs-built_in">min</span>(a + <span class="hljs-number">1</span>, b + c + d);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort"><a href="#C-Min-Max-Sort" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个排列p, 每次可以选两个数x和y, 将两者较小的移到开头, 较大的移到</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价结尾..</p><p>问排成增序所需最小操作次数.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先可以确定操作次数上限是n&#x2F;2, 即(n&#x2F;2, n&#x2F;2+1)…(1, n).</p><p>接下来再看怎么样能少操作几次.</p><p>例子: 1 6 3 4 2 5. (3, 4)一开始就挨在一起了, 并且是(3, 4)而不是(4, 3), 所以可以省略掉这一步, 直接考虑(2, 5). 发现(2, 5)并不分别位于(2, 3)的左右两侧. 所以这一步是必不可少的操作</p><p>如果情况是 1 2 3 4 6 5, 那么(3, 4)和(2, 5)都可以省略了. 只需要做一次(1, 6)操作就行.</p><p>结论就是 (n&#x2F;2, n&#x2F;2+1) 在最中间, 然后n&#x2F;2-1, n&#x2F;2+2分别位于(n&#x2F;2, n&#x2F;2+1)左右两侧, 如果某对逆序了, 或者没有位于两侧, 那么接下来的操作都不能省略.</p><p>用pos记下每个数的位置, l, r记录上一对数对的位置(注意n为奇数的情况, 此时中间只有一个数, 所以l &#x3D; r) 然后从中间开始枚举, 依次判断数对的相对位置就行.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cin &gt;&gt; a[i];   a[i] --;<br>        pos[a[i]] = i;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(a)<br><br>    <span class="hljs-comment">// 4: </span><br>    <span class="hljs-comment">// 0 1 2 3</span><br>    <span class="hljs-comment">// 5: 2</span><br>    <span class="hljs-comment">// 0 1 2 3 4</span><br>    <span class="hljs-type">int</span> ans = n / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = pos[n / <span class="hljs-number">2</span>], r = pos[n / <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (; i &lt; n / <span class="hljs-number">2</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> v1 = (n - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span> - i, v2 = n - <span class="hljs-number">1</span> - v1;<br>        <span class="hljs-built_in">LOG</span>(v1, v2)<br>        <span class="hljs-type">int</span> p1 = pos[v1], p2 = pos[v2];<br>        <span class="hljs-keyword">if</span> (p1 &gt; p2 || !(p1 &lt;= l &amp;&amp; p2 &gt;= r)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        l = p1, r = p2;<br>    &#125;<br>    ans -= i;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Fixed-Prefix-Permutations"><a href="#D-Fixed-Prefix-Permutations" class="headerlink" title="D. Fixed Prefix Permutations"></a><a href="https://codeforces.com/contest/1792/problem/D">D. Fixed Prefix Permutations</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定 n 个 1<del>m 的排列a[1</del>n].</p><p>定义一个排列的分值为: 最大的满足 p1&#x3D;1,p2&#x3D;2,….,pk&#x3D;k 的 k .</p><p>定义两个排列 p,q 的乘积 p×q&#x3D;r 为 r[j]&#x3D;q[p[j]].</p><p>对于每个排列a[i], 求出它乘以所有这 n 个排列a[j]能得到的最大分值.</p><p>最后时刻, 最后一类和剩下的第二第三类地位等价.</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>学习(偷)了日本大神maspy的Trie板子.</p><p>固定的a[i], 记为p. a[j], 记为q. r[i] &#x3D; q[p[i]] &#x3D; i</p><p>q[p[i]] &#x3D; i. 两边同时取q^-1, 也就是取pos_q.</p><p>p[i] &#x3D; pos_q[i] &#x3D; i. 也就是找p[i]和所有pos_q[i]最长的公共前缀. 只需要把所有的pos_q建一个Trie. 然后每次查询p[i]时, 在pos_q中找最长公共前缀的长度就行.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector <span class="hljs-title">p</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<br>    <span class="hljs-function">vector <span class="hljs-title">pos</span><span class="hljs-params">(n, vector&lt;<span class="hljs-type">int</span>&gt;(m))</span></span>;<br>    Trie&lt;<span class="hljs-number">10</span>&gt; tr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            cin &gt;&gt; p[i][j];     p[i][j] --;<br>            pos[i][p[i][j]] = j;<br>        &#125;<br>        <br>        tr.add&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(pos[i], <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-built_in">LOG</span>(pos[i])<br>        <span class="hljs-type">int</span> cv = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            cv = tr.TO[cv][p[i][j]];<br>            <span class="hljs-built_in">LOG</span>(cv)<br>            <span class="hljs-keyword">if</span> (cv == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">break</span>;<br>            ++ cnt;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Min-Max-Sort-1"><a href="#C-Min-Max-Sort-1" class="headerlink" title="C. Min Max Sort"></a><a href="https://codeforces.com/contest/1792/problem/C">C. Min Max Sort</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_数据结构</tag>
      
      <tag>算法_字符串</tag>
      
      <tag>算法_构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 287 A-F</title>
    <link href="/2023/01/29/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20287%20A-F%20+%20Ex/"/>
    <url>/2023/01/29/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20287%20A-F%20+%20Ex/</url>
    
    <content type="html"><![CDATA[<p>F是看似n^3, 实则n^2的树形dp, 用日语就是”二乗の木 DP”. 关键词: 树上子树dp + 连通块.</p><p>同时学到了: <strong><code>array&lt;int, 2&gt;</code>比<code>vector&lt;int&gt;(2)</code>快很多</strong></p><h2 id="A-Majority"><a href="#A-Majority" class="headerlink" title="A. Majority"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_a">A. Majority</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        string s;   cin &gt;&gt; s;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;For&quot;</span>) ++ c;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c &gt; n / <span class="hljs-number">2</span>)  cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Postal-Card"><a href="#B-Postal-Card" class="headerlink" title="B. Postal Card"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_b">B. Postal Card</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>判断后缀串是否出现在<code>set&lt;string&gt;</code> 中</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cin &gt;&gt; s[i];<br>        s[i] = s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>);<br>    &#125;<br>    set&lt;string&gt; S;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        string x;   cin &gt;&gt; x;<br>        S.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>        ans += S.<span class="hljs-built_in">count</span>(x);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Path-Graph"><a href="#C-Path-Graph" class="headerlink" title="C. Path Graph?"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_c">C. Path Graph?</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>判断一张简单无向图是否为一条链.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>max度数 &lt;&#x3D; 2 + <strong>连通性判断</strong></p><p>赛时写的toposort</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;<br>        u --, v --;<br>        g[u].<span class="hljs-built_in">pb</span>(v); g[v].<span class="hljs-built_in">pb</span>(u);<br>        ++ deg[u], ++ deg[v];<br>    &#125;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">1</span>) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> cv = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        st[cv] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nv : g[cv]) <span class="hljs-keyword">if</span> (!st[nv]) &#123;<br>            <span class="hljs-keyword">if</span> (-- deg[nv] &lt;= <span class="hljs-number">1</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(nv);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(st)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : st) &#123;<br>        <span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Match-or-Not"><a href="#D-Match-or-Not" class="headerlink" title="D. Match or Not"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_d">D. Match or Not</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定字符串s(n [1, 3e5])和t(n&gt;&#x3D;m [1, 3e5]). 只由’?’和小写字母组成.</p><p>每次在s前面取i个, 后面取m-i个, 拼起来组成s’. 问s’能否跟t匹配?</p><p>PS: ‘?’可以替换成任意小写字母</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>前面取i个, 后面取m-i个. 想到前后缀. 统计前后缀跟t匹配的字符数量. 若前缀+后缀匹配数量 &#x3D;&#x3D; m, 则成功</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s, t;    cin &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>    s = <span class="hljs-string">&quot; &quot;</span> + s;    t = <span class="hljs-string">&quot; &quot;</span> + t;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> ok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[i])   ok = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;?&#x27;</span> || t[i] == <span class="hljs-string">&#x27;?&#x27;</span>) ok = <span class="hljs-number">1</span>;<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + ok;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= n - m + <span class="hljs-number">1</span>; -- i) &#123;<br>        <span class="hljs-type">int</span> ok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == t[i - n + m])   ok = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;?&#x27;</span> || t[i - n + m] == <span class="hljs-string">&#x27;?&#x27;</span>) ok = <span class="hljs-number">1</span>;<br>        suf[i] = suf[i + <span class="hljs-number">1</span>] + ok;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(pre)<br>    <span class="hljs-built_in">LOG</span>(suf)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> sum = pre[i] + suf[i + n - m + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">LOG</span>(i, i + n - m + <span class="hljs-number">1</span>, sum)<br>        <span class="hljs-keyword">if</span> (sum == m)   cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Karuta"><a href="#E-Karuta" class="headerlink" title="E. Karuta"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_e">E. Karuta</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给n个字符串, 问每个串和其他所有串的 LCP(最长公共前缀) 的最大值</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>先把所有串建 Trie. 然后对每一个s[i]查一遍, 走到计数器只有1的时候就停, 输出当前深度, 复杂度O(∑ |s[i]| )</p><p>赛时多写了个二分, 头脑发热了.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//son记录他的子节点  cnt记录编号为idx的节点 对应字符串数量  idx为节点唯一编号</span><br><span class="hljs-comment">//遍历trie树 的时候注意： 终点是curr ！！！ 而不是 idx,  idx不一定会被更新</span><br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-type">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//curr表示当前节点 初始是 根节点 为空</span><br>    <span class="hljs-type">int</span> curr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; ++ i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>        <span class="hljs-comment">//如果他的儿子 为空</span><br>        <span class="hljs-keyword">if</span>(!son[curr][t]) son[curr][t] = ++idx;<br>        curr = son[curr][t];<br>        ++ cnt[curr];<br>    &#125;<br>    <span class="hljs-comment">//跑完在 字符串终点 ++cnt</span><br>    <span class="hljs-comment">// 终点是curr ！！！ 而不是 idx,  idx不一定会被更新</span><br>    <span class="hljs-comment">// ++ cnt[curr];</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> curr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; ++ i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[curr][t])  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        curr = son[curr][t];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[curr];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;x : s) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">insert</span>(x.<span class="hljs-built_in">data</span>());<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(s)<br>    <span class="hljs-built_in">LOG</span>(<span class="hljs-built_in">query</span>(<span class="hljs-string">&quot;bra&quot;</span>))<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> len = s[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, mid).<span class="hljs-built_in">data</span>()) &gt;= <span class="hljs-number">2</span>)    ok = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (ok)         l = mid;<br>            <span class="hljs-keyword">else</span>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; l &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-Components"><a href="#F-Components" class="headerlink" title="F.  Components"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_f">F.  Components</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一棵树n([1, 5000]), 问有多少个点集的导出子图恰好有x &#x3D; 0, 1, 2…n 个联通分量</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><a href="https://snuke.hatenablog.com/entry/2019/01/15/211812">日本大佬的blog</a></p><p>树形n^2 dp. 看似三层循环, 最坏会达到n^3, 其实应该从合并u和儿子v涉及到的边数考虑.</p><p>合并当前u的子树和孩子v的子树代价: <code>sz[u] *sz[v]</code>, 看最终结果便是: u的子树内所有节点两两之间都考虑过转移了. 也就是一个n个点的”完全图”(实际可能有些点对间没有连边), 即n*(n-1)&#x2F;2.</p><p><code>dp[i][j][0/1]</code>: 以i为根节点的子树, 且i 0不选&#x2F;1选, 形成的连通块个数. 共<code>[u][0], [u][1], [v][0], [v][1]</code> 4种情况</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;<br>        a --, b --;<br>        g[a].<span class="hljs-built_in">pb</span>(b); g[b].<span class="hljs-built_in">pb</span>(a);<br>    &#125;<br><br>    <span class="hljs-comment">// dp[i][j][0/1]: 以i为根的子树, 且选择了i, 形成j个连通块的方案数</span><br>    <span class="hljs-function">vector <span class="hljs-title">dp</span><span class="hljs-params">(n, vector&lt;array&lt;mint, <span class="hljs-number">2</span>&gt;&gt;(n + <span class="hljs-number">1</span>, array&lt;mint, <span class="hljs-number">2</span>&gt;&#123;&#125;))</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-comment">// function&lt;void(int, int)&gt; dfs = [&amp;](int u, int p) -&gt; void &#123;</span><br>    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span> dfs, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p) -&gt; <span class="hljs-type">void</span> &#123;<br>        sz[u] = <span class="hljs-number">1</span>;<br>        dp[u][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[u][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) <span class="hljs-keyword">if</span> (v != p) &#123;<br>            <span class="hljs-built_in">dfs</span>(dfs, v, u);<br>            <span class="hljs-comment">// vector ndp(n + 1, vector&lt;mint&gt;(2));                  </span><br>            <span class="hljs-function">vector <span class="hljs-title">ndp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, array&lt;mint, <span class="hljs-number">2</span>&gt;&#123;&#125;)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= sz[u]; ++ i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= sz[v]; ++ j) &#123;<br>                    ndp[i + j][<span class="hljs-number">0</span>] += dp[u][i][<span class="hljs-number">0</span>] * dp[v][j][<span class="hljs-number">0</span>];     <span class="hljs-comment">// u不拿, v可以拿, 也可以不拿</span><br>                    ndp[i + j][<span class="hljs-number">0</span>] += dp[u][i][<span class="hljs-number">0</span>] * dp[v][j][<span class="hljs-number">1</span>];<br><br>                    ndp[i + j][<span class="hljs-number">1</span>] += dp[u][i][<span class="hljs-number">1</span>] * dp[v][j][<span class="hljs-number">0</span>];     <span class="hljs-comment">// u  拿, v必须不拿, 连通块数量才可以不-1</span><br>                    <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>) &#123;                                   <span class="hljs-comment">// u  拿, v也拿, 那么u和v的2个连通块合并成1个了</span><br>                        ndp[i + j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] += dp[u][i][<span class="hljs-number">1</span>] * dp[v][j][<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(dp[u], ndp);<br>            sz[u] += sz[v];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        cout &lt;&lt; (dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">1</span>]).<span class="hljs-built_in">val</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Ex-Directed-Graph-and-Query"><a href="#Ex-Directed-Graph-and-Query" class="headerlink" title="Ex. Directed Graph and Query"></a><a href="https://atcoder.jp/contests/abc287/tasks/abc287_h">Ex. Directed Graph and Query</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>给定一张有向图g&lt;n, m&gt;(n [2, 2000]), 回答q组询问.</p><p>每组询问包括s和t, 问从s到t的路径的代价最小值.</p><p>一条路径的代价是其经过的点的编号的最大值.</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>如果n在500以内, 可以Floyd插点更新.</p><p>n [2, 2000] 也可以用bitset优化的Floyd传递闭包求解.</p><p><code>d[i][j]</code>表示i -&gt; j可以通过</p><p>最外层枚举插点k, 如果i能够到k, 那么k能够到的点, i也能到.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (d[i][k]) &#123;<br>            d[i] |= d[k];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次插完一个新点k, 就遍历一下所有q, 是否能更新答案.</p><p>总复杂度O(n^3 &#x2F; 64 + nq)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector <span class="hljs-title">d</span><span class="hljs-params">(n, bitset&lt;<span class="hljs-number">2000</span>&gt;())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;<br>        a --;   b --;<br>        d[a].<span class="hljs-built_in">set</span>(b);<br>    &#125;<br>    <span class="hljs-type">int</span> qc;     cin &gt;&gt; qc;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; <span class="hljs-built_in">q</span>(qc);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(qc, inf)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; qc; ++ i) &#123;<br>        <span class="hljs-type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;<br>        s --; t --;<br>        q[i] = &#123;s, t, i&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (d[i][k]) &#123;<br>                d[i] |= d[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [s, t, id] : q) &#123;<br>            <span class="hljs-keyword">if</span> (s &gt; k || t &gt; k) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (d[s][t]) &#123;<br>                ans[id] = <span class="hljs-built_in">min</span>(ans[id], k + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) &#123;<br>        <span class="hljs-keyword">if</span> (x &gt; inf / <span class="hljs-number">2</span>)    cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span>                cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_最短路</tag>
      
      <tag>算法_图论</tag>
      
      <tag>算法_数据结构</tag>
      
      <tag>算法_字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 01.16-01.29 (2023春节)</title>
    <link href="/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/"/>
    <url>/2023/01/24/%E5%91%A8%E8%AE%B0%20-%202023%2001.16-01.29%20(2023%E6%98%A5%E8%8A%82)/</url>
    
    <content type="html"><![CDATA[<h2 id="01-17-周四-大年廿八-阴"><a href="#01-17-周四-大年廿八-阴" class="headerlink" title="01.17 周四 大年廿八 阴"></a>01.17 周四 大年廿八 阴</h2><p>下午出发前往大旺, 傍晚到达. 晚上与大伯奶奶到早茶店吃饭.</p><h2 id="01-18-周五-大年廿九-晴"><a href="#01-18-周五-大年廿九-晴" class="headerlink" title="01.18 周五 大年廿九 晴"></a>01.18 周五 大年廿九 晴</h2><p>早上5点半起床. 六点钟到水岸与堂哥奶奶碰面. 奶奶和我们坐一辆车, 6点10分左右启程, 中途服务区休息一次. 11点多到达村口. 全程睡过来.</p><h2 id="01-21-周六-除夕-雨"><a href="#01-21-周六-除夕-雨" class="headerlink" title="01.21 周六 除夕 雨"></a>01.21 周六 除夕 雨</h2><p>晚上8点有Atcoder Beginner Contest 286. 由于长辈聊天的原因, 我迟到了20分钟, 还好我有先见之明, 提前unrated participation了. 开局到D还是很顺利的. E一眼n&#x3D;300, 鉴定为Floyd, 但是我对Floyd松弛时的更新没有深刻的理解, 导致赛后3分钟才调出E的错误. 何为”最短路松弛的理解”? 其实就是在能够松弛时, 要采取无条件赋值, 而不是取max. 这点在最短路计数上也是一样, 只不过当时是 +&#x3D; , 而不是赋值, 所以我忽视了这点.</p><p>本来老爸让我一定要在益罗塘山上睡一晚, 虽然俺喜欢看恐怖片血腥片, 但这是来真的啊我靠… 好在他在蹭网回去时改变了主意. 零点赏完烟花后入睡.</p><h2 id="01-22-周日-新年初一-晴"><a href="#01-22-周日-新年初一-晴" class="headerlink" title="01.22 周日 新年初一 晴"></a>01.22 周日 新年初一 晴</h2><p>晚上8点有Atcoder Regular Contest 154. 考虑到昨天晚上我因为种种原因晚了20分钟才下山参加比赛, 于是今晚也是unrated participation了. 开局A题直接不会, 贪心思路很容易, 就是让俩数尽可能差的大, 主要是长度为1e5的俩数相乘取模这一点没想好. 搞了一个钟头才摸出来. 什么龟速乘, 忽略高位的数都出来了… 我果然是一急啥蠢事都干了.</p><p>B题一开始看以为又是大聪明题. 但是分析了10分钟发现是可做的, WA了2发也是在半小时内搞出来了一个O(n)的做法. AB总共WA了5发, rk 1200+, 感觉还行, 至少不会掉分(要是A模数运算再熟练些会更好). 而且<strong>B题放我以前肯定是无法发现题目性质的</strong>. 可喜可贺, 希望在新的一年里思维上能有更大的进步!</p><h2 id="01-23-周一-新年初二-雨"><a href="#01-23-周一-新年初二-雨" class="headerlink" title="01.23 周一 新年初二 雨"></a>01.23 周一 新年初二 雨</h2><p>今天要跟奶奶去拜访舅公舅婆. 从恭上村到何家, 大概有20+分钟的车程. 只能说很尬, 那么多亲戚就没几个认识的. 所以我选择和堂哥在屋外聊天. 午饭和舅公一桌, 面对一桌的酸菜, 腌菜, 我TM直接干白饭.</p><p>晚上刷了会题, 刷不动了. 继续看了&lt;尸体派对&gt;第二集. 看了2集之后, 可能是我刚进军二次元不就, 接触的作品太少, 感觉这种恐怖重口题材的挺好看的, 也挺想买steam上的尸体派对几部作品, 奈何太贵, 等骨折了入手一波.</p><p>晚上堂哥又摆出烧烤架, 我蹭了一块鸡柳 + 一条烤肠, 上一次烧烤还是在高中的某次年级出游.</p><h2 id="01-24-周二-新年初三-晴"><a href="#01-24-周二-新年初三-晴" class="headerlink" title="01.24 周二 新年初三 晴"></a>01.24 周二 新年初三 晴</h2><p>晚上依然睡不好觉, 早上七点半起床, 开始收拾行李, 准备下山. 大约九点半时到达恭上村村口吃腌面. 饭后随堂哥驱车前往拜访南良叔. 路上得知南良叔之前的旧屋拆迁了, 据说补偿还不错. 路上被中国电信的捉急信号和高德地图的误导耽误了20分钟, 于10点半到达拜访. 寒暄过后, 11点从党溪村返回大旺, 全程500公里. 4点左右到达大旺. 到达后依然是与大伯奶奶聚餐, 饱餐一顿后送奶奶回家后便准备驱车返回广州.</p><p>返程较短, 所以我尝试开回来. 开了1小时多些, 平均时速块80, 高速上最高开到了120. 估摸着也快有1年没碰方向盘了, 感觉还行.</p><h2 id="01-25-周三-新年初四-晴"><a href="#01-25-周三-新年初四-晴" class="headerlink" title="01.25 周三 新年初四 晴"></a>01.25 周三 新年初四 晴</h2><p>白天在家刷题. 傍晚LY vx问我去不去看电影, 原来他今天回到广州. 于是就打算看8点场的&lt;流浪地球2&gt;.</p><p>本来没打算电影有多大的惊喜, 看了看前面的部分, 感觉有些镜头挺尬的. 刚开始注意到频繁出现的摄像头, 也不知道有啥用意. 直到片尾的彩蛋说550A才是策划一系列危机的幕后黑手, 我才有点懂了. 感觉550A可能就是通过摄像头学习了很多, 在逐月计划, 太空电梯那会的某个阶段产生了意识, 但是处于一种潜伏状态. 另外就是我对于”相控阵”和550A的初衷也是挺好奇的. 不过我认为&lt;流浪地球2&gt;似乎没有&lt;星际穿越&gt;那么难懂.</p><h2 id="01-26-周四-新年初五-晴"><a href="#01-26-周四-新年初五-晴" class="headerlink" title="01.26 周四 新年初五 晴"></a>01.26 周四 新年初五 晴</h2><p>白天在家刷题. 下午购物.</p><p>晚上刷到UP主&lt;那些无名之辈&gt;的动态<a href="https://www.bilibili.com/video/BV12G4y1D7V7/">最看天赋的专业之一：C9院校，同宿舍4个数学男，毕业7年后的生活现状</a>, C9数学专业毕业生生活现状. 1个米国top10计算机读博年收入42w, 1个瑞士读博年收入30+w, 1个学而思老师转广州竞赛教练年收入20+w, 1个本校物理读博年收入5w, 毕业offer60+w. 第三个好巧不巧刚好是竞赛教练, 还是广州的. 看来当前教培改革已经对这行造成了很大的影响. 本来心里最理想的职业看来也走不通了. 我认为这辈子是真的没有遇到真正热爱的东西, 直到大三正式入坑OI(CP &#x2F; ACM). 大四上学期的最后几个月, 可能是我这辈子最后一次为自己热衷的东西不计代价地追寻付出了. 万幸的是上天眷顾, 我找到了优秀的队友, 也选对了赛站, 在我的XCPC最后一舞中收获了牌子.</p><p>之前一直在抱怨高中, 不过今天收到了寒假回校宣讲的信息, 还是挺想回去看看的. 不过现在的我还没脸见江东父老 (哭).</p><h2 id="01-27-周五-新年初六-多云"><a href="#01-27-周五-新年初六-多云" class="headerlink" title="01.27 周五 新年初六 多云"></a>01.27 周五 新年初六 多云</h2><p>白天在家刷题. 下午购物</p><p>晚上有codeforces div3, 常规阴间时间. 本来还在想要不要打, 一看zwling已经报名了, 我也就报名了. 可以说是打得挺烂了. E题非得硬去分析二进制数位的性质, 结果还是得搞对拍. 整题搞了一个多小时, zwling说打表就行, 只花了10+min就搞定了. 妈的又是打表, 上次vp小白月赛的n(1e18)的模仿棋博弈也是没看出要打表. 不过由于cf号目前分段比较低, 所以rk1700+也+55.</p><h2 id="01-28-周六-新年初七-晴-ABC逆风翻盘的一集"><a href="#01-28-周六-新年初七-晴-ABC逆风翻盘的一集" class="headerlink" title="01.28 周六 新年初七 晴 (ABC逆风翻盘的一集)"></a>01.28 周六 新年初七 晴 (ABC逆风翻盘的一集)</h2><p>白天不想学习, 但是又找不到想玩的.</p><p>晚上有Atcoder Beginner Contest 287. 8点麻木地开打, 前两题签完到, C直接给我干趴下了. 判断一张图是不是一条<br>链, 我寻思着不是只用判断: “<code>度1点数==2</code> &amp;&amp; <code>度2点==n-2 </code>&amp;&amp; <code>边数==点数-1</code> “就行了嘛. 直接WA3发, 不过也不是第一次翻车了, 不就是经典codeforces经典卡div2 B嘛. 跳过C先做D, 一开始头脑发热又想不到, 不过好在冷静下来做出来了. 回过头看C, 我TM直接toposort总可以了吧, 于是就过了. 一看rk2000+, 如果不做出E翻盘, 那我的AT1200分青名计划就又要延期了. 看了E的题意, 涉及到前缀, “最大”长度, 我直接想到前缀数据结构Trie + 二分长度. 但是Trie的题也就acwing的模板题做过, 所以花了点时间现学, 把统计词频的代码改成了统计前缀词频, 就过了E. 结果rk1300+, 感觉还行, <strong>+21 to 1115</strong>. 此时还剩下30+分钟, F我想的是树上背包, 但是自知功力还未到. 所以直接开摆.</p><p>本来想早睡的, 但是睡前玩了会&lt;深岩银河&gt;, 又玩到12点半.</p><h2 id="01-28-周日-新年初八-晴"><a href="#01-28-周日-新年初八-晴" class="headerlink" title="01.28 周日 新年初八 晴"></a>01.28 周日 新年初八 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.24(2022春节初三)日晚22点 + 01.29</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 286 A-F</title>
    <link href="/2023/01/22/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20286%20A-F/"/>
    <url>/2023/01/22/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20286%20A-F/</url>
    
    <content type="html"><![CDATA[<p>F还没调出来, 看到maspy大佬用自己的板子熟练得一, 余数vector和除数vector一传, 直接调用自己写的crt函数就出答案了. 感觉等我思维练得差不多了也可以开始系统地学习这种”工程式”cp了</p><h2 id="A-Range-Swap"><a href="#A-Range-Swap" class="headerlink" title="A. Range Swap"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_a">A. Range Swap</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="B-Cat"><a href="#B-Cat" class="headerlink" title="B. Cat"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_b">B. Cat</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="C-Rotate-and-Palindrome"><a href="#C-Rotate-and-Palindrome" class="headerlink" title="C. Rotate and Palindrome"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_c">C. Rotate and Palindrome</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串s(长度n: [1, 5000]). 问通过任意次以下操作使其变成回文串的最小代价.</p><blockquote><p>操作1: s &#x3D; rotate(s.begin(), s.begin() + 1, s.end()) 即循环左移一位. 代价为a</p><p>操作2: 将任意的s[i]修改为c. 代价为b</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>n([1, 5000]): 暴力枚举左移位数 + 修改次数</p><p>左移可以用deque. 利用了pop_front(), push_back()和顺序容器随机访存的特性.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, a, b;    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>    string s;       cin &gt;&gt; s;<br>    deque&lt;<span class="hljs-type">char</span>&gt; dq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) dq.<span class="hljs-built_in">pb</span>(s[i]);<br>    <span class="hljs-type">int</span> best = n * b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> c_cost = (i) * a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; ++ j) &#123;<br>            c_cost += b * (dq[j] != dq[n - j - <span class="hljs-number">1</span>]);<br>        &#125;<br>        best = <span class="hljs-built_in">min</span>(best, c_cost);<br>        <span class="hljs-built_in">LOG</span>(dq, (i) * a, c_cost)<br>        <span class="hljs-keyword">auto</span> s0 = dq.<span class="hljs-built_in">front</span>();   dq.<span class="hljs-built_in">pop_front</span>();<br>        dq.<span class="hljs-built_in">pb</span>(s0);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(best)<br>    cout &lt;&lt; best &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Money-in-Hand"><a href="#D-Money-in-Hand" class="headerlink" title="D. Money in Hand"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_d">D. Money in Hand</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>手头上有n([1, 50])种货币, 第i种: 价值a([1, 100])元, 且拥有b([1, 50])张, 问能否用这些货币刚好凑出x([1, 10000])元</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>暴力分组背包dp即可. O(n * x * b)</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50</span> + <span class="hljs-number">5</span>, M = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> dp[N][M];<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        cin &gt;&gt; a[i] &gt;&gt; b[i];<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= x; ++ j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c * a[i] &lt;= j &amp;&amp; c &lt;= b[i]; ++ c) &#123;<br>                dp[i][j] |= dp[i - <span class="hljs-number">1</span>][j - c * a[i]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(dp[n][x])<br>    <span class="hljs-keyword">if</span> (dp[n][x])   cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Souvenir"><a href="#E-Souvenir" class="headerlink" title="E. Souvenir"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_e">E. Souvenir</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>有n([1, 300])个旅游目标城市, 给定这n个城市之间航班的邻接矩阵, 以及每个城市能购买的纪念品价值a[n]. 现在要求最优化以下目标:</p><blockquote><p>首要: 转机次数最小化</p><p>次要: 转机次数一定时, 最大化路过城市所能购买的纪念品价值</p></blockquote><p>给出q个询问. 每次询问S, T. 分别回答首要目标和次要目标. 若从S无法到达T, 输出”Impossible”</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>n([1, 300]) 一眼Floyd.</p><p>类似于<strong>最短路计数</strong>, 在最短路相同时<code>(dist[i][j] == dist[i][k] + dist[k][j])</code>, 不做最短路更新, 但是要做纪念品价值更新.</p><p><strong>在最短路能更新时, 所有更新均为无条件赋值!!!</strong>. 即不能取max之类的</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300</span> + <span class="hljs-number">10</span>, inf = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp1[N][N], dp2[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">memset</span>(dp1, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dp1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   dp1[i][i] = <span class="hljs-number">0</span>, dp2[i][i] = a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;<br>            <span class="hljs-type">char</span> c;     cin &gt;&gt; c;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;Y&#x27;</span>) &#123;<br>                dp1[i][j] = <span class="hljs-number">1</span>;<br>                dp2[i][j] = a[i] + a[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++ k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;<br>                <span class="hljs-keyword">if</span> (dp1[i][j] &gt; dp1[i][k] + dp1[k][j]) &#123;<br>                    <span class="hljs-comment">// 强制更新dp 不能取max</span><br>                    dp1[i][j] = dp1[i][k] + dp1[k][j];<br>                    dp2[i][j] = dp2[i][k] + dp2[k][j] - a[k];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp1[i][j] == dp1[i][k] + dp1[k][j]) &#123;<br>                    dp2[i][j] = <span class="hljs-built_in">max</span>(dp2[i][j], dp2[i][k] + dp2[k][j] - a[k]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;  cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q --) &#123;<br>        <span class="hljs-type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (dp1[l][r] &lt; inf / <span class="hljs-number">2</span>) &#123;<br>            cout &lt;&lt; dp1[l][r] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dp2[l][r] &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Impossible&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-Guess-The-Number-2"><a href="#F-Guess-The-Number-2" class="headerlink" title="F. Guess The Number 2"></a><a href="https://atcoder.jp/contests/abc286/tasks/abc286_f">F. Guess The Number 2</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>交互题</p><p>你需要猜出电脑给定的一个正整数n([1, 1e9]). 只能通过以下方式算出n:</p><blockquote><p>你给出一个排列a[m] (m: [1~110]).</p><p>电脑会根据a[m]返回一个数组b. b[i] &#x3D; a[ a[ a[i] ] ] … (共a[i]n次)</p></blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><strong>置换环 &#x2F; functional graph</strong> + <strong>中国剩余定理ChineseRemainTheory</strong></p><p>思路其实想了大概10分钟就出了, 因为b和a的关系其实就是在functional graph走了n步所到达的点. functional graph 置换环这类题之前vp 797 div3 做过一道<a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a>.</p><p>所以套路肯定是循环节长度, lcm. 这里变通一下就变成了知道循环节长度和其对应的模数.</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_最短路</tag>
      
      <tag>算法_数论</tag>
      
      <tag>算法_暴力</tag>
      
      <tag>算法_组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2023 01.09-01.15</title>
    <link href="/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/"/>
    <url>/2023/01/21/%E5%91%A8%E8%AE%B0%20-%202023%2001.09-01.15/</url>
    
    <content type="html"><![CDATA[<h2 id="01-09-周一-小雨"><a href="#01-09-周一-小雨" class="headerlink" title="01.09 周一  小雨"></a>01.09 周一  小雨</h2><p>早上十点开始vp Educational Codeforces Round 141. 嗯, 只做了2题, 第二题经典构造矩阵, 做了一个多小时. 其实C题我也不会, 是一道关于最佳可能排名的贪心题. 贪心还是得多练, 正解是二分. D题dp, muggle用的记忆化搜索, 看了他的代码感觉记搜确实得熟练起来.</p><p>晚上八点20开始vp 小白月赛65. 表现依然糟糕, 只会3题. 并且这次的B题是考察字符串匹配, 其实暴力n^2就行. 我非得试着用双指针. 这也暴露出我对字符串匹配的理解误区. 要是真能双指针直接瞎搞, 那还要啥KMP呢? D题这种1e18的一眼结论题, 但是没想过打表, 比赛经验太差. 正解是”模仿棋”. E构造, F贪心 + 树形dp.</p><h2 id="01-10-周二-小雨"><a href="#01-10-周二-小雨" class="headerlink" title="01.10 周二  小雨"></a>01.10 周二  小雨</h2><p>早上补了昨晚的DEF.</p><p>下午晚上补了我第一场牛客比赛(小白月赛34)的所有题. 基本以dp为主, 然后还有一道经典 矩阵每行取数, 求前k大的题. 堆 + 合并行贪心.</p><h2 id="01-11-周三-中雨"><a href="#01-11-周三-中雨" class="headerlink" title="01.11 周三  中雨"></a>01.11 周三  中雨</h2><p>早上10点开始vp 843(div2). 可以算是形势逆转的一局, 虽然一开始经典卡B, 但是对拍调完C之后, 还是想出了B. 赛后发现C有1600分.</p><h2 id="01-12-周四-小雨"><a href="#01-12-周四-小雨" class="headerlink" title="01.12 周四  小雨"></a>01.12 周四  小雨</h2><p>考虑到18号要回大埔过年, 早上先花了点时间下番&lt;更衣人偶坠入爱河&gt;, 但是没有外挂弹幕, 告辞, 晚点再来. 9点40开始vp 839(div3). 表现垃圾. 只会3道. D是拆绝对值 + 约束答案范围.</p><p>中午看到2022南京终于上了cf gym. 看到了&lt;高数100&gt;, 看到了自己和队友们的名字. 在第一页尾部, 相信很快就会被vp的大佬们压下去.  </p><p>下午2点郑老师发来vx说给我发些奖励, 问我银行卡之类的信息.</p><h2 id="01-13-周五-阴"><a href="#01-13-周五-阴" class="headerlink" title="01.13 周五  阴"></a>01.13 周五  阴</h2><p>下午1点突然想看看2022南京的正解, 于是想到zwling之前说的dianhsu写的插件. 用这个插件可以在别人的submission中查看gym的代码. 之后我下了dls的A和D的代码, 然而题目都记不清了.</p><p>下午3点开组会, 和顾学长一起获得了三等奖金, 发了言. 和组里的大部分同学都不熟, 所以挺紧张的.</p><p>组会上我得知很多学长学姐都在2022年做出了A类工作. 心情十分复杂, 想搞科研, 但是心里有放不下CP. 可能是心愿还没有达成吧. 至于这个心愿, 我也不知道具体是个什么样的目标.</p><h2 id="01-14-周六-阴"><a href="#01-14-周六-阴" class="headerlink" title="01.14 周六  阴"></a>01.14 周六  阴</h2><p>vp 844(div1+2)</p><h2 id="01-15-周日-阴"><a href="#01-15-周日-阴" class="headerlink" title="01.15 周日  阴"></a>01.15 周日  阴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：01.21(2022除夕)日午12点</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 89 A-D</title>
    <link href="/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/"/>
    <url>/2023/01/21/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%2089%20A-D/</url>
    
    <content type="html"><![CDATA[<h2 id="D-Practical-Skill-Test"><a href="#D-Practical-Skill-Test" class="headerlink" title="D - Practical Skill Test"></a><a href="https://atcoder.jp/contests/abc089/tasks/abc089_d">D - Practical Skill Test</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个h * w的矩阵a, 里面不重不漏地填充着[1, h * w]的数字. 现在给定一个正整数d ([1, h * w]), 并且给出q组询问:</p><blockquote><p>l, r</p><p>问: <code>a[x1][y1] == l</code> —&gt; <code>a[x2][y2] == l + d</code> —&gt; … —&gt; <code>a[xn][yn] == r</code></p><p>这段路所走过的曼哈顿距离是多少<br>曼哈顿距离: (x1, y1)与(x2, y2)的曼哈顿距离是|x1 - x2| + |y1 - y2|</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="倍增-我的思路"><a href="#倍增-我的思路" class="headerlink" title="倍增 (我的思路)"></a>倍增 (我的思路)</h4><p>既然无法记录从每个点(a值&#x3D;&#x3D;i)出发到[i+1, n]的所有距离, 那么就可以考虑倍增</p><p><code>to[i][j]</code>: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走到的点</p><p><code>dist[i][j]</code>: 表示从i点出发, 走了1 &lt;&lt; j个d的距离所走过的路程</p><p>边界: to超出h * w的部分要特判0</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> - (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; a, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(h + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(w + <span class="hljs-number">1</span>));<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a2cor</span>(h * w + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; ++ j) &#123;<br>            cin &gt;&gt; a[i][j];<br>            a2cor[a[i][j]] = &#123;i, j&#125;;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(h * w + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(h * w + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u + d &lt;= h * w; ++ u) &#123;<br>        to[u][<span class="hljs-number">0</span>] = u + d;<br>        dist[u][<span class="hljs-number">0</span>] = a2cor[u + d] - a2cor[u];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt; <span class="hljs-number">20</span>; ++ b) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= h * w; ++ u) &#123;<br>            to[u][b] = to[to[u][b - <span class="hljs-number">1</span>]][b - <span class="hljs-number">1</span>];<br>            dist[u][b] = dist[u][b - <span class="hljs-number">1</span>] + dist[to[u][b - <span class="hljs-number">1</span>]][b - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> binary_jump = [&amp;](<span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T) &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">19</span>; b &gt;= <span class="hljs-number">0</span>; -- b) <span class="hljs-keyword">if</span> (to[S][b] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (to[S][b] &lt;= T) &#123;<br>                ans += dist[S][b];<br>                S = to[S][b];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">assert</span>(S == T);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> q;  cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q --) &#123;<br>        <span class="hljs-type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; <span class="hljs-built_in">binary_jump</span>(l, r) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="前缀和-官方题解"><a href="#前缀和-官方题解" class="headerlink" title="前缀和 (官方题解)"></a>前缀和 (官方题解)</h4><p>pre[i] 表示a[i - kd] —&gt; a[i - (k-1)d] —&gt; a[i - d] —&gt; a[i] 的路程之和</p><p>pre[i] &#x3D; pre[i - d] + dist(i - d, i)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> - (array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; a, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> h, w, d;    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(h + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(w + <span class="hljs-number">1</span>));<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">a2cor</span>(h * w + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; ++ j) &#123;<br>            cin &gt;&gt; a[i][j];<br>            a2cor[a[i][j]] = &#123;i, j&#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(h * w + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= h * w; ++ i) &#123;<br>        pre[i] = pre[i - <span class="hljs-number">4</span>] + (a2cor[i] - a2cor[i - <span class="hljs-number">4</span>]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;  cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q --) &#123;<br>        <span class="hljs-type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; pre[r] - pre[l - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_数据结构</tag>
      
      <tag>算法_倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 284 A-F</title>
    <link href="/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/"/>
    <url>/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20284%20A-F/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Generalized-ABC"><a href="#A-Generalized-ABC" class="headerlink" title="A. Generalized ABC"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_a">A. Generalized ABC</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; -- i)   cout &lt;&lt; s[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Multi-Test-Cases"><a href="#B-Multi-Test-Cases" class="headerlink" title="B. Multi Test Cases"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_b">B. Multi Test Cases</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>        ans += (x &amp; <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Count-Connected-Components"><a href="#C-Count-Connected-Components" class="headerlink" title="C. Count Connected Components"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_c">C. Count Connected Components</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; p;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x == p[x] ? p[x] : p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    p.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">all</span>(p), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;<br>        u = <span class="hljs-built_in">find</span>(u), v = <span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-keyword">if</span> (u == v)     <span class="hljs-keyword">continue</span>;<br>        p[u] = v;<br>    &#125;<br>    <span class="hljs-type">int</span> wcc = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">LOG</span>(wcc);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        wcc += (<span class="hljs-built_in">find</span>(i) == i);<br>    &#125;<br>    cout &lt;&lt; wcc &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Happy-New-Year-2023"><a href="#D-Happy-New-Year-2023" class="headerlink" title="D. Happy New Year 2023"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_d">D. Happy New Year 2023</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个正整数n (n &lt;&#x3D; 4e18), 找出两个质数p, q. 满足n &#x3D; p * p * q</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>看到(n &lt;&#x3D; 4e18) + 乘三次 —&gt; $(1e18)^{1&#x2F;3} \to \ O(1e6)$</p><p>n &#x3D; p <em>p</em> q</p><p>显然有min(p, q) &lt;&#x3D; n^(1&#x2F;3)</p><p>设x为p, q中最小的数, y为最大的数</p><p>检查x * x * y 和 x * y * y</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> is_p[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(is_p, <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span> is_p);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (is_p[i]) &#123;<br>            primes[cnt ++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) &#123;<br>            is_p[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++ i) &#123;<br>        <span class="hljs-type">int</span> p = primes[i];<br>        <span class="hljs-type">int</span> p2 = p * p;<br>        <span class="hljs-keyword">if</span> (n % p2 == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n / p2 &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n % p)  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> val = n / p;<br>        <span class="hljs-comment">// p * q * q</span><br>        <span class="hljs-type">int</span> rt = <span class="hljs-built_in">sqrtl</span>(val);<br>        <span class="hljs-keyword">if</span> (rt * rt == val) &#123;<br>            cout &lt;&lt; rt &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; p &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Count-Simple-Paths"><a href="#E-Count-Simple-Paths" class="headerlink" title="E. Count Simple Paths"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_e">E. Count Simple Paths</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定G(n &lt;&#x3D; 1e5, m),  统计从1出发的简单路径数目. 其中每个节点度数&lt;8.</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>简单路径数目: <code>dfs + st[n]</code>回溯 &#x2F; <code>bit_dp [1 &lt;&lt; n][n]</code></p><p>类似: <a href="https://atcoder.jp/contests/abc054/tasks/abc054_c">C - One-stroke Path</a></p><p>节点数量过大 + 有节点度数保证 &#x3D;&#x3D; dfs.</p><p>cnt达到题目上限时, 在dfs过程中直接exit(0).</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">bool</span>&gt; st;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; g;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>;<br>    ++ cnt;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">1000000</span>) &#123;<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) &#123;<br>        <span class="hljs-keyword">if</span> (st[v])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v);<br>    &#125;<br>    st[u] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    g.<span class="hljs-built_in">resize</span>(n);<br>    st.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> u, v;   cin &gt;&gt; u &gt;&gt; v;  u --, v --;<br>        g[u].<span class="hljs-built_in">pb</span>(v);<br>        g[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">LOG</span>(cnt);<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-ABCBAC"><a href="#F-ABCBAC" class="headerlink" title="F. ABCBAC"></a><a href="https://atcoder.jp/contests/abc284/tasks/abc284_f">F. ABCBAC</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串s[2 * n](n &lt;&#x3D; 1e6), 设s1[i] &#x3D; s[1, i] + s[n - (i) + 1, n], s2[i] &#x3D; reverse(all(s[i + 1, n - i]))</p><p>问是否存在i, 满足s1 &#x3D;&#x3D; s2</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>string hash: 第一次使用double hash</p><p>本质考察: <strong>哈希拼接(base进制数理解) + 翻转哈希(后缀哈希)</strong></p><p><strong>哈希拼接</strong>: 前缀i + 后缀n-i 拼接. 就比如俩十进制数12, 34567 要拼接起来, 要先把12 * 100000再和后者相加, 才能变成1234567.</p><p>这里的哈希同理, 只不过换成了base进制数, 所以前者(前缀s[1, i])的哈希值先 * pw[n - i] (后缀的长度次幂), 再与后缀的哈希相加.</p><p><strong>哈希截取</strong>: 从1234567中截取”34567”的哈希值, 要将前缀哈希1234567 - 12 * 100000. 即pre[r] - pre[l - 1] * base[r - l + 1].</p><p><strong>翻转哈希</strong>: s[l, r]的翻转哈希: suf[l] - suf[r + 1] * pw[r - l + 1]即可</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-type">hash_t</span> = array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod0 = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>, mod1 = <span class="hljs-number">1e9</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">hash_t</span> base = &#123;<span class="hljs-number">13331</span>, <span class="hljs-number">23333</span>&#125;;<br><span class="hljs-type">hash_t</span> pw[N];<br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> + (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-type">hash_t</span> res = &#123;(a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>]) % mod0, (a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>]) % mod1&#125;;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> - (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-type">hash_t</span> res = &#123;(a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>] + mod0) % mod0, (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>] + mod1) % mod1&#125;;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">hash_t</span> <span class="hljs-keyword">operator</span> * (<span class="hljs-type">hash_t</span> a, <span class="hljs-type">hash_t</span> b) &#123;<br>    <span class="hljs-keyword">return</span> &#123;a[<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>] % mod0, a[<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>] % mod1&#125;;<br>&#125;<br><br><span class="hljs-type">hash_t</span> pre[N], suf[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    string s;   cin &gt;&gt; s;   s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    pw[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++ i) &#123;<br>        pw[i] = pw[i - <span class="hljs-number">1</span>] * base;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++ i) &#123;<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] * base + <span class="hljs-type">hash_t</span>&#123;s[i], s[i]&#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * n; i &gt;= <span class="hljs-number">1</span>; -- i) &#123;<br>        suf[i] = suf[i + <span class="hljs-number">1</span>] * base + <span class="hljs-type">hash_t</span>&#123;s[i], s[i]&#125;;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(n, s)<br><br>    <span class="hljs-comment">// s前i + s后2* n - i</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-comment">// s前i + s后2* n - i 哈希拼接</span><br>        <span class="hljs-comment">// [1, i] [i + 1, i + n] [i + n + 1, 2 * n]</span><br>        <span class="hljs-type">hash_t</span> h1 = pre[i] * pw[n - i] + (pre[<span class="hljs-number">2</span> * n] - pre[i + n + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>] * pw[n - i]) ;<br>        <span class="hljs-comment">// [i + 1, i + n] 翻转后的哈希</span><br>        <span class="hljs-type">hash_t</span> h2 = suf[i + <span class="hljs-number">1</span>] - suf[(i + n) + <span class="hljs-number">1</span>] * pw[n];<br>        <span class="hljs-keyword">if</span> (h1 == h2) &#123;<br>            string ans = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span> + i, n);<br>            <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">all</span>(ans));<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>            cout &lt;&lt; i &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_并查集</tag>
      
      <tag>算法_数论</tag>
      
      <tag>算法_图论</tag>
      
      <tag>算法_哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 285 A-F</title>
    <link href="/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/"/>
    <url>/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20285%20A-F/</url>
    
    <content type="html"><![CDATA[<h2 id="A-Edge-Checker-2"><a href="#A-Edge-Checker-2" class="headerlink" title="A. Edge Checker 2"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_a">A. Edge Checker 2</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, b;   cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> (b / a == <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Longest-Uncommon-Prefixs"><a href="#B-Longest-Uncommon-Prefixs" class="headerlink" title="B. Longest Uncommon Prefixs"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_b">B. Longest Uncommon Prefixs</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    string s;   cin &gt;&gt; s;   s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; i + l &lt;= n; ++ l) &#123;<br>            <span class="hljs-keyword">if</span> (s[l] == s[l + i]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, l);<br>        &#125;   <br>        <span class="hljs-built_in">LOG</span>(ans)<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-abc285-brutmhyhiizp"><a href="#C-abc285-brutmhyhiizp" class="headerlink" title="C. abc285_brutmhyhiizp"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_c">C. abc285_brutmhyhiizp</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>将26进制数(A-Z)转成10进制数(0-9)<br>BRUTMHYHIIZP —&gt; 10000000000000000</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;  cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        ans = ans * <span class="hljs-number">26</span> + (s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Change-Usernames"><a href="#D-Change-Usernames" class="headerlink" title="D. Change Usernames"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_d">D. Change Usernames</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>n个改名需求&lt;s[i], t[i]&gt;, 问是否能通过合理安排这n次改名的顺序, 使得改名没有冲突.</p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">a b<br>b c<br>c a<br>ans: No<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">a b<br>b c<br>ans: Yes<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>其实就是map&lt;string, int&gt;哈希 + 判环. toposort就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    map&lt;string, <span class="hljs-type">int</span>&gt; id;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">to</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">ind</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        string s, t;    cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-type">int</span> si, ti;<br>        <span class="hljs-keyword">if</span> (!id.<span class="hljs-built_in">count</span>(s))   id[s] = ++ idx;<br>        <span class="hljs-keyword">if</span> (!id.<span class="hljs-built_in">count</span>(t))   id[t] = ++ idx;<br>        si = id[s];<br>        ti = id[t];<br>        to[si] = ti;<br>        ++ ind[ti];<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ind[i] == <span class="hljs-number">0</span>)    q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> cv = q.<span class="hljs-built_in">front</span>();    q.<span class="hljs-built_in">pop</span>();<br>        st[cv] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!to[cv])    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">auto</span> nv = to[cv];<br>        <span class="hljs-keyword">if</span> (-- ind[nv] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(nv);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) ok = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ok) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Work-or-Rest"><a href="#E-Work-or-Rest" class="headerlink" title="E. Work or Rest"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_e">E. Work or Rest</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>一共有n(&lt;&#x3D;5000)天, 每天可以是工作日 or 休息日 现在需要安排这n天, 使得工作效率之和最大化. 第i天(工作日)的工作效率定义为:</p><p>设这一天离最近的休息日距离d(把这n天视为一个环, 即第1天和第n天首尾相连), 第i天的工作效率为a[d]. 其中a[n]是给定的序列</p><p>如XOOOX (O代表工作日, X代表休息日)中:</p><blockquote><p>O[1] &#x3D; a[min(1, 3)]</p><p>O[2] &#x3D; a[min(2, 2)]</p><p>O[3] &#x3D; a[min(3, 1)]</p></blockquote><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先要将n天的安排和a[n]独立开, 毕竟我第i天是工作日不代表这天的效率就是a的某个数, 具体要看n天的安排.</p><p>又因为n天是一个环, 所以可以设第一天是工作日.</p><p>影响效率之和的因素只有休息日天数和间隔. 设某两天休息日的间隔为d, 则这两天间的工作日效率之和为:</p><blockquote><p>d&#x3D;1: a1</p><p>d&#x3D;2: 2*a1</p><p>d&#x3D;3: 2*a1 + a2</p></blockquote><p>记<code>b[d]</code>为间隔d天的效率贡献</p><p>n&lt;&#x3D;5000. 可以n^2 DP</p><h4 id="间隔数dp"><a href="#间隔数dp" class="headerlink" title="间隔数dp"></a>间隔数dp</h4><p><code>dp[i][j]</code> 表示安排完了前i天, 且当前已经连续j天是工作日</p><p><code>dp[i][j] = dp[i][j - 1]</code></p><p><code>dp[i][0] = dp[i][j] + b[j]</code></p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];<br>    a[n + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   b[i] = b[i - <span class="hljs-number">1</span>] + a[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>    <br>    <span class="hljs-comment">// Why 必须初始化 负数? </span><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n - <span class="hljs-number">1</span>; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j] + b[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = dp[n + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全背包dp"><a href="#完全背包dp" class="headerlink" title="完全背包dp"></a>完全背包dp</h4><p>把间隔数i + 1(连续i天工作日 + 1天休息日)视作物品i的体积, d[i]视作物品i的价值. 背包容量为n</p><blockquote><p>w[i] &#x3D; w[i - 1] + a[i + 1 &gt;&gt; 1];</p><p>v[i] &#x3D; i + 1;</p></blockquote><p><code>dp[n][n]</code>即为所求</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)       cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        w[i] = w[i - <span class="hljs-number">1</span>] + a[i + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>];<br>        v[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; ++ i) &#123;</span><br>    <span class="hljs-comment">//     for (int c = 0; c * v[i] &lt;= n; ++ c) &#123;</span><br>    <span class="hljs-comment">//         for (int j = c * v[i]; j &lt;= n; ++ j) &#123;</span><br>    <span class="hljs-comment">//             dp[i][j] = max(dp[i][j], dp[i - 1][j - c * v[i]] + w[i] * c);</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-comment">// for (int j = n; j &gt;= 0; -- j) &#123;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++ j) &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-keyword">if</span> (j &gt;= v[i])<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][j - v[i]] + w[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// OXXXXXX OXXXXXX</span><br>    <span class="hljs-built_in">LOG</span>(dp[n][n])<br>    cout &lt;&lt; dp[n][n] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-Substring-of-Sorted-String"><a href="#F-Substring-of-Sorted-String" class="headerlink" title="F. Substring of Sorted String"></a><a href="https://atcoder.jp/contests/abc285/tasks/abc285_f">F. Substring of Sorted String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>小写字符串s[n], q个询问<br>2种询问方式:</p><blockquote><p>1 x c: s[x] &#x3D; c</p><p>2 l r: 设t[n]&#x3D;sort(all(s)), 判断s[l, r]是否为t的子串</p></blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><blockquote><p>s &#x3D; acbd     t &#x3D; abcd</p><p>q &#x3D; 2 1 4    NO</p><p>s &#x3D; abbd     t &#x3D; abbd</p><p>q &#x3D; 2 1 3    YES</p><p>s &#x3D; abcdc     t &#x3D; abccd</p><p>q &#x3D; 2 2 4    NO</p></blockquote><p>tag[i]记录s[i - 1] -&gt; s[i] 是否为非递减</p><p>seg[c].range(l, r) 记录字母c在[l, r]内出现次数</p><p>s[l, r]为t的子串, 需要满足以下两个条件:</p><ol><li>s[l + 1, r]内的字符都是递增的. 即tag.range_sum(l + 1, r) &#x3D;&#x3D; 0</li><li>s[l + 1, r - 1]内的字符出现频数 &#x3D;&#x3D; t对应字符出现频数. 如样例3</li></ol><p>tag: 单点修改, 区间求和 —&gt; fenwick_tree</p><p>seg: 求s[l, r]内某字符的出现频数, 支持修改 —&gt; fenwick_tree</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_tree</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tr;<br>    <span class="hljs-built_in">fenwick_tree</span>(<span class="hljs-type">int</span> n) &#123;<span class="hljs-keyword">this</span>-&gt;n = n; tr.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">5</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>   </span>&#123;<span class="hljs-keyword">return</span> x &amp; -x;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;       cin &gt;&gt; n;<br>    string s;    cin &gt;&gt; s;      s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    <span class="hljs-type">int</span> q;       cin &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;fenwick_tree&gt;  <span class="hljs-title">seg</span><span class="hljs-params">(<span class="hljs-number">26</span>, fenwick_tree(n + <span class="hljs-number">5</span>))</span></span>;<br>    <span class="hljs-function">fenwick_tree <span class="hljs-title">tag</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        cnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        seg[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) tag.<span class="hljs-built_in">add</span>(i, s[i - <span class="hljs-number">1</span>] &gt; s[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q --) &#123;<br>        <span class="hljs-type">int</span> op;   cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> x;  <span class="hljs-type">char</span> c;<br>            cin &gt;&gt; x &gt;&gt; c;<br><br>            cnt[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>] --;<br>            seg[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">add</span>(x, <span class="hljs-number">-1</span>);<br>            <span class="hljs-comment">// s[x - 1] s[x] s[x + 1]</span><br>            <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) &#123;<br>                tag.<span class="hljs-built_in">add</span>(x, -(tag.<span class="hljs-built_in">range</span>(x, x)));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x &lt; n) &#123;<br>                tag.<span class="hljs-built_in">add</span>(x + <span class="hljs-number">1</span>, -(tag.<span class="hljs-built_in">range</span>(x + <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span>)));<br>            &#125;<br><br>            s[x] = c;<br>            cnt[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>            seg[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">add</span>(x, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) &#123;<br>                tag.<span class="hljs-built_in">add</span>(x, s[x - <span class="hljs-number">1</span>] &gt; s[x]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x &lt; n) &#123;<br>                tag.<span class="hljs-built_in">add</span>(x + <span class="hljs-number">1</span>, s[x] &gt; s[x + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l, r;   cin &gt;&gt; l &gt;&gt; r;<br>            <span class="hljs-type">int</span> ok = <span class="hljs-literal">true</span>;<br>            ok &amp;= (tag.<span class="hljs-built_in">range</span>(l + <span class="hljs-number">1</span>, r) == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s[l] + <span class="hljs-number">1</span> - <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= s[r] - <span class="hljs-number">1</span> - <span class="hljs-string">&#x27;a&#x27;</span>; ++ i) &#123;<br>                ok &amp;= (seg[i].<span class="hljs-built_in">range</span>(l, r) == cnt[i]);<br>            &#125;<br>            <span class="hljs-built_in">LOG</span>(ok)<br>            <span class="hljs-keyword">if</span> (ok)     cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 844 (Div. 1 + Div. 2, based on VK Cup 2022 - Elimination Round) A-D</title>
    <link href="/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/"/>
    <url>/2023/01/17/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20844%20(Div.%201%20+%20Div.%202,%20based%20on%20VK%20Cup%202022%20-%20Elimination%20Round)%20A-D/</url>
    
    <content type="html"><![CDATA[<p>比赛次日晚上vp, B卡了20分钟, 其实思路出得很快, 但不会证明, 感觉是那种intuition. 可是排完序了还在搞前缀最小值 and 后缀最大值… C单纯模拟, 我对情况讨论不清, 写了依托答辩, 150行, WA4发. rk2400+, 感觉进步空间很大.</p><p>补题: D因式分解 + 枚举因子 + 压缩状态</p><h2 id="A-Parallel-Projection"><a href="#A-Parallel-Projection" class="headerlink" title="A. Parallel Projection"></a><a href="https://codeforces.com/contest/1782/problem/A">A. Parallel Projection</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>房间中有两点分别位于地板和天花板, 已知房间大小和两点坐标, 用一条线段将两点连接, 求线段最短距离. （线段须依附地板, 墙壁或者天花板）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分别计算俩点向四个方向的墙面相连的距离, 求最小值</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> w, d, h;    cin &gt;&gt; w &gt;&gt; d &gt;&gt; h;<br>    <span class="hljs-type">int</span> a, b, f, g; cin &gt;&gt; a &gt;&gt; b &gt;&gt; f &gt;&gt; g;<br>    <span class="hljs-type">int</span> dist1 = <span class="hljs-built_in">min</span>(a, f);<br>    <span class="hljs-type">int</span> dist2 = <span class="hljs-built_in">min</span>(b, g);<br>    <span class="hljs-type">int</span> dist3 = w - <span class="hljs-built_in">max</span>(a, f);<br>    <span class="hljs-type">int</span> dist4 = d - <span class="hljs-built_in">max</span>(b, g);<br>    <span class="hljs-type">int</span> ans1 = <span class="hljs-number">2</span> * dist1 + <span class="hljs-built_in">abs</span>(a - f) + <span class="hljs-built_in">abs</span>(b - g) + h;<br>    <span class="hljs-type">int</span> ans2 = <span class="hljs-number">2</span> * dist2 + <span class="hljs-built_in">abs</span>(a - f) + <span class="hljs-built_in">abs</span>(b - g) + h;<br>    <span class="hljs-type">int</span> ans3 = <span class="hljs-number">2</span> * dist3 + <span class="hljs-built_in">abs</span>(a - f) + <span class="hljs-built_in">abs</span>(b - g) + h;<br>    <span class="hljs-type">int</span> ans4 = <span class="hljs-number">2</span> * dist4 + <span class="hljs-built_in">abs</span>(a - f) + <span class="hljs-built_in">abs</span>(b - g) + h;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">min</span>(&#123;ans1, ans2, ans3, ans4&#125;);<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Going-to-the-Cinema"><a href="#B-Going-to-the-Cinema" class="headerlink" title="B. Going to the Cinema"></a><a href="https://codeforces.com/contest/1782/problem/B">B. Going to the Cinema</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n个人去看电影, 每个人可以选择去or不去, i号人有一个参数ai, 表示自己去当且仅当除自己外至少还有ai个人去,这表明i号人会伤心,如果满足如下两条件之一:</p><ol><li>自己去,但除自己外去的人数 &lt; ai</li><li>自己不去,但除自己外去的人数&gt;&#x3D; ai</li></ol><p>问有多少种选择去的人的集合的方案,使得没有人伤心.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>设去的人的集合A&#x3D;{p1,⋯,pa},不去的人的集合B&#x3D;{q1,⋯,qb},则A⋃B&#x3D;{1,⋯,n},a+b&#x3D;n.​</p><ol><li>对A中的每个人ai,他去的充要条件为a − 1 ≥ ai, 则集合A合法当且仅当$a-1 \geq \max_{1 \leq i\leq a} a_{p_i}$.</li><li>对B中的每个人aj,他不去的充要条件为a &lt; aj, 则集合B合法当且仅当<br>$a &lt; \min_{1\leq j\leq b} a_{q_j}$.</li></ol><p>枚举去的人数i∈[0,n].将a升序排列后,对每个下标i, i &gt; a[i] &amp;&amp; i &lt; a[i + 1]</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">begin</span>() + n + <span class="hljs-number">1</span>);<br>    a[n + <span class="hljs-number">1</span>] = inf; a[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">LOG</span>(a)<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; a[i] &amp;&amp; i &lt; a[i + <span class="hljs-number">1</span>]) &#123;<br>            ++ ans;<br>            <span class="hljs-built_in">LOG</span>(i, a[i], a[i + <span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Equal-Frequencies"><a href="#C-Equal-Frequencies" class="headerlink" title="C. Equal Frequencies"></a><a href="https://codeforces.com/contest/1782/problem/C">C. Equal Frequencies</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>称一个字符串是好的,如果每种字符出现的次数都相等.</p><p>n为字符串s的长度. s为一个只包含小写英文字母的字符串.求将s变换成好的字符串t所需改变的最小字符数, 输出任一变换后好的字符串t.</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>显然字符种类数seg 是不超过26的n约数, 每种字符的出现次数ac为n &#x2F; seg</p><p>首先将字母按照cnt[26] (字母出现频数) 降序排序, 要<strong>尽最大可能利用现有的多的字母</strong></p><p>以下代码用来找到最小的代及cost其对应的ac</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= n; ++ d) <span class="hljs-keyword">if</span> (n % d == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>, seg = n / d;<br>    <span class="hljs-keyword">if</span> (seg &gt; <span class="hljs-number">26</span>)   <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; seg; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (now &lt; mn_cost) &#123;<br>        mn_cost = now;          best_ac = d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要统计<strong>cnt不足ac的部分</strong>就行了, 不足的部分肯定是需要其他redundant的来补充的.</p><p>aim[26]表示t中每个字母的目标次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; best_seg; ++ i) &#123;<br>    aim[ord[i]] = best_ac;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来只需要看s[i]的cnt:</p><ol><li>cnt &gt;  aim[s[i]], 在26个字母中找cnt还不足aim的进行替换</li><li>cnt &lt;&#x3D; aim[s[i]], 跳过</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    string s;   cin &gt;&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)   cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ord</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>    <span class="hljs-built_in">iota</span>(<span class="hljs-built_in">all</span>(ord), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(ord), [&amp;](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>        <span class="hljs-keyword">return</span> cnt[a] &gt; cnt[b];<br>    &#125;);<br>    <span class="hljs-comment">// d: n的因子, 作为每个字母的出现次数</span><br>    <span class="hljs-type">int</span> mn_cost = n, best_ac = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= n; ++ d) <span class="hljs-keyword">if</span> (n % d == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>, seg = n / d;<br>        <span class="hljs-keyword">if</span> (seg &gt; <span class="hljs-number">26</span>)   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; seg; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[ord[i]] &lt; d)    now += d - cnt[ord[i]];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (now &lt; mn_cost) &#123;<br>            mn_cost = now;          best_ac = d;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> best_seg = n / best_ac;<br>    <span class="hljs-built_in">LOG</span>(mn_cost, best_ac, best_seg)<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">aim</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; best_seg; ++ i) &#123;<br>        aim[ord[i]] = best_ac;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(aim)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : s) &#123;<br>        <span class="hljs-keyword">if</span> (aim[ch - <span class="hljs-string">&#x27;a&#x27;</span>] &gt;= cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = <span class="hljs-number">0</span>; to &lt; <span class="hljs-number">26</span>; ++ to) &#123;<br>            <span class="hljs-keyword">if</span> (aim[to] &gt; cnt[to]) &#123;<br>                cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>] --;<br>                ch = (<span class="hljs-type">char</span>)to + <span class="hljs-string">&#x27;a&#x27;</span>;<br>                cnt[ch - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(s)<br>    cout &lt;&lt; mn_cost &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Many-Perfect-Squares"><a href="#D-Many-Perfect-Squares" class="headerlink" title="D. Many Perfect Squares"></a><a href="https://codeforces.com/contest/1782/problem/D">D. Many Perfect Squares</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>非递减数组<code>a[n](1≤n≤50)</code>. 需要选择一个数 x , 使得 a1 + x, a2 + x, a3 + 3…an + x中, 有尽可能多的完全平方数. 输出最多的完全平方数的个数.</p><p>例如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 6 13 22 90<br></code></pre></td></tr></table></figure><p>选择 x &#x3D; 3</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">4,9,16,25,93<br></code></pre></td></tr></table></figure><p>4,9,16,25,93<br>最多有4个完全平方数</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>题目要求能使多个ai同时满足题意的x. 先考虑每个能使1对ai, aj同时满足题意的x.</p><p>先sort(all(a))</p><p>设有 $i &lt; j, a_i + x &#x3D; va^2 ,a_j + x &#x3D; vb^2$</p><p>对完全平方数做差有$vb^2 - va^2 &#x3D; (vb-va)(vb+va) &#x3D; a_j + x - (a_i + x) &#x3D; a_j - a_i$</p><p>令 diff &#x3D; aj - ai</p><p>则 (vb - va)(vb + va) &#x3D; diff, (vb - va)和(vb + va)这两个数一定都是 diff 的因子. 我们枚举 diff 的因子d &#x3D; diva * divb , 然后就知道va, vb的具体的数值. 然后 $a_i + x &#x3D; va^2$ , 就可以获得一个能使得ai, aj同时满足题意的 x.</p><p>用dp[x] |&#x3D; 1 &lt;&lt; i | 1 &lt;&lt; j 表示x可以使得ai, aj同时满足题意.</p><p>最后统计一下每个x的二进制1个数就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a));<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> diff = a[j] - a[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> div = <span class="hljs-number">1</span>; div * div &lt;= diff; ++ div) &#123;<br>                <span class="hljs-keyword">if</span> (diff % div != <span class="hljs-number">0</span>)    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> diva = div, divb = diff / div;<br>                <span class="hljs-keyword">if</span> (diva % <span class="hljs-number">2</span> != divb % <span class="hljs-number">2</span>)     <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-comment">// 12 = 2 * 6       va = 2, vb = 4    </span><br>                <span class="hljs-comment">// x = va * va - a[i]</span><br>                <span class="hljs-type">int</span> va = (divb - diva) / <span class="hljs-number">2</span>, vb = (diva + divb) / <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> x = va * va - a[i];<br>                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)                      <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">LOG</span>(a[i], a[j], diff, va, vb)<br>                dp[x] |= (<span class="hljs-number">1ll</span> &lt;&lt; i) | (<span class="hljs-number">1ll</span> &lt;&lt; j);<br>            &#125;       <br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 只有1个数a, 肯定能找到x, 使得a+x是平方数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, val] : dp) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, (<span class="hljs-type">int</span>)<span class="hljs-built_in">popcountll</span>(val));<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_实现</tag>
      
      <tag>算法_数论</tag>
      
      <tag>算法_暴力</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_位运算</tag>
      
      <tag>算法_数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 134 A-F</title>
    <link href="/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/"/>
    <url>/2023/01/15/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20134%20A-F/</url>
    
    <content type="html"><![CDATA[<h2 id="R2532橙题-F-Permutation-Oddness"><a href="#R2532橙题-F-Permutation-Oddness" class="headerlink" title="R2532橙题 F - Permutation Oddness"></a>R2532橙题 <a href="https://atcoder.jp/contests/abc134/tasks/abc134_f">F - Permutation Oddness</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>设 P &#x3D; (p1, p2, p3, …, pn)是{1,2,3,…,n}(n&lt;&#x3D;50)的排列. 定义Oddness:&#x3D; $\sum |p_i - i|$. 求满足定义Oddness &#x3D; k 的不同排列P的数量</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>此题相当困难. 做的第一道橙题, 看题解都看了好久才能理解.</p><p>这里以<a href="https://img.atcoder.jp/abc134/editorial.pdf">官方题解</a>为基础, 加以翻译并解释. </p><blockquote><p>若存在一组兔子(R1​∼Rn​)和一组海龟(T1​∼Tn​), 请问有多少种方式可以形成n组 (兔,龟) 组合, 使得各组龟兔下标的差值（绝对值）求和之后恰等于 K</p></blockquote><p>dp[i][j][k][l]&#x3D;表示在考虑R1​∼Ri​与T1​∼Ti​时, 仍然有j个兔没有在这个范围内找到配对、有k个龟没有在这个范围内找到配对、可以确定的oddess为l的排列数量. </p><p>因为在考虑前i个时, 兔和龟未配对的数量实际上是相等的(j&#x3D;k), 所以dp数组可以简化浓缩为dp[i][j][k], 这里的k继承之前l的意义. </p><p>状态转移方程写作：<br>dp[i][j][k] &#x3D; (2j + 1)dp[i-1][j][k-2j] + (j+1)(j+1)dp[i-1][j+1][k-2j]+dp[i-1][j-1][k-2j]</p><p>当考虑第i个数与盒子的时候, 分5种情况: </p><blockquote><p>数i和盒子i直接配对, 未配对的依然是j个</p><p>但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] +&#x3D; dp[i - 1][j][k - 2 * j];</p></blockquote><blockquote><p>数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] +&#x3D; dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</p><p>有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>dp[i][j][k] +&#x3D; dp[i - 1][j][k - 2 * j] * j;</p></blockquote><blockquote><p>盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</p><p>未配对的数-1, 盒子数-1, 所以未配对的-1个. </p><p>当前状态j, 所以上一状态j+1</p><p>有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j + 1 &lt;&#x3D; i) dp[i][j][k] +&#x3D; dp[i - 1][j + 1][k - 2 * j] * (j + 1) * (j + 1);</p></blockquote><blockquote><p>数i和盒子i都不配对, 未配对的是j+1个</p><p>有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</p><p>if (j &gt;&#x3D; 1)     dp[i][j][k] +&#x3D; dp[i - 1][j - 1][k - 2 * j];</p></blockquote><p>注意, 可能情况个数要从上一状态出发考虑</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mint dp[N][N][N * N];    <br><span class="hljs-comment">// 前i个数, 还剩下j个数不能够在当前考虑的1~i个盒子中找到目标安放配对</span><br><span class="hljs-comment">// 且 当前的奇异值为k的方案数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; ++ j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span> * j; k &lt;= n * n; ++ k) &#123;<br>                <span class="hljs-comment">// 数i和盒子i直接配对, 未配对的依然是j个</span><br>                <span class="hljs-comment">// 但是这剩下的j个数, 由于他们最终配对的目标都往右移了1个数, 每个对总k值的贡献就要+1了</span><br>                dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">2</span> * j];<br>                <span class="hljs-comment">// 数i和[1~i-1]的盒子的j个盒子中选一个配对, 未配对的数不变, 盒子-1+1, 所以未配对的依然是j个</span><br>                <span class="hljs-comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span><br>                dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">2</span> * j] * j;<br>                <span class="hljs-comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 未配对的数-1+1, 盒子不变, 所以未配对的依然是j个</span><br>                <span class="hljs-comment">// 有j中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span><br>                dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">2</span> * j] * j;<br>                <span class="hljs-comment">// 盒子i和[1~i-1]的数的j个数中选一个配对, 数i和[1~i-1]的盒子的j个盒子中选一个配对</span><br>                <span class="hljs-comment">// 未配对的数-1, 盒子数-1, 所以未配对的-1个. </span><br>                <span class="hljs-comment">// 当前状态j, 所以上一状态j+1</span><br>                <span class="hljs-comment">// 有(j+1)*(j+1)中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span><br>                <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt;= i) dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>][k - <span class="hljs-number">2</span> * j] * (j + <span class="hljs-number">1</span>) * (j + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 数i和盒子i都不配对, 未配对的是j+1个</span><br>                <span class="hljs-comment">// 有1中可能. 同样, 剩下的j个数, 每个对总k值的贡献就要+1了</span><br>                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">1</span>)     dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">2</span> * j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[n][<span class="hljs-number">0</span>][k] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 797 (Div. 3) A-G</title>
    <link href="/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/"/>
    <url>/2023/01/14/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20797%20(Div.%203)%20A-G/</url>
    
    <content type="html"><![CDATA[<p>昨晚vp, div3+rk600+, 感觉还行. 虽然前四题很久之前比赛时做过, 但是vp的时候还是出的很慢. E题当时比赛时就不会做, vp的时候依然卡住了. 先做了F题, 比较套路的置换环. 倒回去再想出了E题. G题考虑不周全, 讨论完了才发现样例对不上.</p><p>补题:</p><h2 id="A-Print-a-Pedestal-Codeforces-logo"><a href="#A-Print-a-Pedestal-Codeforces-logo" class="headerlink" title="A. Print a Pedestal (Codeforces logo?)"></a><a href="https://codeforces.com/contest/1690/problem/A">A. Print a Pedestal (Codeforces logo?)</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> d = n / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; d &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; d + <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d + <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; d + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d + <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; d - <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Array-Decrements"><a href="#B-Array-Decrements" class="headerlink" title="B. Array Decrements)"></a><a href="https://codeforces.com/contest/1690/problem/B">B. Array Decrements)</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : b)   cin &gt;&gt; x;<br><br>    set&lt;<span class="hljs-type">int</span>&gt; d0, d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> cd = b[i] - a[i];<br>        <span class="hljs-keyword">if</span> (b[i] == <span class="hljs-number">0</span>) &#123;<br>            d0.<span class="hljs-built_in">insert</span>(cd);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            d.<span class="hljs-built_in">insert</span>(cd);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (d.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (d.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// d.size == 1</span><br>    <span class="hljs-keyword">if</span> (*d0.<span class="hljs-built_in">begin</span>() &lt; *d.<span class="hljs-built_in">begin</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Restoring-the-Duration-of-Tasks"><a href="#C-Restoring-the-Duration-of-Tasks" class="headerlink" title="C. Restoring the Duration of Tasks"></a><a href="https://codeforces.com/contest/1690/problem/C">C. Restoring the Duration of Tasks</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果当前任务到来时间s &gt; 上个任务完成时间f[i - 1], d &#x3D; f - s<br>否则当前任务到来时间s &lt; 上个任务完成时间 d &#x3D; f - f[i - 1]</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n)</span> ,<span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : s)   cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : f)   cin &gt;&gt; x;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">1</span>, f[<span class="hljs-number">0</span>] - s[<span class="hljs-number">0</span>])</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt; f[i - <span class="hljs-number">1</span>])    ans.<span class="hljs-built_in">pb</span>(f[i] - s[i]);<br>        <span class="hljs-keyword">else</span>                    ans.<span class="hljs-built_in">pb</span>(f[i] - f[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Black-and-White-Stripe"><a href="#D-Black-and-White-Stripe" class="headerlink" title="D. Black and White Stripe"></a><a href="https://codeforces.com/contest/1690/problem/D">D. Black and White Stripe</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    string s;   cin &gt;&gt; s;   s = <span class="hljs-string">&quot; &quot;</span> + s;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        pre[i] = pre[i - <span class="hljs-number">1</span>] + (s[i] == <span class="hljs-string">&#x27;B&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + k - <span class="hljs-number">1</span> &lt;= n; ++ i) &#123;<br>        <span class="hljs-type">int</span> l = i, r = l + k - <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">min</span>(ans, r - l + <span class="hljs-number">1</span> - (pre[r] - pre[l - <span class="hljs-number">1</span>]));<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Price-Maximization"><a href="#E-Price-Maximization" class="headerlink" title="E. Price Maximization"></a><a href="https://codeforces.com/contest/1690/problem/E">E. Price Maximization</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给定一个序列和一个数k,将序列中的数两两分组,总得分为每组两个数除以<br>的和k, 求和最大是多少</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>每个数能整除k的部分一定会对答案有贡献. 所以每个数先mod上k. 然后ans加上整除的部分.</p><p>把mod完k之后的数扔进multiset里面, 然后取出第一个数x, 要想有1的贡献, 那么跟他配对的另一个数y, 一定要&gt;&#x3D;k - x, 所以lower_bound一下k - x</p><p>也可以把a排序, 然后首尾双指针搞搞</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) &#123;<br>        cin &gt;&gt; x;<br>        ans += x / k;<br>        x %= k;<br>        <span class="hljs-keyword">if</span> (x)  S.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">auto</span> itx = S.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-comment">// 先取值, 再删除? </span><br>        <span class="hljs-type">int</span> x = *itx;<br>        S.<span class="hljs-built_in">erase</span>(itx);<br>        <span class="hljs-keyword">auto</span> ity = S.<span class="hljs-built_in">lower_bound</span>(k - x);<br>        <span class="hljs-keyword">if</span> (ity != S.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-type">int</span> y = *ity;<br>            ans ++;<br>            S.<span class="hljs-built_in">erase</span>(ity);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-Shifting-String"><a href="#F-Shifting-String" class="headerlink" title="F. Shifting String"></a><a href="https://codeforces.com/contest/1690/problem/F">F. Shifting String</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给出一个字符串和一个置换群,问按照置换群操作多少次后字符串会回到最初的状态</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先把置换拆成若干个环,环之间是独立的. 答案就是每个环回到初始状态需要步数的最小公倍数.判断每个环的周期只需要循环移位判断(or 暴力check环长的因数是否满足要求)即可,复杂度为 $O(n \sqrt{n})$</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;      cin &gt;&gt; n;<br>    string s;   cin &gt;&gt; s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : p) &#123;<br>        cin &gt;&gt; x;<br>        x --;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-type">int</span> now = i;<br>        vector&lt;<span class="hljs-type">int</span>&gt; loop;<br>        <span class="hljs-keyword">for</span> (; st[now] == <span class="hljs-number">-1</span>; now = p[now]) &#123;<br>            loop.<span class="hljs-built_in">pb</span>(now);<br>            st[now] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">LOG</span>(loop)<br>        deque&lt;<span class="hljs-type">char</span>&gt; dq0, dq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : loop) dq0.<span class="hljs-built_in">pb</span>(s[p]);<br>        dq.<span class="hljs-built_in">assign</span>(<span class="hljs-built_in">all</span>(dq0));<br>        <span class="hljs-type">int</span> cl = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (;cl &lt; loop.<span class="hljs-built_in">size</span>(); ++ cl) &#123;<br>            <span class="hljs-keyword">auto</span> c = dq.<span class="hljs-built_in">back</span>(); dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_front</span>(c);<br>            <span class="hljs-keyword">if</span> (dq == dq0) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        len.<span class="hljs-built_in">pb</span>(cl + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : len) &#123;<br>        ans = <span class="hljs-built_in">lcm</span>(ans, x);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G-Count-the-Trains"><a href="#G-Count-the-Trains" class="headerlink" title="G. Count the Trains"></a><a href="https://codeforces.com/contest/1690/problem/G">G. Count the Trains</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>每辆车有一个最高速度,其速度不能超过最高速度也不能超过它前面的车的速度,如此整个序列会被分成速度值相等的若干段,每次操作会降低某个位置的最高速度,问每次操作完序列的总段数是多少</p><p>例如[10, 13, 5, 2, 6] &#x3D;&gt; [10, 10, 5, 2, 2] 一共有3种不同的数</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>维护每段火车的车头位置和整节车的速度.</p><p>在i位置插入一节速度为x的车厢it, 等同于插入一节长度为1的火车</p><p>如果速度x &gt;&#x3D; 左边的火车段的速度, 就直接把it合并到左边(erase掉it)</p><p>如果速度x &lt; 右边, 就把it作为右边火车的车头, 合并掉右边的火车段(erase掉next(it)).</p><p>insert和erase的次数不会超过O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x) &#123;<br>        mp[i] = x;<br>        <span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(i);       <span class="hljs-comment">// 根据键key查找</span><br><br>        <span class="hljs-comment">// 9 | 5    ---&gt; 9 10 | 5</span><br>        <span class="hljs-keyword">if</span> (it != mp.<span class="hljs-built_in">begin</span>() &amp;&amp; <span class="hljs-built_in">prev</span>(it)-&gt;second &lt;= x) &#123;<br>            mp.<span class="hljs-built_in">erase</span>(it);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 9 | 5 | 3 | 1  ---&gt; 9 | 2 5 3 | 1</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next</span>(it) != mp.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">next</span>(it)-&gt;second &gt;= x) &#123;<br>            mp.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">next</span>(it));<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-built_in">add</span>(i, a[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-type">int</span> k, d;   cin &gt;&gt; k &gt;&gt; d;      k --;<br>        a[k] -= d;<br>        <span class="hljs-built_in">add</span>(k, a[k]);<br>        cout &lt;&lt; mp.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_组合数学</tag>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年记 - 2022</title>
    <link href="/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/"/>
    <url>/2023/01/13/%E5%B9%B4%E8%AE%B0%20-%202022/</url>
    
    <content type="html"><![CDATA[<h2 id="2022-年终总结"><a href="#2022-年终总结" class="headerlink" title="2022 年终总结"></a>2022 年终总结</h2><p>刘城君</p><hr><h2 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h2><p>开始图划分的任务: 基于标签传播思想, 优化目标主要是复制因子RF.</p><p>随机初始化种子节点的tag, 多轮多源BFS的方式进行tag, 选取邻居最多的tag进行标记.</p><p>1度点优化. 1度点对RF没有影响</p><p>tag合并(按照tag规模&#x2F;tag结点重合度). 但由于块数与节点数的数量关系限制, 效果不佳.</p><p>每个一次assign多个tag(一次性覆盖)</p><p>由于传播方式存在问题, 因此负载均衡很差.</p><hr><h2 id="9月-11月"><a href="#9月-11月" class="headerlink" title="9月 - 11月"></a>9月 - 11月</h2><p>期间阅读了HEP, NE等论文, 了解到Local search的策略, 以及分区boundary节点度数分布对RF的影响. 同时再次阅读了NE的源码.</p><p>为了优化负载均衡, 尝试在初始阶段就用BFS确定分区大致分布, 此阶段可以保障tag平衡. 第二阶段加入tag约束, 进行剩余节点的tag assignment.</p><p>效果较5月版本有明显进步, 数据集Lj上的表现(-p 8)为: RF&#x3D;1.66-1.71 Balance &#x3D; 1.05. 已经优于除NE外的其他算法. 但距离NE的1.33, 1.00仍有较大差距</p><hr><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><p>分析RF和Tag的分区交界处节点的度数分布, 发现RF 2&#x2F;3度点数量基本没有.</p><p>尝试将初始块变得更加紧密: 选k-core作为初始块. 效果一般</p><p>11月版本中第二阶段传播顺序诡异, 并且存在传播失败的可能.</p><p>尝试由当前的按照节点id顺序被动传播改成按照&lt;节点|tag|, 负载均衡, 节点度数&gt;的优先级进行BFS主动传播. 效果不如11月版本</p><hr><h2 id="1月-现在"><a href="#1月-现在" class="headerlink" title="1月 - 现在"></a>1月 - 现在</h2><p>修改第一阶段BFS的策略, 加入启发式策略: 优先扩展与Core紧密的节点.</p><p>基于NE的代码进行实现, 并且尝试两种版本:</p><blockquote><p>优先扩展与Core紧密的节点: RF: 1.7+, Balance: 1.00</p><p>优先扩展与Core+Boundary紧密的节点: 本质上就是NE, RF效果与NE十分接近</p></blockquote><p>在修改NE代码过程中, 意识到初始分区只分配p-1块, 最后1块分配p, 从而取消第二阶段的传播. 效果可能会优于当前版本</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>idea储备不足: 阅读更多相关论文</p><p>争取在RF &#x2F; 实际任务效果上取得进展</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 839 (Div. 3) A-G</title>
    <link href="/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/"/>
    <url>/2023/01/12/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20839%20(Div.%203)%20A-G/</url>
    
    <content type="html"><![CDATA[<p>上午vp, div3+rk5000+, 鉴定为春春的飞舞. C题R1000的贪心做了半小时. D题根本没想到往确定x的范围上去想, 只想着分类讨论a数组的最值分布. E题博弈看了虽然知道分开统计a, b各自需要涂色的数量, 但是却不知道怎么判断输赢.</p><p>补题: D题要从题目限制的不等式去推出x的范围. F题发掘性质: 可染色的块一定是递减的.</p><h2 id="C-Different-Differences"><a href="#C-Different-Differences" class="headerlink" title="C. Different Differences"></a><a href="https://codeforces.com/contest/1772/problem/C">C. Different Differences</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="D-Absolute-Sorting"><a href="#D-Absolute-Sorting" class="headerlink" title="D. Absolute Sorting"></a><a href="https://codeforces.com/contest/1772/problem/D">D. Absolute Sorting</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>a[n], 询问是否存在一个数x, a[i] &lt;- |a[i] - x|, 形成非单调递减序列, 如果不存在输出-1</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>假设找到了一个x满足题意. 那么就有|a[i] - x| &lt;&#x3D; |a[i+1] - x|.</p><p>两边平方: $(a[i] - x)^2 \leq (a[i+1] - x)^2$<br>因式分解: $(a[i] - a[i+1])(a[i] + a[i+1] - 2x) \leq 0$</p><p>接下来逐个判断a[i] - a[i+1], 分类讨论:</p><blockquote><p>a[i] - a[i+1] &gt; 0: a[i] + a[i+1] - 2x &lt;&#x3D; 0<br>a[i] - a[i+1] &lt; 0: a[i] + a[i+1] - 2x &gt;&#x3D; 0</p></blockquote><p>即可得到x的范围</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br>    <span class="hljs-type">int</span> mx = (<span class="hljs-type">int</span>)<span class="hljs-number">2e9</span>, mn = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// (x - y)(x + y - 2x) &lt;= 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> x = a[i], y = a[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (x &gt; y) &#123;    <span class="hljs-comment">// (x + y - 2x) &lt; 0</span><br>            mn = <span class="hljs-built_in">max</span>(mn, x + y + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; y) &#123;   <span class="hljs-comment">// (x + y - 2x) &gt; 0</span><br>            mx = <span class="hljs-built_in">min</span>(mx, x + y &gt;&gt; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// x没有要求</span><br>            ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mn &lt;= mx) &#123;<br>        cout &lt;&lt; mn &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-Permutation-Game"><a href="#E-Permutation-Game" class="headerlink" title="E. Permutation Game"></a><a href="https://codeforces.com/contest/1772/problem/E">E. Permutation Game</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>题意, 在一个序列p中, AB两人轮流操作, 每次的操作选择</p><ol><li>将p中的某个数变为可调换位置的(涂色)</li><li>重新排列, 但只能调动可变换位置的</li><li>跳过回合</li></ol><p>如果最后形成上升序列甲赢, 递减序列乙赢, 否则平局</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">4<br>1 2 4 3<br></code></pre></td></tr></table></figure><p>A要涂色的: p[3], p[4]<br>B要涂色的: p[3], p[4], p[1], p[2]</p><p>AB俩人都要涂色的: p[3], p[4]<br>只属于A自己要涂色的: 没有<br>只属于B自己要涂色的: p[1], p[2]</p><p>如果A把只有自己要涂色的(a)+公共涂色的都涂完了(c), B还剩下没涂, A就赢了<br>如果B把只有自己要涂色的(b)+公共涂色的都涂完了(c), A还剩下没涂, B就赢了</p><p>但是要注意A是先手, 所以就算AB同时涂完(b+c&#x3D;&#x3D;a), 也算A赢. 其他都是平局, 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : p) &#123;<br>        cin &gt;&gt; x;<br>        x --;<br>    &#125;<br><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (p[i] == i) &#123;<br>            ++ b;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[i] == n - i - <span class="hljs-number">1</span>) &#123;<br>            ++ a;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ++ c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(a, b, c)<br>    <span class="hljs-keyword">if</span> (a &gt; b + c) &#123;    <span class="hljs-comment">// b先翻完. 如果相等的话, 后手染色完, 下一轮到先手, 先手就直接排序了</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Second&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &gt;= a + c) &#123;   <span class="hljs-comment">// a先翻完, 由于a先手, 同时ab翻完也不行</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;First&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 两个人会剩下一个地方没有染色, 但是谁都不敢染, 因为染色了, 对手就会排序. </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Tie&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-Copy-of-a-Copy-of-a-Copy"><a href="#F-Copy-of-a-Copy-of-a-Copy" class="headerlink" title="F. Copy of a Copy of a Copy"></a><a href="https://codeforces.com/contest/1772/problem/F">F. Copy of a Copy of a Copy</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一个n行m列的01矩阵 (3≤n,m≤30). 其中0表示白色, 1表示黑色. 每次你可以选择以下操作的中的一个:</p><ol><li>选择一个不是边界的点 (i,j)(i≠1,i≠n,j≠1,j≠m), 并且他的上下左右的4个点, 其颜色都与之相反, 则把这个点变成相反的颜色.</li><li>创建一个当前矩阵的拷贝.</li></ol><p>执行了 k(k≤100)次拷贝操作. 现在给出制作的所有 k 个拷贝. 此外, 还有初始的矩阵.  然而, 所有k+1个矩阵的顺序被打乱了. 因为找出初始版本, 并且输出经过了哪些操作.</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>一旦对某个单元格涂色, 就再也不能重新涂色了. 这是因为不能对它的邻居也重新涂色, 因为它们中的每一个都有至少一个相同颜色的邻居——这个单元格本身</p><p>这给了我们副本的顺序. 只需按照当前可以进行的重新涂色操作数量的降序对它们进行排序即可. 如果数字相同, 则副本必须相等, 因此它们的顺序无关紧要.</p><p>排序后, 考虑一对相邻图片的所有不同单元格. 不可能有两个不同的单元格彼此相邻. 因此, 任何操作都不能干扰另一个操作. 所以制作副本的时候, 随便顺序操作就行</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    ++ k;<br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&gt; <span class="hljs-built_in">a</span>(k + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(m)));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">1</span>; id &lt;= k; ++ id) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>                cin &gt;&gt; a[id][i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; <span class="hljs-built_in">cnt</span>(k + <span class="hljs-number">1</span>);<br>    vector&lt;<span class="hljs-type">int</span>&gt; dx&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id = <span class="hljs-number">1</span>; id &lt;= k; ++ id) &#123;<br>        cnt[id][<span class="hljs-number">1</span>] = id;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m - <span class="hljs-number">1</span>; ++ j) &#123;<br>                <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">auto</span> cc = a[id][i][j];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> dir = <span class="hljs-number">0</span>; dir &lt; <span class="hljs-number">4</span>; ++ dir) &#123;<br>                    <span class="hljs-keyword">auto</span> nc = a[id][i + dx[dir]][j + dy[dir]];<br>                    diff += (cc != nc);<br>                &#125;<br>                cnt[id][<span class="hljs-number">0</span>] += (diff == <span class="hljs-number">4</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// LOG(cnt)</span><br><br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">begin</span>(cnt) + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>(cnt), greater&lt;array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;&gt;());<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= k; ++ i) &#123;<br>        <span class="hljs-keyword">auto</span> g0 = a[cnt[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]], g1 = a[cnt[i][<span class="hljs-number">1</span>]];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; m; ++ l) &#123;<br>                <span class="hljs-keyword">if</span> (g0[j][l] != g1[j][l]) &#123;<br>                    ans.<span class="hljs-built_in">pb</span>(&#123;j, l&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">-1</span>, cnt[i][<span class="hljs-number">1</span>]&#125;);<br>    &#125;<br>    cout &lt;&lt; cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y] : ans) &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; x + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G-Gaining-Rating"><a href="#G-Gaining-Rating" class="headerlink" title="G. Gaining Rating"></a><a href="https://codeforces.com/contest/1772/problem/G">G. Gaining Rating</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>你在一个网站上下棋 , 初始你的等级为$x(x \le 10^{12})$ , 你想要升级到 y$(x &lt; y \le 10^{12})$你有$n(n \le 2 * 10^5)$个对手, 第i个队友的等级为 a[i]$(a[i] \le 10^{12})$ . 你需要与这些对手对战, 如果你的等级大于等于对手的等级, 你将获胜, 并且等级加1. 否则等级减1.</p><p>注意, 对手的等级不会发生变化.</p><p>为了防止你一直打最低等级的对手的, 网站有一个规定. 如果你要与对手 i 对战, 则应该没有其他对手 j, 使得你与 i 的比赛次数多于与 j 的比赛次数. 问你需要打多少局, 才能升到等级y, 如果不能输出-1.</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>要想rating++, 肯定是先跟a[i]小于自己x的人先打, rating打上去了, 再找之前打不过的复仇, 从他们身上赚rating. 所以要先按照a升序排序.</p><p>先判断最开始一轮, rating能不能有所长进, 如果不能, 那就不行</p><p>算完第一轮的长进change之后, 开始逐个找之前打不过的人a[i]. 自己需要加win_t轮change, 最后第win_t + 1轮到达a[i]面前时, 我已经有了x + win_t * change + i的rating. 即 $x + win_t * change + i \geq a[i]$. 取个ceil就可以算出复仇a[i]的轮数了</p><p>但是有可能在打败a[i]之前, 就已经达到了y的目标, 所以要算出suc_t &#x3D; ceil(y - x - i, change). 如果win_t &gt;&#x3D; suc_t, 就要进入最后一轮, 直到x&gt;&#x3D;y.</p><p>直到最后全部a都能击败后, 直接随便挑对手就行了. 即ans +&#x3D; y - x(当前的rating)</p><p>注意上述的x, change和ans都是会实时更新的</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x, y;  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// b: 是否可以击败i</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;   <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a));<br>    <span class="hljs-type">int</span> change = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= a[i])  ++ x, ++ change, ++ ans, b[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span>            -- x, -- change, ++ ans, b[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (x &gt;= y)     &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="hljs-keyword">return</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (change &lt;= <span class="hljs-number">0</span>)    &#123;cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;        <span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">auto</span> ceil = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (a + b - <span class="hljs-number">1</span>) / b;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) <span class="hljs-keyword">if</span> (b[i] == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-comment">// x + win_t * change + i &gt;= a[i]</span><br>        <span class="hljs-comment">// (a[i] - x - i) / change &lt;= win_t</span><br>        <span class="hljs-type">int</span> <span class="hljs-type">win_t</span> = <span class="hljs-built_in">ceil</span>(a[i] - x - i, change);<br>        <span class="hljs-comment">// x + suc_t * change + i &gt;= y</span><br>        <span class="hljs-comment">// (y - x - i) / change &lt;= suc_t</span><br>        <span class="hljs-type">int</span> <span class="hljs-type">suc_t</span> = <span class="hljs-built_in">ceil</span>(y - x - i, change);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">win_t</span> &gt;= <span class="hljs-type">suc_t</span>) &#123;<br>            ans += <span class="hljs-type">suc_t</span> * n;<br>            x += <span class="hljs-type">suc_t</span> * change;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                <span class="hljs-keyword">if</span> (x &gt;= a[j])  ++ x, ++ ans;<br>                <span class="hljs-keyword">else</span>            -- x, ++ ans;<br>                <span class="hljs-keyword">if</span> (x &gt;= y) &#123;cout &lt;&lt; ans &lt;&lt; endl;       <span class="hljs-keyword">return</span>;&#125;<br>            &#125;<br>        &#125;<br>        ans += <span class="hljs-type">win_t</span> * n;<br>        x += <span class="hljs-type">win_t</span> * change;<br>        b[i] = <span class="hljs-number">1</span>;<br>        change += <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans + y - x &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_数论</tag>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 685 (Div. 2) A-E</title>
    <link href="/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/"/>
    <url>/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20685%20(Div.%202)%20A-E/</url>
    
    <content type="html"><![CDATA[<p>做这套题主要是因为我搜”模仿棋”, 搜到了这场的D题, 顺便把其他题也做了</p><h2 id="C-String-Equality"><a href="#C-String-Equality" class="headerlink" title="C. String Equality"></a><a href="https://codeforces.com/contest/1451/problem/C">C. String Equality</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给两个字符串a和b, 问a能不能通过无限次操作到b.</p><p>第一种操作, 相邻交换字符:</p><p>第二种操作, 选取区间长度为k的子串,而且子串中的字母都 &lt;’z’, 每一个字母都加一（比如S0&#x3D;’a’ 操作后,S0&#x3D;’b’)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="D-Circle-Game"><a href="#D-Circle-Game" class="headerlink" title="D. Circle Game"></a><a href="https://codeforces.com/contest/1451/problem/D">D. Circle Game</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给一个d和R,A和B轮流操作, 从(0,0)开始移动, 可以选择 x+&#x3D;d 或者 y+&#x3D;d ,当某人下一次移动会超过圆(圆心在(0,0), 半径为R)的时候, 那个人就输了</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="E-Bitwise-Queries-Hard-Version"><a href="#E-Bitwise-Queries-Hard-Version" class="headerlink" title="E. Bitwise Queries (Hard Version)"></a><a href="https://codeforces.com/contest/1451/problem/E2">E. Bitwise Queries (Hard Version)</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 n 的数组(n 是 2 的幂) , 有 3 种操作, AND OR XOR, 可以获得数组两个元素的 AND OR XOR 值, 仅限 n+1 次操作求原数组</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先考虑以 $a_1$ 为基准求出 $a_1 \oplus a_k$, 这样只要求出 $a_1$ 就可以求出整个数组, 这一步需要 $n-1$ 次操作.</p><p>因为只有 $n$ 个元素, 元素的范围是 $[0,n-1]$, 所以可以进行分类讨论：</p><p>1.所有元素并不是互不相同. 也就是说有重复的元素, 这样只要找到相同的元素, 对相同的元素进行 AND 操作就可以求出这个元素（因为知道了这两个元素和 $a_1$ 的异或值）, 又因为知道了所有元素和 $a_1$ 的 XOR, 所以可以直接算出整个数组. 考虑如何找到相同的元素, 可以开个桶记录每个元素出现的次数. 取最大的出现次数（这种情况下至少两次）, 然后进行一次查找就可以得到所有异或 $a_1$ 相同的元素也就是相同的元素, 任意取两个询问 AND 就可以了. 不过这里有个要注意的, 如果 $a_1$ 恰好是重复的元素只会扫到 $1$ 个不一样的元素, 取 $1$ 询问即可.</p><p>2.所有元素互不相同. 也就是是 $[0,n-1]$ 的全排列. 考虑 XOR 的性质, 相同就是 $0$, 也就是说可以选择 $1$ 这个数, 只有最后一位是 $1$, 其他都是 $0$, 也就是说如果 $a_1\oplus a_k&#x3D;1$, $a_1$ 和 $a_k$ 只有最后一位不一样, 可以通过 AND 操作求出前 $\log n-1$ 位. 同理如果 $a_1\oplus a_k&#x3D;\frac n2$, $a_1$ 和 $a_k$ 只有第一位不一样, 可以通过 AND 操作求出后 $\log n-1$ 位. 把两个结果组合一下（直接或起来）就可以得到 $a_1$. 其实不一定要选择 $1$ 和 $\frac n2$, 只要保证这两个数二进制下每位都至少有个数是 $0$ 就行.</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AND</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;AND &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;<br>    <span class="hljs-type">int</span> res;    cin &gt;&gt; res;     <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">XOR</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;XOR &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;<br>    <span class="hljs-type">int</span> res;    cin &gt;&gt; res;     <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">xr</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;  cnt[<span class="hljs-number">0</span>] ++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        xr[i] = <span class="hljs-built_in">XOR</span>(<span class="hljs-number">1</span>, i);<br>        cnt[xr[i]] ++;<br>    &#125;<br>    <span class="hljs-type">int</span> a1, mx_show_xr = <span class="hljs-built_in">max_element</span>(<span class="hljs-built_in">all</span>(cnt)) - cnt.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// mx_show_xr: 出现最多的xr值</span><br>    <span class="hljs-keyword">if</span> (cnt[mx_show_xr] &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// n个数中有重复的</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; dulplicate_pos;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123; <br>            <span class="hljs-comment">// if (cnt[xr[i]] == cnt[mx_show_xr]) &#123;         // X!!! cnt一致的xr值可能有多个!!!</span><br>            <span class="hljs-keyword">if</span> (xr[i] == mx_show_xr) &#123;<br>                dulplicate_pos.<span class="hljs-built_in">pb</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">LOG</span>(dulplicate_pos)<br>        <span class="hljs-comment">// assert(dulplicate_pos.size() &gt; 1);</span><br>        <span class="hljs-type">int</span> a_dulplicate;<br>        <span class="hljs-keyword">if</span> (dulplicate_pos.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            a_dulplicate = <span class="hljs-built_in">AND</span>(<span class="hljs-number">1</span>, dulplicate_pos.<span class="hljs-built_in">back</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            a_dulplicate = <span class="hljs-built_in">AND</span>(dulplicate_pos.<span class="hljs-built_in">front</span>(), dulplicate_pos.<span class="hljs-built_in">back</span>());<br>        &#125;<br>        a1 = a_dulplicate ^ mx_show_xr;<br>        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 因为全排列, 并且n是二的次幂 a1^a[2~n], 会保证1~n-1的数全部出现一次</span><br>    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// n个数无重复, 就是[0, n-1]的全排列 </span><br>        <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">all</span>(xr), <span class="hljs-number">1</span>) - xr.<span class="hljs-built_in">begin</span>();         <span class="hljs-comment">// a1跟x异或, 得到了00...1, 说明a1大部分都跟x相同</span><br>        <span class="hljs-type">int</span> py = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">all</span>(xr), n / <span class="hljs-number">2</span>) - xr.<span class="hljs-built_in">begin</span>();<br>        a1 = <span class="hljs-built_in">AND</span>(<span class="hljs-number">1</span>, px) | <span class="hljs-built_in">AND</span>(<span class="hljs-number">1</span>, py);<br>        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; a1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>            cout &lt;&lt; (a1 ^ xr[i]) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_博弈</tag>
      
      <tag>算法_位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - Codeforces Round 843 (Div. 2) A-E</title>
    <link href="/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/"/>
    <url>/2023/01/11/%E9%A2%98%E8%A7%A3%20-%20Codeforces%20Round%20843%20(Div.%202)%20A-E/</url>
    
    <content type="html"><![CDATA[<p>次日上午vp写了依托答辩, B一开始没想到. 写C对拍了几次, 花了一个多小时.不过rk2000左右, 比上次vp卡B构造一小时rk6000好多了.</p><p>补题: C有用lowbit的简单做法. D利用最小质因子作为交换机的交换机式建图套路题</p><h2 id="A-Gardener-and-the-Capybaras"><a href="#A-Gardener-and-the-Capybaras" class="headerlink" title="A. Gardener and the Capybaras"></a><a href="https://codeforces.com/contest/1775/problem/A2">A. Gardener and the Capybaras</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>将仅包含a和b的字符串s分成三部分s&#x3D;s1+s2+s3, 使得s2是这三个部分的一个最值（最大值或最小值, 按字典序比较）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>s2为max: s1, s3肯定越短越好, 全a越好, 所以从左边第一个b开始截取子串到倒二, s2肯定比全a的s1大, 长度也&gt;&#x3D;s3</p><p>s2为min: 直接拿一个a就行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;   cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-string">&#x27;a&#x27;</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>) &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// aaaabaaab</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>            cout &lt;&lt; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>  &lt;&lt; s.<span class="hljs-built_in">substr</span>(i, n - i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a><a href="https://codeforces.com/contest/1775/problem/B">B. Gardener and the Array</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>记 f(a) 是 a 数组中, 所有数的按位或.</p><p>现有 n 个数 c1,c2…cn组成的数组, 询问是否有两个不同的子数组 a 和 b , 使得 f(a)&#x3D;f(b)</p><p>数据保证所有数的二进制中 1 的数量之和不超过$10^5$</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果ci的所有位上的数都不是独一无二的, 并且记他们分布在cj, ck上(不一定是只有2个, 这里简单起见). 那么就有f(ci | cj | ck) &#x3D; f(cj | ck). 如下样例:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">3<br>3 1 2 4<br>2 2 3<br>4 3 4 <br></code></pre></td></tr></table></figure><p>ci: 2 3</p><p>cj: 1 2 4</p><p>ck: 3 4</p><p>所以只需要判断ci的所有位是否都独一无二就行了, 即cnt[bit] &gt; 1</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">c</span>(n);<br>    <span class="hljs-comment">// vector&lt;int&gt; cnt(200000 + 10, 0);</span><br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> k;  cin &gt;&gt; k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++ j) &#123;<br>            <span class="hljs-type">int</span> x;  cin &gt;&gt; x;<br>            c[i].<span class="hljs-built_in">pb</span>(x);<br>            cnt[x] ++;<br>        &#125;<br>        <span class="hljs-comment">// sort(all(c[i]));</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;v = c[i];<br>        <span class="hljs-type">bool</span> suc = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v) &#123;<br>            suc &amp;= (cnt[x] &gt; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (suc) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-Interesting-Sequence"><a href="#C-Interesting-Sequence" class="headerlink" title="C. Interesting Sequence"></a><a href="https://codeforces.com/contest/1775/problem/C">C. Interesting Sequence</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>对于n, 求最小的m, 使得 n&amp;(n+1)&amp;…&amp;m &#x3D; x</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>获取<strong>x的二进制长度: floor(log2(x)) + 1</strong></p><p>每一二进制位上, 只可能从无0变成有0<br>所以x只可能是n的二进制子集<br>某一二进制位经历从1变成0, 全部低位肯定全部经历过全0<br>所以: x只能保留n高位1的子集<br>他的高一位也要经历翻转<br>所以: 如果x跟n在mask的交界处有俩相邻的1, 那就不行<br>注意还要判断除了x和n的最长公共前缀外, x后面还有没有1, 如果有1就不行</p><p>n: 0000110111100000101 101101011001110100111011001000000000000000000<br>x: 0000110111100000101 000000000000000000000000000000000000000000000<br>ans: -1 (公共前缀最后一位是1)</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000000000000000000000000000000000000000000000<br>ans: 000011011110000011</p><p>n: 000011011110000010 1101101011001110100111011001000000000000000000<br>x: 000011011110000010 1000010000000000000000000000000000000000000000<br>ans: -1 (mask &amp; x !&#x3D; x)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;   cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x &gt; n) &#123;        <span class="hljs-comment">// &amp; 只会变小</span><br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (x == n) &#123;<br>        cout &lt;&lt; n &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> bit = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">log2</span>(n)) + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; (<span class="hljs-number">1ll</span> &lt;&lt; bit) &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>, last = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">62</span>;<br>    <span class="hljs-keyword">for</span> (; b &gt;= <span class="hljs-number">0</span>; -- b) &#123;<br>        <span class="hljs-keyword">if</span> ((x &gt;&gt; b &amp; <span class="hljs-number">1</span>) == (n &gt;&gt; b &amp; <span class="hljs-number">1</span>)) &#123;<br>            mask |= (<span class="hljs-type">int</span>)(x &gt;&gt; b &amp; <span class="hljs-number">1</span>) &lt;&lt; b;<br>            last = (x &gt;&gt; b &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((n &gt;&gt; b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (x &gt;&gt; b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;  <br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (last == <span class="hljs-number">1</span> || (mask &amp; x) != x) &#123;            <span class="hljs-comment">// 1011 -&gt; 1010</span><br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 最后1个1的位置</span><br>    b += <span class="hljs-number">1</span>;<br>    mask |= <span class="hljs-number">1ll</span> &lt;&lt; (b);<br>    cout &lt;&lt; mask &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>附上对拍数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">mt19937 <span class="hljs-title">mrand</span><span class="hljs-params">(random_device&#123;&#125;())</span></span>; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">mrand</span>() % x + <span class="hljs-number">1</span>; &#125;   <span class="hljs-comment">// [1, x]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10000</span>;<br>    cout &lt;&lt; n &lt;&lt; endl;<br>    vector pw&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">1024</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">rnd</span>(<span class="hljs-number">1000</span>), b = pw[<span class="hljs-built_in">rnd</span>(pw.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>] + pw[<span class="hljs-built_in">rnd</span>(pw.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>];<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-Friendly-Spiders"><a href="#D-Friendly-Spiders" class="headerlink" title="D. Friendly Spiders"></a><a href="https://codeforces.com/contest/1775/problem/D">D. Friendly Spiders</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现有 n 个数 a1,a2⋯,an. 如果 gcd(ai,aj)&gt;1, 则它们之间有一条长度为 1 的边. 请找到 s 和 t 的最短路径. $1\le n, a_i\le 3\times 10^5$</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>边权01 -&gt; 01bfs</p><p>建图问题:</p><ul><li>每一次遇到一个数时, 即使它只有一条边, 我们也需要花费O(n)的代价求出所有与它相关的边. 最终导致n^2建图</li><li>图的边数很多, 没有办法快速求解</li></ul><p>从埃氏筛刷is_p表的方法, 可以想到用最小质因子作为交换机. 将包含这个质因子的其他数连接起来. 边数: n^2 -&gt; 2*n</p><p>最终, 每个点只跟自己的质因子连边, 建图复杂度$O(n \sqrt{n})$. bfs复杂度$O(n + n \sqrt{n})$</p><p>坑点: 节点数值a[i]可以一样, 所以建图的时候就用编号建.</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v2id</span>(<span class="hljs-number">300000</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) &#123;<br>        cin &gt;&gt; x;<br>        v2id[x].<span class="hljs-built_in">pb</span>(++ idx);<br>    &#125;<br>    <span class="hljs-type">int</span> s, t;   cin &gt;&gt; s &gt;&gt; t;<br>    vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; <span class="hljs-built_in">g</span>(<span class="hljs-number">600000</span> + <span class="hljs-number">10</span>);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">is_p</span><span class="hljs-params">(<span class="hljs-number">300000</span> + <span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">300000</span>; ++ i) &#123;<br>        <span class="hljs-comment">// if (st[i])      continue;</span><br>        <span class="hljs-keyword">if</span> (!is_p[i])   <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 2, 4, 6, 8, 10...之间连边 打电话式建图n^2</span><br>        <span class="hljs-comment">// 交换机式建图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= <span class="hljs-number">300000</span>; j += i) &#123;  <br>            <span class="hljs-keyword">if</span> (j != i)     is_p[j] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (v2id[j].<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> uid : v2id[j]) &#123;<br>                    g[uid].<span class="hljs-built_in">pb</span>(&#123;i + <span class="hljs-number">300000</span>, <span class="hljs-number">0</span>&#125;);<br>                    g[i + <span class="hljs-number">300000</span>].<span class="hljs-built_in">pb</span>(&#123;uid, <span class="hljs-number">1</span>&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    deque&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; dq;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-number">600000</span> + <span class="hljs-number">10</span>, inf)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">600000</span> + <span class="hljs-number">10</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    dist[s] = <span class="hljs-number">0</span>;                        dq.<span class="hljs-built_in">pb</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (dq.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [cd, cv] = dq.<span class="hljs-built_in">front</span>();     dq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span> (cd &gt; dist[cv])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (cv == t) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [nv, w] : g[cv]) &#123;<br>            <span class="hljs-built_in">LOG</span>(cv, nv, w)<br>            <span class="hljs-keyword">if</span> (dist[nv] &gt; dist[cv] + w) &#123;<br>                dist[nv] = dist[cv] + w;<br>                pre[nv] = cv;<br>                <span class="hljs-keyword">if</span> (w == <span class="hljs-number">1</span>) &#123;<br>                    dq.<span class="hljs-built_in">pb</span>(&#123;dist[nv], nv&#125;);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    dq.<span class="hljs-built_in">push_front</span>(&#123;dist[nv], nv&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(dist[t])<br>    <span class="hljs-keyword">if</span> (dist[t] &gt; inf / <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> now = t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-keyword">while</span> (now != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (now &lt;= <span class="hljs-number">300000</span>) &#123;<br>            path.<span class="hljs-built_in">pb</span>(now);<br>        &#125;<br>        now = pre[now];<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">all</span>(path));<br>    <span class="hljs-built_in">LOG</span>(path)<br>    cout &lt;&lt; path.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : path) cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-The-Human-Equation"><a href="#E-The-Human-Equation" class="headerlink" title="E. The Human Equation"></a><a href="https://codeforces.com/contest/1775/problem/E">E. The Human Equation</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给一个序列a[n] (n&lt;&#x3D;2e5), 要通过下面的两种操作, 最终全部变成0, 最少需要操作几次</p><blockquote><p>操作1: 选a的一个子序列, 然后子序列奇数位+1, 偶数位-1<br>操作2: 选a的一个子序列, 然后子序列奇数位-1, 偶数位+1</p></blockquote><p>如[1,4,2,8,5,7,3,6,9] -&gt; [4,2,5,6]用操作1<br>-&gt; [1,5,1,8,6,7,3,5,9]</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>pre[n]: a[n]的前缀和数组</p><p>a[i] + 1, a[j] - 1 相当于pre[i ~ j - 1] + 1<br>a[3] + 1, a[4] - 1 相当于pre[3] + 1<br>a[3] + 1, a[5] - 1 相当于pre[3 ~ 4] + 1</p><p>最终状态: pre全部为0</p><p>所以一次操作, 可以把pre上任何位置上的数+1 &#x2F; -1</p><p>只需要记录前缀和中的mn和mx, 答案分类讨论下就行</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a)   cin &gt;&gt; x;<br><br>    <span class="hljs-type">int</span> cs = <span class="hljs-number">0</span>, mx = <span class="hljs-number">-2e9</span>, mn = <span class="hljs-number">2e9</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cs += a[i];<br>        mx = <span class="hljs-built_in">max</span>(mx, cs);<br>        mn = <span class="hljs-built_in">min</span>(mn, cs);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mx &lt; <span class="hljs-number">0</span>)         ans = <span class="hljs-built_in">abs</span>(mn);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mn &gt; <span class="hljs-number">0</span>)    ans = <span class="hljs-built_in">abs</span>(mx);<br>    <span class="hljs-keyword">else</span>                ans = mx - mn;<br>    <span class="hljs-built_in">LOG</span>(ans, mn, mx)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_最短路</tag>
      
      <tag>算法_数论</tag>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 牛客小白月赛65 A-F</title>
    <link href="/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/"/>
    <url>/2023/01/09/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B65%20A-F/</url>
    
    <content type="html"><![CDATA[<h2 id="B-牛牛写情书"><a href="#B-牛牛写情书" class="headerlink" title="B - 牛牛写情书"></a><a href="https://ac.nowcoder.com/acm/contest/49888/B">B - 牛牛写情书</a></h2><h3 id="题意-分析"><a href="#题意-分析" class="headerlink" title="题意 + 分析"></a>题意 + 分析</h3><p>判断模式串T是否是给定串S的子串.<br>瞎写双指针      X<br>KMP &#x2F; 双哈希            V<br>5e3: 直接substr暴力$n^2$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;   cin &gt;&gt; n &gt;&gt; m;<br>    string os, k;    cin &gt;&gt; os &gt;&gt; k;<br>    string s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(os[i])) &#123;<br>            s.<span class="hljs-built_in">pb</span>(os[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(s)<br>    n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + m - <span class="hljs-number">1</span> &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">substr</span>(i, m) == k) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-牛牛排队伍"><a href="#C-牛牛排队伍" class="headerlink" title="C - 牛牛排队伍"></a><a href="https://ac.nowcoder.com/acm/contest/49888/C">C - 牛牛排队伍</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 n 个人排队, 1 号排在 2 号前面, 2 号排在 3 号前面. 老师会把某个人叫走, 叫走之后这个人就离开了队伍, 即a-b-c &#x3D;&gt; a-c. 老师偶尔也会感到疑问, 她想知道此时排在 a 号前面的同学是几号呢？</p><p>一共会有 k 次操作, 每次会执行下面的一种：</p><ol><li>把 x 叫走</li><li>求排在 x 前面的是谁</li></ol><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pre, nxt模拟双向链表</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>            pre[i] = i - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>            nxt[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (k --) &#123;<br>        <span class="hljs-type">int</span> op, x;  cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> a = pre[x], b = nxt[x];<br>            pre[x] = nxt[x] = <span class="hljs-number">0</span>;<br>            nxt[a] = b;<br>            pre[b] = a;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; pre[x] &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-牛牛取石子"><a href="#D-牛牛取石子" class="headerlink" title="D - 牛牛取石子"></a><a href="https://ac.nowcoder.com/acm/contest/49888/D">D - 牛牛取石子</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 分别有a, b个, 牛牛和牛妹轮流取石子, 牛牛先手, 每次取石子的时候只能从以下 2 种方案种挑一种来取：</p><blockquote><p>第一堆取 1 个, 第二堆取 2 个<br>第一堆取 2 个, 第二堆取 1 个</p></blockquote><p>谁先无法取石子, 谁就输了. 假设牛牛和牛妹都很聪明, 请问谁会获胜？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1e18: 打表找规律</p><p>模仿是博弈里面的一个重要的策略, 主要思想:<br>断对手后路, 并且对局任何时候都能够重复对手的行为. 这样的话, 当对手还有做法, 自己必然有对应的方法</p><p>a, b两堆石子, 必败态是: min(a, b) % 3 &#x3D;&#x3D; 0. 因为后手总是可以控制min(a, b)在一轮下来-3<br>B能赢的局面, B用模仿策略一定会赢: 4 4 -&gt; 一轮模仿 -&gt; 1 1<br>B不能赢的局面, B不用模仿策略, 用其他策略也一定会输:<br>A: 5 4<br>B: 4 2(必胜态) | 3 3(必败态) a给b第二种局面 b必输<br>原因在于: 若min(a, b) % 3 !&#x3D; 0     A总是可以把min(a, b) % 3 &#x3D;&#x3D; 0的局面给B</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> C = <span class="hljs-number">15</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">awin</span>(C + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(C + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>awin[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = awin[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= C; ++ i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; j &gt;= <span class="hljs-number">2</span>)   awin[i][j] |= !awin[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span> &amp;&amp; j &gt;= <span class="hljs-number">1</span>)   awin[i][j] |= !awin[i - <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &gt; b)  <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-type">int</span> r = a / <span class="hljs-number">3</span>;      <span class="hljs-comment">// ab互走r轮对称棋</span><br>    b = b - r * <span class="hljs-number">3</span>;<br>    a = a - r * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span>(a, b) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (a == b &amp;&amp; a == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="E-牛牛的构造"><a href="#E-牛牛的构造" class="headerlink" title="E - 牛牛的构造"></a><a href="https://ac.nowcoder.com/acm/contest/49888/E">E - 牛牛的构造</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>构造一个1到n的排列, 使得其中正好有k个二元组(i,j)满足, $1 \leq i&lt;j \leq n$ &amp;&amp; $a_i - a_j &#x3D; 2^x(x\in N)(1\le n \le 10^6, 1\le k \le 10^9)$</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>考虑降序的排列: 9 8 7 6 5 4 3 2 1</p><blockquote><p>f[x]: 降序排列时, x对xi-xj&#x3D;2^k 的贡献<br>f[9]: 4<br>f[8]: 3<br>f[7]: 3<br>f[6]: 3<br>f[5]: 3<br>f[4]: 2<br>f[3]: 2<br>f[2]: 1<br>f[1]: 0</p></blockquote><p>先降序, 后升序<br>降序部分: 由于比dec[i]的数都在dec[i]右边. 所以dec[i]的贡献就是f[dec[i]]<br>升序部分: 比inc[i]自己小的数全在自己左边, 所以inc[i]的贡献为0<br>​</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        f[i] = f[i - <span class="hljs-number">1</span>] + (<span class="hljs-built_in">popcountll</span>(i - <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(f)<br>    <span class="hljs-type">int</span> mxk = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">all</span>(f), (<span class="hljs-type">int</span>)<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (mxk &lt; k) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dec, inc;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; -- i) &#123;<br>        <span class="hljs-keyword">if</span> (k &gt;= f[i]) &#123;<br>            dec.<span class="hljs-built_in">pb</span>(i);<br>            k -= f[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            inc.<span class="hljs-built_in">pb</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">all</span>(inc));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : dec)  cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : inc)  cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-牛牛的考试"><a href="#F-牛牛的考试" class="headerlink" title="F -  牛牛的考试"></a><a href="https://ac.nowcoder.com/acm/contest/49888/F">F -  牛牛的考试</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有 n 门课程都需要预习, 每个课程有对应的预习时长, 并且除第1门课外都有前置课程. （第1个课程需要预习完其他所有课程才能预习. ）可以选择双开学习, 手机和电脑在同一时间预习不同的课程, 也可以选择单开, 某个时间只预习一个课程. 每个课程预习后, 牛牛就会不间断的继续预习下一个能预习的课程. 问牛牛最短多久能预习完所有课程？<br>若某个课程需要花费 5 分钟, 牛牛可以选择先预习 2 分钟, 然后去预习别的课程, 再回来预习剩下的 3 分钟.</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>树形dp: array&lt;int, 2&gt; dp[i]表示学完第i门课及所有子树所需的最少双开时间和单开时间</p><blockquote><p>对于同一门课而言:<br>双开时间可以转成单开时间, 即双开可以反悔成单开.<br>但是单开不能转成双开, 否则说明同时用手机电脑学同一门课.</p></blockquote><p>所以在合并两个节点的dp的时候, 要先聪某门课的双开时间拿一点出来, 把这俩节点的单开时间尽可能凑得接近, 然后再合并这俩的单开时间.</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; g;<br>vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; dp;   <span class="hljs-comment">// dp[i][0] : 双开时间, dp[i][1] : 单开时间</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-function">array&lt;<span class="hljs-type">int</span>, 2&gt; <span class="hljs-title">add</span><span class="hljs-params">(array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; a, array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-comment">// &#123;0, 4&#125; + &#123;0, 8&#125; = &#123;4, 4&#125;</span><br>    <span class="hljs-comment">// &#123;1, 2&#125; + &#123;0, 5&#125; = &#123;0, 4&#125; + &#123;0, 5&#125; = &#123;4, 1&#125;</span><br>    <span class="hljs-comment">// &#123;3, 2&#125; + &#123;0, 4&#125; = &#123;0, 5&#125; + &#123;0, 4&#125; = &#123;5, 1&#125;</span><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>])    <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">min</span>(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>);<br>    a[<span class="hljs-number">0</span>] -= d, a[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span> * d;<br>    <span class="hljs-keyword">return</span> &#123;a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>] + <span class="hljs-built_in">min</span>(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]), <span class="hljs-built_in">max</span>(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]) - <span class="hljs-built_in">min</span>(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>])&#125;;<br>    <span class="hljs-comment">// 下面的是错的: 一次性把双开转成单开, 但是单开再转成双开是不成立的</span><br>    <span class="hljs-comment">// return &#123;(a[0] * 2 + b[0] * 2 + a[1] + b[1]) / 2, (a[0] * 2 + b[0] * 2 + a[1] + b[1]) % 2&#125;;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        dp[u] = <span class="hljs-built_in">add</span>(dp[u], dp[v]);<br>    &#125;<br>    dp[u][<span class="hljs-number">1</span>] += a[u];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;  cin &gt;&gt; n;<br>    g.<span class="hljs-built_in">resize</span>(n);    dp.<span class="hljs-built_in">resize</span>(n);   a.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> x;  cin &gt;&gt; x;   x--;<br>        g[i].<span class="hljs-built_in">pb</span>(x); g[x].<span class="hljs-built_in">pb</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_构造</tag>
      
      <tag>算法_博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2022 12.19-12.25 (喉咙最痛的一集)</title>
    <link href="/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25%20(%E5%96%89%E5%92%99%E6%9C%80%E7%97%9B%E7%9A%84%E4%B8%80%E9%9B%86)/"/>
    <url>/2022/12/29/%E5%91%A8%E8%AE%B0%20-%202022%2012.19-12.25%20(%E5%96%89%E5%92%99%E6%9C%80%E7%97%9B%E7%9A%84%E4%B8%80%E9%9B%86)/</url>
    
    <content type="html"><![CDATA[<h2 id="12-19-周一-晴"><a href="#12-19-周一-晴" class="headerlink" title="12.19 周一  晴"></a>12.19 周一  晴</h2><p>今天得早起赶早上9点的高铁, 于是我7点整就起床了, 在宿舍吃完早餐7:30出门, 想到要面对满大街满车的小阳人, 我就换上了N95. 坐地铁到南站认证了学生资质后, 大概还剩下15分钟. 我的座位在高铁车厢左上方靠窗的位置. 上了车我就直接睡到站. 到南站后, 我不记得以往出站口是哪了, 毕竟前两次回家都是坐火车回的, 所以这次老爸兜了一圈才找到我.</p><p>虽然知道家里人都已经阳了, 但我仍然认为病毒只是小事, 并且感染是迟早的事, 所以一上车就把口罩摘了. 回到家我最想做的事情是学琴, 所以下单了&lt;哈农&gt;和&lt;拜厄&gt;,</p><h2 id="12-20-周二-晴"><a href="#12-20-周二-晴" class="headerlink" title="12.20 周二  晴"></a>12.20 周二  晴</h2><p>感染第一天: 流鼻涕</p><h2 id="12-21-周三-晴"><a href="#12-21-周三-晴" class="headerlink" title="12.21 周三  晴"></a>12.21 周三  晴</h2><p>待填</p><h2 id="12-22-周四-多云"><a href="#12-22-周四-多云" class="headerlink" title="12.22 周四  多云"></a>12.22 周四  多云</h2><h2 id="12-23-周五-阴"><a href="#12-23-周五-阴" class="headerlink" title="12.23 周五 阴"></a>12.23 周五 阴</h2><p>待填</p><h2 id="12-24-周六-晴"><a href="#12-24-周六-晴" class="headerlink" title="12.24 周六 晴"></a>12.24 周六 晴</h2><p>今天是考研第一天, 希望舍友jmy和xhq都顺利上岸~</p><p>晚上打了atcoder Beginner Contest 283, E题罚坐. rk1800+, 分数只加了3分. 赛后看题解, 感觉这题是非典型的DP. 搞笑的是, 我赛时一直以为是大聪明构造题, 压根没往DP上想, 不过题目难度1800+分蓝题也摆在这, 题目显然不是现阶段的我赛时能搞得定的. F则是拆绝对值 + 区间最值查询 + 单点修改. 这种拆绝对值的套路算是学到了, 不过这种线段树写起来我也够呛. 毕竟目前线段树总共做了不超过5题, 也是时候补补数据结构了.</p><h2 id="12-25-周日-晴"><a href="#12-25-周日-晴" class="headerlink" title="12.25 周日 晴"></a>12.25 周日 晴</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>回忆于：12.29日晚22点</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2022 12.12-12.18 (圆梦XCPC)</title>
    <link href="/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18%20(%E5%9C%86%E6%A2%A6XCPC)/"/>
    <url>/2022/12/20/%E5%91%A8%E8%AE%B0%20-%202022%2012.12-12.18%20(%E5%9C%86%E6%A2%A6XCPC)/</url>
    
    <content type="html"><![CDATA[<h2 id="12-12-周一-晴"><a href="#12-12-周一-晴" class="headerlink" title="12.12 周一  晴"></a>12.12 周一  晴</h2><p>早上刷题.</p><p>下午和zzm在综楼二楼教员休息室下番《冰菓》《中二病也要谈恋爱》《路人女主的养成方法》, 同时刷题. 主要是《D. Range &#x3D; √Sum》这题, R1800的构造题, 只能想出偶数的构造方法, 奇数情况还是过于抽象了.</p><p>晚上吃师生缘的煎饼果子, 看完了《剃须. 然后捡到高中生》. 个人认为这番其实还算治愈番, 但是事实上知乎B站上许多评论都抓着女主公交车的设定一直踩. 可能是这还只是我正式进军二次元后看的第二部番, 姑且还觉得不错, 挺期待剃须出第二部的.</p><p>晚上跟zzm及他同学联机深岩银河.</p><h2 id="12-13-周二-晴"><a href="#12-13-周二-晴" class="headerlink" title="12.13 周二  晴"></a>12.13 周二  晴</h2><p>日程基本同周一.</p><h2 id="12-14-周三-晴"><a href="#12-14-周三-晴" class="headerlink" title="12.14 周三  晴"></a>12.14 周三  晴</h2><p>日程基本同周一. 下番《辉夜大小姐想让我告白》全部三季. 晚餐尝试了步步高门口街道上的潼关肉夹馍, 10块量少但味道不错.</p><h2 id="12-15-周四-多云"><a href="#12-15-周四-多云" class="headerlink" title="12.15 周四  多云"></a>12.15 周四  多云</h2><p>今天9:45-11:45 是《高性能计算》的期末考试. 虽然线上考试并且开卷, 但我仍觉得很难. 老师也觉得很难, 所以又延长了10分钟到11:55. 我12点整把试卷拍照上传助教邮箱. 挺无语的, 本来就一限选, 还搞严格的签到、实验和线上考试.</p><p>晚上zwling发消息说南京站的物资到了, 惊喜的是外套居然还带ICPC标. 相比之下沈阳的廉价格子衫就是屑了.</p><h2 id="12-16-周五-阴"><a href="#12-16-周五-阴" class="headerlink" title="12.16 周五 阴"></a>12.16 周五 阴</h2><p>话不多说, 养精蓄锐ing.</p><h2 id="12-17-周六-晴"><a href="#12-17-周六-晴" class="headerlink" title="12.17 周六 晴"></a>12.17 周六 晴</h2><p>今天14:00-16:00是ICPC南京站的热身赛. 10点半不到我就吃了午餐, 午餐在师生缘吃的自助. 同样还是12点小睡了30分钟到1点起床. 我带上南京站的物资——3碗鸭血粉丝和《高数100》的牌子在楼下跟zwling汇合, 一起前往院楼. 看得出zwling似乎有些生病, 不过都拼到这一步了, 我相信大家都是想让本科的ICPC生涯有始有终的.</p><p>走到天马公寓门口时, 后面一位好心的小姐姐提醒了我书包在漏水. 听到她的提醒我先是愣了下, 随后立马把笔记本电脑拿了出来. 之前其实也发生过水壶漏水的事故, 并且电脑都没啥事. 但是这次漏水偏偏赶在热身赛赛前1小时不到, 并且还刚好是3人3机位. 一看到电脑朝下的那一边湿了一大片, 内心也凉了大半截. 不过<strong>好在有初中毕业游手机进水的经验</strong>, 这次还是学聪明了：虽然很想知道电脑是否还健在, 也很想知道明天的正式赛会不会受到影响, 我也还是忍住没按下开机键, 在路上全称用手拎着电脑边甩边让风吹, 到院楼放在门口晒了20分钟. 热身赛马上就要开始了, 我只能按下开机键, 已经做好了最坏的打算. 电脑也跟我开了个玩笑, 开机成功后自己又重启了, 不过好在这只是系统更新. 最后电脑开是能开, 但是左下角的屏幕就暗一片亮一片.</p><p>热身赛开始阶段我们跟着榜, 着力于过题数最多的B, 却发现只能想到6次方（n&#x3D;20）的做法. 我的想法是每次直接找第一个1, 然后BFS到另外一个1, 将轨迹应用于全图. 这样每次至少减少1个1, 复杂度虽然不会超, 但是却无法保证轨迹总长度不超过50000, 所以也没敢上机写. 可是诡异的是很多支队伍都很快通过了. 前1小时我们都还是1题没过. 直到姜哥看到D题题面有对B题随机化解法的代码, 才发现这是往年南京站原题. 于是姜哥很快把D题签了, 然后把D题的代码直接复制到B, 至此B也过了. 最后的A题我和zwling想出了二分的假算法, 前期一直没找到钱越多买的书越多的反例, 因此也就因此WA. 姜哥及时提出了反例, 并且给出了正确的贪心做法, 只不过此时已经接近结束了.</p><p>虽说我们热身赛封榜前一道没过, 排在了300名左右. 在回宿舍的路上, 姜哥还说他隔壁宿舍有人羊了. 按照我一直奉为圭臬的人品守恒定律, 我已经看到了明天的结果：高数100将在南京站修成正果. 首先是队长zwling生病疑似阳性, 然后又是我电脑进水. 接下来又是姜哥附近与有人确诊. 这无疑给了我莫大的鼓舞. 回到园区后, zwling还是去门口核酸亭做了混检.</p><p>晚上打了atcoder Beginner Contest 282, 直接D题罚坐. rk2000+, tnnd看来青名又要离我远去了.</p><h2 id="12-18-周日-晴-终极时刻"><a href="#12-18-周日-晴-终极时刻" class="headerlink" title="12.18 周日 晴 (终极时刻)"></a>12.18 周日 晴 (终极时刻)</h2><p>仍是凌晨1点睡, 只不过早上9:30起床, 10:00前进餐完毕, 只吃了肉松饼和上次CCSP发的零食, 睡了20来分钟. 10:00出发去院楼参加南京正式赛.</p><p>开题签到题I, 在我们迟疑的功夫, 已经过了快300人了.</p><p>第二题G贪心, 姜哥首先发现要贪心0前半段要取1, 后半段取-1, 随后我提出了二分分界线. 姜哥提出可以O(n)做, 但是写挂了, 于是我就上机开始二分了. 又到了<strong>经典二分分界线环节</strong>, 我还被这个分界线在最左边的情况卡了10分钟, 不愧是我…不过好在在姜哥提醒下, 很快就写完了. 幸运地一发A了.</p><p>第三题看着像计算几何, 姜哥一开始就说这题很简单, 只需要判断v型就行了, 我和zwling都是懵的. 随后姜哥画了几下就上机码了, 第一发没过. 随后过了10来分钟他想出了corner case, <strong>交上去居然直接过了 (WTF???)</strong>. 当然我们也只是开心了一下, 毕竟从此到结束, 我们都再也没能过一道题.</p><p>第四题大模拟二维前缀和, 我们还剩2小时的时间. 我想的是用将轨迹表示成一个01矩阵, 然后再用这个矩阵和最后袋鼠组成的矩形, 做类似求交算移入移出了多少. 姜哥表示应该确实就只是二维前缀和, 随后就开始码. 但是最后因为查不出哪里越界, 一直段错误.</p><p>结束后, 虽然zwling觉得可能还是打铁, 但我和姜哥都觉得铜牌概率蛮大.</p><p>5:30开始滚榜, 当看到《高数100》出现在铜牌区时, <strong>我意识到本科的算法竞赛已经没有遗憾了</strong>. 我觉得这次铜牌不仅幸运女神站在我们这边, 更重要的是队伍的实力确实有所上升, 毕竟这次zwling生病了. 如果他没生病, 我估计我们能将A题调出来. </p><p>最后本科的所有XCPC至此都告一段落了, 想起知乎上一个问题: “打了4年XCPC, 可是最后打铁, 能算XCPCer吗?”, 有人这样回答: “一日为XCPCer, 终身为XCPCer”. 希望多年以后我看到这块奖牌的照片, 能回忆起那些年和zwling, 姜哥奋斗的日子. 希望我能一直为自己曾经是一名 (裆部)XCPCer而自豪. </p><p>希望<strong>zwling能在BUAA找到更强的队友</strong>, 继续在算法竞赛上取得更高的成就. 也<strong>希望姜哥顺利上岸</strong>, 在研究生阶段继续发挥他过人的思维优势. 最后也<strong>感谢我的舍友ZZM</strong>为了给我做志愿者特意推迟2周时间回家.</p><p>接下来就是修改《软件工程》课程大作业的报告, 并且收拾行李, 准备第二天9点的高铁了. 要好好放松下了, 首先得先把剩下的2集麻衣学姐看完hh.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>回忆于：12.20日晚22点<br>BGM：《青春ブタ野郎》青春猪头少年不会梦到兔女郎学姐</p><p>我把《高数100》的队牌带回了宿舍, 跟我大一第一次参加新生赛收获的那个气球、校赛的气球放在一起. 这些都将成为本科最珍贵的回忆：一个智力普通且非OI生的XCPC故事.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/"/>
    <url>/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B105%20D/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/44749">比赛链接</a></p><h2 id="Dijkstra-松弛的理解"><a href="#Dijkstra-松弛的理解" class="headerlink" title="Dijkstra 松弛的理解"></a>Dijkstra 松弛的理解</h2><p>“松弛”的概念来自对最短路径的估计与不为压缩而设计的螺旋拉伸弹簧的长度之间的类比. 最初, 最短路径的成本被高估了, 就像延伸的弹簧一样. 当找到更短的路径时, 估计的成本会降低, 弹簧会放松. 最终, 找到了最短的路径（如果存在）, 并且弹簧已经松弛到其静止长度.</p><h2 id="D-点分治分点"><a href="#D-点分治分点" class="headerlink" title="D - 点分治分点"></a>D - 点分治分点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>G&lt;n, m&gt;, 且$n, m \leq 1e5$, 定义一条简单路径的 low 值为其路径上的边权的最小值, d(u, v) 为从 u 到 v 所有简单路径的最大 low 值. 对于给定的s, u 从 1 到 n 输出 d(s, u), 如果没有任何一条简单路径则输出 -1.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>点边数1e5 -&gt; Dijkstra变形套路</p><p>dist[i]: s-&gt;i的每条路径最短边中的最大值</p><p>松弛逻辑: 起初dist[nv]置为-inf, 小于实际值. 需要经过nv的入点cv和入边w的更新来进行松弛变大, 让dist[nv]松弛到实际值. 如果w比dist[cv]小, 说明w将成为s-&gt;nv所有路径的最短边. 反之, 还是用dist[cv]去更新dist[nv].</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, inf = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, s;<br>vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; G[N];<br><br><span class="hljs-type">int</span> dist[N];    <span class="hljs-comment">// s-&gt;i 每条路径最短边中的最大值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        G[u].<span class="hljs-built_in">pb</span>(&#123;v, w&#125;);<br>    &#125;<br><br>    priority_queue&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; pq;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[s] = inf;<br>    pq.<span class="hljs-built_in">push</span>(&#123;inf, s&#125;);<br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [cd, cv] = pq.<span class="hljs-built_in">top</span>();   pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (dist[cv] &gt; cd) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// cerr &lt;&lt; cv &lt;&lt; endl;</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [nv, w] : G[cv]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[nv] &lt; <span class="hljs-built_in">min</span>(dist[cv], w)) &#123;<br>                dist[nv] = <span class="hljs-built_in">min</span>(dist[cv], w);<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[nv], nv&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (dist[i] &lt; -inf / <span class="hljs-number">2</span> || dist[i] &gt; inf / <span class="hljs-number">2</span>) &#123;<br>            dist[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        cout &lt;&lt; dist[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 第八届“图灵杯”个人赛</title>
    <link href="/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/"/>
    <url>/2022/11/07/%E9%A2%98%E8%A7%A3%20-%20%E7%AC%AC%E5%85%AB%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9D%E4%B8%AA%E4%BA%BA%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/11746">比赛链接</a></p><h2 id="贪吃的派蒙"><a href="#贪吃的派蒙" class="headerlink" title="贪吃的派蒙"></a><a href="https://ac.nowcoder.com/acm/contest/11746/G">贪吃的派蒙</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在每一次的排队中, 编号为i的角色领取上限为Ai, 这意味着他可以领取的甜甜花酿鸡在$[1-Ai]$范围内. 当一个角色领完本次的甜甜花酿鸡, 他&#x2F;她就会回到队列的末尾, 直到所有甜甜花酿鸡都被吃完为止. 当轮到一个角色领取时, 如果所有的甜甜花酿鸡都被领完, 那么他&#x2F;她就要帮大家刷盘子.</p><p>贪吃的派蒙每次都吃固定的Ax个甜甜花酿鸡(如果剩下的甜甜花酿鸡的数量比Ax小, 那么他就把剩下的都吃完). 我们很容易找到派蒙的编号, Ax比其他所有的Ai都要大. 大家都想让派蒙最后留下来刷盘子, 请你写一个程序来判断这是否可能.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><h2 id="Seek-the-Joker-II"><a href="#Seek-the-Joker-II" class="headerlink" title="Seek the Joker II"></a><a href="https://ac.nowcoder.com/acm/contest/11746/E">Seek the Joker II</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>两堆石子, 一堆k-1, 另一堆n-k, 先取到任意一堆的最后一个输</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记 - 2022 10.31-11.06 (XCPC最遗憾的一集)</title>
    <link href="/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.06%20(XCPC%E6%9C%80%E9%81%97%E6%86%BE%E7%9A%84%E4%B8%80%E9%9B%86)/"/>
    <url>/2022/11/06/%E5%91%A8%E8%AE%B0%20-%202022%2010.31-11.06%20(XCPC%E6%9C%80%E9%81%97%E6%86%BE%E7%9A%84%E4%B8%80%E9%9B%86)/</url>
    
    <content type="html"><![CDATA[<h2 id="11-3-周四-晴"><a href="#11-3-周四-晴" class="headerlink" title="11.3 周四 晴"></a>11.3 周四 晴</h2><p>今天一早起来就看到知乎推送《多地核酸开始自费》, 又了解到大舅那边前几天已经开始自费了, 收费是4元&#x2F;次. 不禁联想到昨天还吐槽核酸检测人员的高收入.</p><p>早十有《高性能计算》, 依旧是平平无奇地上半节课签到, 课间从复邻舍401后门溜回宿舍. 不过今天罗HZ老师提到了签到的问题, 在课上指出了缺课达3次需要补卡. 我想起上上周自己因为没看课表, 直接漏掉了一次签到. 不料午饭后, 有同学在课程群里问有没有爬山组队. 这才知道所谓的补卡其实是跟LHZ爬岳麓山, 好感度++. 自己也得找个机会把缺的这次签到补回来.</p><p>下午依旧是赛前的日常刷题.</p><p>晚饭步步高挑香小面. 晚九点打算继续昨晚的师大天马宿舍之行. 虽然没有大门大开, 但是也只是扫个码就放行了. 漫步在师大宿舍园区, 我和ZZM都明显感觉到和湖大天马宿舍不同的地方. 简单来说就是中南南校区和这里都更加具有校园的氛围, 体现在绿化, 路旁的人行道, 路旁的宣传栏, 也体现在这里建筑的杂乱.</p><h2 id="11-4-周五-晴"><a href="#11-4-周五-晴" class="headerlink" title="11.4 周五 晴"></a>11.4 周五 晴</h2><p>8点30分第一个下床. 刷题. 干午饭. 学委此时也发了关于毕设导师的通知了, 毕设郑老师之前提过, 但是目前又没了消息. 我最担心的是找不到愿意挂名的导师.</p><p>下午第三节有《软件工程》, 课上做了些2022辽宁省赛的题目, 发现题目难度不大. 做了<a href="https://ac.nowcoder.com/acm/contest/43937/B">可莉的五子棋</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/M">画画</a>. <a href="https://ac.nowcoder.com/acm/contest/43937/I">图的分割</a>和<a href="https://ac.nowcoder.com/acm/contest/43937/G">栈与公约数</a>暂时没想到做法.</p><p>晚上有例行的每周大组会, 我问了WSH, 发现大家都找了毕设的导师, 所以我也打算把当前进度汇报一下, 顺便问问毕设的事情. 于是跟老师和彭Z约了明天晚上讨论进度.</p><h2 id="11-5-周六-晴"><a href="#11-5-周六-晴" class="headerlink" title="11.5 周六 晴"></a>11.5 周六 晴</h2><p>今天14:00-16:00是ICPC沈阳站的热身赛. 所以10点半不到就吃了午餐, 休息小睡了20分钟后. 便在阜埠河公交站和zwl骑车去院楼105准备上机环境.</p><p>在比赛开始时, zwl的后置录像手机夹住了关机键, 手机直接关机了, 所以我们整场比赛都没法正常交题. 不过还是能看题面, A题签到, B题是输出 (随机生成)满足条件的a序列的期望. 公式是$\frac{(n!)^2}{n^n}$. 就是不知道<code>double</code>的精度能否满足要求. C题是类似石子合并的DP题. 但是暴力DP只能$O(n^3)$由于不知道如何优化至$O(n^2)$, 所以最后只能写一个假算法. 赛后问了SJ, 得知是四边形不等式决策单调性相关, 打扰了.</p><p>晚上的Atcoder只打了半小时.</p><h2 id="11-6-周日-晴"><a href="#11-6-周日-晴" class="headerlink" title="11.6 周日 晴"></a>11.6 周日 晴</h2><p>总结: 遗憾打铁<br>仍是凌晨1点睡, 8:30起床, 10:30前进餐完毕, 睡了10来分钟. 11:30到院楼参加沈阳正式赛.</p><p>开题签到题, 统计字符串中T和D的个数, WA了一发.<br>第二题找规律题, 姜哥首先发现r取越大越好, 但是只考虑a[i]作为左端点, 没加上右端点的情况, WA了一发</p><p>第三题构造题, 我首先用子矩阵数量公式判断出了无解情况. ZWL打表, 发现了长相特殊的合法情况, 所以尝试将二维压缩为一维. 问题转换成把一个数分解成若干个$\frac{i \times (i+1)}{2}$表示. 我提出从i从高到低贪心, 二分i的位置, 上机同时姜哥找反例. 姜哥发现没有反例并且提出可以线性, 但是我写到后面犯傻, 直接神志不清, 并不清楚线性的意思. 于是姜哥接过来完成算法. 第一发TLE, <code>endl</code>原因. 第二发WA, 爆<code>long long</code>. 最后过了</p><p>第四题大模拟暴搜, 题意没读懂, 其实就是炉石随从攻击的逻辑, 奈何没玩过. 调试1个半小时, 没能调对第二个样例. 以为是精度问题. 最后Rank290+无奈打铁.</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 275 A-F</title>
    <link href="/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/"/>
    <url>/2022/11/04/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20275%20A-F/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个$r \times c (r, c\in [1, 9])$二维平面S. 元素<code>S[i][j]</code>是’#’或者’.’, 找出这个平面上所有四个顶点都是’#’的正方形数.</p><p>如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">##.......<br>##.......<br>.........<br>.......#.<br>.....#...<br>........#<br>......#..<br>.........<br>.........<br></code></pre></td></tr></table></figure><p>具有顶点 (1,1)、(1,2)、(2,2) 和 (2,1) 的正方形在所有四个顶点都放置了棋子.</p><p>具有顶点 (4,8)、(5,6)、(7,7) 和 (6,9) 的正方形也有放置在所有四个顶点的棋子.</p><p>因此, 答案是 2.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>枚举正方形两个顶点, 确定一条向量. 再通过旋转这条向量, 得到其他两个点的坐标.</p><p>向量<code>[x, y]</code>顺时针旋转90°: <code>[y, -x]</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rot</span><span class="hljs-params">(array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt; &amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> [x, y] = v;<br>    v = &#123;y, -x&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">1</span> &amp;&amp; x &lt;= <span class="hljs-number">9</span> &amp;&amp; y &gt;= <span class="hljs-number">1</span> &amp;&amp; y &lt;= <span class="hljs-number">9</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++ i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">9</span>; ++ j) <br>            cin &gt;&gt; g[i][j];<br><br>    cerr &lt;&lt; g[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] &lt;&lt; endl;<br>    cerr &lt;&lt; g[<span class="hljs-number">5</span>][<span class="hljs-number">7</span>] &lt;&lt; endl;<br><br>    set&lt;set&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; S;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ci = <span class="hljs-number">1</span>; ci &lt;= <span class="hljs-number">9</span>; ++ ci) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cj = <span class="hljs-number">1</span>; cj &lt;= <span class="hljs-number">9</span>; ++ cj) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ni = <span class="hljs-number">1</span>; ni &lt;= <span class="hljs-number">9</span>; ++ ni) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nj = <span class="hljs-number">1</span>; nj &lt;= <span class="hljs-number">9</span>; ++ nj) <br>                    <span class="hljs-keyword">if</span> (!(ni == ci &amp;&amp; nj == cj) &amp;&amp; g[ci][cj] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[ni][nj] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                        array&lt;<span class="hljs-type">int</span>, 2&gt; v = &#123;ni - ci, nj - cj&#125;;<br>                        <span class="hljs-built_in">rot</span>(v);<br>                        <span class="hljs-type">int</span> i3 = ni + v[<span class="hljs-number">0</span>], j3 = nj + v[<span class="hljs-number">1</span>];<br>                        <span class="hljs-built_in">rot</span>(v);<br>                        <span class="hljs-type">int</span> i4 = i3 + v[<span class="hljs-number">0</span>], j4 = j3 + v[<span class="hljs-number">1</span>];<br>                        <span class="hljs-comment">// if (ci == 5 &amp;&amp; cj == 5 &amp;&amp; ni == 5 &amp;&amp; nj == 7)   cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; endl;</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i3, j3) &amp;&amp; <span class="hljs-built_in">check</span>(i4, j4)<br>                        &amp;&amp; g[i3][j3] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; g[i4][j4] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                            <span class="hljs-comment">// cerr &lt;&lt; ci &lt;&lt; &#x27; &#x27; &lt;&lt; cj &lt;&lt; &#x27; &#x27; &lt;&lt; ni &lt;&lt; &#x27; &#x27; &lt;&lt; nj &lt;&lt; &#x27; &#x27; &lt;&lt; i3 &lt;&lt; &#x27; &#x27; &lt;&lt; j3 &lt;&lt; endl;</span><br>                            set&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; s;<br>                            s.<span class="hljs-built_in">insert</span>(&#123;ci, cj&#125;);<br>                            s.<span class="hljs-built_in">insert</span>(&#123;ni, nj&#125;);<br>                            s.<span class="hljs-built_in">insert</span>(&#123;i3, j3&#125;);<br>                            s.<span class="hljs-built_in">insert</span>(&#123;i4, j4&#125;);<br>                            S.<span class="hljs-built_in">insert</span>(s);<br>                        &#125;<br>                    &#125;   <br>            &#125;<br>        &#125;<br>    cerr &lt;&lt; S.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    cout &lt;&lt; S.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>为非负整数 x 定义的函数 f(x) 满足以下条件：</p><ul><li><p>$f(0) &#x3D; 1$</p></li><li><p>$f(k) &#x3D; f(\lfloor \frac{k}{2}\rfloor) + f(\lfloor \frac{k}{3}\rfloor)$ 对于任何正整数 k</p></li></ul><p>然后找到 $f(N), N\in[0, 1^{18}]$.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>最多需要$log_2n \times log_3n$这么多个数的f值. 标准记搜</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (dp.<span class="hljs-built_in">count</span>(u))    <span class="hljs-keyword">return</span> dp[u];<br>    <span class="hljs-keyword">return</span> dp[u] = <span class="hljs-built_in">dfs</span>(u / <span class="hljs-number">2</span>) + <span class="hljs-built_in">dfs</span>(u / <span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">dfs</span>(n) &lt;&lt; endl;<br>    cerr &lt;&lt; dp.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个一维的棋盘上有 N + 1 个格子, 下标从 0 到 N , 玩家要从 0 这个点出发, 前往 N 这个点. 每个回合玩家都要扔一个 M 面的骰子, 每个骰面上都有不同的数字, 值域是 $[1, M]$ , 扔出每个面的概率都是 $\frac{1}{M}$ . 玩家需要根据要出来的骰面前进, 如果预计前进之后走出了棋盘, 就需要退回多走出的步数, 如果在终点停了下来, 游戏就胜利了, 不能再扔骰子. 问 K 回合后, 玩家胜利的概率. 将结果对 998244353 取模.</p><p>$0 \le M \le N \le 1000, M \in [1, 10], K \in [1, 1000]$ .</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>令 <code>dp[i][j]</code> 为扔第 j 次骰子后, 玩家到达下标为 i 的格子的概率.</p><p>对于每一个 <code>dp[i][j]</code>  $dp[next_i][j + 1] &#x3D; dp[i][j] \times \frac{1}{M}$. 注意如果走出了棋盘, 要特殊讨论停下来的下标.</p><p>已经到达终点n的状态<code>[n][j]</code>不用再向<code>[next_i][j + 1]</code>转移了</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> dp[N][N];       <span class="hljs-comment">// 到达第i格, 共走了j步的所有情况之和</span><br><span class="hljs-comment">// 已经到达n的情况: dp[n][j] 要分开算, += dp[n][j-1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % mod;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>        a = a * a % mod;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> m_1 = <span class="hljs-built_in">qmi</span>(m , mod - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++ j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= m; ++ len) &#123;<br>                <span class="hljs-type">int</span> ni = i + len;<br>                <span class="hljs-keyword">if</span> (ni &gt; n) &#123;<br>                    ni = n - (ni - n);<br>                &#125;<br>                <span class="hljs-comment">// if (next_i &lt;= i) &#123;</span><br>                <span class="hljs-comment">//     cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27; &#x27; &lt;&lt; next_i &lt;&lt; endl;</span><br>                <span class="hljs-comment">// &#125;</span><br>                dp[ni][j + <span class="hljs-number">1</span>] += (dp[i][j] * m_1) % mod;<br>                dp[ni][j + <span class="hljs-number">1</span>] %= mod;<br><br>            &#125;<br>        &#125;<br>        dp[n][j + <span class="hljs-number">1</span>] += dp[n][j];<br>        dp[n][j + <span class="hljs-number">1</span>] %= mod;<br>    &#125;<br>    cerr &lt;&lt; dp[n][k] &lt;&lt; endl;<br>    cout &lt;&lt; dp[n][k] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 A , 定义一次操作的内容是, 删除 A 中一段连续的序列.</p><p>问对于 1, 2, …, M 中的每个数 s , 分别至少要操作多少次,  才能使得 A 中剩下的数和为 s , 如果不可能就输出 -1 .</p><p>$0 \le N \le M \le 3000,  1 \le a_i \le 3000$</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组分段式的DP, 用一个维度表示当前元素是否在分段中</p><p><code>dp[N][N][2]</code>: 前i个数, 构成总和为j, 且第i个数是否在总和中</p><p>如果a[i]不计入总和: <code>dp[i][j][0] = min(&#123;dp[i][j][0], dp[i - 1][j][0], dp[i - 1][j][1] + 1&#125;);</code></p><p>如果a[i]计入总和: <code>dp[i][j][1] = min(&#123;dp[i][j][1], dp[i - 1][j - a[i]][0], dp[i - 1][j - a[i]][1]&#125;);</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> dp[N][N][<span class="hljs-number">2</span>];            <span class="hljs-comment">// 前i个数, 构成总和为j, 且第i个数是否在总和中</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];<br><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++ j) &#123;<br>            dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(&#123;dp[i][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>&#125;);<br>            <span class="hljs-keyword">if</span> (j - a[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(&#123;dp[i][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - a[i]][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j - a[i]][<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// cerr &lt;&lt; dp[n][2][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[n][2][1] &lt;&lt; endl;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++ j) &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">min</span>(&#123;dp[n][j][<span class="hljs-number">0</span>], dp[n][j][<span class="hljs-number">1</span>]&#125;);<br>        <span class="hljs-keyword">if</span> (ans &gt; <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span> / <span class="hljs-number">2</span>)   ans = <span class="hljs-number">-1</span>;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>这次题目总体比较简单, 但是由于概率dp的短板, 导致赛时只做出了A-D, Rank 1600+. 事实上我认为F作为蓝题DP也是比较简单的</p><p>C 模拟 + 向量旋转</p><p>D 记忆化搜索</p><p>E 概率DP</p><p>F DP + 数组划分 &#x2F; 选取子段</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_实现</tag>
      
      <tag>算法_搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - AtCoder Beginner Contest 192 D-F</title>
    <link href="/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/"/>
    <url>/2022/11/03/%E9%A2%98%E8%A7%A3%20-%20AtCoder%20Beginner%20Contest%20192%20D-F/</url>
    
    <content type="html"><![CDATA[<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定整数 $X, X \in [1, 10^{60}]$和 $M, M \in [1, 10^{18}]$, 设 $d$ 是 $X$ 最大的一位数. </p><p>求对于所有的 $a&gt;d,a \in \mathbb{Z}$, $ a $ 进制数 $ X $ 所代表的数的个数, 同时 $ X _a\le M$. </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先, 对于所有 $len (X) &gt;1$ 的情况, $ a $ 的个数与题意中所求一一对应. 而 $len (x) &#x3D;1$ 只需特判. </p><p>注意到这样的 $ a $ 一定在一个连续区间内, 左端点固定, 则可以二分右端点求得数量. </p><p>同时, <code>long long</code> 相乘可能会爆, 必须乘乘数<code>base</code>之前判断当前<code>val &gt; target / base </code>. 或者用 <code>__int128</code>AtCoder 支持 或龟速乘. </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string x;<br><span class="hljs-type">int</span> m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; x &gt;&gt; m;<br>    <span class="hljs-type">signed</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : x)  mx = <span class="hljs-built_in">max</span>(mx, ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (x.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;                        <span class="hljs-comment">// 特判: 因为题目要求不同的数</span><br>        <span class="hljs-keyword">if</span> (mx &lt;= m)    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> base) -&gt; <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x.<span class="hljs-built_in">size</span>(); ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (val &gt; m / base) &#123;               <span class="hljs-comment">// 每次 + *base 之前 跟目标 /base 作比较 防止溢出</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> b = x[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            val *= base;<br>            val += b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (val &lt;= m);<br>    &#125;;<br><br>    <span class="hljs-type">int</span> l = mx, r = <span class="hljs-number">1e18</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid))         l = mid;<br>        <span class="hljs-keyword">else</span>                    r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    cerr &lt;&lt; l &lt;&lt; endl;<br>    cout &lt;&lt; l - mx &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>$G(N, M), N, M \leq 1e5$ 无向图. 设初始时刻为 $ 0 $, 则进入某条边的时刻必须为 $xK_i, x\in\mathbb{N}$, 可以在节点停留, 消耗时间为 $T_i, K_i,T_i \in [1, 1e9]$. 求 $ X $ 到 $ Y $ 的最短路, 不连通则输出 <code>-1</code>. </p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>注意到时间仍然是越短越好, 满足 dijkstra 的基本条件, 直接跑, 改一下松弛时候的边权更新值即可. </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, x, y;<br>vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; G[N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-type">int</span> a, b, t, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; k;<br>        G[a].<span class="hljs-built_in">pb</span>(&#123;b, t, k&#125;);<br>        G[b].<span class="hljs-built_in">pb</span>(&#123;a, t, k&#125;);<br>    &#125;<br>    priority_queue&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;, vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;, greater&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt;&gt; pq;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[x] = <span class="hljs-number">0</span>;    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, x&#125;);<br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [cd, cv] = pq.<span class="hljs-built_in">top</span>();   pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (cd &gt; dist[cv])  <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// cerr &lt;&lt; cd &lt;&lt; &#x27; &#x27; &lt;&lt; cv &lt;&lt; endl;</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [nv, t, k] : G[cv]) &#123;<br>            <span class="hljs-type">int</span> nd = (cd + k - <span class="hljs-number">1</span>) / k * k;<br>            nd = nd + t;<br>            <span class="hljs-comment">// cerr &lt;&lt; nv &lt;&lt; &#x27; &#x27; &lt;&lt; nd &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (nd &lt; dist[nv]) &#123;<br>                dist[nv] = nd;<br>                pq.<span class="hljs-built_in">push</span>(&#123;nd, nv&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cerr &lt;&lt; dist[y] &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (dist[y] &gt;= <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span> / <span class="hljs-number">2</span>)  cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span>                                    cout &lt;&lt; dist[y] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定数组a[N], $a[i] \leq 1e7$和$X \in [1e9, 1e18]$, 要求选出k个数, 总和记为sum, 设$sum + mn * k &#x3D; X$, 求出满足的最小整数mn的值. </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>100个数取数 -&gt; 背包. 但是和背包总和太大, 所以要考虑加入模数</p><p>枚举所有可能选择的物品个数 $ choose $, 分别进行 DP. </p><p><code>dp[k][i][j]</code> &#x3D; 前k个数, 选了i个数, 它们的和必须是%choose&#x3D;j, 满足要求的和的最大值</p><p>不拿第k个物品: <code>dp[k][i][j] = dp[k - 1][i][j];</code></p><p>拿第k个物品: <code>dp[k][i][j] = max(dp[k][i][j], dp[k - 1][i - 1][(j - w[k] + choose) % choose] + a[k]);</code></p><p>总复杂度 $\mathcal{O}(n^4)$. </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, x;<br><span class="hljs-type">int</span> a[N], w[N];<br><span class="hljs-type">int</span> dp[N][N][N];        <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i];<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1e18</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> choose = <span class="hljs-number">1</span>; choose &lt;= n; ++ choose) &#123;<br>        <span class="hljs-type">int</span> m = x % choose;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   w[i] = a[i] % choose;<br>        <br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> dp);<br>        <span class="hljs-comment">// dp[k][i][j] = 前k个数, 选了i个数, 它们的和必须是%choose=j, 满足要求的和的最大值</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++ k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">min</span>(k, choose); ++ i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; choose; ++ j) &#123;<br>                    <span class="hljs-keyword">if</span> (~dp[k - <span class="hljs-number">1</span>][i][j]) &#123;<br>                        dp[k][i][j] = dp[k - <span class="hljs-number">1</span>][i][j];<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (~dp[k - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>][(j - w[k] + choose) % choose]) &#123;<br>                        dp[k][i][j] = <span class="hljs-built_in">max</span>(dp[k][i][j], dp[k - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>][(j - w[k] + choose) % choose] + a[k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最终必须选择了choose个, 并且这choose个总和sum, 满足sum % choose == x % choose</span><br>        <span class="hljs-keyword">if</span> (~dp[n][choose][m]) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, (x - dp[n][choose][m]) / choose);<br>        &#125;<br>    &#125;<br>    cerr &lt;&lt; ans &lt;&lt; endl;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>D 考察乘法溢出, 各种边界讨论比较繁琐</p><p>E 最短路变形, 松弛边权做一下变化即可</p><p>F 背包+模数, 在外层套一层for模数<code>choose</code>, 状态表示加一个维度表示当前总和mod <code>choose</code>的值</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_二分</tag>
      
      <tag>算法_最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 牛客小白月赛59 D-F</title>
    <link href="/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/"/>
    <url>/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B59%20D-F/</url>
    
    <content type="html"><![CDATA[<h2 id="D-国际象棋"><a href="#D-国际象棋" class="headerlink" title="D - 国际象棋"></a>D - 国际象棋</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>n x m (1000) 的竖着放的棋盘, 每次在某一列从上往下丢1个黑白棋子, 黑白间隔着丢, 共丢t (1e6) 个. 问何时出现k连相同颜色的棋子(连棋子规则同五子棋)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>每次加入棋子, 就判断这个位置上”-“, “|”, “&#x2F;“. “\“四个方向上已经连了几个了.</p><p>注意不能分8个方向</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, k, t;<br><span class="hljs-type">int</span> h[N], g[N][N];<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tt = <span class="hljs-number">1</span>; tt &lt;= t; ++ tt) &#123;<br>        <span class="hljs-type">int</span> col, x = tt % <span class="hljs-number">2</span>;    cin &gt;&gt; col;<br>        g[++ h[col]][col] = x;<br><br>        <span class="hljs-type">int</span> cx = h[col], cy = col;<br><span class="hljs-comment">//         cerr &lt;&lt; tt &lt;&lt; &#x27; &#x27; &lt;&lt; cx &lt;&lt; &#x27; &#x27; &lt;&lt; cy &lt;&lt; endl;</span><br><span class="hljs-comment">//         for (int i = n; i &gt;= 1; -- i)   for (int j = 1; j &lt;= m; ++ j)   cerr &lt;&lt; g[i][j] &lt;&lt; &quot; \n&quot;[j == m];</span><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cx + <span class="hljs-number">1</span> &lt;= n &amp;&amp; g[cx + <span class="hljs-number">1</span>][cy] == x)   ++ cx, ++ cnt;<br>        cx = h[col], cy = col;<br>        <span class="hljs-keyword">while</span> (cx - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; g[cx - <span class="hljs-number">1</span>][cy] == x)   -- cx, ++ cnt;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k)       <span class="hljs-keyword">return</span> tt;<br><span class="hljs-comment">//         cerr &lt;&lt; &quot; - &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><br>        cx = h[col], cy = col;<br>        cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cy + <span class="hljs-number">1</span> &lt;= m &amp;&amp; g[cx][cy + <span class="hljs-number">1</span>] == x)   ++ cy, ++ cnt;<br>        cx = h[col], cy = col; <br>        <span class="hljs-keyword">while</span> (cy - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; g[cx][cy - <span class="hljs-number">1</span>] == x)   -- cy, ++ cnt;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k)       <span class="hljs-keyword">return</span> tt;<br><span class="hljs-comment">//         cerr &lt;&lt; &quot; | &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><br>        cx = h[col], cy = col;<br>        cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cx + <span class="hljs-number">1</span> &lt;= n &amp;&amp; cy + <span class="hljs-number">1</span> &lt;= m &amp;&amp; g[cx + <span class="hljs-number">1</span>][cy + <span class="hljs-number">1</span>] == x)   ++ cx, ++ cy, ++ cnt;<br>        cx = h[col], cy = col;<br>        <span class="hljs-keyword">while</span> (cx - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; cy - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; g[cx - <span class="hljs-number">1</span>][cy - <span class="hljs-number">1</span>] == x)   -- cx, -- cy, ++ cnt;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k)       <span class="hljs-keyword">return</span> tt;<br><span class="hljs-comment">//         cerr &lt;&lt; &quot; / &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><br>        cx = h[col], cy = col;<br>        cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cx + <span class="hljs-number">1</span> &lt;= n &amp;&amp; cy - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; g[cx + <span class="hljs-number">1</span>][cy - <span class="hljs-number">1</span>] == x)   ++ cx, -- cy, ++ cnt;<br>        cx = h[col], cy = col;<br>        <span class="hljs-keyword">while</span> (cx - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; cy + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; g[cx - <span class="hljs-number">1</span>][cy + <span class="hljs-number">1</span>] == x)   -- cx, ++ cy, ++ cnt;<br>        <span class="hljs-keyword">if</span> (cnt &gt;= k)       <span class="hljs-keyword">return</span> tt;<br><span class="hljs-comment">//         cerr &lt;&lt; &quot; \\ &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-弹珠碰撞"><a href="#E-弹珠碰撞" class="headerlink" title="E - 弹珠碰撞"></a>E - 弹珠碰撞</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>长度为 n 的线段上, 有 m 颗弹珠在匀速以1单位&#x2F;s 左右滚动. 弹珠ball有d, p两个参数. d(0&#x2F;1)表示左&#x2F;右方向, p表示初始位置. </p><p>两颗滚动方向相反的弹珠位置重合的时候就会停滞 1 单位时间不滚动, 并交换两颗弹珠滚动的方向. 一颗弹珠可以反复发生碰撞, 如果在停滞中受到碰撞, 则停滞时间会累加. </p><p>如果一颗弹珠滚到了位置 0 或位置 n+1, 那么这颗弹珠就滚出了线段. 问最后一颗弹珠在什么时候滚出线段？</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>a -&gt;  &lt;- b 左右两个弹珠相撞后</p><p>&lt;-a   b -&gt; </p><p>&lt;-b   a -&gt; 其实也能等价于a, b两个球直接穿过彼此. 有一道gym上的题, 学弟LLQ就想出来了这个性质, 挺经典的</p><p>算时间的时候, 只用看珠子在前进到终点的过程中, 迎面而来有多少个珠子, 用前后缀统计下就行.</p><p>​</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> d, p;<br>&#125; ball[N];<br><span class="hljs-type">int</span> pre1[N];        <span class="hljs-comment">// -&gt;</span><br><span class="hljs-type">int</span> suf0[N];        <span class="hljs-comment">// &lt;-</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i)   cin &gt;&gt; ball[i].p;<br>    <span class="hljs-built_in">sort</span>(ball + <span class="hljs-number">1</span>, ball + <span class="hljs-number">1</span> + m, [&amp;](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.p &lt; b.p;<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i)   pre1[i] = pre1[i - <span class="hljs-number">1</span>] + (ball[i].d == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= <span class="hljs-number">1</span>; -- i)   suf0[i] = suf0[i + <span class="hljs-number">1</span>] + (ball[i].d == <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>        <span class="hljs-keyword">auto</span> [d, p] = ball[i];<br>        <span class="hljs-type">int</span> t = (d ? (n + <span class="hljs-number">1</span> - p) + suf0[i] : p + pre1[i]);<br>        <span class="hljs-comment">// cerr &lt;&lt; t &lt;&lt; endl;</span><br>        ans = <span class="hljs-built_in">max</span>(t, ans);<br>    &#125;<br>    cerr &lt;&lt; ans &lt;&lt; endl;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-困难卷积"><a href="#F-困难卷积" class="headerlink" title="F - 困难卷积"></a>F - 困难卷积</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定整数序列 a[n], b[n], 求：<br>$$<br>\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\Big\lfloor\sqrt{|a_i-b_j|}\Big\rfloor<br>$$</p><p>其中 $\lfloor x\rfloor$表示不超过 x 的最大整数, 例如 $\lfloor 3.5\rfloor&#x3D;3,\lfloor\sqrt 2\rfloor &#x3D;1$. </p><p>$1≤n≤10^6, 0\leq a_i,b_i\leq 3\times 10^6, \sum a_i,\sum b_i\leq 10^7$. </p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>3e6 排除暴力. 注意到$\sum_{a_i}$才10倍于len(a), 说明有很多数都是重复的. 所以分组计算就行</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N], b[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnta, cntb;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; a[i], cnta[a[i]] ++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   cin &gt;&gt; b[i], cntb[b[i]] ++;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [va, ca] : cnta) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [vb, cb] : cntb) &#123;<br>            ans += <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">abs</span>(va - vb))) * ca * cb;<br>        &#125;<br>    cerr &lt;&lt; ans &lt;&lt; endl;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - 牛客小白月赛34 A-H</title>
    <link href="/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/"/>
    <url>/2022/11/01/%E9%A2%98%E8%A7%A3%20-%20%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B34%20A-H/</url>
    
    <content type="html"><![CDATA[<p>这场是我在牛客上打的第一场比赛, 应该也是我打的第一场CP比赛. 现在来朝花夕拾(补题).</p><h2 id="A-dd爱科学1-0-2-0"><a href="#A-dd爱科学1-0-2-0" class="headerlink" title="A - dd爱科学1.0+2.0"></a><a href="https://ac.nowcoder.com/acm/contest/11211/A">A - dd爱科学1.0</a><a href="https://ac.nowcoder.com/acm/contest/11211/C">+2.0</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>数组a[n](1≤n≤1000000, isupper(a[i]) &#x3D;&#x3D; true). 求通过修改变成不下降序列的最小代价, 每次修改一个数x为y的代价为1(2.0版本为|x - y|).</p><blockquote><p>1.0 ACEBF -&gt; ACEEF 代价 &#x3D; 1<br>2.0 AEEBC -&gt; AEEEE 代价 &#x3D; 偏移量总和为|B-E|+|C-E|&#x3D;3+2&#x3D;5</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>dp[i][j]</code>表示改至第i位为止, 最后一位为j的最小代价(或者理解成最后一位&lt;&#x3D;j也行)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">26</span>; ++ j) &#123;         <span class="hljs-comment">// 当前字符为curr</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= j; ++ k) &#123;      <span class="hljs-comment">// 从上一字符转移而来</span><br>        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][k] + <span class="hljs-built_in">abs</span>(curr - j));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到: <code>min (f[i - 1][1~j-1]+abs)</code> 的值 已经被记录在<code>f[i][j - 1]</code>里了. 这样可以少O(26)的复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">26</span>; ++ j) &#123;<br>    f[i][j] = <span class="hljs-built_in">min</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">abs</span>(curr - j));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, &amp;str[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">26</span>; ++ i)    f[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>    &#123;<br>        <span class="hljs-type">int</span> curr = str[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//当前字符改成</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">26</span>; ++ j) &#123;<br>            <span class="hljs-comment">//从上一字符转移而来</span><br>            <span class="hljs-comment">// for(int k = 1; k &lt;= j; ++ k)</span><br>                <span class="hljs-comment">// f[i][j] = min(f[i][j], f[i - 1][k] + abs(curr - j));</span><br>            <span class="hljs-comment">// min (f[i - 1][1~j-1]+abs) 的值 已经被记录在f[i][j - 1]里了</span><br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i][j - <span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-built_in">abs</span>(curr - j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++ i)    ans = <span class="hljs-built_in">min</span>(ans, f[n][i]);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-dd爱探险"><a href="#B-dd爱探险" class="headerlink" title="B - dd爱探险"></a><a href="https://ac.nowcoder.com/acm/contest/11211/B">B - dd爱探险</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有n(3≤n≤16)个空间站, 任意两个空间站间可以相互跳跃, 由空间站x跳跃到空间站y所需要的代价为<code>P[x][y]</code>,注意不保证<code>p[x][y]=p[y][x]</code>, dd可以任意选择出发的空间站, 并通过恰好n-1次跳跃把所有空间站跳完, 并且dd必须选择2次跳跃, 其中一次跳跃中进行重力加速, 另一次跳跃中进行反重力加速, 重力加速会导致当前跳跃代价变为0, 反重力加速会导致当前跳跃代价翻倍(乘2), 问跳完所有空间站所需要最小代价</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>状压DP. 经典TSP like<br><code>dp[1 &lt;&lt; N][N][2][2]</code>: 走过了i中为1的点,且当前最后到达j, g, rg是否用了重力 &#x2F; 反重力</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">16</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1</span> &lt;&lt; N][N][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];        <span class="hljs-comment">// 是否用了重力 / 反重力</span><br><span class="hljs-type">int</span> n;  <br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            cin &gt;&gt; w[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        dp[<span class="hljs-number">1</span> &lt;&lt; i][i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; val &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++ val) &#123;         <span class="hljs-comment">// 1e5</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> from = <span class="hljs-number">0</span>; from &lt; n; ++ from) &#123;         <span class="hljs-comment">// 10</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to = <span class="hljs-number">0</span>; to &lt; n; ++ to) &#123;           <span class="hljs-comment">// 10</span><br>                <span class="hljs-keyword">if</span> ((val &gt;&gt; to &amp; <span class="hljs-number">1</span>) &amp;&amp; (val &gt;&gt; from &amp; <span class="hljs-number">1</span>)) &#123;<br>                    dp[val][to][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(&#123;dp[val][to][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + w[from][to]&#125;);<br>                    dp[val][to][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(&#123;dp[val][to][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>, dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + w[from][to]&#125;);<br>                    dp[val][to][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(&#123;dp[val][to][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + w[from][to] * <span class="hljs-number">2</span>, dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + w[from][to]&#125;);<br>                    dp[val][to][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(&#123;dp[val][to][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">0</span>, dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + w[from][to] * <span class="hljs-number">2</span>, dp[val ^ <span class="hljs-number">1</span> &lt;&lt; to][from][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + w[from][to]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        ans = <span class="hljs-built_in">min</span>(ans, dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="D-dd爱矩阵"><a href="#D-dd爱矩阵" class="headerlink" title="D - dd爱矩阵"></a><a href="https://ac.nowcoder.com/acm/contest/11211/D">D - dd爱矩阵</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给一个n∗n的矩阵, 每行各选一个数字, 把选出来的n个数字相加, 一共有$n^{n}$ 种可行答案, 输出前n大</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>优先队列 + 动态前k大 + 数组合并</p><p>类似: <a href="https://www.luogu.com.cn/problem/P2085">P2085 最小函数值</a></p><p>先把问题简化一下, 如果两行, 每行 n个数, 怎么选<br>把两行分别降序 sort, 令第一行为数组 a, 第二行为数组 b<br>则可得到最大值为 a[0]+b[0], 并且得到 a[i]+b[j-1]&gt;a[i]+b[j]&gt;a[i]+b[j+1]<br>所以可以把 a[0]+b[i]全部推入优先队列当中, 并且标记对应的 i,每次取出 top, 再把 a[0]+b[i+1]推入优先队列当中,  n次操作即可得到前 n大<br>复杂度 O(nlogn)<br>回到这个题目, 由于是 n行, 可以每次处理两行, 并成一行新的,  n-1次操作把 n行并成一行, 复杂度 O(n^2 logn)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)<br>        heap.<span class="hljs-built_in">push</span>(&#123;a[<span class="hljs-number">0</span>] + b[i], <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> top = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> sum = top.first, idx = top.second;<br>        heap.<span class="hljs-built_in">push</span>(&#123;sum - a[idx] + a[idx + <span class="hljs-number">1</span>], idx + <span class="hljs-number">1</span>&#125;);<br>        t[i] = sum;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)<br>        a[i] = t[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)     cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++ j) cin &gt;&gt; b[j];<br>        <span class="hljs-built_in">merge</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="E-dd爱旋转"><a href="#E-dd爱旋转" class="headerlink" title="E - dd爱旋转"></a><a href="https://ac.nowcoder.com/acm/contest/11211/E">E - dd爱旋转</a></h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>读入一个n∗n的矩阵, 对于一个矩阵有以下两种操作<br>1:顺时针旋180°</p><blockquote><p>[1 2] &#x3D;&gt; [4 3]<br>[3 4]    [2 1]</p></blockquote><p>2:关于行镜像</p><blockquote><p>[1 2] &#x3D;&gt; [3 4]<br>[3 4]    [1 2]</p></blockquote><p>给出q个操作, 输出操作完的矩阵</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>操作1: 相当于行镜像, 列镜像各做一次<br>操作2: 相当于行镜像做一次</p><p>只用看操作1和操作2的奇偶性就行了</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>            <span class="hljs-keyword">if</span>(!vis[i][j])<br>            &#123;<br>                vis[i][j] = vis[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j] =  <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">swap</span>(m[i][j], m[n + <span class="hljs-number">1</span> - i][n + <span class="hljs-number">1</span> - j]);<br>            &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">2</span>; ++ i)<br>        <span class="hljs-built_in">swap</span>(m[i], m[n + <span class="hljs-number">1</span> - i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>            cin &gt;&gt; m[i][j];<br><br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t --)<br>    &#123;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>) ++ cnt1;<br>        <span class="hljs-keyword">else</span>        ++ cnt2;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt1 % <span class="hljs-number">2</span>)    <span class="hljs-built_in">op1</span>();<br>    <span class="hljs-keyword">if</span>(cnt2 % <span class="hljs-number">2</span>)    <span class="hljs-built_in">op2</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j)<br>            cout &lt;&lt;  m[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="F-dd爱框框"><a href="#F-dd爱框框" class="headerlink" title="F - dd爱框框"></a><a href="https://ac.nowcoder.com/acm/contest/11211/F">F - dd爱框框</a></h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>读入n(1≤n≤10000000),x(1≤x≤10000),给出n个数a[1],a[2],……,求最小的区间[l,r], 使a[l]+a[l+1]+……+a[r]≥x, 若存在相同长度区间, 输出l最小的那个</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>二分区间长度 + 前缀和check + 二分内更新答案<br>OR 滑动窗口(不会)</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i + len &lt;= n; ++ i)<br>        <span class="hljs-keyword">if</span>(s[i + len] - s[i - <span class="hljs-number">1</span>] &gt;= x)<br>        &#123;<br>            lbound = i, rbound = i + len;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);    <br>    cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <br>    &#123;<br>        ll t;<br>        cin &gt;&gt; t;<br>        s[i] = s[i - <span class="hljs-number">1</span>] + t;<br>    &#125;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))    r = mid;<br>        <span class="hljs-keyword">else</span>    l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; lbound &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; rbound &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="G-dd爱捣乱"><a href="#G-dd爱捣乱" class="headerlink" title="G - dd爱捣乱"></a><a href="https://ac.nowcoder.com/acm/contest/11211/G">G - dd爱捣乱</a></h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>一个完美串(islower &#x3D;&#x3D; true)应该满足该串中任意长度≥2≥2的子串都不是回文串, 把一个字符从xx变成yy的代价是min(|x-y|,26-|x-y|),(|x-y|为ascii码差值), 问把一个串变成完美串的最小代价</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>首先讨论完美串满足条件, 如果是奇串, 则每一位前后两位不同, 即 <code>a[i-1]≠a[i+1]</code><br>如果是偶串, 则相邻两位不同 <code>a[i]≠a[i-1]</code><br>综上, 只要<strong>任意连续三位都满足两两不同</strong>, 就是一个完美串<br>那么一个很显然的想法, 枚举每一位的情况, 保证再枚举前两位情况, 保证不同的情况下更新答案<br>复杂度 <code>O(n×26^3)</code>, 显然不可接受<br>所以进一步想, 每一位最多只会受前两位和后两位的影响, 所以最差情况下五个字母全部不同(abccd, 中间的c要+&#x3D;2. 如果只有±1,0就不行了). 实际上相邻三个字符各自改变量最多只有五种情况: ±2,±1,0.<br>所以对于每一位只要枚举改变量就行了,  <code>dp[i][j][k]</code>表示把第 i-1位的改变量是 j, 第 i位的改变量是 k的最小代价<br><code>dp[i][j][k]←dp[i-1][l][j]</code><br>最后枚举最后两位改变量 <code>min(dp[n][i][j])</code>就是答案<br>复杂度 <code>O(n×5^3)</code></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e2</span> + <span class="hljs-number">10</span>, offset = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">6</span>][<span class="hljs-number">6</span>];    <span class="hljs-comment">// 第i-1位的改变量为j, 第i位的改变量为k</span><br><span class="hljs-type">int</span> a[N], n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    string s;   cin &gt;&gt; s;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)   a[i] = s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-2</span>; j &lt;= <span class="hljs-number">2</span>; ++ j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">-2</span>; k &lt;= <span class="hljs-number">2</span>; ++ k) &#123;<br>            <span class="hljs-keyword">if</span> ((a[<span class="hljs-number">1</span>] + j + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> != (a[<span class="hljs-number">2</span>] + k + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span>) &#123;<br>                dp[<span class="hljs-number">2</span>][j + offset][k + offset] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">2</span>][j + offset][k + offset], <span class="hljs-built_in">abs</span>(j) + <span class="hljs-built_in">abs</span>(k));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-2</span>; j &lt;= <span class="hljs-number">2</span>; ++ j) &#123;    <span class="hljs-comment">// i-1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">-2</span>; k &lt;= <span class="hljs-number">2</span>; ++ k) &#123;        <span class="hljs-comment">// i</span><br>                <span class="hljs-keyword">if</span> ((a[i] + k + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> != (a[i - <span class="hljs-number">1</span>] + j + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span>) &#123; <span class="hljs-comment">// dp[i][j][k]</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">-2</span>; l &lt;= <span class="hljs-number">2</span>; ++ l) &#123;            <span class="hljs-comment">// i-2</span><br>                        <span class="hljs-keyword">if</span> ( ((a[i - <span class="hljs-number">1</span>] + j + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> != (a[i - <span class="hljs-number">2</span>] + l + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span>) <br>                            &amp;&amp; ((a[i] + k + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> != (a[i - <span class="hljs-number">2</span>] + l + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span>)) &#123;     <span class="hljs-comment">// dp[i - 1][l][j] </span><br>                            dp[i][j + offset][k + offset] = <span class="hljs-built_in">min</span>(dp[i][j + offset][k + offset], dp[i - <span class="hljs-number">1</span>][l + offset][j + offset] + <span class="hljs-built_in">abs</span>(k));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-2</span>; j &lt;= <span class="hljs-number">2</span>; ++ j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">-2</span>; k &lt;= <span class="hljs-number">2</span>; ++ k) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, dp[n][j + offset][k + offset]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="H-dd爱整齐"><a href="#H-dd爱整齐" class="headerlink" title="H - dd爱整齐"></a><a href="https://ac.nowcoder.com/acm/contest/11211/H">H - dd爱整齐</a></h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>当k&#x3D;1时abababab, k&#x3D;2时abbabbabb, k&#x3D;3时abbbabbb这种类型的是优美序列, 现在给你一个数组a[n]和k((1≤k≤n≤1000000)), 每次你可以让数组中的数减1, 问你最少的操作次数使得n数组为k优美序列. 当然不一定就是abbabb, bbabba这个也是2的优美序列. 只要是优美序列的一段(子串)就行. 同时要保证a&gt;&#x3D;b.</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>看到循环结构 &#x2F; 循环节, 要往模数上想<br>目标序列作为k优美序列的子串, 注意到当len(目标序列) &gt;&#x3D; k时, 每k个数就会固定有一个a, k-1个b, 所以只需要确认a的位置就行.</p><p>把位置i对 k+1取余, 余数相等的位置的值必然相等. 因为给定了限制条件 a≥b, 所以通过简单贪心+前缀和计算把第i + Z*k位置上的数改变成a, 其他变成b的代价. 复杂度 O(n)</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;   cin &gt;&gt; n &gt;&gt; k;  <br>    ++ k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(k)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(k)</span>, <span class="hljs-title">mn</span><span class="hljs-params">(k, inf)</span></span>;<br>    <span class="hljs-type">int</span> mna = <span class="hljs-number">1e18</span>, suma = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        cin &gt;&gt; a[i];    mna = <span class="hljs-built_in">min</span>(mna, a[i]);   suma += a[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        sum[i % k] += a[i];<br>        cnt[i % k] ++;<br>        mn[i % k] = <span class="hljs-built_in">min</span>(mn[i % k], a[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = inf;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++ i) &#123;      <span class="hljs-comment">// 把第i个数变成a, 其他的数变成b</span><br>        <span class="hljs-type">int</span> val = sum[i] - cnt[i] * mn[i] + (suma - sum[i]) - (n - cnt[i]) * mna;<br>        ans = <span class="hljs-built_in">min</span>(ans, val);<br>    &#125;<br>    <span class="hljs-built_in">LOG</span>(ans)<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法_DP</tag>
      
      <tag>算法_贪心</tag>
      
      <tag>算法_构造</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux - Ubuntu 下使用 Clash 代理</title>
    <link href="/2022/02/02/Linux%20-%20Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/"/>
    <url>/2022/02/02/Linux%20-%20Ubuntu%20%E4%B8%8B%E4%BD%BF%E7%94%A8%20Clash%20%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu科学上网</p><ol><li>在 <a href="https://link.zhihu.com/?target=https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a> 下载对应的 clash 版本（普通电脑对应的是 linux-amd64 版本），解压，重命名为 clash.</li><li>添加执行权限（sudo chmod + x clash），将 clash 放到 &#x2F;usr&#x2F;bin&#x2F; 目录下（sudo cp clash &#x2F;usr&#x2F;bin&#x2F;）.</li><li>在终端中运行 clash，会在 ~&#x2F;.config&#x2F;clash 文件夹下生成 config.yaml 和 Country.mmdb 两个文件. 用商家提供的替换这两个文件，重新运行 clash.</li><li>设置系统代理：<br> <img src="/images/2022-02-02-clash-on-Ubuntu_1.png" alt="1"></li></ol><blockquote><ol><li>用 nohup clash &amp; 命令可以使程序在后台运行，即使退出终端也不影响.</li><li>将clash进程加入开机自启动</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
